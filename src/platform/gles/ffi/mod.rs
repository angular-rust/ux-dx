#![allow(unused_attributes)]
#![no_std]
#![allow(bad_style)]
#![deny(missing_docs)]
#![deny(missing_debug_implementations)]
#![cfg_attr(docs_rs, feature(doc_cfg))]

//! Supported Features:
//! * `global_loader`: Include all mechanisms necessary for calling GL using
//!   global functions.
//! * `struct_loader`: Include all mechanisms necessary for calling GL as
//!   methods on a struct.
//! * `debug_trace_calls`: if cfg!(debug_assertions), any call to a GL function
//!   will `trace!` what was called and with what args.
//! * `debug_automatic_glGetError`: If cfg!(debug_assertions), this will
//!   automatically call `glGetError` after every call to any *other* GL
//!   function. If an error code occurs it's shown via `error!` along with the
//!   name of the fn that had the error.
//! * `log`: imports `trace!` and `error!` macros from the `log` crate.
//!   Otherwise they just call `println!` and `eprintln!` respectively.
//! * `chlorine`: gets all C types from the `chlorine` crate (which is `no_std`
//!   friendly). Otherwise they will be imported from `std::os::raw`.
//! * `bytemuck`: Adds support for the `bytemuck` crate, mostly in the form of
//!   `bytemuck::Zeroable` on `GlFns`.
//! * `inline`: Tags all GL calls as `#[inline]`.
//! * `inline_always`: Tags all GL calls as `#[inline(always)]`. This will
//!   effectively override the `inline` feature.
//!
//! The crate is `no_std` friendly by default, but features above can end up
//! requiring `std` to be available.
//!
//! # GL Loaders
//! The docs for this crate hosted on docs.rs generate **both** the
//! `global_loader` and `struct_loader` documentation for sake of completeness.
//!
//! However, you are generally expected to use **only one** loader style in any
//! particular project.
//!
//! Each loader style has its own small advantages:
//! * The `global_loader` stores the GL fn pointers in static `AtomicPtr`
//!   values.
//!   * Call [`load_global_gl_with`] to initialize the pointers.
//!   * Each GL fn is available as a global fn under its standard
//!     name, eg `glGetError()`.
//!   * This lets you call GL functions from anywhere at all, and it's how you
//!     might expect to use GL if you have a C background.
//!   * Being able to call GL from anywhere makes it easy to write Drop impls,
//!     among other things.
// * The `struct_loader` stores all the fn pointers in the fields of a
//   [`GlFns`] struct.
//   * Call [`GlFns::load_with`] to make a `GlFns` value.
//   * Each GL fn is available as a method on the struct with the `gl`
//     prefix removed. It's presumed that you'll call the struct itself `gl`,
//     so calls will look something like `gl.GetError()`.
//   * This is closer to how WebGL works on WASM targets, and so this is how
//     the [`glow`](https://docs.rs/glow) crate works to maintain consistency
//     across desktop and web.
//   * Also, if you want to do any sort of "live code reloading" you'll have to
//     use the struct loader. DLLs don't share their static values with the
//     main program, so if the DLL uses the global loader functions the
//     pointers won't be loaded and calling any GL fn from the DLL will
//     panic. Instead, if you just pass a `&GlFns` to your DLL it can call the
//     GL methods just fine.
//
//! In both styles, if you call a fn that isn't loaded you will get a
//! panic. This generally only happens if the context doesn't fully support
//! the GL version. You can check if a GL command is loaded or not before
//! actually calling it by adding `_is_loaded` to the name of the command. In
//! other words, `glGetError_is_loaded` to check if `glGetError` is globally
//! loaded, and `gl.GetError_is_loaded` to check if it's loaded in a `GlFns`.
//! All of the "`_is_loaded`" functions are hidden in the generated docs just
//! to keep things tidy, but they're there.
//!
//! # Safety
//! In general, there's many ways that GL can go wrong.
//!
//! For the purposes of this library, it's important to focus on the fact that:
//! * Initially all functions are None pointers. If a fn is called when it's in a None state then you'll get a panic (reminder: a panic is safe).
//! * You can load pointers from the current GL context (described above).
//!   * These pointers are technically context specific, though in practice different contexts for the same graphics driver often all share the same fn pointers.
//!   * The loader has no way to verify that pointers it gets are actually pointers to the correct functions, it just trusts what you tell it.
//! * Since loading a fn pointer transitions the world from "it will definitely (safely) panic to call that GL command" to "it might be UB to call that GL command (even with the correct arguments)", the act of simply loading a fn pointer is itself considered to be `unsafe`.
//! * Individual GL commands are generally safe to use once they've been properly loaded for the current context, but this crate doesn't attempt to sort out what is safe and what's not. All GL commands are blanket marked as being `unsafe`.
//! It's up to you to try and manage this unsafety! Sorry, but this crate just does what you tell it to.

#[cfg(any(
    all(
        not(feature = "log"),
        any(feature = "debug_trace_calls", feature = "debug_automatic_glGetError")
    ),
    not(feature = "chlorine"),
))]
extern crate std;

#[cfg(feature = "chlorine")]
use chlorine::*;
#[cfg(not(feature = "chlorine"))]
use std::os::raw::*;

#[cfg(feature = "log")]
#[allow(unused)]
use log::{error, trace};
#[cfg(all(not(feature = "log"), feature = "debug_trace_calls"))]
macro_rules! trace { ($($arg:tt)*) => { std::println!($($arg)*) } }
#[cfg(all(not(feature = "log"), feature = "debug_automatic_glGetError"))]
macro_rules! error { ($($arg:tt)*) => { std::eprintln!($($arg)*) } }

use core::{
    mem::transmute,
    ptr::null_mut,
    sync::atomic::{AtomicPtr, Ordering},
};
#[allow(dead_code)]
const RELAX: Ordering = Ordering::Relaxed;
#[allow(dead_code)]
type APcv = AtomicPtr<c_void>;
#[cfg(not(feature = "struct_loader"))]
const fn ap_None() -> APcv {
    AtomicPtr::new(null_mut())
}

/// This is called to panic when a not-loaded fn is attempted.
///
/// Placing the panic mechanism in this cold fn generally helps code generation for the hot path.
/// Or so the sages say, at least.
#[cold]
#[inline(never)]
#[allow(dead_code)]
fn go_panic_because_fn_not_loaded(name: &str) -> ! {
    panic!("called {name} but it was not loaded.", name = name)
}

/// Loads a fn pointer.
/// Rejects suggested pointer addresses which are likely to be lies.
/// This fn is used by both the global loader and struct loader.
/// We mark it as `inline(never)` to favor a small binary over initialization speed.
/// Returns if there's now a non-None value in the atomic pointer.
#[inline(never)]
#[allow(dead_code)]
fn load_dyn_name_atomic_ptr(
    get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    fn_name: &[u8],
    ptr: &APcv,
) -> bool {
    // if this fails the code generator itself royally screwed up somehow,
    // and so it's only a debug assert.
    debug_assert_eq!(*fn_name.last().unwrap(), 0);
    let p: *mut c_void = get_proc_address(fn_name.as_ptr() as *const c_char);
    let p_usize = p as usize;
    // You *should* get None for failed lookups, but some systems have been
    // reported to give "error code" values such as -1 or small non-None values.
    // To help guard against this silliness, we consider these values to also
    // just be a result of None.
    if p_usize == core::usize::MAX || p_usize < 8 {
        ptr.store(null_mut(), RELAX);
        false
    } else {
        ptr.store(p, RELAX);
        true
    }
}

/// Returns if an error was printed.
#[cfg(feature = "debug_automatic_glGetError")]
#[inline(never)]
fn report_error_code_from(name: &str, err: GLenum) {
    match err {
        GL_NO_ERROR => return,
        GL_INVALID_ENUM => error!("Invalid Enum to {name}.", name = name),
        GL_INVALID_VALUE => error!("Invalid Value to {name}.", name = name),
        GL_INVALID_OPERATION => error!("Invalid Operation to {name}.", name = name),
        GL_INVALID_FRAMEBUFFER_OPERATION => {
            error!("Invalid Framebuffer Operation to {name}.", name = name)
        }
        GL_OUT_OF_MEMORY => error!("Out of Memory in {name}.", name = name),
        GL_STACK_UNDERFLOW => error!("Stack Underflow in {name}.", name = name),
        GL_STACK_OVERFLOW => error!("Stack Overflow in {name}.", name = name),
        unknown => error!(
            "Unknown error code {unknown} to {name}.",
            name = name,
            unknown = unknown
        ),
    }
}

#[inline(always)]
#[allow(dead_code)]
unsafe fn call_atomic_ptr_0arg<Ret>(name: &str, ptr: &APcv) -> Ret {
    let p = ptr.load(RELAX);
    match transmute::<*mut c_void, Option<extern "system" fn() -> Ret>>(p) {
        Some(fn_p) => fn_p(),
        None => go_panic_because_fn_not_loaded(name),
    }
}

#[inline(always)]
#[allow(dead_code)]
unsafe fn call_atomic_ptr_1arg<Ret, A>(name: &str, ptr: &APcv, a: A) -> Ret {
    let p = ptr.load(RELAX);
    match transmute::<*mut c_void, Option<extern "system" fn(A) -> Ret>>(p) {
        Some(fn_p) => fn_p(a),
        None => go_panic_because_fn_not_loaded(name),
    }
}

#[inline(always)]
#[allow(dead_code)]
unsafe fn call_atomic_ptr_2arg<Ret, A, B>(name: &str, ptr: &APcv, a: A, b: B) -> Ret {
    let p = ptr.load(RELAX);
    match transmute::<*mut c_void, Option<extern "system" fn(A, B) -> Ret>>(p) {
        Some(fn_p) => fn_p(a, b),
        None => go_panic_because_fn_not_loaded(name),
    }
}

#[inline(always)]
#[allow(dead_code)]
unsafe fn call_atomic_ptr_3arg<Ret, A, B, C>(name: &str, ptr: &APcv, a: A, b: B, c: C) -> Ret {
    let p = ptr.load(RELAX);
    match transmute::<*mut c_void, Option<extern "system" fn(A, B, C) -> Ret>>(p) {
        Some(fn_p) => fn_p(a, b, c),
        None => go_panic_because_fn_not_loaded(name),
    }
}

#[inline(always)]
#[allow(dead_code)]
unsafe fn call_atomic_ptr_4arg<Ret, A, B, C, D>(
    name: &str,
    ptr: &APcv,
    a: A,
    b: B,
    c: C,
    d: D,
) -> Ret {
    let p = ptr.load(RELAX);
    match transmute::<*mut c_void, Option<extern "system" fn(A, B, C, D) -> Ret>>(p) {
        Some(fn_p) => fn_p(a, b, c, d),
        None => go_panic_because_fn_not_loaded(name),
    }
}

#[inline(always)]
#[allow(dead_code)]
unsafe fn call_atomic_ptr_5arg<Ret, A, B, C, D, E>(
    name: &str,
    ptr: &APcv,
    a: A,
    b: B,
    c: C,
    d: D,
    e: E,
) -> Ret {
    let p = ptr.load(RELAX);
    match transmute::<*mut c_void, Option<extern "system" fn(A, B, C, D, E) -> Ret>>(p) {
        Some(fn_p) => fn_p(a, b, c, d, e),
        None => go_panic_because_fn_not_loaded(name),
    }
}

#[inline(always)]
#[allow(dead_code)]
unsafe fn call_atomic_ptr_6arg<Ret, A, B, C, D, E, F>(
    name: &str,
    ptr: &APcv,
    a: A,
    b: B,
    c: C,
    d: D,
    e: E,
    f: F,
) -> Ret {
    let p = ptr.load(RELAX);
    match transmute::<*mut c_void, Option<extern "system" fn(A, B, C, D, E, F) -> Ret>>(p) {
        Some(fn_p) => fn_p(a, b, c, d, e, f),
        None => go_panic_because_fn_not_loaded(name),
    }
}

#[inline(always)]
#[allow(dead_code)]
unsafe fn call_atomic_ptr_7arg<Ret, A, B, C, D, E, F, G>(
    name: &str,
    ptr: &APcv,
    a: A,
    b: B,
    c: C,
    d: D,
    e: E,
    f: F,
    g: G,
) -> Ret {
    let p = ptr.load(RELAX);
    match transmute::<*mut c_void, Option<extern "system" fn(A, B, C, D, E, F, G) -> Ret>>(p) {
        Some(fn_p) => fn_p(a, b, c, d, e, f, g),
        None => go_panic_because_fn_not_loaded(name),
    }
}

#[inline(always)]
#[allow(dead_code)]
unsafe fn call_atomic_ptr_8arg<Ret, A, B, C, D, E, F, G, H>(
    name: &str,
    ptr: &APcv,
    a: A,
    b: B,
    c: C,
    d: D,
    e: E,
    f: F,
    g: G,
    h: H,
) -> Ret {
    let p = ptr.load(RELAX);
    match transmute::<*mut c_void, Option<extern "system" fn(A, B, C, D, E, F, G, H) -> Ret>>(p) {
        Some(fn_p) => fn_p(a, b, c, d, e, f, g, h),
        None => go_panic_because_fn_not_loaded(name),
    }
}

#[inline(always)]
#[allow(dead_code)]
unsafe fn call_atomic_ptr_9arg<Ret, A, B, C, D, E, F, G, H, I>(
    name: &str,
    ptr: &APcv,
    a: A,
    b: B,
    c: C,
    d: D,
    e: E,
    f: F,
    g: G,
    h: H,
    i: I,
) -> Ret {
    let p = ptr.load(RELAX);
    match transmute::<*mut c_void, Option<extern "system" fn(A, B, C, D, E, F, G, H, I) -> Ret>>(p)
    {
        Some(fn_p) => fn_p(a, b, c, d, e, f, g, h, i),
        None => go_panic_because_fn_not_loaded(name),
    }
}

#[inline(always)]
#[allow(dead_code)]
unsafe fn call_atomic_ptr_10arg<Ret, A, B, C, D, E, F, G, H, I, J>(
    name: &str,
    ptr: &APcv,
    a: A,
    b: B,
    c: C,
    d: D,
    e: E,
    f: F,
    g: G,
    h: H,
    i: I,
    j: J,
) -> Ret {
    let p = ptr.load(RELAX);
    match transmute::<*mut c_void, Option<extern "system" fn(A, B, C, D, E, F, G, H, I, J) -> Ret>>(
        p,
    ) {
        Some(fn_p) => fn_p(a, b, c, d, e, f, g, h, i, j),
        None => go_panic_because_fn_not_loaded(name),
    }
}

#[inline(always)]
#[allow(dead_code)]
unsafe fn call_atomic_ptr_11arg<Ret, A, B, C, D, E, F, G, H, I, J, K>(
    name: &str,
    ptr: &APcv,
    a: A,
    b: B,
    c: C,
    d: D,
    e: E,
    f: F,
    g: G,
    h: H,
    i: I,
    j: J,
    k: K,
) -> Ret {
    let p = ptr.load(RELAX);
    match transmute::<*mut c_void, Option<extern "system" fn(A, B, C, D, E, F, G, H, I, J, K) -> Ret>>(
        p,
    ) {
        Some(fn_p) => fn_p(a, b, c, d, e, f, g, h, i, j, k),
        None => go_panic_because_fn_not_loaded(name),
    }
}

#[inline(always)]
#[allow(dead_code)]
unsafe fn call_atomic_ptr_12arg<Ret, A, B, C, D, E, F, G, H, I, J, K, L>(
    name: &str,
    ptr: &APcv,
    a: A,
    b: B,
    c: C,
    d: D,
    e: E,
    f: F,
    g: G,
    h: H,
    i: I,
    j: J,
    k: K,
    l: L,
) -> Ret {
    let p = ptr.load(RELAX);
    match transmute::<
        *mut c_void,
        Option<extern "system" fn(A, B, C, D, E, F, G, H, I, J, K, L) -> Ret>,
    >(p)
    {
        Some(fn_p) => fn_p(a, b, c, d, e, f, g, h, i, j, k, l),
        None => go_panic_because_fn_not_loaded(name),
    }
}

#[inline(always)]
#[allow(dead_code)]
unsafe fn call_atomic_ptr_15arg<Ret, A, B, C, D, E, F, G, H, I, J, K, L, M, N, O>(
    name: &str,
    ptr: &APcv,
    a: A,
    b: B,
    c: C,
    d: D,
    e: E,
    f: F,
    g: G,
    h: H,
    i: I,
    j: J,
    k: K,
    l: L,
    m: M,
    n: N,
    o: O,
) -> Ret {
    let p = ptr.load(RELAX);
    match transmute::<
        *mut c_void,
        Option<extern "system" fn(A, B, C, D, E, F, G, H, I, J, K, L, M, N, O) -> Ret>,
    >(p)
    {
        Some(fn_p) => fn_p(a, b, c, d, e, f, g, h, i, j, k, l, m, n, o),
        None => go_panic_because_fn_not_loaded(name),
    }
}

#[cfg(not(feature = "struct_loader"))]
pub use global_commands::*;
#[cfg(not(feature = "struct_loader"))]
pub mod global_commands {
    //! Contains functions for using the global GL loader.
    use super::*;
    use crate::platform::gles::types::*;

    #[cfg(feature = "debug_automatic_glGetError")]
    #[inline(never)]
    unsafe fn global_automatic_glGetError(name: &str) {
        let mut err = glGetError();
        while err != GL_NO_ERROR {
            report_error_code_from(name, err);
            err = glGetError();
        }
    }

    /// Loads all global functions using the `get_proc_address` given.
    ///
    /// The closure should, when given a None-terminated name of a function,
    /// return a pointer to that function. If the fn isn't available, then
    /// a None pointer should be returned instead.
    ///
    /// This allows you to call [SDL_GL_GetProcAddress](https://wiki.libsdl.org/SDL_GL_GetProcAddress),
    /// [wglGetProcAddress](https://docs.microsoft.com/en-us/windows/win32/api/wingdi/nf-wingdi-wglgetprocaddress),
    /// or some similar function, depending on your OS.
    pub unsafe fn load_global_gl_with<F>(mut get_proc_address: F)
    where
        F: FnMut(*const c_char) -> *mut c_void,
    {
        #[cfg(any(feature = "GL_EXT_win32_keyed_mutex"))]
        #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_win32_keyed_mutex"))))]
        {
            glAcquireKeyedMutexWin32EXT_load_with_dyn(&mut get_proc_address) as usize;
        }
        glActiveShaderProgram_load_with_dyn(&mut get_proc_address) as usize;
        #[cfg(any(feature = "GL_EXT_separate_shader_objects"))]
        #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_separate_shader_objects"))))]
        {
            glActiveShaderProgramEXT_load_with_dyn(&mut get_proc_address) as usize;
        }
        glActiveTexture_load_with_dyn(&mut get_proc_address) as usize;
        #[cfg(any(feature = "GL_QCOM_alpha_test"))]
        #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_QCOM_alpha_test"))))]
        {
            glAlphaFuncQCOM_load_with_dyn(&mut get_proc_address) as usize;
        }
        #[cfg(any(feature = "GL_INTEL_framebuffer_CMAA"))]
        #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_INTEL_framebuffer_CMAA"))))]
        {
            glApplyFramebufferAttachmentCMAAINTEL_load_with_dyn(&mut get_proc_address) as usize;
        }
        glAttachShader_load_with_dyn(&mut get_proc_address) as usize;
        #[cfg(any(feature = "GL_NV_conditional_render"))]
        #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_conditional_render"))))]
        {
            glBeginConditionalRenderNV_load_with_dyn(&mut get_proc_address) as usize;
        }
        #[cfg(any(feature = "GL_AMD_performance_monitor"))]
        #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_AMD_performance_monitor"))))]
        {
            glBeginPerfMonitorAMD_load_with_dyn(&mut get_proc_address) as usize;
        }
        #[cfg(any(feature = "GL_INTEL_performance_query"))]
        #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_INTEL_performance_query"))))]
        {
            glBeginPerfQueryINTEL_load_with_dyn(&mut get_proc_address) as usize;
        }
        glBeginQuery_load_with_dyn(&mut get_proc_address) as usize;
        #[cfg(any(
            feature = "GL_EXT_disjoint_timer_query",
            feature = "GL_EXT_occlusion_query_boolean"
        ))]
        #[cfg_attr(
            docs_rs,
            doc(cfg(any(
                feature = "GL_EXT_disjoint_timer_query",
                feature = "GL_EXT_occlusion_query_boolean"
            )))
        )]
        {
            glBeginQueryEXT_load_with_dyn(&mut get_proc_address) as usize;
        }
        glBeginTransformFeedback_load_with_dyn(&mut get_proc_address) as usize;
        glBindAttribLocation_load_with_dyn(&mut get_proc_address) as usize;
        glBindBuffer_load_with_dyn(&mut get_proc_address) as usize;
        glBindBufferBase_load_with_dyn(&mut get_proc_address) as usize;
        glBindBufferRange_load_with_dyn(&mut get_proc_address) as usize;
        #[cfg(any(feature = "GL_EXT_blend_func_extended"))]
        #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_blend_func_extended"))))]
        {
            glBindFragDataLocationEXT_load_with_dyn(&mut get_proc_address) as usize;
        }
        #[cfg(any(feature = "GL_EXT_blend_func_extended"))]
        #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_blend_func_extended"))))]
        {
            glBindFragDataLocationIndexedEXT_load_with_dyn(&mut get_proc_address) as usize;
        }
        glBindFramebuffer_load_with_dyn(&mut get_proc_address) as usize;
        glBindImageTexture_load_with_dyn(&mut get_proc_address) as usize;
        glBindProgramPipeline_load_with_dyn(&mut get_proc_address) as usize;
        #[cfg(any(feature = "GL_EXT_separate_shader_objects"))]
        #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_separate_shader_objects"))))]
        {
            glBindProgramPipelineEXT_load_with_dyn(&mut get_proc_address) as usize;
        }
        glBindRenderbuffer_load_with_dyn(&mut get_proc_address) as usize;
        glBindSampler_load_with_dyn(&mut get_proc_address) as usize;
        #[cfg(any(feature = "GL_NV_shading_rate_image"))]
        #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_shading_rate_image"))))]
        {
            glBindShadingRateImageNV_load_with_dyn(&mut get_proc_address) as usize;
        }
        glBindTexture_load_with_dyn(&mut get_proc_address) as usize;
        glBindTransformFeedback_load_with_dyn(&mut get_proc_address) as usize;
        glBindVertexArray_load_with_dyn(&mut get_proc_address) as usize;
        #[cfg(any(feature = "GL_OES_vertex_array_object"))]
        #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_OES_vertex_array_object"))))]
        {
            glBindVertexArrayOES_load_with_dyn(&mut get_proc_address) as usize;
        }
        glBindVertexBuffer_load_with_dyn(&mut get_proc_address) as usize;
        glBlendBarrier_load_with_dyn(&mut get_proc_address) as usize;
        #[cfg(any(feature = "GL_KHR_blend_equation_advanced"))]
        #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_KHR_blend_equation_advanced"))))]
        {
            glBlendBarrierKHR_load_with_dyn(&mut get_proc_address) as usize;
        }
        #[cfg(any(feature = "GL_NV_blend_equation_advanced"))]
        #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_blend_equation_advanced"))))]
        {
            glBlendBarrierNV_load_with_dyn(&mut get_proc_address) as usize;
        }
        glBlendColor_load_with_dyn(&mut get_proc_address) as usize;
        glBlendEquation_load_with_dyn(&mut get_proc_address) as usize;
        glBlendEquationSeparate_load_with_dyn(&mut get_proc_address) as usize;
        glBlendEquationSeparatei_load_with_dyn(&mut get_proc_address) as usize;
        #[cfg(any(feature = "GL_EXT_draw_buffers_indexed"))]
        #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_draw_buffers_indexed"))))]
        {
            glBlendEquationSeparateiEXT_load_with_dyn(&mut get_proc_address) as usize;
        }
        #[cfg(any(feature = "GL_OES_draw_buffers_indexed"))]
        #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_OES_draw_buffers_indexed"))))]
        {
            glBlendEquationSeparateiOES_load_with_dyn(&mut get_proc_address) as usize;
        }
        glBlendEquationi_load_with_dyn(&mut get_proc_address) as usize;
        #[cfg(any(feature = "GL_EXT_draw_buffers_indexed"))]
        #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_draw_buffers_indexed"))))]
        {
            glBlendEquationiEXT_load_with_dyn(&mut get_proc_address) as usize;
        }
        #[cfg(any(feature = "GL_OES_draw_buffers_indexed"))]
        #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_OES_draw_buffers_indexed"))))]
        {
            glBlendEquationiOES_load_with_dyn(&mut get_proc_address) as usize;
        }
        glBlendFunc_load_with_dyn(&mut get_proc_address) as usize;
        glBlendFuncSeparate_load_with_dyn(&mut get_proc_address) as usize;
        glBlendFuncSeparatei_load_with_dyn(&mut get_proc_address) as usize;
        #[cfg(any(feature = "GL_EXT_draw_buffers_indexed"))]
        #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_draw_buffers_indexed"))))]
        {
            glBlendFuncSeparateiEXT_load_with_dyn(&mut get_proc_address) as usize;
        }
        #[cfg(any(feature = "GL_OES_draw_buffers_indexed"))]
        #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_OES_draw_buffers_indexed"))))]
        {
            glBlendFuncSeparateiOES_load_with_dyn(&mut get_proc_address) as usize;
        }
        glBlendFunci_load_with_dyn(&mut get_proc_address) as usize;
        #[cfg(any(feature = "GL_EXT_draw_buffers_indexed"))]
        #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_draw_buffers_indexed"))))]
        {
            glBlendFunciEXT_load_with_dyn(&mut get_proc_address) as usize;
        }
        #[cfg(any(feature = "GL_OES_draw_buffers_indexed"))]
        #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_OES_draw_buffers_indexed"))))]
        {
            glBlendFunciOES_load_with_dyn(&mut get_proc_address) as usize;
        }
        #[cfg(any(feature = "GL_NV_blend_equation_advanced"))]
        #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_blend_equation_advanced"))))]
        {
            glBlendParameteriNV_load_with_dyn(&mut get_proc_address) as usize;
        }
        glBlitFramebuffer_load_with_dyn(&mut get_proc_address) as usize;
        #[cfg(any(feature = "GL_ANGLE_framebuffer_blit"))]
        #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_ANGLE_framebuffer_blit"))))]
        {
            glBlitFramebufferANGLE_load_with_dyn(&mut get_proc_address) as usize;
        }
        #[cfg(any(feature = "GL_NV_framebuffer_blit"))]
        #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_framebuffer_blit"))))]
        {
            glBlitFramebufferNV_load_with_dyn(&mut get_proc_address) as usize;
        }
        #[cfg(any(feature = "GL_NV_memory_attachment"))]
        #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_memory_attachment"))))]
        {
            glBufferAttachMemoryNV_load_with_dyn(&mut get_proc_address) as usize;
        }
        glBufferData_load_with_dyn(&mut get_proc_address) as usize;
        #[cfg(any(feature = "GL_NV_memory_object_sparse"))]
        #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_memory_object_sparse"))))]
        {
            glBufferPageCommitmentMemNV_load_with_dyn(&mut get_proc_address) as usize;
        }
        #[cfg(any(feature = "GL_EXT_buffer_storage"))]
        #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_buffer_storage"))))]
        {
            glBufferStorageEXT_load_with_dyn(&mut get_proc_address) as usize;
        }
        #[cfg(any(feature = "GL_EXT_external_buffer"))]
        #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_external_buffer"))))]
        {
            glBufferStorageExternalEXT_load_with_dyn(&mut get_proc_address) as usize;
        }
        #[cfg(any(feature = "GL_EXT_memory_object"))]
        #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_memory_object"))))]
        {
            glBufferStorageMemEXT_load_with_dyn(&mut get_proc_address) as usize;
        }
        glBufferSubData_load_with_dyn(&mut get_proc_address) as usize;
        glCheckFramebufferStatus_load_with_dyn(&mut get_proc_address) as usize;
        glClear_load_with_dyn(&mut get_proc_address) as usize;
        glClearBufferfi_load_with_dyn(&mut get_proc_address) as usize;
        glClearBufferfv_load_with_dyn(&mut get_proc_address) as usize;
        glClearBufferiv_load_with_dyn(&mut get_proc_address) as usize;
        glClearBufferuiv_load_with_dyn(&mut get_proc_address) as usize;
        glClearColor_load_with_dyn(&mut get_proc_address) as usize;
        glClearDepthf_load_with_dyn(&mut get_proc_address) as usize;
        #[cfg(any(feature = "GL_EXT_shader_pixel_local_storage2"))]
        #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_shader_pixel_local_storage2"))))]
        {
            glClearPixelLocalStorageuiEXT_load_with_dyn(&mut get_proc_address) as usize;
        }
        glClearStencil_load_with_dyn(&mut get_proc_address) as usize;
        #[cfg(any(feature = "GL_EXT_clear_texture"))]
        #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_clear_texture"))))]
        {
            glClearTexImageEXT_load_with_dyn(&mut get_proc_address) as usize;
        }
        #[cfg(any(feature = "GL_EXT_clear_texture"))]
        #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_clear_texture"))))]
        {
            glClearTexSubImageEXT_load_with_dyn(&mut get_proc_address) as usize;
        }
        glClientWaitSync_load_with_dyn(&mut get_proc_address) as usize;
        #[cfg(any(feature = "GL_APPLE_sync"))]
        #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_APPLE_sync"))))]
        {
            glClientWaitSyncAPPLE_load_with_dyn(&mut get_proc_address) as usize;
        }
        #[cfg(any(feature = "GL_EXT_clip_control"))]
        #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_clip_control"))))]
        {
            glClipControlEXT_load_with_dyn(&mut get_proc_address) as usize;
        }
        glColorMask_load_with_dyn(&mut get_proc_address) as usize;
        glColorMaski_load_with_dyn(&mut get_proc_address) as usize;
        #[cfg(any(feature = "GL_EXT_draw_buffers_indexed"))]
        #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_draw_buffers_indexed"))))]
        {
            glColorMaskiEXT_load_with_dyn(&mut get_proc_address) as usize;
        }
        #[cfg(any(feature = "GL_OES_draw_buffers_indexed"))]
        #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_OES_draw_buffers_indexed"))))]
        {
            glColorMaskiOES_load_with_dyn(&mut get_proc_address) as usize;
        }
        glCompileShader_load_with_dyn(&mut get_proc_address) as usize;
        glCompressedTexImage2D_load_with_dyn(&mut get_proc_address) as usize;
        glCompressedTexImage3D_load_with_dyn(&mut get_proc_address) as usize;
        #[cfg(any(feature = "GL_OES_texture_3D"))]
        #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_OES_texture_3D"))))]
        {
            glCompressedTexImage3DOES_load_with_dyn(&mut get_proc_address) as usize;
        }
        glCompressedTexSubImage2D_load_with_dyn(&mut get_proc_address) as usize;
        glCompressedTexSubImage3D_load_with_dyn(&mut get_proc_address) as usize;
        #[cfg(any(feature = "GL_OES_texture_3D"))]
        #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_OES_texture_3D"))))]
        {
            glCompressedTexSubImage3DOES_load_with_dyn(&mut get_proc_address) as usize;
        }
        #[cfg(any(feature = "GL_NV_conservative_raster_pre_snap_triangles"))]
        #[cfg_attr(
            docs_rs,
            doc(cfg(any(feature = "GL_NV_conservative_raster_pre_snap_triangles")))
        )]
        {
            glConservativeRasterParameteriNV_load_with_dyn(&mut get_proc_address) as usize;
        }
        glCopyBufferSubData_load_with_dyn(&mut get_proc_address) as usize;
        #[cfg(any(feature = "GL_NV_copy_buffer"))]
        #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_copy_buffer"))))]
        {
            glCopyBufferSubDataNV_load_with_dyn(&mut get_proc_address) as usize;
        }
        glCopyImageSubData_load_with_dyn(&mut get_proc_address) as usize;
        #[cfg(any(feature = "GL_EXT_copy_image"))]
        #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_copy_image"))))]
        {
            glCopyImageSubDataEXT_load_with_dyn(&mut get_proc_address) as usize;
        }
        #[cfg(any(feature = "GL_OES_copy_image"))]
        #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_OES_copy_image"))))]
        {
            glCopyImageSubDataOES_load_with_dyn(&mut get_proc_address) as usize;
        }
        #[cfg(any(feature = "GL_NV_path_rendering"))]
        #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_path_rendering"))))]
        {
            glCopyPathNV_load_with_dyn(&mut get_proc_address) as usize;
        }
        glCopyTexImage2D_load_with_dyn(&mut get_proc_address) as usize;
        glCopyTexSubImage2D_load_with_dyn(&mut get_proc_address) as usize;
        glCopyTexSubImage3D_load_with_dyn(&mut get_proc_address) as usize;
        #[cfg(any(feature = "GL_OES_texture_3D"))]
        #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_OES_texture_3D"))))]
        {
            glCopyTexSubImage3DOES_load_with_dyn(&mut get_proc_address) as usize;
        }
        #[cfg(any(feature = "GL_APPLE_copy_texture_levels"))]
        #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_APPLE_copy_texture_levels"))))]
        {
            glCopyTextureLevelsAPPLE_load_with_dyn(&mut get_proc_address) as usize;
        }
        #[cfg(any(feature = "GL_NV_path_rendering"))]
        #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_path_rendering"))))]
        {
            glCoverFillPathInstancedNV_load_with_dyn(&mut get_proc_address) as usize;
        }
        #[cfg(any(feature = "GL_NV_path_rendering"))]
        #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_path_rendering"))))]
        {
            glCoverFillPathNV_load_with_dyn(&mut get_proc_address) as usize;
        }
        #[cfg(any(feature = "GL_NV_path_rendering"))]
        #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_path_rendering"))))]
        {
            glCoverStrokePathInstancedNV_load_with_dyn(&mut get_proc_address) as usize;
        }
        #[cfg(any(feature = "GL_NV_path_rendering"))]
        #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_path_rendering"))))]
        {
            glCoverStrokePathNV_load_with_dyn(&mut get_proc_address) as usize;
        }
        #[cfg(any(feature = "GL_NV_coverage_sample"))]
        #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_coverage_sample"))))]
        {
            glCoverageMaskNV_load_with_dyn(&mut get_proc_address) as usize;
        }
        #[cfg(any(feature = "GL_NV_framebuffer_mixed_samples"))]
        #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_framebuffer_mixed_samples"))))]
        {
            glCoverageModulationNV_load_with_dyn(&mut get_proc_address) as usize;
        }
        #[cfg(any(feature = "GL_NV_framebuffer_mixed_samples"))]
        #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_framebuffer_mixed_samples"))))]
        {
            glCoverageModulationTableNV_load_with_dyn(&mut get_proc_address) as usize;
        }
        #[cfg(any(feature = "GL_NV_coverage_sample"))]
        #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_coverage_sample"))))]
        {
            glCoverageOperationNV_load_with_dyn(&mut get_proc_address) as usize;
        }
        #[cfg(any(feature = "GL_EXT_memory_object"))]
        #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_memory_object"))))]
        {
            glCreateMemoryObjectsEXT_load_with_dyn(&mut get_proc_address) as usize;
        }
        #[cfg(any(feature = "GL_INTEL_performance_query"))]
        #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_INTEL_performance_query"))))]
        {
            glCreatePerfQueryINTEL_load_with_dyn(&mut get_proc_address) as usize;
        }
        glCreateProgram_load_with_dyn(&mut get_proc_address) as usize;
        #[cfg(any(feature = "GL_NV_timeline_semaphore"))]
        #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_timeline_semaphore"))))]
        {
            glCreateSemaphoresNV_load_with_dyn(&mut get_proc_address) as usize;
        }
        glCreateShader_load_with_dyn(&mut get_proc_address) as usize;
        glCreateShaderProgramv_load_with_dyn(&mut get_proc_address) as usize;
        #[cfg(any(feature = "GL_EXT_separate_shader_objects"))]
        #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_separate_shader_objects"))))]
        {
            glCreateShaderProgramvEXT_load_with_dyn(&mut get_proc_address) as usize;
        }
        glCullFace_load_with_dyn(&mut get_proc_address) as usize;
        glDebugMessageCallback_load_with_dyn(&mut get_proc_address) as usize;
        #[cfg(any(feature = "GL_KHR_debug"))]
        #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_KHR_debug"))))]
        {
            glDebugMessageCallbackKHR_load_with_dyn(&mut get_proc_address) as usize;
        }
        glDebugMessageControl_load_with_dyn(&mut get_proc_address) as usize;
        #[cfg(any(feature = "GL_KHR_debug"))]
        #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_KHR_debug"))))]
        {
            glDebugMessageControlKHR_load_with_dyn(&mut get_proc_address) as usize;
        }
        glDebugMessageInsert_load_with_dyn(&mut get_proc_address) as usize;
        #[cfg(any(feature = "GL_KHR_debug"))]
        #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_KHR_debug"))))]
        {
            glDebugMessageInsertKHR_load_with_dyn(&mut get_proc_address) as usize;
        }
        glDeleteBuffers_load_with_dyn(&mut get_proc_address) as usize;
        #[cfg(any(feature = "GL_NV_fence"))]
        #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_fence"))))]
        {
            glDeleteFencesNV_load_with_dyn(&mut get_proc_address) as usize;
        }
        glDeleteFramebuffers_load_with_dyn(&mut get_proc_address) as usize;
        #[cfg(any(feature = "GL_EXT_memory_object"))]
        #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_memory_object"))))]
        {
            glDeleteMemoryObjectsEXT_load_with_dyn(&mut get_proc_address) as usize;
        }
        #[cfg(any(feature = "GL_NV_path_rendering"))]
        #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_path_rendering"))))]
        {
            glDeletePathsNV_load_with_dyn(&mut get_proc_address) as usize;
        }
        #[cfg(any(feature = "GL_AMD_performance_monitor"))]
        #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_AMD_performance_monitor"))))]
        {
            glDeletePerfMonitorsAMD_load_with_dyn(&mut get_proc_address) as usize;
        }
        #[cfg(any(feature = "GL_INTEL_performance_query"))]
        #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_INTEL_performance_query"))))]
        {
            glDeletePerfQueryINTEL_load_with_dyn(&mut get_proc_address) as usize;
        }
        glDeleteProgram_load_with_dyn(&mut get_proc_address) as usize;
        glDeleteProgramPipelines_load_with_dyn(&mut get_proc_address) as usize;
        #[cfg(any(feature = "GL_EXT_separate_shader_objects"))]
        #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_separate_shader_objects"))))]
        {
            glDeleteProgramPipelinesEXT_load_with_dyn(&mut get_proc_address) as usize;
        }
        glDeleteQueries_load_with_dyn(&mut get_proc_address) as usize;
        #[cfg(any(
            feature = "GL_EXT_disjoint_timer_query",
            feature = "GL_EXT_occlusion_query_boolean"
        ))]
        #[cfg_attr(
            docs_rs,
            doc(cfg(any(
                feature = "GL_EXT_disjoint_timer_query",
                feature = "GL_EXT_occlusion_query_boolean"
            )))
        )]
        {
            glDeleteQueriesEXT_load_with_dyn(&mut get_proc_address) as usize;
        }
        glDeleteRenderbuffers_load_with_dyn(&mut get_proc_address) as usize;
        glDeleteSamplers_load_with_dyn(&mut get_proc_address) as usize;
        #[cfg(any(feature = "GL_EXT_semaphore"))]
        #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_semaphore"))))]
        {
            glDeleteSemaphoresEXT_load_with_dyn(&mut get_proc_address) as usize;
        }
        glDeleteShader_load_with_dyn(&mut get_proc_address) as usize;
        glDeleteSync_load_with_dyn(&mut get_proc_address) as usize;
        #[cfg(any(feature = "GL_APPLE_sync"))]
        #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_APPLE_sync"))))]
        {
            glDeleteSyncAPPLE_load_with_dyn(&mut get_proc_address) as usize;
        }
        glDeleteTextures_load_with_dyn(&mut get_proc_address) as usize;
        glDeleteTransformFeedbacks_load_with_dyn(&mut get_proc_address) as usize;
        glDeleteVertexArrays_load_with_dyn(&mut get_proc_address) as usize;
        #[cfg(any(feature = "GL_OES_vertex_array_object"))]
        #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_OES_vertex_array_object"))))]
        {
            glDeleteVertexArraysOES_load_with_dyn(&mut get_proc_address) as usize;
        }
        glDepthFunc_load_with_dyn(&mut get_proc_address) as usize;
        glDepthMask_load_with_dyn(&mut get_proc_address) as usize;
        #[cfg(any(feature = "GL_NV_viewport_array"))]
        #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_viewport_array"))))]
        {
            glDepthRangeArrayfvNV_load_with_dyn(&mut get_proc_address) as usize;
        }
        #[cfg(any(feature = "GL_OES_viewport_array"))]
        #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_OES_viewport_array"))))]
        {
            glDepthRangeArrayfvOES_load_with_dyn(&mut get_proc_address) as usize;
        }
        #[cfg(any(feature = "GL_NV_viewport_array"))]
        #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_viewport_array"))))]
        {
            glDepthRangeIndexedfNV_load_with_dyn(&mut get_proc_address) as usize;
        }
        #[cfg(any(feature = "GL_OES_viewport_array"))]
        #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_OES_viewport_array"))))]
        {
            glDepthRangeIndexedfOES_load_with_dyn(&mut get_proc_address) as usize;
        }
        glDepthRangef_load_with_dyn(&mut get_proc_address) as usize;
        glDetachShader_load_with_dyn(&mut get_proc_address) as usize;
        glDisable_load_with_dyn(&mut get_proc_address) as usize;
        #[cfg(any(feature = "GL_QCOM_driver_control"))]
        #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_QCOM_driver_control"))))]
        {
            glDisableDriverControlQCOM_load_with_dyn(&mut get_proc_address) as usize;
        }
        glDisableVertexAttribArray_load_with_dyn(&mut get_proc_address) as usize;
        glDisablei_load_with_dyn(&mut get_proc_address) as usize;
        #[cfg(any(feature = "GL_EXT_draw_buffers_indexed"))]
        #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_draw_buffers_indexed"))))]
        {
            glDisableiEXT_load_with_dyn(&mut get_proc_address) as usize;
        }
        #[cfg(any(feature = "GL_NV_viewport_array"))]
        #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_viewport_array"))))]
        {
            glDisableiNV_load_with_dyn(&mut get_proc_address) as usize;
        }
        #[cfg(any(
            feature = "GL_OES_draw_buffers_indexed",
            feature = "GL_OES_viewport_array"
        ))]
        #[cfg_attr(
            docs_rs,
            doc(cfg(any(
                feature = "GL_OES_draw_buffers_indexed",
                feature = "GL_OES_viewport_array"
            )))
        )]
        {
            glDisableiOES_load_with_dyn(&mut get_proc_address) as usize;
        }
        #[cfg(any(feature = "GL_EXT_discard_framebuffer"))]
        #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_discard_framebuffer"))))]
        {
            glDiscardFramebufferEXT_load_with_dyn(&mut get_proc_address) as usize;
        }
        glDispatchCompute_load_with_dyn(&mut get_proc_address) as usize;
        glDispatchComputeIndirect_load_with_dyn(&mut get_proc_address) as usize;
        glDrawArrays_load_with_dyn(&mut get_proc_address) as usize;
        glDrawArraysIndirect_load_with_dyn(&mut get_proc_address) as usize;
        glDrawArraysInstanced_load_with_dyn(&mut get_proc_address) as usize;
        #[cfg(any(feature = "GL_ANGLE_instanced_arrays"))]
        #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_ANGLE_instanced_arrays"))))]
        {
            glDrawArraysInstancedANGLE_load_with_dyn(&mut get_proc_address) as usize;
        }
        #[cfg(any(feature = "GL_EXT_base_instance"))]
        #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_base_instance"))))]
        {
            glDrawArraysInstancedBaseInstanceEXT_load_with_dyn(&mut get_proc_address) as usize;
        }
        #[cfg(any(feature = "GL_EXT_draw_instanced", feature = "GL_EXT_instanced_arrays"))]
        #[cfg_attr(
            docs_rs,
            doc(cfg(any(
                feature = "GL_EXT_draw_instanced",
                feature = "GL_EXT_instanced_arrays"
            )))
        )]
        {
            glDrawArraysInstancedEXT_load_with_dyn(&mut get_proc_address) as usize;
        }
        #[cfg(any(feature = "GL_NV_draw_instanced"))]
        #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_draw_instanced"))))]
        {
            glDrawArraysInstancedNV_load_with_dyn(&mut get_proc_address) as usize;
        }
        glDrawBuffers_load_with_dyn(&mut get_proc_address) as usize;
        #[cfg(any(feature = "GL_EXT_draw_buffers"))]
        #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_draw_buffers"))))]
        {
            glDrawBuffersEXT_load_with_dyn(&mut get_proc_address) as usize;
        }
        #[cfg(any(feature = "GL_EXT_multiview_draw_buffers"))]
        #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_multiview_draw_buffers"))))]
        {
            glDrawBuffersIndexedEXT_load_with_dyn(&mut get_proc_address) as usize;
        }
        #[cfg(any(feature = "GL_NV_draw_buffers"))]
        #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_draw_buffers"))))]
        {
            glDrawBuffersNV_load_with_dyn(&mut get_proc_address) as usize;
        }
        glDrawElements_load_with_dyn(&mut get_proc_address) as usize;
        glDrawElementsBaseVertex_load_with_dyn(&mut get_proc_address) as usize;
        #[cfg(any(feature = "GL_EXT_draw_elements_base_vertex"))]
        #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_draw_elements_base_vertex"))))]
        {
            glDrawElementsBaseVertexEXT_load_with_dyn(&mut get_proc_address) as usize;
        }
        #[cfg(any(feature = "GL_OES_draw_elements_base_vertex"))]
        #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_OES_draw_elements_base_vertex"))))]
        {
            glDrawElementsBaseVertexOES_load_with_dyn(&mut get_proc_address) as usize;
        }
        glDrawElementsIndirect_load_with_dyn(&mut get_proc_address) as usize;
        glDrawElementsInstanced_load_with_dyn(&mut get_proc_address) as usize;
        #[cfg(any(feature = "GL_ANGLE_instanced_arrays"))]
        #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_ANGLE_instanced_arrays"))))]
        {
            glDrawElementsInstancedANGLE_load_with_dyn(&mut get_proc_address) as usize;
        }
        #[cfg(any(feature = "GL_EXT_base_instance"))]
        #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_base_instance"))))]
        {
            glDrawElementsInstancedBaseInstanceEXT_load_with_dyn(&mut get_proc_address) as usize;
        }
        glDrawElementsInstancedBaseVertex_load_with_dyn(&mut get_proc_address) as usize;
        #[cfg(any(feature = "GL_EXT_base_instance"))]
        #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_base_instance"))))]
        {
            glDrawElementsInstancedBaseVertexBaseInstanceEXT_load_with_dyn(&mut get_proc_address)
                as usize;
        }
        #[cfg(any(feature = "GL_EXT_draw_elements_base_vertex"))]
        #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_draw_elements_base_vertex"))))]
        {
            glDrawElementsInstancedBaseVertexEXT_load_with_dyn(&mut get_proc_address) as usize;
        }
        #[cfg(any(feature = "GL_OES_draw_elements_base_vertex"))]
        #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_OES_draw_elements_base_vertex"))))]
        {
            glDrawElementsInstancedBaseVertexOES_load_with_dyn(&mut get_proc_address) as usize;
        }
        #[cfg(any(feature = "GL_EXT_draw_instanced", feature = "GL_EXT_instanced_arrays"))]
        #[cfg_attr(
            docs_rs,
            doc(cfg(any(
                feature = "GL_EXT_draw_instanced",
                feature = "GL_EXT_instanced_arrays"
            )))
        )]
        {
            glDrawElementsInstancedEXT_load_with_dyn(&mut get_proc_address) as usize;
        }
        #[cfg(any(feature = "GL_NV_draw_instanced"))]
        #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_draw_instanced"))))]
        {
            glDrawElementsInstancedNV_load_with_dyn(&mut get_proc_address) as usize;
        }
        #[cfg(any(feature = "GL_NV_mesh_shader"))]
        #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_mesh_shader"))))]
        {
            glDrawMeshTasksIndirectNV_load_with_dyn(&mut get_proc_address) as usize;
        }
        #[cfg(any(feature = "GL_NV_mesh_shader"))]
        #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_mesh_shader"))))]
        {
            glDrawMeshTasksNV_load_with_dyn(&mut get_proc_address) as usize;
        }
        glDrawRangeElements_load_with_dyn(&mut get_proc_address) as usize;
        glDrawRangeElementsBaseVertex_load_with_dyn(&mut get_proc_address) as usize;
        #[cfg(any(feature = "GL_EXT_draw_elements_base_vertex"))]
        #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_draw_elements_base_vertex"))))]
        {
            glDrawRangeElementsBaseVertexEXT_load_with_dyn(&mut get_proc_address) as usize;
        }
        #[cfg(any(feature = "GL_OES_draw_elements_base_vertex"))]
        #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_OES_draw_elements_base_vertex"))))]
        {
            glDrawRangeElementsBaseVertexOES_load_with_dyn(&mut get_proc_address) as usize;
        }
        #[cfg(any(feature = "GL_EXT_draw_transform_feedback"))]
        #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_draw_transform_feedback"))))]
        {
            glDrawTransformFeedbackEXT_load_with_dyn(&mut get_proc_address) as usize;
        }
        #[cfg(any(feature = "GL_EXT_draw_transform_feedback"))]
        #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_draw_transform_feedback"))))]
        {
            glDrawTransformFeedbackInstancedEXT_load_with_dyn(&mut get_proc_address) as usize;
        }
        #[cfg(any(feature = "GL_NV_draw_vulkan_image"))]
        #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_draw_vulkan_image"))))]
        {
            glDrawVkImageNV_load_with_dyn(&mut get_proc_address) as usize;
        }
        #[cfg(any(feature = "GL_OES_EGL_image"))]
        #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_OES_EGL_image"))))]
        {
            glEGLImageTargetRenderbufferStorageOES_load_with_dyn(&mut get_proc_address) as usize;
        }
        #[cfg(any(feature = "GL_EXT_EGL_image_storage"))]
        #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_EGL_image_storage"))))]
        {
            glEGLImageTargetTexStorageEXT_load_with_dyn(&mut get_proc_address) as usize;
        }
        #[cfg(any(feature = "GL_OES_EGL_image"))]
        #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_OES_EGL_image"))))]
        {
            glEGLImageTargetTexture2DOES_load_with_dyn(&mut get_proc_address) as usize;
        }
        #[cfg(any(feature = "GL_EXT_EGL_image_storage"))]
        #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_EGL_image_storage"))))]
        {
            glEGLImageTargetTextureStorageEXT_load_with_dyn(&mut get_proc_address) as usize;
        }
        glEnable_load_with_dyn(&mut get_proc_address) as usize;
        #[cfg(any(feature = "GL_QCOM_driver_control"))]
        #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_QCOM_driver_control"))))]
        {
            glEnableDriverControlQCOM_load_with_dyn(&mut get_proc_address) as usize;
        }
        glEnableVertexAttribArray_load_with_dyn(&mut get_proc_address) as usize;
        glEnablei_load_with_dyn(&mut get_proc_address) as usize;
        #[cfg(any(feature = "GL_EXT_draw_buffers_indexed"))]
        #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_draw_buffers_indexed"))))]
        {
            glEnableiEXT_load_with_dyn(&mut get_proc_address) as usize;
        }
        #[cfg(any(feature = "GL_NV_viewport_array"))]
        #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_viewport_array"))))]
        {
            glEnableiNV_load_with_dyn(&mut get_proc_address) as usize;
        }
        #[cfg(any(
            feature = "GL_OES_draw_buffers_indexed",
            feature = "GL_OES_viewport_array"
        ))]
        #[cfg_attr(
            docs_rs,
            doc(cfg(any(
                feature = "GL_OES_draw_buffers_indexed",
                feature = "GL_OES_viewport_array"
            )))
        )]
        {
            glEnableiOES_load_with_dyn(&mut get_proc_address) as usize;
        }
        #[cfg(any(feature = "GL_NV_conditional_render"))]
        #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_conditional_render"))))]
        {
            glEndConditionalRenderNV_load_with_dyn(&mut get_proc_address) as usize;
        }
        #[cfg(any(feature = "GL_AMD_performance_monitor"))]
        #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_AMD_performance_monitor"))))]
        {
            glEndPerfMonitorAMD_load_with_dyn(&mut get_proc_address) as usize;
        }
        #[cfg(any(feature = "GL_INTEL_performance_query"))]
        #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_INTEL_performance_query"))))]
        {
            glEndPerfQueryINTEL_load_with_dyn(&mut get_proc_address) as usize;
        }
        glEndQuery_load_with_dyn(&mut get_proc_address) as usize;
        #[cfg(any(
            feature = "GL_EXT_disjoint_timer_query",
            feature = "GL_EXT_occlusion_query_boolean"
        ))]
        #[cfg_attr(
            docs_rs,
            doc(cfg(any(
                feature = "GL_EXT_disjoint_timer_query",
                feature = "GL_EXT_occlusion_query_boolean"
            )))
        )]
        {
            glEndQueryEXT_load_with_dyn(&mut get_proc_address) as usize;
        }
        #[cfg(any(feature = "GL_QCOM_tiled_rendering"))]
        #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_QCOM_tiled_rendering"))))]
        {
            glEndTilingQCOM_load_with_dyn(&mut get_proc_address) as usize;
        }
        glEndTransformFeedback_load_with_dyn(&mut get_proc_address) as usize;
        #[cfg(any(feature = "GL_QCOM_extended_get"))]
        #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_QCOM_extended_get"))))]
        {
            glExtGetBufferPointervQCOM_load_with_dyn(&mut get_proc_address) as usize;
        }
        #[cfg(any(feature = "GL_QCOM_extended_get"))]
        #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_QCOM_extended_get"))))]
        {
            glExtGetBuffersQCOM_load_with_dyn(&mut get_proc_address) as usize;
        }
        #[cfg(any(feature = "GL_QCOM_extended_get"))]
        #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_QCOM_extended_get"))))]
        {
            glExtGetFramebuffersQCOM_load_with_dyn(&mut get_proc_address) as usize;
        }
        #[cfg(any(feature = "GL_QCOM_extended_get2"))]
        #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_QCOM_extended_get2"))))]
        {
            glExtGetProgramBinarySourceQCOM_load_with_dyn(&mut get_proc_address) as usize;
        }
        #[cfg(any(feature = "GL_QCOM_extended_get2"))]
        #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_QCOM_extended_get2"))))]
        {
            glExtGetProgramsQCOM_load_with_dyn(&mut get_proc_address) as usize;
        }
        #[cfg(any(feature = "GL_QCOM_extended_get"))]
        #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_QCOM_extended_get"))))]
        {
            glExtGetRenderbuffersQCOM_load_with_dyn(&mut get_proc_address) as usize;
        }
        #[cfg(any(feature = "GL_QCOM_extended_get2"))]
        #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_QCOM_extended_get2"))))]
        {
            glExtGetShadersQCOM_load_with_dyn(&mut get_proc_address) as usize;
        }
        #[cfg(any(feature = "GL_QCOM_extended_get"))]
        #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_QCOM_extended_get"))))]
        {
            glExtGetTexLevelParameterivQCOM_load_with_dyn(&mut get_proc_address) as usize;
        }
        #[cfg(any(feature = "GL_QCOM_extended_get"))]
        #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_QCOM_extended_get"))))]
        {
            glExtGetTexSubImageQCOM_load_with_dyn(&mut get_proc_address) as usize;
        }
        #[cfg(any(feature = "GL_QCOM_extended_get"))]
        #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_QCOM_extended_get"))))]
        {
            glExtGetTexturesQCOM_load_with_dyn(&mut get_proc_address) as usize;
        }
        #[cfg(any(feature = "GL_QCOM_extended_get2"))]
        #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_QCOM_extended_get2"))))]
        {
            glExtIsProgramBinaryQCOM_load_with_dyn(&mut get_proc_address) as usize;
        }
        #[cfg(any(feature = "GL_QCOM_extended_get"))]
        #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_QCOM_extended_get"))))]
        {
            glExtTexObjectStateOverrideiQCOM_load_with_dyn(&mut get_proc_address) as usize;
        }
        #[cfg(any(feature = "GL_QCOM_frame_extrapolation"))]
        #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_QCOM_frame_extrapolation"))))]
        {
            glExtrapolateTex2DQCOM_load_with_dyn(&mut get_proc_address) as usize;
        }
        glFenceSync_load_with_dyn(&mut get_proc_address) as usize;
        #[cfg(any(feature = "GL_APPLE_sync"))]
        #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_APPLE_sync"))))]
        {
            glFenceSyncAPPLE_load_with_dyn(&mut get_proc_address) as usize;
        }
        glFinish_load_with_dyn(&mut get_proc_address) as usize;
        #[cfg(any(feature = "GL_NV_fence"))]
        #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_fence"))))]
        {
            glFinishFenceNV_load_with_dyn(&mut get_proc_address) as usize;
        }
        glFlush_load_with_dyn(&mut get_proc_address) as usize;
        glFlushMappedBufferRange_load_with_dyn(&mut get_proc_address) as usize;
        #[cfg(any(feature = "GL_EXT_map_buffer_range"))]
        #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_map_buffer_range"))))]
        {
            glFlushMappedBufferRangeEXT_load_with_dyn(&mut get_proc_address) as usize;
        }
        #[cfg(any(feature = "GL_NV_fragment_coverage_to_color"))]
        #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_fragment_coverage_to_color"))))]
        {
            glFragmentCoverageColorNV_load_with_dyn(&mut get_proc_address) as usize;
        }
        #[cfg(any(feature = "GL_EXT_shader_framebuffer_fetch_non_coherent"))]
        #[cfg_attr(
            docs_rs,
            doc(cfg(any(feature = "GL_EXT_shader_framebuffer_fetch_non_coherent")))
        )]
        {
            glFramebufferFetchBarrierEXT_load_with_dyn(&mut get_proc_address) as usize;
        }
        #[cfg(any(feature = "GL_QCOM_shader_framebuffer_fetch_noncoherent"))]
        #[cfg_attr(
            docs_rs,
            doc(cfg(any(feature = "GL_QCOM_shader_framebuffer_fetch_noncoherent")))
        )]
        {
            glFramebufferFetchBarrierQCOM_load_with_dyn(&mut get_proc_address) as usize;
        }
        #[cfg(any(feature = "GL_QCOM_framebuffer_foveated"))]
        #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_QCOM_framebuffer_foveated"))))]
        {
            glFramebufferFoveationConfigQCOM_load_with_dyn(&mut get_proc_address) as usize;
        }
        #[cfg(any(feature = "GL_QCOM_framebuffer_foveated"))]
        #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_QCOM_framebuffer_foveated"))))]
        {
            glFramebufferFoveationParametersQCOM_load_with_dyn(&mut get_proc_address) as usize;
        }
        glFramebufferParameteri_load_with_dyn(&mut get_proc_address) as usize;
        #[cfg(any(feature = "GL_MESA_framebuffer_flip_y"))]
        #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_MESA_framebuffer_flip_y"))))]
        {
            glFramebufferParameteriMESA_load_with_dyn(&mut get_proc_address) as usize;
        }
        #[cfg(any(feature = "GL_EXT_shader_pixel_local_storage2"))]
        #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_shader_pixel_local_storage2"))))]
        {
            glFramebufferPixelLocalStorageSizeEXT_load_with_dyn(&mut get_proc_address) as usize;
        }
        glFramebufferRenderbuffer_load_with_dyn(&mut get_proc_address) as usize;
        #[cfg(any(feature = "GL_NV_sample_locations"))]
        #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_sample_locations"))))]
        {
            glFramebufferSampleLocationsfvNV_load_with_dyn(&mut get_proc_address) as usize;
        }
        glFramebufferTexture_load_with_dyn(&mut get_proc_address) as usize;
        glFramebufferTexture2D_load_with_dyn(&mut get_proc_address) as usize;
        #[cfg(any(feature = "GL_IMG_framebuffer_downsample"))]
        #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_IMG_framebuffer_downsample"))))]
        {
            glFramebufferTexture2DDownsampleIMG_load_with_dyn(&mut get_proc_address) as usize;
        }
        #[cfg(any(feature = "GL_EXT_multisampled_render_to_texture"))]
        #[cfg_attr(
            docs_rs,
            doc(cfg(any(feature = "GL_EXT_multisampled_render_to_texture")))
        )]
        {
            glFramebufferTexture2DMultisampleEXT_load_with_dyn(&mut get_proc_address) as usize;
        }
        #[cfg(any(feature = "GL_IMG_multisampled_render_to_texture"))]
        #[cfg_attr(
            docs_rs,
            doc(cfg(any(feature = "GL_IMG_multisampled_render_to_texture")))
        )]
        {
            glFramebufferTexture2DMultisampleIMG_load_with_dyn(&mut get_proc_address) as usize;
        }
        #[cfg(any(feature = "GL_OES_texture_3D"))]
        #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_OES_texture_3D"))))]
        {
            glFramebufferTexture3DOES_load_with_dyn(&mut get_proc_address) as usize;
        }
        #[cfg(any(feature = "GL_EXT_geometry_shader"))]
        #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_geometry_shader"))))]
        {
            glFramebufferTextureEXT_load_with_dyn(&mut get_proc_address) as usize;
        }
        glFramebufferTextureLayer_load_with_dyn(&mut get_proc_address) as usize;
        #[cfg(any(feature = "GL_IMG_framebuffer_downsample"))]
        #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_IMG_framebuffer_downsample"))))]
        {
            glFramebufferTextureLayerDownsampleIMG_load_with_dyn(&mut get_proc_address) as usize;
        }
        #[cfg(any(feature = "GL_OVR_multiview_multisampled_render_to_texture"))]
        #[cfg_attr(
            docs_rs,
            doc(cfg(any(feature = "GL_OVR_multiview_multisampled_render_to_texture")))
        )]
        {
            glFramebufferTextureMultisampleMultiviewOVR_load_with_dyn(&mut get_proc_address)
                as usize;
        }
        #[cfg(any(feature = "GL_OVR_multiview"))]
        #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_OVR_multiview"))))]
        {
            glFramebufferTextureMultiviewOVR_load_with_dyn(&mut get_proc_address) as usize;
        }
        #[cfg(any(feature = "GL_OES_geometry_shader"))]
        #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_OES_geometry_shader"))))]
        {
            glFramebufferTextureOES_load_with_dyn(&mut get_proc_address) as usize;
        }
        glFrontFace_load_with_dyn(&mut get_proc_address) as usize;
        glGenBuffers_load_with_dyn(&mut get_proc_address) as usize;
        #[cfg(any(feature = "GL_NV_fence"))]
        #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_fence"))))]
        {
            glGenFencesNV_load_with_dyn(&mut get_proc_address) as usize;
        }
        glGenFramebuffers_load_with_dyn(&mut get_proc_address) as usize;
        #[cfg(any(feature = "GL_NV_path_rendering"))]
        #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_path_rendering"))))]
        {
            glGenPathsNV_load_with_dyn(&mut get_proc_address) as usize;
        }
        #[cfg(any(feature = "GL_AMD_performance_monitor"))]
        #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_AMD_performance_monitor"))))]
        {
            glGenPerfMonitorsAMD_load_with_dyn(&mut get_proc_address) as usize;
        }
        glGenProgramPipelines_load_with_dyn(&mut get_proc_address) as usize;
        #[cfg(any(feature = "GL_EXT_separate_shader_objects"))]
        #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_separate_shader_objects"))))]
        {
            glGenProgramPipelinesEXT_load_with_dyn(&mut get_proc_address) as usize;
        }
        glGenQueries_load_with_dyn(&mut get_proc_address) as usize;
        #[cfg(any(
            feature = "GL_EXT_disjoint_timer_query",
            feature = "GL_EXT_occlusion_query_boolean"
        ))]
        #[cfg_attr(
            docs_rs,
            doc(cfg(any(
                feature = "GL_EXT_disjoint_timer_query",
                feature = "GL_EXT_occlusion_query_boolean"
            )))
        )]
        {
            glGenQueriesEXT_load_with_dyn(&mut get_proc_address) as usize;
        }
        glGenRenderbuffers_load_with_dyn(&mut get_proc_address) as usize;
        glGenSamplers_load_with_dyn(&mut get_proc_address) as usize;
        #[cfg(any(feature = "GL_EXT_semaphore"))]
        #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_semaphore"))))]
        {
            glGenSemaphoresEXT_load_with_dyn(&mut get_proc_address) as usize;
        }
        glGenTextures_load_with_dyn(&mut get_proc_address) as usize;
        glGenTransformFeedbacks_load_with_dyn(&mut get_proc_address) as usize;
        glGenVertexArrays_load_with_dyn(&mut get_proc_address) as usize;
        #[cfg(any(feature = "GL_OES_vertex_array_object"))]
        #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_OES_vertex_array_object"))))]
        {
            glGenVertexArraysOES_load_with_dyn(&mut get_proc_address) as usize;
        }
        glGenerateMipmap_load_with_dyn(&mut get_proc_address) as usize;
        glGetActiveAttrib_load_with_dyn(&mut get_proc_address) as usize;
        glGetActiveUniform_load_with_dyn(&mut get_proc_address) as usize;
        glGetActiveUniformBlockName_load_with_dyn(&mut get_proc_address) as usize;
        glGetActiveUniformBlockiv_load_with_dyn(&mut get_proc_address) as usize;
        glGetActiveUniformsiv_load_with_dyn(&mut get_proc_address) as usize;
        glGetAttachedShaders_load_with_dyn(&mut get_proc_address) as usize;
        glGetAttribLocation_load_with_dyn(&mut get_proc_address) as usize;
        glGetBooleani_v_load_with_dyn(&mut get_proc_address) as usize;
        glGetBooleanv_load_with_dyn(&mut get_proc_address) as usize;
        glGetBufferParameteri64v_load_with_dyn(&mut get_proc_address) as usize;
        glGetBufferParameteriv_load_with_dyn(&mut get_proc_address) as usize;
        glGetBufferPointerv_load_with_dyn(&mut get_proc_address) as usize;
        #[cfg(any(feature = "GL_OES_mapbuffer"))]
        #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_OES_mapbuffer"))))]
        {
            glGetBufferPointervOES_load_with_dyn(&mut get_proc_address) as usize;
        }
        #[cfg(any(feature = "GL_NV_framebuffer_mixed_samples"))]
        #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_framebuffer_mixed_samples"))))]
        {
            glGetCoverageModulationTableNV_load_with_dyn(&mut get_proc_address) as usize;
        }
        glGetDebugMessageLog_load_with_dyn(&mut get_proc_address) as usize;
        #[cfg(any(feature = "GL_KHR_debug"))]
        #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_KHR_debug"))))]
        {
            glGetDebugMessageLogKHR_load_with_dyn(&mut get_proc_address) as usize;
        }
        #[cfg(any(feature = "GL_QCOM_driver_control"))]
        #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_QCOM_driver_control"))))]
        {
            glGetDriverControlStringQCOM_load_with_dyn(&mut get_proc_address) as usize;
        }
        #[cfg(any(feature = "GL_QCOM_driver_control"))]
        #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_QCOM_driver_control"))))]
        {
            glGetDriverControlsQCOM_load_with_dyn(&mut get_proc_address) as usize;
        }
        glGetError_load_with_dyn(&mut get_proc_address) as usize;
        #[cfg(any(feature = "GL_NV_fence"))]
        #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_fence"))))]
        {
            glGetFenceivNV_load_with_dyn(&mut get_proc_address) as usize;
        }
        #[cfg(any(feature = "GL_INTEL_performance_query"))]
        #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_INTEL_performance_query"))))]
        {
            glGetFirstPerfQueryIdINTEL_load_with_dyn(&mut get_proc_address) as usize;
        }
        #[cfg(any(feature = "GL_NV_viewport_array"))]
        #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_viewport_array"))))]
        {
            glGetFloati_vNV_load_with_dyn(&mut get_proc_address) as usize;
        }
        #[cfg(any(feature = "GL_OES_viewport_array"))]
        #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_OES_viewport_array"))))]
        {
            glGetFloati_vOES_load_with_dyn(&mut get_proc_address) as usize;
        }
        glGetFloatv_load_with_dyn(&mut get_proc_address) as usize;
        #[cfg(any(feature = "GL_EXT_blend_func_extended"))]
        #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_blend_func_extended"))))]
        {
            glGetFragDataIndexEXT_load_with_dyn(&mut get_proc_address) as usize;
        }
        glGetFragDataLocation_load_with_dyn(&mut get_proc_address) as usize;
        glGetFramebufferAttachmentParameteriv_load_with_dyn(&mut get_proc_address) as usize;
        glGetFramebufferParameteriv_load_with_dyn(&mut get_proc_address) as usize;
        #[cfg(any(feature = "GL_MESA_framebuffer_flip_y"))]
        #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_MESA_framebuffer_flip_y"))))]
        {
            glGetFramebufferParameterivMESA_load_with_dyn(&mut get_proc_address) as usize;
        }
        #[cfg(any(feature = "GL_EXT_shader_pixel_local_storage2"))]
        #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_shader_pixel_local_storage2"))))]
        {
            glGetFramebufferPixelLocalStorageSizeEXT_load_with_dyn(&mut get_proc_address) as usize;
        }
        glGetGraphicsResetStatus_load_with_dyn(&mut get_proc_address) as usize;
        #[cfg(any(feature = "GL_EXT_robustness"))]
        #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_robustness"))))]
        {
            glGetGraphicsResetStatusEXT_load_with_dyn(&mut get_proc_address) as usize;
        }
        #[cfg(any(feature = "GL_KHR_robustness"))]
        #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_KHR_robustness"))))]
        {
            glGetGraphicsResetStatusKHR_load_with_dyn(&mut get_proc_address) as usize;
        }
        #[cfg(any(feature = "GL_NV_bindless_texture"))]
        #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_bindless_texture"))))]
        {
            glGetImageHandleNV_load_with_dyn(&mut get_proc_address) as usize;
        }
        glGetInteger64i_v_load_with_dyn(&mut get_proc_address) as usize;
        glGetInteger64v_load_with_dyn(&mut get_proc_address) as usize;
        #[cfg(any(feature = "GL_APPLE_sync"))]
        #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_APPLE_sync"))))]
        {
            glGetInteger64vAPPLE_load_with_dyn(&mut get_proc_address) as usize;
        }
        #[cfg(any(feature = "GL_EXT_disjoint_timer_query"))]
        #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_disjoint_timer_query"))))]
        {
            glGetInteger64vEXT_load_with_dyn(&mut get_proc_address) as usize;
        }
        glGetIntegeri_v_load_with_dyn(&mut get_proc_address) as usize;
        #[cfg(any(feature = "GL_EXT_multiview_draw_buffers"))]
        #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_multiview_draw_buffers"))))]
        {
            glGetIntegeri_vEXT_load_with_dyn(&mut get_proc_address) as usize;
        }
        glGetIntegerv_load_with_dyn(&mut get_proc_address) as usize;
        #[cfg(any(feature = "GL_NV_internalformat_sample_query"))]
        #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_internalformat_sample_query"))))]
        {
            glGetInternalformatSampleivNV_load_with_dyn(&mut get_proc_address) as usize;
        }
        glGetInternalformativ_load_with_dyn(&mut get_proc_address) as usize;
        #[cfg(any(feature = "GL_NV_memory_attachment"))]
        #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_memory_attachment"))))]
        {
            glGetMemoryObjectDetachedResourcesuivNV_load_with_dyn(&mut get_proc_address) as usize;
        }
        #[cfg(any(feature = "GL_EXT_memory_object"))]
        #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_memory_object"))))]
        {
            glGetMemoryObjectParameterivEXT_load_with_dyn(&mut get_proc_address) as usize;
        }
        glGetMultisamplefv_load_with_dyn(&mut get_proc_address) as usize;
        #[cfg(any(feature = "GL_INTEL_performance_query"))]
        #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_INTEL_performance_query"))))]
        {
            glGetNextPerfQueryIdINTEL_load_with_dyn(&mut get_proc_address) as usize;
        }
        glGetObjectLabel_load_with_dyn(&mut get_proc_address) as usize;
        #[cfg(any(feature = "GL_EXT_debug_label"))]
        #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_debug_label"))))]
        {
            glGetObjectLabelEXT_load_with_dyn(&mut get_proc_address) as usize;
        }
        #[cfg(any(feature = "GL_KHR_debug"))]
        #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_KHR_debug"))))]
        {
            glGetObjectLabelKHR_load_with_dyn(&mut get_proc_address) as usize;
        }
        glGetObjectPtrLabel_load_with_dyn(&mut get_proc_address) as usize;
        #[cfg(any(feature = "GL_KHR_debug"))]
        #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_KHR_debug"))))]
        {
            glGetObjectPtrLabelKHR_load_with_dyn(&mut get_proc_address) as usize;
        }
        #[cfg(any(feature = "GL_NV_path_rendering"))]
        #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_path_rendering"))))]
        {
            glGetPathCommandsNV_load_with_dyn(&mut get_proc_address) as usize;
        }
        #[cfg(any(feature = "GL_NV_path_rendering"))]
        #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_path_rendering"))))]
        {
            glGetPathCoordsNV_load_with_dyn(&mut get_proc_address) as usize;
        }
        #[cfg(any(feature = "GL_NV_path_rendering"))]
        #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_path_rendering"))))]
        {
            glGetPathDashArrayNV_load_with_dyn(&mut get_proc_address) as usize;
        }
        #[cfg(any(feature = "GL_NV_path_rendering"))]
        #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_path_rendering"))))]
        {
            glGetPathLengthNV_load_with_dyn(&mut get_proc_address) as usize;
        }
        #[cfg(any(feature = "GL_NV_path_rendering"))]
        #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_path_rendering"))))]
        {
            glGetPathMetricRangeNV_load_with_dyn(&mut get_proc_address) as usize;
        }
        #[cfg(any(feature = "GL_NV_path_rendering"))]
        #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_path_rendering"))))]
        {
            glGetPathMetricsNV_load_with_dyn(&mut get_proc_address) as usize;
        }
        #[cfg(any(feature = "GL_NV_path_rendering"))]
        #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_path_rendering"))))]
        {
            glGetPathParameterfvNV_load_with_dyn(&mut get_proc_address) as usize;
        }
        #[cfg(any(feature = "GL_NV_path_rendering"))]
        #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_path_rendering"))))]
        {
            glGetPathParameterivNV_load_with_dyn(&mut get_proc_address) as usize;
        }
        #[cfg(any(feature = "GL_NV_path_rendering"))]
        #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_path_rendering"))))]
        {
            glGetPathSpacingNV_load_with_dyn(&mut get_proc_address) as usize;
        }
        #[cfg(any(feature = "GL_INTEL_performance_query"))]
        #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_INTEL_performance_query"))))]
        {
            glGetPerfCounterInfoINTEL_load_with_dyn(&mut get_proc_address) as usize;
        }
        #[cfg(any(feature = "GL_AMD_performance_monitor"))]
        #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_AMD_performance_monitor"))))]
        {
            glGetPerfMonitorCounterDataAMD_load_with_dyn(&mut get_proc_address) as usize;
        }
        #[cfg(any(feature = "GL_AMD_performance_monitor"))]
        #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_AMD_performance_monitor"))))]
        {
            glGetPerfMonitorCounterInfoAMD_load_with_dyn(&mut get_proc_address) as usize;
        }
        #[cfg(any(feature = "GL_AMD_performance_monitor"))]
        #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_AMD_performance_monitor"))))]
        {
            glGetPerfMonitorCounterStringAMD_load_with_dyn(&mut get_proc_address) as usize;
        }
        #[cfg(any(feature = "GL_AMD_performance_monitor"))]
        #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_AMD_performance_monitor"))))]
        {
            glGetPerfMonitorCountersAMD_load_with_dyn(&mut get_proc_address) as usize;
        }
        #[cfg(any(feature = "GL_AMD_performance_monitor"))]
        #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_AMD_performance_monitor"))))]
        {
            glGetPerfMonitorGroupStringAMD_load_with_dyn(&mut get_proc_address) as usize;
        }
        #[cfg(any(feature = "GL_AMD_performance_monitor"))]
        #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_AMD_performance_monitor"))))]
        {
            glGetPerfMonitorGroupsAMD_load_with_dyn(&mut get_proc_address) as usize;
        }
        #[cfg(any(feature = "GL_INTEL_performance_query"))]
        #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_INTEL_performance_query"))))]
        {
            glGetPerfQueryDataINTEL_load_with_dyn(&mut get_proc_address) as usize;
        }
        #[cfg(any(feature = "GL_INTEL_performance_query"))]
        #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_INTEL_performance_query"))))]
        {
            glGetPerfQueryIdByNameINTEL_load_with_dyn(&mut get_proc_address) as usize;
        }
        #[cfg(any(feature = "GL_INTEL_performance_query"))]
        #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_INTEL_performance_query"))))]
        {
            glGetPerfQueryInfoINTEL_load_with_dyn(&mut get_proc_address) as usize;
        }
        glGetPointerv_load_with_dyn(&mut get_proc_address) as usize;
        #[cfg(any(feature = "GL_KHR_debug"))]
        #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_KHR_debug"))))]
        {
            glGetPointervKHR_load_with_dyn(&mut get_proc_address) as usize;
        }
        glGetProgramBinary_load_with_dyn(&mut get_proc_address) as usize;
        #[cfg(any(feature = "GL_OES_get_program_binary"))]
        #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_OES_get_program_binary"))))]
        {
            glGetProgramBinaryOES_load_with_dyn(&mut get_proc_address) as usize;
        }
        glGetProgramInfoLog_load_with_dyn(&mut get_proc_address) as usize;
        glGetProgramInterfaceiv_load_with_dyn(&mut get_proc_address) as usize;
        glGetProgramPipelineInfoLog_load_with_dyn(&mut get_proc_address) as usize;
        #[cfg(any(feature = "GL_EXT_separate_shader_objects"))]
        #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_separate_shader_objects"))))]
        {
            glGetProgramPipelineInfoLogEXT_load_with_dyn(&mut get_proc_address) as usize;
        }
        glGetProgramPipelineiv_load_with_dyn(&mut get_proc_address) as usize;
        #[cfg(any(feature = "GL_EXT_separate_shader_objects"))]
        #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_separate_shader_objects"))))]
        {
            glGetProgramPipelineivEXT_load_with_dyn(&mut get_proc_address) as usize;
        }
        glGetProgramResourceIndex_load_with_dyn(&mut get_proc_address) as usize;
        glGetProgramResourceLocation_load_with_dyn(&mut get_proc_address) as usize;
        #[cfg(any(feature = "GL_EXT_blend_func_extended"))]
        #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_blend_func_extended"))))]
        {
            glGetProgramResourceLocationIndexEXT_load_with_dyn(&mut get_proc_address) as usize;
        }
        glGetProgramResourceName_load_with_dyn(&mut get_proc_address) as usize;
        #[cfg(any(feature = "GL_NV_path_rendering"))]
        #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_path_rendering"))))]
        {
            glGetProgramResourcefvNV_load_with_dyn(&mut get_proc_address) as usize;
        }
        glGetProgramResourceiv_load_with_dyn(&mut get_proc_address) as usize;
        glGetProgramiv_load_with_dyn(&mut get_proc_address) as usize;
        #[cfg(any(feature = "GL_EXT_disjoint_timer_query"))]
        #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_disjoint_timer_query"))))]
        {
            glGetQueryObjecti64vEXT_load_with_dyn(&mut get_proc_address) as usize;
        }
        #[cfg(any(feature = "GL_EXT_disjoint_timer_query"))]
        #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_disjoint_timer_query"))))]
        {
            glGetQueryObjectivEXT_load_with_dyn(&mut get_proc_address) as usize;
        }
        #[cfg(any(feature = "GL_EXT_disjoint_timer_query"))]
        #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_disjoint_timer_query"))))]
        {
            glGetQueryObjectui64vEXT_load_with_dyn(&mut get_proc_address) as usize;
        }
        glGetQueryObjectuiv_load_with_dyn(&mut get_proc_address) as usize;
        #[cfg(any(
            feature = "GL_EXT_disjoint_timer_query",
            feature = "GL_EXT_occlusion_query_boolean"
        ))]
        #[cfg_attr(
            docs_rs,
            doc(cfg(any(
                feature = "GL_EXT_disjoint_timer_query",
                feature = "GL_EXT_occlusion_query_boolean"
            )))
        )]
        {
            glGetQueryObjectuivEXT_load_with_dyn(&mut get_proc_address) as usize;
        }
        glGetQueryiv_load_with_dyn(&mut get_proc_address) as usize;
        #[cfg(any(
            feature = "GL_EXT_disjoint_timer_query",
            feature = "GL_EXT_occlusion_query_boolean"
        ))]
        #[cfg_attr(
            docs_rs,
            doc(cfg(any(
                feature = "GL_EXT_disjoint_timer_query",
                feature = "GL_EXT_occlusion_query_boolean"
            )))
        )]
        {
            glGetQueryivEXT_load_with_dyn(&mut get_proc_address) as usize;
        }
        glGetRenderbufferParameteriv_load_with_dyn(&mut get_proc_address) as usize;
        glGetSamplerParameterIiv_load_with_dyn(&mut get_proc_address) as usize;
        #[cfg(any(feature = "GL_EXT_texture_border_clamp"))]
        #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_texture_border_clamp"))))]
        {
            glGetSamplerParameterIivEXT_load_with_dyn(&mut get_proc_address) as usize;
        }
        #[cfg(any(feature = "GL_OES_texture_border_clamp"))]
        #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_OES_texture_border_clamp"))))]
        {
            glGetSamplerParameterIivOES_load_with_dyn(&mut get_proc_address) as usize;
        }
        glGetSamplerParameterIuiv_load_with_dyn(&mut get_proc_address) as usize;
        #[cfg(any(feature = "GL_EXT_texture_border_clamp"))]
        #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_texture_border_clamp"))))]
        {
            glGetSamplerParameterIuivEXT_load_with_dyn(&mut get_proc_address) as usize;
        }
        #[cfg(any(feature = "GL_OES_texture_border_clamp"))]
        #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_OES_texture_border_clamp"))))]
        {
            glGetSamplerParameterIuivOES_load_with_dyn(&mut get_proc_address) as usize;
        }
        glGetSamplerParameterfv_load_with_dyn(&mut get_proc_address) as usize;
        glGetSamplerParameteriv_load_with_dyn(&mut get_proc_address) as usize;
        #[cfg(any(feature = "GL_NV_timeline_semaphore"))]
        #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_timeline_semaphore"))))]
        {
            glGetSemaphoreParameterivNV_load_with_dyn(&mut get_proc_address) as usize;
        }
        #[cfg(any(feature = "GL_EXT_semaphore"))]
        #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_semaphore"))))]
        {
            glGetSemaphoreParameterui64vEXT_load_with_dyn(&mut get_proc_address) as usize;
        }
        glGetShaderInfoLog_load_with_dyn(&mut get_proc_address) as usize;
        glGetShaderPrecisionFormat_load_with_dyn(&mut get_proc_address) as usize;
        glGetShaderSource_load_with_dyn(&mut get_proc_address) as usize;
        glGetShaderiv_load_with_dyn(&mut get_proc_address) as usize;
        #[cfg(any(feature = "GL_NV_shading_rate_image"))]
        #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_shading_rate_image"))))]
        {
            glGetShadingRateImagePaletteNV_load_with_dyn(&mut get_proc_address) as usize;
        }
        #[cfg(any(feature = "GL_NV_shading_rate_image"))]
        #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_shading_rate_image"))))]
        {
            glGetShadingRateSampleLocationivNV_load_with_dyn(&mut get_proc_address) as usize;
        }
        glGetString_load_with_dyn(&mut get_proc_address) as usize;
        glGetStringi_load_with_dyn(&mut get_proc_address) as usize;
        glGetSynciv_load_with_dyn(&mut get_proc_address) as usize;
        #[cfg(any(feature = "GL_APPLE_sync"))]
        #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_APPLE_sync"))))]
        {
            glGetSyncivAPPLE_load_with_dyn(&mut get_proc_address) as usize;
        }
        glGetTexLevelParameterfv_load_with_dyn(&mut get_proc_address) as usize;
        glGetTexLevelParameteriv_load_with_dyn(&mut get_proc_address) as usize;
        glGetTexParameterIiv_load_with_dyn(&mut get_proc_address) as usize;
        #[cfg(any(feature = "GL_EXT_texture_border_clamp"))]
        #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_texture_border_clamp"))))]
        {
            glGetTexParameterIivEXT_load_with_dyn(&mut get_proc_address) as usize;
        }
        #[cfg(any(feature = "GL_OES_texture_border_clamp"))]
        #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_OES_texture_border_clamp"))))]
        {
            glGetTexParameterIivOES_load_with_dyn(&mut get_proc_address) as usize;
        }
        glGetTexParameterIuiv_load_with_dyn(&mut get_proc_address) as usize;
        #[cfg(any(feature = "GL_EXT_texture_border_clamp"))]
        #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_texture_border_clamp"))))]
        {
            glGetTexParameterIuivEXT_load_with_dyn(&mut get_proc_address) as usize;
        }
        #[cfg(any(feature = "GL_OES_texture_border_clamp"))]
        #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_OES_texture_border_clamp"))))]
        {
            glGetTexParameterIuivOES_load_with_dyn(&mut get_proc_address) as usize;
        }
        glGetTexParameterfv_load_with_dyn(&mut get_proc_address) as usize;
        glGetTexParameteriv_load_with_dyn(&mut get_proc_address) as usize;
        #[cfg(any(feature = "GL_IMG_bindless_texture"))]
        #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_IMG_bindless_texture"))))]
        {
            glGetTextureHandleIMG_load_with_dyn(&mut get_proc_address) as usize;
        }
        #[cfg(any(feature = "GL_NV_bindless_texture"))]
        #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_bindless_texture"))))]
        {
            glGetTextureHandleNV_load_with_dyn(&mut get_proc_address) as usize;
        }
        #[cfg(any(feature = "GL_IMG_bindless_texture"))]
        #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_IMG_bindless_texture"))))]
        {
            glGetTextureSamplerHandleIMG_load_with_dyn(&mut get_proc_address) as usize;
        }
        #[cfg(any(feature = "GL_NV_bindless_texture"))]
        #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_bindless_texture"))))]
        {
            glGetTextureSamplerHandleNV_load_with_dyn(&mut get_proc_address) as usize;
        }
        glGetTransformFeedbackVarying_load_with_dyn(&mut get_proc_address) as usize;
        #[cfg(any(feature = "GL_ANGLE_translated_shader_source"))]
        #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_ANGLE_translated_shader_source"))))]
        {
            glGetTranslatedShaderSourceANGLE_load_with_dyn(&mut get_proc_address) as usize;
        }
        glGetUniformBlockIndex_load_with_dyn(&mut get_proc_address) as usize;
        glGetUniformIndices_load_with_dyn(&mut get_proc_address) as usize;
        glGetUniformLocation_load_with_dyn(&mut get_proc_address) as usize;
        glGetUniformfv_load_with_dyn(&mut get_proc_address) as usize;
        #[cfg(any(feature = "GL_NV_gpu_shader5"))]
        #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_gpu_shader5"))))]
        {
            glGetUniformi64vNV_load_with_dyn(&mut get_proc_address) as usize;
        }
        glGetUniformiv_load_with_dyn(&mut get_proc_address) as usize;
        glGetUniformuiv_load_with_dyn(&mut get_proc_address) as usize;
        #[cfg(any(feature = "GL_EXT_memory_object", feature = "GL_EXT_semaphore"))]
        #[cfg_attr(
            docs_rs,
            doc(cfg(any(feature = "GL_EXT_memory_object", feature = "GL_EXT_semaphore")))
        )]
        {
            glGetUnsignedBytei_vEXT_load_with_dyn(&mut get_proc_address) as usize;
        }
        #[cfg(any(feature = "GL_EXT_memory_object", feature = "GL_EXT_semaphore"))]
        #[cfg_attr(
            docs_rs,
            doc(cfg(any(feature = "GL_EXT_memory_object", feature = "GL_EXT_semaphore")))
        )]
        {
            glGetUnsignedBytevEXT_load_with_dyn(&mut get_proc_address) as usize;
        }
        glGetVertexAttribIiv_load_with_dyn(&mut get_proc_address) as usize;
        glGetVertexAttribIuiv_load_with_dyn(&mut get_proc_address) as usize;
        glGetVertexAttribPointerv_load_with_dyn(&mut get_proc_address) as usize;
        glGetVertexAttribfv_load_with_dyn(&mut get_proc_address) as usize;
        glGetVertexAttribiv_load_with_dyn(&mut get_proc_address) as usize;
        #[cfg(any(feature = "GL_NV_draw_vulkan_image"))]
        #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_draw_vulkan_image"))))]
        {
            glGetVkProcAddrNV_load_with_dyn(&mut get_proc_address) as usize;
        }
        glGetnUniformfv_load_with_dyn(&mut get_proc_address) as usize;
        #[cfg(any(feature = "GL_EXT_robustness"))]
        #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_robustness"))))]
        {
            glGetnUniformfvEXT_load_with_dyn(&mut get_proc_address) as usize;
        }
        #[cfg(any(feature = "GL_KHR_robustness"))]
        #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_KHR_robustness"))))]
        {
            glGetnUniformfvKHR_load_with_dyn(&mut get_proc_address) as usize;
        }
        glGetnUniformiv_load_with_dyn(&mut get_proc_address) as usize;
        #[cfg(any(feature = "GL_EXT_robustness"))]
        #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_robustness"))))]
        {
            glGetnUniformivEXT_load_with_dyn(&mut get_proc_address) as usize;
        }
        #[cfg(any(feature = "GL_KHR_robustness"))]
        #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_KHR_robustness"))))]
        {
            glGetnUniformivKHR_load_with_dyn(&mut get_proc_address) as usize;
        }
        glGetnUniformuiv_load_with_dyn(&mut get_proc_address) as usize;
        #[cfg(any(feature = "GL_KHR_robustness"))]
        #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_KHR_robustness"))))]
        {
            glGetnUniformuivKHR_load_with_dyn(&mut get_proc_address) as usize;
        }
        glHint_load_with_dyn(&mut get_proc_address) as usize;
        #[cfg(any(feature = "GL_EXT_memory_object_fd"))]
        #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_memory_object_fd"))))]
        {
            glImportMemoryFdEXT_load_with_dyn(&mut get_proc_address) as usize;
        }
        #[cfg(any(feature = "GL_EXT_memory_object_win32"))]
        #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_memory_object_win32"))))]
        {
            glImportMemoryWin32HandleEXT_load_with_dyn(&mut get_proc_address) as usize;
        }
        #[cfg(any(feature = "GL_EXT_memory_object_win32"))]
        #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_memory_object_win32"))))]
        {
            glImportMemoryWin32NameEXT_load_with_dyn(&mut get_proc_address) as usize;
        }
        #[cfg(any(feature = "GL_EXT_semaphore_fd"))]
        #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_semaphore_fd"))))]
        {
            glImportSemaphoreFdEXT_load_with_dyn(&mut get_proc_address) as usize;
        }
        #[cfg(any(feature = "GL_EXT_semaphore_win32"))]
        #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_semaphore_win32"))))]
        {
            glImportSemaphoreWin32HandleEXT_load_with_dyn(&mut get_proc_address) as usize;
        }
        #[cfg(any(feature = "GL_EXT_semaphore_win32"))]
        #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_semaphore_win32"))))]
        {
            glImportSemaphoreWin32NameEXT_load_with_dyn(&mut get_proc_address) as usize;
        }
        #[cfg(any(feature = "GL_EXT_debug_marker"))]
        #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_debug_marker"))))]
        {
            glInsertEventMarkerEXT_load_with_dyn(&mut get_proc_address) as usize;
        }
        #[cfg(any(feature = "GL_NV_path_rendering"))]
        #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_path_rendering"))))]
        {
            glInterpolatePathsNV_load_with_dyn(&mut get_proc_address) as usize;
        }
        glInvalidateFramebuffer_load_with_dyn(&mut get_proc_address) as usize;
        glInvalidateSubFramebuffer_load_with_dyn(&mut get_proc_address) as usize;
        glIsBuffer_load_with_dyn(&mut get_proc_address) as usize;
        glIsEnabled_load_with_dyn(&mut get_proc_address) as usize;
        glIsEnabledi_load_with_dyn(&mut get_proc_address) as usize;
        #[cfg(any(feature = "GL_EXT_draw_buffers_indexed"))]
        #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_draw_buffers_indexed"))))]
        {
            glIsEnablediEXT_load_with_dyn(&mut get_proc_address) as usize;
        }
        #[cfg(any(feature = "GL_NV_viewport_array"))]
        #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_viewport_array"))))]
        {
            glIsEnablediNV_load_with_dyn(&mut get_proc_address) as usize;
        }
        #[cfg(any(
            feature = "GL_OES_draw_buffers_indexed",
            feature = "GL_OES_viewport_array"
        ))]
        #[cfg_attr(
            docs_rs,
            doc(cfg(any(
                feature = "GL_OES_draw_buffers_indexed",
                feature = "GL_OES_viewport_array"
            )))
        )]
        {
            glIsEnablediOES_load_with_dyn(&mut get_proc_address) as usize;
        }
        #[cfg(any(feature = "GL_NV_fence"))]
        #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_fence"))))]
        {
            glIsFenceNV_load_with_dyn(&mut get_proc_address) as usize;
        }
        glIsFramebuffer_load_with_dyn(&mut get_proc_address) as usize;
        #[cfg(any(feature = "GL_NV_bindless_texture"))]
        #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_bindless_texture"))))]
        {
            glIsImageHandleResidentNV_load_with_dyn(&mut get_proc_address) as usize;
        }
        #[cfg(any(feature = "GL_EXT_memory_object"))]
        #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_memory_object"))))]
        {
            glIsMemoryObjectEXT_load_with_dyn(&mut get_proc_address) as usize;
        }
        #[cfg(any(feature = "GL_NV_path_rendering"))]
        #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_path_rendering"))))]
        {
            glIsPathNV_load_with_dyn(&mut get_proc_address) as usize;
        }
        #[cfg(any(feature = "GL_NV_path_rendering"))]
        #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_path_rendering"))))]
        {
            glIsPointInFillPathNV_load_with_dyn(&mut get_proc_address) as usize;
        }
        #[cfg(any(feature = "GL_NV_path_rendering"))]
        #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_path_rendering"))))]
        {
            glIsPointInStrokePathNV_load_with_dyn(&mut get_proc_address) as usize;
        }
        glIsProgram_load_with_dyn(&mut get_proc_address) as usize;
        glIsProgramPipeline_load_with_dyn(&mut get_proc_address) as usize;
        #[cfg(any(feature = "GL_EXT_separate_shader_objects"))]
        #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_separate_shader_objects"))))]
        {
            glIsProgramPipelineEXT_load_with_dyn(&mut get_proc_address) as usize;
        }
        glIsQuery_load_with_dyn(&mut get_proc_address) as usize;
        #[cfg(any(
            feature = "GL_EXT_disjoint_timer_query",
            feature = "GL_EXT_occlusion_query_boolean"
        ))]
        #[cfg_attr(
            docs_rs,
            doc(cfg(any(
                feature = "GL_EXT_disjoint_timer_query",
                feature = "GL_EXT_occlusion_query_boolean"
            )))
        )]
        {
            glIsQueryEXT_load_with_dyn(&mut get_proc_address) as usize;
        }
        glIsRenderbuffer_load_with_dyn(&mut get_proc_address) as usize;
        glIsSampler_load_with_dyn(&mut get_proc_address) as usize;
        #[cfg(any(feature = "GL_EXT_semaphore"))]
        #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_semaphore"))))]
        {
            glIsSemaphoreEXT_load_with_dyn(&mut get_proc_address) as usize;
        }
        glIsShader_load_with_dyn(&mut get_proc_address) as usize;
        glIsSync_load_with_dyn(&mut get_proc_address) as usize;
        #[cfg(any(feature = "GL_APPLE_sync"))]
        #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_APPLE_sync"))))]
        {
            glIsSyncAPPLE_load_with_dyn(&mut get_proc_address) as usize;
        }
        glIsTexture_load_with_dyn(&mut get_proc_address) as usize;
        #[cfg(any(feature = "GL_NV_bindless_texture"))]
        #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_bindless_texture"))))]
        {
            glIsTextureHandleResidentNV_load_with_dyn(&mut get_proc_address) as usize;
        }
        glIsTransformFeedback_load_with_dyn(&mut get_proc_address) as usize;
        glIsVertexArray_load_with_dyn(&mut get_proc_address) as usize;
        #[cfg(any(feature = "GL_OES_vertex_array_object"))]
        #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_OES_vertex_array_object"))))]
        {
            glIsVertexArrayOES_load_with_dyn(&mut get_proc_address) as usize;
        }
        #[cfg(any(feature = "GL_EXT_debug_label"))]
        #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_debug_label"))))]
        {
            glLabelObjectEXT_load_with_dyn(&mut get_proc_address) as usize;
        }
        glLineWidth_load_with_dyn(&mut get_proc_address) as usize;
        glLinkProgram_load_with_dyn(&mut get_proc_address) as usize;
        #[cfg(any(feature = "GL_NV_bindless_texture"))]
        #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_bindless_texture"))))]
        {
            glMakeImageHandleNonResidentNV_load_with_dyn(&mut get_proc_address) as usize;
        }
        #[cfg(any(feature = "GL_NV_bindless_texture"))]
        #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_bindless_texture"))))]
        {
            glMakeImageHandleResidentNV_load_with_dyn(&mut get_proc_address) as usize;
        }
        #[cfg(any(feature = "GL_NV_bindless_texture"))]
        #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_bindless_texture"))))]
        {
            glMakeTextureHandleNonResidentNV_load_with_dyn(&mut get_proc_address) as usize;
        }
        #[cfg(any(feature = "GL_NV_bindless_texture"))]
        #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_bindless_texture"))))]
        {
            glMakeTextureHandleResidentNV_load_with_dyn(&mut get_proc_address) as usize;
        }
        #[cfg(any(feature = "GL_OES_mapbuffer"))]
        #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_OES_mapbuffer"))))]
        {
            glMapBufferOES_load_with_dyn(&mut get_proc_address) as usize;
        }
        glMapBufferRange_load_with_dyn(&mut get_proc_address) as usize;
        #[cfg(any(feature = "GL_EXT_map_buffer_range"))]
        #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_map_buffer_range"))))]
        {
            glMapBufferRangeEXT_load_with_dyn(&mut get_proc_address) as usize;
        }
        #[cfg(any(feature = "GL_NV_path_rendering"))]
        #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_path_rendering"))))]
        {
            glMatrixFrustumEXT_load_with_dyn(&mut get_proc_address) as usize;
        }
        #[cfg(any(feature = "GL_NV_path_rendering"))]
        #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_path_rendering"))))]
        {
            glMatrixLoad3x2fNV_load_with_dyn(&mut get_proc_address) as usize;
        }
        #[cfg(any(feature = "GL_NV_path_rendering"))]
        #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_path_rendering"))))]
        {
            glMatrixLoad3x3fNV_load_with_dyn(&mut get_proc_address) as usize;
        }
        #[cfg(any(feature = "GL_NV_path_rendering"))]
        #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_path_rendering"))))]
        {
            glMatrixLoadIdentityEXT_load_with_dyn(&mut get_proc_address) as usize;
        }
        #[cfg(any(feature = "GL_NV_path_rendering"))]
        #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_path_rendering"))))]
        {
            glMatrixLoadTranspose3x3fNV_load_with_dyn(&mut get_proc_address) as usize;
        }
        #[cfg(any(feature = "GL_NV_path_rendering"))]
        #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_path_rendering"))))]
        {
            glMatrixLoadTransposedEXT_load_with_dyn(&mut get_proc_address) as usize;
        }
        #[cfg(any(feature = "GL_NV_path_rendering"))]
        #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_path_rendering"))))]
        {
            glMatrixLoadTransposefEXT_load_with_dyn(&mut get_proc_address) as usize;
        }
        #[cfg(any(feature = "GL_NV_path_rendering"))]
        #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_path_rendering"))))]
        {
            glMatrixLoaddEXT_load_with_dyn(&mut get_proc_address) as usize;
        }
        #[cfg(any(feature = "GL_NV_path_rendering"))]
        #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_path_rendering"))))]
        {
            glMatrixLoadfEXT_load_with_dyn(&mut get_proc_address) as usize;
        }
        #[cfg(any(feature = "GL_NV_path_rendering"))]
        #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_path_rendering"))))]
        {
            glMatrixMult3x2fNV_load_with_dyn(&mut get_proc_address) as usize;
        }
        #[cfg(any(feature = "GL_NV_path_rendering"))]
        #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_path_rendering"))))]
        {
            glMatrixMult3x3fNV_load_with_dyn(&mut get_proc_address) as usize;
        }
        #[cfg(any(feature = "GL_NV_path_rendering"))]
        #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_path_rendering"))))]
        {
            glMatrixMultTranspose3x3fNV_load_with_dyn(&mut get_proc_address) as usize;
        }
        #[cfg(any(feature = "GL_NV_path_rendering"))]
        #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_path_rendering"))))]
        {
            glMatrixMultTransposedEXT_load_with_dyn(&mut get_proc_address) as usize;
        }
        #[cfg(any(feature = "GL_NV_path_rendering"))]
        #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_path_rendering"))))]
        {
            glMatrixMultTransposefEXT_load_with_dyn(&mut get_proc_address) as usize;
        }
        #[cfg(any(feature = "GL_NV_path_rendering"))]
        #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_path_rendering"))))]
        {
            glMatrixMultdEXT_load_with_dyn(&mut get_proc_address) as usize;
        }
        #[cfg(any(feature = "GL_NV_path_rendering"))]
        #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_path_rendering"))))]
        {
            glMatrixMultfEXT_load_with_dyn(&mut get_proc_address) as usize;
        }
        #[cfg(any(feature = "GL_NV_path_rendering"))]
        #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_path_rendering"))))]
        {
            glMatrixOrthoEXT_load_with_dyn(&mut get_proc_address) as usize;
        }
        #[cfg(any(feature = "GL_NV_path_rendering"))]
        #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_path_rendering"))))]
        {
            glMatrixPopEXT_load_with_dyn(&mut get_proc_address) as usize;
        }
        #[cfg(any(feature = "GL_NV_path_rendering"))]
        #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_path_rendering"))))]
        {
            glMatrixPushEXT_load_with_dyn(&mut get_proc_address) as usize;
        }
        #[cfg(any(feature = "GL_NV_path_rendering"))]
        #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_path_rendering"))))]
        {
            glMatrixRotatedEXT_load_with_dyn(&mut get_proc_address) as usize;
        }
        #[cfg(any(feature = "GL_NV_path_rendering"))]
        #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_path_rendering"))))]
        {
            glMatrixRotatefEXT_load_with_dyn(&mut get_proc_address) as usize;
        }
        #[cfg(any(feature = "GL_NV_path_rendering"))]
        #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_path_rendering"))))]
        {
            glMatrixScaledEXT_load_with_dyn(&mut get_proc_address) as usize;
        }
        #[cfg(any(feature = "GL_NV_path_rendering"))]
        #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_path_rendering"))))]
        {
            glMatrixScalefEXT_load_with_dyn(&mut get_proc_address) as usize;
        }
        #[cfg(any(feature = "GL_NV_path_rendering"))]
        #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_path_rendering"))))]
        {
            glMatrixTranslatedEXT_load_with_dyn(&mut get_proc_address) as usize;
        }
        #[cfg(any(feature = "GL_NV_path_rendering"))]
        #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_path_rendering"))))]
        {
            glMatrixTranslatefEXT_load_with_dyn(&mut get_proc_address) as usize;
        }
        #[cfg(any(feature = "GL_KHR_parallel_shader_compile"))]
        #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_KHR_parallel_shader_compile"))))]
        {
            glMaxShaderCompilerThreadsKHR_load_with_dyn(&mut get_proc_address) as usize;
        }
        glMemoryBarrier_load_with_dyn(&mut get_proc_address) as usize;
        glMemoryBarrierByRegion_load_with_dyn(&mut get_proc_address) as usize;
        #[cfg(any(feature = "GL_EXT_memory_object"))]
        #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_memory_object"))))]
        {
            glMemoryObjectParameterivEXT_load_with_dyn(&mut get_proc_address) as usize;
        }
        glMinSampleShading_load_with_dyn(&mut get_proc_address) as usize;
        #[cfg(any(feature = "GL_OES_sample_shading"))]
        #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_OES_sample_shading"))))]
        {
            glMinSampleShadingOES_load_with_dyn(&mut get_proc_address) as usize;
        }
        #[cfg(any(feature = "GL_EXT_multi_draw_arrays"))]
        #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_multi_draw_arrays"))))]
        {
            glMultiDrawArraysEXT_load_with_dyn(&mut get_proc_address) as usize;
        }
        #[cfg(any(feature = "GL_EXT_multi_draw_indirect"))]
        #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_multi_draw_indirect"))))]
        {
            glMultiDrawArraysIndirectEXT_load_with_dyn(&mut get_proc_address) as usize;
        }
        #[cfg(any(
            feature = "GL_EXT_draw_elements_base_vertex",
            feature = "GL_OES_draw_elements_base_vertex"
        ))]
        #[cfg_attr(
            docs_rs,
            doc(cfg(any(
                feature = "GL_EXT_draw_elements_base_vertex",
                feature = "GL_OES_draw_elements_base_vertex"
            )))
        )]
        {
            glMultiDrawElementsBaseVertexEXT_load_with_dyn(&mut get_proc_address) as usize;
        }
        #[cfg(any(feature = "GL_EXT_multi_draw_arrays"))]
        #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_multi_draw_arrays"))))]
        {
            glMultiDrawElementsEXT_load_with_dyn(&mut get_proc_address) as usize;
        }
        #[cfg(any(feature = "GL_EXT_multi_draw_indirect"))]
        #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_multi_draw_indirect"))))]
        {
            glMultiDrawElementsIndirectEXT_load_with_dyn(&mut get_proc_address) as usize;
        }
        #[cfg(any(feature = "GL_NV_mesh_shader"))]
        #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_mesh_shader"))))]
        {
            glMultiDrawMeshTasksIndirectCountNV_load_with_dyn(&mut get_proc_address) as usize;
        }
        #[cfg(any(feature = "GL_NV_mesh_shader"))]
        #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_mesh_shader"))))]
        {
            glMultiDrawMeshTasksIndirectNV_load_with_dyn(&mut get_proc_address) as usize;
        }
        #[cfg(any(feature = "GL_NV_memory_attachment"))]
        #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_memory_attachment"))))]
        {
            glNamedBufferAttachMemoryNV_load_with_dyn(&mut get_proc_address) as usize;
        }
        #[cfg(any(feature = "GL_NV_memory_object_sparse"))]
        #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_memory_object_sparse"))))]
        {
            glNamedBufferPageCommitmentMemNV_load_with_dyn(&mut get_proc_address) as usize;
        }
        #[cfg(any(feature = "GL_EXT_external_buffer"))]
        #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_external_buffer"))))]
        {
            glNamedBufferStorageExternalEXT_load_with_dyn(&mut get_proc_address) as usize;
        }
        #[cfg(any(feature = "GL_EXT_memory_object"))]
        #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_memory_object"))))]
        {
            glNamedBufferStorageMemEXT_load_with_dyn(&mut get_proc_address) as usize;
        }
        #[cfg(any(feature = "GL_NV_sample_locations"))]
        #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_sample_locations"))))]
        {
            glNamedFramebufferSampleLocationsfvNV_load_with_dyn(&mut get_proc_address) as usize;
        }
        #[cfg(any(feature = "GL_AMD_framebuffer_multisample_advanced"))]
        #[cfg_attr(
            docs_rs,
            doc(cfg(any(feature = "GL_AMD_framebuffer_multisample_advanced")))
        )]
        {
            glNamedRenderbufferStorageMultisampleAdvancedAMD_load_with_dyn(&mut get_proc_address)
                as usize;
        }
        glObjectLabel_load_with_dyn(&mut get_proc_address) as usize;
        #[cfg(any(feature = "GL_KHR_debug"))]
        #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_KHR_debug"))))]
        {
            glObjectLabelKHR_load_with_dyn(&mut get_proc_address) as usize;
        }
        glObjectPtrLabel_load_with_dyn(&mut get_proc_address) as usize;
        #[cfg(any(feature = "GL_KHR_debug"))]
        #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_KHR_debug"))))]
        {
            glObjectPtrLabelKHR_load_with_dyn(&mut get_proc_address) as usize;
        }
        glPatchParameteri_load_with_dyn(&mut get_proc_address) as usize;
        #[cfg(any(feature = "GL_EXT_tessellation_shader"))]
        #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_tessellation_shader"))))]
        {
            glPatchParameteriEXT_load_with_dyn(&mut get_proc_address) as usize;
        }
        #[cfg(any(feature = "GL_OES_tessellation_shader"))]
        #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_OES_tessellation_shader"))))]
        {
            glPatchParameteriOES_load_with_dyn(&mut get_proc_address) as usize;
        }
        #[cfg(any(feature = "GL_NV_path_rendering"))]
        #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_path_rendering"))))]
        {
            glPathCommandsNV_load_with_dyn(&mut get_proc_address) as usize;
        }
        #[cfg(any(feature = "GL_NV_path_rendering"))]
        #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_path_rendering"))))]
        {
            glPathCoordsNV_load_with_dyn(&mut get_proc_address) as usize;
        }
        #[cfg(any(feature = "GL_NV_path_rendering"))]
        #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_path_rendering"))))]
        {
            glPathCoverDepthFuncNV_load_with_dyn(&mut get_proc_address) as usize;
        }
        #[cfg(any(feature = "GL_NV_path_rendering"))]
        #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_path_rendering"))))]
        {
            glPathDashArrayNV_load_with_dyn(&mut get_proc_address) as usize;
        }
        #[cfg(any(feature = "GL_NV_path_rendering"))]
        #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_path_rendering"))))]
        {
            glPathGlyphIndexArrayNV_load_with_dyn(&mut get_proc_address) as usize;
        }
        #[cfg(any(feature = "GL_NV_path_rendering"))]
        #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_path_rendering"))))]
        {
            glPathGlyphIndexRangeNV_load_with_dyn(&mut get_proc_address) as usize;
        }
        #[cfg(any(feature = "GL_NV_path_rendering"))]
        #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_path_rendering"))))]
        {
            glPathGlyphRangeNV_load_with_dyn(&mut get_proc_address) as usize;
        }
        #[cfg(any(feature = "GL_NV_path_rendering"))]
        #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_path_rendering"))))]
        {
            glPathGlyphsNV_load_with_dyn(&mut get_proc_address) as usize;
        }
        #[cfg(any(feature = "GL_NV_path_rendering"))]
        #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_path_rendering"))))]
        {
            glPathMemoryGlyphIndexArrayNV_load_with_dyn(&mut get_proc_address) as usize;
        }
        #[cfg(any(feature = "GL_NV_path_rendering"))]
        #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_path_rendering"))))]
        {
            glPathParameterfNV_load_with_dyn(&mut get_proc_address) as usize;
        }
        #[cfg(any(feature = "GL_NV_path_rendering"))]
        #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_path_rendering"))))]
        {
            glPathParameterfvNV_load_with_dyn(&mut get_proc_address) as usize;
        }
        #[cfg(any(feature = "GL_NV_path_rendering"))]
        #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_path_rendering"))))]
        {
            glPathParameteriNV_load_with_dyn(&mut get_proc_address) as usize;
        }
        #[cfg(any(feature = "GL_NV_path_rendering"))]
        #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_path_rendering"))))]
        {
            glPathParameterivNV_load_with_dyn(&mut get_proc_address) as usize;
        }
        #[cfg(any(feature = "GL_NV_path_rendering"))]
        #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_path_rendering"))))]
        {
            glPathStencilDepthOffsetNV_load_with_dyn(&mut get_proc_address) as usize;
        }
        #[cfg(any(feature = "GL_NV_path_rendering"))]
        #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_path_rendering"))))]
        {
            glPathStencilFuncNV_load_with_dyn(&mut get_proc_address) as usize;
        }
        #[cfg(any(feature = "GL_NV_path_rendering"))]
        #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_path_rendering"))))]
        {
            glPathStringNV_load_with_dyn(&mut get_proc_address) as usize;
        }
        #[cfg(any(feature = "GL_NV_path_rendering"))]
        #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_path_rendering"))))]
        {
            glPathSubCommandsNV_load_with_dyn(&mut get_proc_address) as usize;
        }
        #[cfg(any(feature = "GL_NV_path_rendering"))]
        #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_path_rendering"))))]
        {
            glPathSubCoordsNV_load_with_dyn(&mut get_proc_address) as usize;
        }
        glPauseTransformFeedback_load_with_dyn(&mut get_proc_address) as usize;
        glPixelStorei_load_with_dyn(&mut get_proc_address) as usize;
        #[cfg(any(feature = "GL_NV_path_rendering"))]
        #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_path_rendering"))))]
        {
            glPointAlongPathNV_load_with_dyn(&mut get_proc_address) as usize;
        }
        #[cfg(any(feature = "GL_NV_polygon_mode"))]
        #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_polygon_mode"))))]
        {
            glPolygonModeNV_load_with_dyn(&mut get_proc_address) as usize;
        }
        glPolygonOffset_load_with_dyn(&mut get_proc_address) as usize;
        #[cfg(any(feature = "GL_EXT_polygon_offset_clamp"))]
        #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_polygon_offset_clamp"))))]
        {
            glPolygonOffsetClampEXT_load_with_dyn(&mut get_proc_address) as usize;
        }
        glPopDebugGroup_load_with_dyn(&mut get_proc_address) as usize;
        #[cfg(any(feature = "GL_KHR_debug"))]
        #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_KHR_debug"))))]
        {
            glPopDebugGroupKHR_load_with_dyn(&mut get_proc_address) as usize;
        }
        #[cfg(any(feature = "GL_EXT_debug_marker"))]
        #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_debug_marker"))))]
        {
            glPopGroupMarkerEXT_load_with_dyn(&mut get_proc_address) as usize;
        }
        glPrimitiveBoundingBox_load_with_dyn(&mut get_proc_address) as usize;
        #[cfg(any(feature = "GL_EXT_primitive_bounding_box"))]
        #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_primitive_bounding_box"))))]
        {
            glPrimitiveBoundingBoxEXT_load_with_dyn(&mut get_proc_address) as usize;
        }
        #[cfg(any(feature = "GL_OES_primitive_bounding_box"))]
        #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_OES_primitive_bounding_box"))))]
        {
            glPrimitiveBoundingBoxOES_load_with_dyn(&mut get_proc_address) as usize;
        }
        glProgramBinary_load_with_dyn(&mut get_proc_address) as usize;
        #[cfg(any(feature = "GL_OES_get_program_binary"))]
        #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_OES_get_program_binary"))))]
        {
            glProgramBinaryOES_load_with_dyn(&mut get_proc_address) as usize;
        }
        glProgramParameteri_load_with_dyn(&mut get_proc_address) as usize;
        #[cfg(any(feature = "GL_EXT_separate_shader_objects"))]
        #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_separate_shader_objects"))))]
        {
            glProgramParameteriEXT_load_with_dyn(&mut get_proc_address) as usize;
        }
        #[cfg(any(feature = "GL_NV_path_rendering"))]
        #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_path_rendering"))))]
        {
            glProgramPathFragmentInputGenNV_load_with_dyn(&mut get_proc_address) as usize;
        }
        glProgramUniform1f_load_with_dyn(&mut get_proc_address) as usize;
        #[cfg(any(feature = "GL_EXT_separate_shader_objects"))]
        #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_separate_shader_objects"))))]
        {
            glProgramUniform1fEXT_load_with_dyn(&mut get_proc_address) as usize;
        }
        glProgramUniform1fv_load_with_dyn(&mut get_proc_address) as usize;
        #[cfg(any(feature = "GL_EXT_separate_shader_objects"))]
        #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_separate_shader_objects"))))]
        {
            glProgramUniform1fvEXT_load_with_dyn(&mut get_proc_address) as usize;
        }
        glProgramUniform1i_load_with_dyn(&mut get_proc_address) as usize;
        #[cfg(any(feature = "GL_NV_gpu_shader5"))]
        #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_gpu_shader5"))))]
        {
            glProgramUniform1i64NV_load_with_dyn(&mut get_proc_address) as usize;
        }
        #[cfg(any(feature = "GL_NV_gpu_shader5"))]
        #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_gpu_shader5"))))]
        {
            glProgramUniform1i64vNV_load_with_dyn(&mut get_proc_address) as usize;
        }
        #[cfg(any(feature = "GL_EXT_separate_shader_objects"))]
        #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_separate_shader_objects"))))]
        {
            glProgramUniform1iEXT_load_with_dyn(&mut get_proc_address) as usize;
        }
        glProgramUniform1iv_load_with_dyn(&mut get_proc_address) as usize;
        #[cfg(any(feature = "GL_EXT_separate_shader_objects"))]
        #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_separate_shader_objects"))))]
        {
            glProgramUniform1ivEXT_load_with_dyn(&mut get_proc_address) as usize;
        }
        glProgramUniform1ui_load_with_dyn(&mut get_proc_address) as usize;
        #[cfg(any(feature = "GL_NV_gpu_shader5"))]
        #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_gpu_shader5"))))]
        {
            glProgramUniform1ui64NV_load_with_dyn(&mut get_proc_address) as usize;
        }
        #[cfg(any(feature = "GL_NV_gpu_shader5"))]
        #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_gpu_shader5"))))]
        {
            glProgramUniform1ui64vNV_load_with_dyn(&mut get_proc_address) as usize;
        }
        #[cfg(any(feature = "GL_EXT_separate_shader_objects"))]
        #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_separate_shader_objects"))))]
        {
            glProgramUniform1uiEXT_load_with_dyn(&mut get_proc_address) as usize;
        }
        glProgramUniform1uiv_load_with_dyn(&mut get_proc_address) as usize;
        #[cfg(any(feature = "GL_EXT_separate_shader_objects"))]
        #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_separate_shader_objects"))))]
        {
            glProgramUniform1uivEXT_load_with_dyn(&mut get_proc_address) as usize;
        }
        glProgramUniform2f_load_with_dyn(&mut get_proc_address) as usize;
        #[cfg(any(feature = "GL_EXT_separate_shader_objects"))]
        #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_separate_shader_objects"))))]
        {
            glProgramUniform2fEXT_load_with_dyn(&mut get_proc_address) as usize;
        }
        glProgramUniform2fv_load_with_dyn(&mut get_proc_address) as usize;
        #[cfg(any(feature = "GL_EXT_separate_shader_objects"))]
        #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_separate_shader_objects"))))]
        {
            glProgramUniform2fvEXT_load_with_dyn(&mut get_proc_address) as usize;
        }
        glProgramUniform2i_load_with_dyn(&mut get_proc_address) as usize;
        #[cfg(any(feature = "GL_NV_gpu_shader5"))]
        #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_gpu_shader5"))))]
        {
            glProgramUniform2i64NV_load_with_dyn(&mut get_proc_address) as usize;
        }
        #[cfg(any(feature = "GL_NV_gpu_shader5"))]
        #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_gpu_shader5"))))]
        {
            glProgramUniform2i64vNV_load_with_dyn(&mut get_proc_address) as usize;
        }
        #[cfg(any(feature = "GL_EXT_separate_shader_objects"))]
        #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_separate_shader_objects"))))]
        {
            glProgramUniform2iEXT_load_with_dyn(&mut get_proc_address) as usize;
        }
        glProgramUniform2iv_load_with_dyn(&mut get_proc_address) as usize;
        #[cfg(any(feature = "GL_EXT_separate_shader_objects"))]
        #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_separate_shader_objects"))))]
        {
            glProgramUniform2ivEXT_load_with_dyn(&mut get_proc_address) as usize;
        }
        glProgramUniform2ui_load_with_dyn(&mut get_proc_address) as usize;
        #[cfg(any(feature = "GL_NV_gpu_shader5"))]
        #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_gpu_shader5"))))]
        {
            glProgramUniform2ui64NV_load_with_dyn(&mut get_proc_address) as usize;
        }
        #[cfg(any(feature = "GL_NV_gpu_shader5"))]
        #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_gpu_shader5"))))]
        {
            glProgramUniform2ui64vNV_load_with_dyn(&mut get_proc_address) as usize;
        }
        #[cfg(any(feature = "GL_EXT_separate_shader_objects"))]
        #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_separate_shader_objects"))))]
        {
            glProgramUniform2uiEXT_load_with_dyn(&mut get_proc_address) as usize;
        }
        glProgramUniform2uiv_load_with_dyn(&mut get_proc_address) as usize;
        #[cfg(any(feature = "GL_EXT_separate_shader_objects"))]
        #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_separate_shader_objects"))))]
        {
            glProgramUniform2uivEXT_load_with_dyn(&mut get_proc_address) as usize;
        }
        glProgramUniform3f_load_with_dyn(&mut get_proc_address) as usize;
        #[cfg(any(feature = "GL_EXT_separate_shader_objects"))]
        #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_separate_shader_objects"))))]
        {
            glProgramUniform3fEXT_load_with_dyn(&mut get_proc_address) as usize;
        }
        glProgramUniform3fv_load_with_dyn(&mut get_proc_address) as usize;
        #[cfg(any(feature = "GL_EXT_separate_shader_objects"))]
        #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_separate_shader_objects"))))]
        {
            glProgramUniform3fvEXT_load_with_dyn(&mut get_proc_address) as usize;
        }
        glProgramUniform3i_load_with_dyn(&mut get_proc_address) as usize;
        #[cfg(any(feature = "GL_NV_gpu_shader5"))]
        #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_gpu_shader5"))))]
        {
            glProgramUniform3i64NV_load_with_dyn(&mut get_proc_address) as usize;
        }
        #[cfg(any(feature = "GL_NV_gpu_shader5"))]
        #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_gpu_shader5"))))]
        {
            glProgramUniform3i64vNV_load_with_dyn(&mut get_proc_address) as usize;
        }
        #[cfg(any(feature = "GL_EXT_separate_shader_objects"))]
        #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_separate_shader_objects"))))]
        {
            glProgramUniform3iEXT_load_with_dyn(&mut get_proc_address) as usize;
        }
        glProgramUniform3iv_load_with_dyn(&mut get_proc_address) as usize;
        #[cfg(any(feature = "GL_EXT_separate_shader_objects"))]
        #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_separate_shader_objects"))))]
        {
            glProgramUniform3ivEXT_load_with_dyn(&mut get_proc_address) as usize;
        }
        glProgramUniform3ui_load_with_dyn(&mut get_proc_address) as usize;
        #[cfg(any(feature = "GL_NV_gpu_shader5"))]
        #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_gpu_shader5"))))]
        {
            glProgramUniform3ui64NV_load_with_dyn(&mut get_proc_address) as usize;
        }
        #[cfg(any(feature = "GL_NV_gpu_shader5"))]
        #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_gpu_shader5"))))]
        {
            glProgramUniform3ui64vNV_load_with_dyn(&mut get_proc_address) as usize;
        }
        #[cfg(any(feature = "GL_EXT_separate_shader_objects"))]
        #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_separate_shader_objects"))))]
        {
            glProgramUniform3uiEXT_load_with_dyn(&mut get_proc_address) as usize;
        }
        glProgramUniform3uiv_load_with_dyn(&mut get_proc_address) as usize;
        #[cfg(any(feature = "GL_EXT_separate_shader_objects"))]
        #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_separate_shader_objects"))))]
        {
            glProgramUniform3uivEXT_load_with_dyn(&mut get_proc_address) as usize;
        }
        glProgramUniform4f_load_with_dyn(&mut get_proc_address) as usize;
        #[cfg(any(feature = "GL_EXT_separate_shader_objects"))]
        #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_separate_shader_objects"))))]
        {
            glProgramUniform4fEXT_load_with_dyn(&mut get_proc_address) as usize;
        }
        glProgramUniform4fv_load_with_dyn(&mut get_proc_address) as usize;
        #[cfg(any(feature = "GL_EXT_separate_shader_objects"))]
        #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_separate_shader_objects"))))]
        {
            glProgramUniform4fvEXT_load_with_dyn(&mut get_proc_address) as usize;
        }
        glProgramUniform4i_load_with_dyn(&mut get_proc_address) as usize;
        #[cfg(any(feature = "GL_NV_gpu_shader5"))]
        #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_gpu_shader5"))))]
        {
            glProgramUniform4i64NV_load_with_dyn(&mut get_proc_address) as usize;
        }
        #[cfg(any(feature = "GL_NV_gpu_shader5"))]
        #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_gpu_shader5"))))]
        {
            glProgramUniform4i64vNV_load_with_dyn(&mut get_proc_address) as usize;
        }
        #[cfg(any(feature = "GL_EXT_separate_shader_objects"))]
        #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_separate_shader_objects"))))]
        {
            glProgramUniform4iEXT_load_with_dyn(&mut get_proc_address) as usize;
        }
        glProgramUniform4iv_load_with_dyn(&mut get_proc_address) as usize;
        #[cfg(any(feature = "GL_EXT_separate_shader_objects"))]
        #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_separate_shader_objects"))))]
        {
            glProgramUniform4ivEXT_load_with_dyn(&mut get_proc_address) as usize;
        }
        glProgramUniform4ui_load_with_dyn(&mut get_proc_address) as usize;
        #[cfg(any(feature = "GL_NV_gpu_shader5"))]
        #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_gpu_shader5"))))]
        {
            glProgramUniform4ui64NV_load_with_dyn(&mut get_proc_address) as usize;
        }
        #[cfg(any(feature = "GL_NV_gpu_shader5"))]
        #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_gpu_shader5"))))]
        {
            glProgramUniform4ui64vNV_load_with_dyn(&mut get_proc_address) as usize;
        }
        #[cfg(any(feature = "GL_EXT_separate_shader_objects"))]
        #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_separate_shader_objects"))))]
        {
            glProgramUniform4uiEXT_load_with_dyn(&mut get_proc_address) as usize;
        }
        glProgramUniform4uiv_load_with_dyn(&mut get_proc_address) as usize;
        #[cfg(any(feature = "GL_EXT_separate_shader_objects"))]
        #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_separate_shader_objects"))))]
        {
            glProgramUniform4uivEXT_load_with_dyn(&mut get_proc_address) as usize;
        }
        #[cfg(any(feature = "GL_IMG_bindless_texture"))]
        #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_IMG_bindless_texture"))))]
        {
            glProgramUniformHandleui64IMG_load_with_dyn(&mut get_proc_address) as usize;
        }
        #[cfg(any(feature = "GL_NV_bindless_texture"))]
        #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_bindless_texture"))))]
        {
            glProgramUniformHandleui64NV_load_with_dyn(&mut get_proc_address) as usize;
        }
        #[cfg(any(feature = "GL_IMG_bindless_texture"))]
        #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_IMG_bindless_texture"))))]
        {
            glProgramUniformHandleui64vIMG_load_with_dyn(&mut get_proc_address) as usize;
        }
        #[cfg(any(feature = "GL_NV_bindless_texture"))]
        #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_bindless_texture"))))]
        {
            glProgramUniformHandleui64vNV_load_with_dyn(&mut get_proc_address) as usize;
        }
        glProgramUniformMatrix2fv_load_with_dyn(&mut get_proc_address) as usize;
        #[cfg(any(feature = "GL_EXT_separate_shader_objects"))]
        #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_separate_shader_objects"))))]
        {
            glProgramUniformMatrix2fvEXT_load_with_dyn(&mut get_proc_address) as usize;
        }
        glProgramUniformMatrix2x3fv_load_with_dyn(&mut get_proc_address) as usize;
        #[cfg(any(feature = "GL_EXT_separate_shader_objects"))]
        #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_separate_shader_objects"))))]
        {
            glProgramUniformMatrix2x3fvEXT_load_with_dyn(&mut get_proc_address) as usize;
        }
        glProgramUniformMatrix2x4fv_load_with_dyn(&mut get_proc_address) as usize;
        #[cfg(any(feature = "GL_EXT_separate_shader_objects"))]
        #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_separate_shader_objects"))))]
        {
            glProgramUniformMatrix2x4fvEXT_load_with_dyn(&mut get_proc_address) as usize;
        }
        glProgramUniformMatrix3fv_load_with_dyn(&mut get_proc_address) as usize;
        #[cfg(any(feature = "GL_EXT_separate_shader_objects"))]
        #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_separate_shader_objects"))))]
        {
            glProgramUniformMatrix3fvEXT_load_with_dyn(&mut get_proc_address) as usize;
        }
        glProgramUniformMatrix3x2fv_load_with_dyn(&mut get_proc_address) as usize;
        #[cfg(any(feature = "GL_EXT_separate_shader_objects"))]
        #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_separate_shader_objects"))))]
        {
            glProgramUniformMatrix3x2fvEXT_load_with_dyn(&mut get_proc_address) as usize;
        }
        glProgramUniformMatrix3x4fv_load_with_dyn(&mut get_proc_address) as usize;
        #[cfg(any(feature = "GL_EXT_separate_shader_objects"))]
        #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_separate_shader_objects"))))]
        {
            glProgramUniformMatrix3x4fvEXT_load_with_dyn(&mut get_proc_address) as usize;
        }
        glProgramUniformMatrix4fv_load_with_dyn(&mut get_proc_address) as usize;
        #[cfg(any(feature = "GL_EXT_separate_shader_objects"))]
        #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_separate_shader_objects"))))]
        {
            glProgramUniformMatrix4fvEXT_load_with_dyn(&mut get_proc_address) as usize;
        }
        glProgramUniformMatrix4x2fv_load_with_dyn(&mut get_proc_address) as usize;
        #[cfg(any(feature = "GL_EXT_separate_shader_objects"))]
        #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_separate_shader_objects"))))]
        {
            glProgramUniformMatrix4x2fvEXT_load_with_dyn(&mut get_proc_address) as usize;
        }
        glProgramUniformMatrix4x3fv_load_with_dyn(&mut get_proc_address) as usize;
        #[cfg(any(feature = "GL_EXT_separate_shader_objects"))]
        #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_separate_shader_objects"))))]
        {
            glProgramUniformMatrix4x3fvEXT_load_with_dyn(&mut get_proc_address) as usize;
        }
        glPushDebugGroup_load_with_dyn(&mut get_proc_address) as usize;
        #[cfg(any(feature = "GL_KHR_debug"))]
        #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_KHR_debug"))))]
        {
            glPushDebugGroupKHR_load_with_dyn(&mut get_proc_address) as usize;
        }
        #[cfg(any(feature = "GL_EXT_debug_marker"))]
        #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_debug_marker"))))]
        {
            glPushGroupMarkerEXT_load_with_dyn(&mut get_proc_address) as usize;
        }
        #[cfg(any(feature = "GL_EXT_disjoint_timer_query"))]
        #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_disjoint_timer_query"))))]
        {
            glQueryCounterEXT_load_with_dyn(&mut get_proc_address) as usize;
        }
        #[cfg(any(
            feature = "GL_EXT_raster_multisample",
            feature = "GL_NV_framebuffer_mixed_samples"
        ))]
        #[cfg_attr(
            docs_rs,
            doc(cfg(any(
                feature = "GL_EXT_raster_multisample",
                feature = "GL_NV_framebuffer_mixed_samples"
            )))
        )]
        {
            glRasterSamplesEXT_load_with_dyn(&mut get_proc_address) as usize;
        }
        glReadBuffer_load_with_dyn(&mut get_proc_address) as usize;
        #[cfg(any(feature = "GL_EXT_multiview_draw_buffers"))]
        #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_multiview_draw_buffers"))))]
        {
            glReadBufferIndexedEXT_load_with_dyn(&mut get_proc_address) as usize;
        }
        #[cfg(any(feature = "GL_NV_read_buffer"))]
        #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_read_buffer"))))]
        {
            glReadBufferNV_load_with_dyn(&mut get_proc_address) as usize;
        }
        glReadPixels_load_with_dyn(&mut get_proc_address) as usize;
        glReadnPixels_load_with_dyn(&mut get_proc_address) as usize;
        #[cfg(any(feature = "GL_EXT_robustness"))]
        #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_robustness"))))]
        {
            glReadnPixelsEXT_load_with_dyn(&mut get_proc_address) as usize;
        }
        #[cfg(any(feature = "GL_KHR_robustness"))]
        #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_KHR_robustness"))))]
        {
            glReadnPixelsKHR_load_with_dyn(&mut get_proc_address) as usize;
        }
        #[cfg(any(feature = "GL_EXT_win32_keyed_mutex"))]
        #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_win32_keyed_mutex"))))]
        {
            glReleaseKeyedMutexWin32EXT_load_with_dyn(&mut get_proc_address) as usize;
        }
        glReleaseShaderCompiler_load_with_dyn(&mut get_proc_address) as usize;
        glRenderbufferStorage_load_with_dyn(&mut get_proc_address) as usize;
        glRenderbufferStorageMultisample_load_with_dyn(&mut get_proc_address) as usize;
        #[cfg(any(feature = "GL_ANGLE_framebuffer_multisample"))]
        #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_ANGLE_framebuffer_multisample"))))]
        {
            glRenderbufferStorageMultisampleANGLE_load_with_dyn(&mut get_proc_address) as usize;
        }
        #[cfg(any(feature = "GL_APPLE_framebuffer_multisample"))]
        #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_APPLE_framebuffer_multisample"))))]
        {
            glRenderbufferStorageMultisampleAPPLE_load_with_dyn(&mut get_proc_address) as usize;
        }
        #[cfg(any(feature = "GL_AMD_framebuffer_multisample_advanced"))]
        #[cfg_attr(
            docs_rs,
            doc(cfg(any(feature = "GL_AMD_framebuffer_multisample_advanced")))
        )]
        {
            glRenderbufferStorageMultisampleAdvancedAMD_load_with_dyn(&mut get_proc_address)
                as usize;
        }
        #[cfg(any(feature = "GL_EXT_multisampled_render_to_texture"))]
        #[cfg_attr(
            docs_rs,
            doc(cfg(any(feature = "GL_EXT_multisampled_render_to_texture")))
        )]
        {
            glRenderbufferStorageMultisampleEXT_load_with_dyn(&mut get_proc_address) as usize;
        }
        #[cfg(any(feature = "GL_IMG_multisampled_render_to_texture"))]
        #[cfg_attr(
            docs_rs,
            doc(cfg(any(feature = "GL_IMG_multisampled_render_to_texture")))
        )]
        {
            glRenderbufferStorageMultisampleIMG_load_with_dyn(&mut get_proc_address) as usize;
        }
        #[cfg(any(feature = "GL_NV_framebuffer_multisample"))]
        #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_framebuffer_multisample"))))]
        {
            glRenderbufferStorageMultisampleNV_load_with_dyn(&mut get_proc_address) as usize;
        }
        #[cfg(any(feature = "GL_NV_memory_attachment"))]
        #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_memory_attachment"))))]
        {
            glResetMemoryObjectParameterNV_load_with_dyn(&mut get_proc_address) as usize;
        }
        #[cfg(any(feature = "GL_NV_sample_locations"))]
        #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_sample_locations"))))]
        {
            glResolveDepthValuesNV_load_with_dyn(&mut get_proc_address) as usize;
        }
        #[cfg(any(feature = "GL_APPLE_framebuffer_multisample"))]
        #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_APPLE_framebuffer_multisample"))))]
        {
            glResolveMultisampleFramebufferAPPLE_load_with_dyn(&mut get_proc_address) as usize;
        }
        glResumeTransformFeedback_load_with_dyn(&mut get_proc_address) as usize;
        glSampleCoverage_load_with_dyn(&mut get_proc_address) as usize;
        glSampleMaski_load_with_dyn(&mut get_proc_address) as usize;
        glSamplerParameterIiv_load_with_dyn(&mut get_proc_address) as usize;
        #[cfg(any(feature = "GL_EXT_texture_border_clamp"))]
        #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_texture_border_clamp"))))]
        {
            glSamplerParameterIivEXT_load_with_dyn(&mut get_proc_address) as usize;
        }
        #[cfg(any(feature = "GL_OES_texture_border_clamp"))]
        #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_OES_texture_border_clamp"))))]
        {
            glSamplerParameterIivOES_load_with_dyn(&mut get_proc_address) as usize;
        }
        glSamplerParameterIuiv_load_with_dyn(&mut get_proc_address) as usize;
        #[cfg(any(feature = "GL_EXT_texture_border_clamp"))]
        #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_texture_border_clamp"))))]
        {
            glSamplerParameterIuivEXT_load_with_dyn(&mut get_proc_address) as usize;
        }
        #[cfg(any(feature = "GL_OES_texture_border_clamp"))]
        #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_OES_texture_border_clamp"))))]
        {
            glSamplerParameterIuivOES_load_with_dyn(&mut get_proc_address) as usize;
        }
        glSamplerParameterf_load_with_dyn(&mut get_proc_address) as usize;
        glSamplerParameterfv_load_with_dyn(&mut get_proc_address) as usize;
        glSamplerParameteri_load_with_dyn(&mut get_proc_address) as usize;
        glSamplerParameteriv_load_with_dyn(&mut get_proc_address) as usize;
        glScissor_load_with_dyn(&mut get_proc_address) as usize;
        #[cfg(any(feature = "GL_NV_viewport_array"))]
        #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_viewport_array"))))]
        {
            glScissorArrayvNV_load_with_dyn(&mut get_proc_address) as usize;
        }
        #[cfg(any(feature = "GL_OES_viewport_array"))]
        #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_OES_viewport_array"))))]
        {
            glScissorArrayvOES_load_with_dyn(&mut get_proc_address) as usize;
        }
        #[cfg(any(feature = "GL_NV_scissor_exclusive"))]
        #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_scissor_exclusive"))))]
        {
            glScissorExclusiveArrayvNV_load_with_dyn(&mut get_proc_address) as usize;
        }
        #[cfg(any(feature = "GL_NV_scissor_exclusive"))]
        #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_scissor_exclusive"))))]
        {
            glScissorExclusiveNV_load_with_dyn(&mut get_proc_address) as usize;
        }
        #[cfg(any(feature = "GL_NV_viewport_array"))]
        #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_viewport_array"))))]
        {
            glScissorIndexedNV_load_with_dyn(&mut get_proc_address) as usize;
        }
        #[cfg(any(feature = "GL_OES_viewport_array"))]
        #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_OES_viewport_array"))))]
        {
            glScissorIndexedOES_load_with_dyn(&mut get_proc_address) as usize;
        }
        #[cfg(any(feature = "GL_NV_viewport_array"))]
        #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_viewport_array"))))]
        {
            glScissorIndexedvNV_load_with_dyn(&mut get_proc_address) as usize;
        }
        #[cfg(any(feature = "GL_OES_viewport_array"))]
        #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_OES_viewport_array"))))]
        {
            glScissorIndexedvOES_load_with_dyn(&mut get_proc_address) as usize;
        }
        #[cfg(any(feature = "GL_AMD_performance_monitor"))]
        #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_AMD_performance_monitor"))))]
        {
            glSelectPerfMonitorCountersAMD_load_with_dyn(&mut get_proc_address) as usize;
        }
        #[cfg(any(feature = "GL_NV_timeline_semaphore"))]
        #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_timeline_semaphore"))))]
        {
            glSemaphoreParameterivNV_load_with_dyn(&mut get_proc_address) as usize;
        }
        #[cfg(any(feature = "GL_EXT_semaphore"))]
        #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_semaphore"))))]
        {
            glSemaphoreParameterui64vEXT_load_with_dyn(&mut get_proc_address) as usize;
        }
        #[cfg(any(feature = "GL_NV_fence"))]
        #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_fence"))))]
        {
            glSetFenceNV_load_with_dyn(&mut get_proc_address) as usize;
        }
        glShaderBinary_load_with_dyn(&mut get_proc_address) as usize;
        glShaderSource_load_with_dyn(&mut get_proc_address) as usize;
        #[cfg(any(feature = "GL_NV_shading_rate_image"))]
        #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_shading_rate_image"))))]
        {
            glShadingRateImageBarrierNV_load_with_dyn(&mut get_proc_address) as usize;
        }
        #[cfg(any(feature = "GL_NV_shading_rate_image"))]
        #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_shading_rate_image"))))]
        {
            glShadingRateImagePaletteNV_load_with_dyn(&mut get_proc_address) as usize;
        }
        #[cfg(any(feature = "GL_QCOM_shading_rate"))]
        #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_QCOM_shading_rate"))))]
        {
            glShadingRateQCOM_load_with_dyn(&mut get_proc_address) as usize;
        }
        #[cfg(any(feature = "GL_NV_shading_rate_image"))]
        #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_shading_rate_image"))))]
        {
            glShadingRateSampleOrderCustomNV_load_with_dyn(&mut get_proc_address) as usize;
        }
        #[cfg(any(feature = "GL_NV_shading_rate_image"))]
        #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_shading_rate_image"))))]
        {
            glShadingRateSampleOrderNV_load_with_dyn(&mut get_proc_address) as usize;
        }
        #[cfg(any(feature = "GL_EXT_semaphore"))]
        #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_semaphore"))))]
        {
            glSignalSemaphoreEXT_load_with_dyn(&mut get_proc_address) as usize;
        }
        #[cfg(any(feature = "GL_NV_draw_vulkan_image"))]
        #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_draw_vulkan_image"))))]
        {
            glSignalVkFenceNV_load_with_dyn(&mut get_proc_address) as usize;
        }
        #[cfg(any(feature = "GL_NV_draw_vulkan_image"))]
        #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_draw_vulkan_image"))))]
        {
            glSignalVkSemaphoreNV_load_with_dyn(&mut get_proc_address) as usize;
        }
        #[cfg(any(feature = "GL_QCOM_tiled_rendering"))]
        #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_QCOM_tiled_rendering"))))]
        {
            glStartTilingQCOM_load_with_dyn(&mut get_proc_address) as usize;
        }
        #[cfg(any(feature = "GL_NV_path_rendering"))]
        #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_path_rendering"))))]
        {
            glStencilFillPathInstancedNV_load_with_dyn(&mut get_proc_address) as usize;
        }
        #[cfg(any(feature = "GL_NV_path_rendering"))]
        #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_path_rendering"))))]
        {
            glStencilFillPathNV_load_with_dyn(&mut get_proc_address) as usize;
        }
        glStencilFunc_load_with_dyn(&mut get_proc_address) as usize;
        glStencilFuncSeparate_load_with_dyn(&mut get_proc_address) as usize;
        glStencilMask_load_with_dyn(&mut get_proc_address) as usize;
        glStencilMaskSeparate_load_with_dyn(&mut get_proc_address) as usize;
        glStencilOp_load_with_dyn(&mut get_proc_address) as usize;
        glStencilOpSeparate_load_with_dyn(&mut get_proc_address) as usize;
        #[cfg(any(feature = "GL_NV_path_rendering"))]
        #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_path_rendering"))))]
        {
            glStencilStrokePathInstancedNV_load_with_dyn(&mut get_proc_address) as usize;
        }
        #[cfg(any(feature = "GL_NV_path_rendering"))]
        #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_path_rendering"))))]
        {
            glStencilStrokePathNV_load_with_dyn(&mut get_proc_address) as usize;
        }
        #[cfg(any(feature = "GL_NV_path_rendering"))]
        #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_path_rendering"))))]
        {
            glStencilThenCoverFillPathInstancedNV_load_with_dyn(&mut get_proc_address) as usize;
        }
        #[cfg(any(feature = "GL_NV_path_rendering"))]
        #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_path_rendering"))))]
        {
            glStencilThenCoverFillPathNV_load_with_dyn(&mut get_proc_address) as usize;
        }
        #[cfg(any(feature = "GL_NV_path_rendering"))]
        #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_path_rendering"))))]
        {
            glStencilThenCoverStrokePathInstancedNV_load_with_dyn(&mut get_proc_address) as usize;
        }
        #[cfg(any(feature = "GL_NV_path_rendering"))]
        #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_path_rendering"))))]
        {
            glStencilThenCoverStrokePathNV_load_with_dyn(&mut get_proc_address) as usize;
        }
        #[cfg(any(feature = "GL_NV_conservative_raster"))]
        #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_conservative_raster"))))]
        {
            glSubpixelPrecisionBiasNV_load_with_dyn(&mut get_proc_address) as usize;
        }
        #[cfg(any(feature = "GL_NV_fence"))]
        #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_fence"))))]
        {
            glTestFenceNV_load_with_dyn(&mut get_proc_address) as usize;
        }
        #[cfg(any(feature = "GL_NV_memory_attachment"))]
        #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_memory_attachment"))))]
        {
            glTexAttachMemoryNV_load_with_dyn(&mut get_proc_address) as usize;
        }
        glTexBuffer_load_with_dyn(&mut get_proc_address) as usize;
        #[cfg(any(feature = "GL_EXT_texture_buffer"))]
        #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_texture_buffer"))))]
        {
            glTexBufferEXT_load_with_dyn(&mut get_proc_address) as usize;
        }
        #[cfg(any(feature = "GL_OES_texture_buffer"))]
        #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_OES_texture_buffer"))))]
        {
            glTexBufferOES_load_with_dyn(&mut get_proc_address) as usize;
        }
        glTexBufferRange_load_with_dyn(&mut get_proc_address) as usize;
        #[cfg(any(feature = "GL_EXT_texture_buffer"))]
        #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_texture_buffer"))))]
        {
            glTexBufferRangeEXT_load_with_dyn(&mut get_proc_address) as usize;
        }
        #[cfg(any(feature = "GL_OES_texture_buffer"))]
        #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_OES_texture_buffer"))))]
        {
            glTexBufferRangeOES_load_with_dyn(&mut get_proc_address) as usize;
        }
        #[cfg(any(feature = "GL_QCOM_motion_estimation"))]
        #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_QCOM_motion_estimation"))))]
        {
            glTexEstimateMotionQCOM_load_with_dyn(&mut get_proc_address) as usize;
        }
        #[cfg(any(feature = "GL_QCOM_motion_estimation"))]
        #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_QCOM_motion_estimation"))))]
        {
            glTexEstimateMotionRegionsQCOM_load_with_dyn(&mut get_proc_address) as usize;
        }
        glTexImage2D_load_with_dyn(&mut get_proc_address) as usize;
        glTexImage3D_load_with_dyn(&mut get_proc_address) as usize;
        #[cfg(any(feature = "GL_OES_texture_3D"))]
        #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_OES_texture_3D"))))]
        {
            glTexImage3DOES_load_with_dyn(&mut get_proc_address) as usize;
        }
        #[cfg(any(feature = "GL_EXT_sparse_texture"))]
        #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_sparse_texture"))))]
        {
            glTexPageCommitmentEXT_load_with_dyn(&mut get_proc_address) as usize;
        }
        #[cfg(any(feature = "GL_NV_memory_object_sparse"))]
        #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_memory_object_sparse"))))]
        {
            glTexPageCommitmentMemNV_load_with_dyn(&mut get_proc_address) as usize;
        }
        glTexParameterIiv_load_with_dyn(&mut get_proc_address) as usize;
        #[cfg(any(feature = "GL_EXT_texture_border_clamp"))]
        #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_texture_border_clamp"))))]
        {
            glTexParameterIivEXT_load_with_dyn(&mut get_proc_address) as usize;
        }
        #[cfg(any(feature = "GL_OES_texture_border_clamp"))]
        #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_OES_texture_border_clamp"))))]
        {
            glTexParameterIivOES_load_with_dyn(&mut get_proc_address) as usize;
        }
        glTexParameterIuiv_load_with_dyn(&mut get_proc_address) as usize;
        #[cfg(any(feature = "GL_EXT_texture_border_clamp"))]
        #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_texture_border_clamp"))))]
        {
            glTexParameterIuivEXT_load_with_dyn(&mut get_proc_address) as usize;
        }
        #[cfg(any(feature = "GL_OES_texture_border_clamp"))]
        #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_OES_texture_border_clamp"))))]
        {
            glTexParameterIuivOES_load_with_dyn(&mut get_proc_address) as usize;
        }
        glTexParameterf_load_with_dyn(&mut get_proc_address) as usize;
        glTexParameterfv_load_with_dyn(&mut get_proc_address) as usize;
        glTexParameteri_load_with_dyn(&mut get_proc_address) as usize;
        glTexParameteriv_load_with_dyn(&mut get_proc_address) as usize;
        #[cfg(any(feature = "GL_EXT_texture_storage"))]
        #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_texture_storage"))))]
        {
            glTexStorage1DEXT_load_with_dyn(&mut get_proc_address) as usize;
        }
        glTexStorage2D_load_with_dyn(&mut get_proc_address) as usize;
        #[cfg(any(feature = "GL_EXT_texture_storage"))]
        #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_texture_storage"))))]
        {
            glTexStorage2DEXT_load_with_dyn(&mut get_proc_address) as usize;
        }
        glTexStorage2DMultisample_load_with_dyn(&mut get_proc_address) as usize;
        glTexStorage3D_load_with_dyn(&mut get_proc_address) as usize;
        #[cfg(any(feature = "GL_EXT_texture_storage"))]
        #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_texture_storage"))))]
        {
            glTexStorage3DEXT_load_with_dyn(&mut get_proc_address) as usize;
        }
        glTexStorage3DMultisample_load_with_dyn(&mut get_proc_address) as usize;
        #[cfg(any(feature = "GL_OES_texture_storage_multisample_2d_array"))]
        #[cfg_attr(
            docs_rs,
            doc(cfg(any(feature = "GL_OES_texture_storage_multisample_2d_array")))
        )]
        {
            glTexStorage3DMultisampleOES_load_with_dyn(&mut get_proc_address) as usize;
        }
        #[cfg(any(feature = "GL_EXT_memory_object"))]
        #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_memory_object"))))]
        {
            glTexStorageMem2DEXT_load_with_dyn(&mut get_proc_address) as usize;
        }
        #[cfg(any(feature = "GL_EXT_memory_object"))]
        #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_memory_object"))))]
        {
            glTexStorageMem2DMultisampleEXT_load_with_dyn(&mut get_proc_address) as usize;
        }
        #[cfg(any(feature = "GL_EXT_memory_object"))]
        #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_memory_object"))))]
        {
            glTexStorageMem3DEXT_load_with_dyn(&mut get_proc_address) as usize;
        }
        #[cfg(any(feature = "GL_EXT_memory_object"))]
        #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_memory_object"))))]
        {
            glTexStorageMem3DMultisampleEXT_load_with_dyn(&mut get_proc_address) as usize;
        }
        glTexSubImage2D_load_with_dyn(&mut get_proc_address) as usize;
        glTexSubImage3D_load_with_dyn(&mut get_proc_address) as usize;
        #[cfg(any(feature = "GL_OES_texture_3D"))]
        #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_OES_texture_3D"))))]
        {
            glTexSubImage3DOES_load_with_dyn(&mut get_proc_address) as usize;
        }
        #[cfg(any(feature = "GL_NV_memory_attachment"))]
        #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_memory_attachment"))))]
        {
            glTextureAttachMemoryNV_load_with_dyn(&mut get_proc_address) as usize;
        }
        #[cfg(any(feature = "GL_QCOM_texture_foveated"))]
        #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_QCOM_texture_foveated"))))]
        {
            glTextureFoveationParametersQCOM_load_with_dyn(&mut get_proc_address) as usize;
        }
        #[cfg(any(feature = "GL_NV_memory_object_sparse"))]
        #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_memory_object_sparse"))))]
        {
            glTexturePageCommitmentMemNV_load_with_dyn(&mut get_proc_address) as usize;
        }
        #[cfg(any(feature = "GL_EXT_texture_storage"))]
        #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_texture_storage"))))]
        {
            glTextureStorage1DEXT_load_with_dyn(&mut get_proc_address) as usize;
        }
        #[cfg(any(feature = "GL_EXT_texture_storage"))]
        #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_texture_storage"))))]
        {
            glTextureStorage2DEXT_load_with_dyn(&mut get_proc_address) as usize;
        }
        #[cfg(any(feature = "GL_EXT_texture_storage"))]
        #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_texture_storage"))))]
        {
            glTextureStorage3DEXT_load_with_dyn(&mut get_proc_address) as usize;
        }
        #[cfg(any(feature = "GL_EXT_memory_object"))]
        #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_memory_object"))))]
        {
            glTextureStorageMem2DEXT_load_with_dyn(&mut get_proc_address) as usize;
        }
        #[cfg(any(feature = "GL_EXT_memory_object"))]
        #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_memory_object"))))]
        {
            glTextureStorageMem2DMultisampleEXT_load_with_dyn(&mut get_proc_address) as usize;
        }
        #[cfg(any(feature = "GL_EXT_memory_object"))]
        #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_memory_object"))))]
        {
            glTextureStorageMem3DEXT_load_with_dyn(&mut get_proc_address) as usize;
        }
        #[cfg(any(feature = "GL_EXT_memory_object"))]
        #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_memory_object"))))]
        {
            glTextureStorageMem3DMultisampleEXT_load_with_dyn(&mut get_proc_address) as usize;
        }
        #[cfg(any(feature = "GL_EXT_texture_view"))]
        #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_texture_view"))))]
        {
            glTextureViewEXT_load_with_dyn(&mut get_proc_address) as usize;
        }
        #[cfg(any(feature = "GL_OES_texture_view"))]
        #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_OES_texture_view"))))]
        {
            glTextureViewOES_load_with_dyn(&mut get_proc_address) as usize;
        }
        glTransformFeedbackVaryings_load_with_dyn(&mut get_proc_address) as usize;
        #[cfg(any(feature = "GL_NV_path_rendering"))]
        #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_path_rendering"))))]
        {
            glTransformPathNV_load_with_dyn(&mut get_proc_address) as usize;
        }
        glUniform1f_load_with_dyn(&mut get_proc_address) as usize;
        glUniform1fv_load_with_dyn(&mut get_proc_address) as usize;
        glUniform1i_load_with_dyn(&mut get_proc_address) as usize;
        #[cfg(any(feature = "GL_NV_gpu_shader5"))]
        #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_gpu_shader5"))))]
        {
            glUniform1i64NV_load_with_dyn(&mut get_proc_address) as usize;
        }
        #[cfg(any(feature = "GL_NV_gpu_shader5"))]
        #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_gpu_shader5"))))]
        {
            glUniform1i64vNV_load_with_dyn(&mut get_proc_address) as usize;
        }
        glUniform1iv_load_with_dyn(&mut get_proc_address) as usize;
        glUniform1ui_load_with_dyn(&mut get_proc_address) as usize;
        #[cfg(any(feature = "GL_NV_gpu_shader5"))]
        #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_gpu_shader5"))))]
        {
            glUniform1ui64NV_load_with_dyn(&mut get_proc_address) as usize;
        }
        #[cfg(any(feature = "GL_NV_gpu_shader5"))]
        #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_gpu_shader5"))))]
        {
            glUniform1ui64vNV_load_with_dyn(&mut get_proc_address) as usize;
        }
        glUniform1uiv_load_with_dyn(&mut get_proc_address) as usize;
        glUniform2f_load_with_dyn(&mut get_proc_address) as usize;
        glUniform2fv_load_with_dyn(&mut get_proc_address) as usize;
        glUniform2i_load_with_dyn(&mut get_proc_address) as usize;
        #[cfg(any(feature = "GL_NV_gpu_shader5"))]
        #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_gpu_shader5"))))]
        {
            glUniform2i64NV_load_with_dyn(&mut get_proc_address) as usize;
        }
        #[cfg(any(feature = "GL_NV_gpu_shader5"))]
        #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_gpu_shader5"))))]
        {
            glUniform2i64vNV_load_with_dyn(&mut get_proc_address) as usize;
        }
        glUniform2iv_load_with_dyn(&mut get_proc_address) as usize;
        glUniform2ui_load_with_dyn(&mut get_proc_address) as usize;
        #[cfg(any(feature = "GL_NV_gpu_shader5"))]
        #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_gpu_shader5"))))]
        {
            glUniform2ui64NV_load_with_dyn(&mut get_proc_address) as usize;
        }
        #[cfg(any(feature = "GL_NV_gpu_shader5"))]
        #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_gpu_shader5"))))]
        {
            glUniform2ui64vNV_load_with_dyn(&mut get_proc_address) as usize;
        }
        glUniform2uiv_load_with_dyn(&mut get_proc_address) as usize;
        glUniform3f_load_with_dyn(&mut get_proc_address) as usize;
        glUniform3fv_load_with_dyn(&mut get_proc_address) as usize;
        glUniform3i_load_with_dyn(&mut get_proc_address) as usize;
        #[cfg(any(feature = "GL_NV_gpu_shader5"))]
        #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_gpu_shader5"))))]
        {
            glUniform3i64NV_load_with_dyn(&mut get_proc_address) as usize;
        }
        #[cfg(any(feature = "GL_NV_gpu_shader5"))]
        #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_gpu_shader5"))))]
        {
            glUniform3i64vNV_load_with_dyn(&mut get_proc_address) as usize;
        }
        glUniform3iv_load_with_dyn(&mut get_proc_address) as usize;
        glUniform3ui_load_with_dyn(&mut get_proc_address) as usize;
        #[cfg(any(feature = "GL_NV_gpu_shader5"))]
        #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_gpu_shader5"))))]
        {
            glUniform3ui64NV_load_with_dyn(&mut get_proc_address) as usize;
        }
        #[cfg(any(feature = "GL_NV_gpu_shader5"))]
        #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_gpu_shader5"))))]
        {
            glUniform3ui64vNV_load_with_dyn(&mut get_proc_address) as usize;
        }
        glUniform3uiv_load_with_dyn(&mut get_proc_address) as usize;
        glUniform4f_load_with_dyn(&mut get_proc_address) as usize;
        glUniform4fv_load_with_dyn(&mut get_proc_address) as usize;
        glUniform4i_load_with_dyn(&mut get_proc_address) as usize;
        #[cfg(any(feature = "GL_NV_gpu_shader5"))]
        #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_gpu_shader5"))))]
        {
            glUniform4i64NV_load_with_dyn(&mut get_proc_address) as usize;
        }
        #[cfg(any(feature = "GL_NV_gpu_shader5"))]
        #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_gpu_shader5"))))]
        {
            glUniform4i64vNV_load_with_dyn(&mut get_proc_address) as usize;
        }
        glUniform4iv_load_with_dyn(&mut get_proc_address) as usize;
        glUniform4ui_load_with_dyn(&mut get_proc_address) as usize;
        #[cfg(any(feature = "GL_NV_gpu_shader5"))]
        #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_gpu_shader5"))))]
        {
            glUniform4ui64NV_load_with_dyn(&mut get_proc_address) as usize;
        }
        #[cfg(any(feature = "GL_NV_gpu_shader5"))]
        #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_gpu_shader5"))))]
        {
            glUniform4ui64vNV_load_with_dyn(&mut get_proc_address) as usize;
        }
        glUniform4uiv_load_with_dyn(&mut get_proc_address) as usize;
        glUniformBlockBinding_load_with_dyn(&mut get_proc_address) as usize;
        #[cfg(any(feature = "GL_IMG_bindless_texture"))]
        #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_IMG_bindless_texture"))))]
        {
            glUniformHandleui64IMG_load_with_dyn(&mut get_proc_address) as usize;
        }
        #[cfg(any(feature = "GL_NV_bindless_texture"))]
        #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_bindless_texture"))))]
        {
            glUniformHandleui64NV_load_with_dyn(&mut get_proc_address) as usize;
        }
        #[cfg(any(feature = "GL_IMG_bindless_texture"))]
        #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_IMG_bindless_texture"))))]
        {
            glUniformHandleui64vIMG_load_with_dyn(&mut get_proc_address) as usize;
        }
        #[cfg(any(feature = "GL_NV_bindless_texture"))]
        #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_bindless_texture"))))]
        {
            glUniformHandleui64vNV_load_with_dyn(&mut get_proc_address) as usize;
        }
        glUniformMatrix2fv_load_with_dyn(&mut get_proc_address) as usize;
        glUniformMatrix2x3fv_load_with_dyn(&mut get_proc_address) as usize;
        #[cfg(any(feature = "GL_NV_non_square_matrices"))]
        #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_non_square_matrices"))))]
        {
            glUniformMatrix2x3fvNV_load_with_dyn(&mut get_proc_address) as usize;
        }
        glUniformMatrix2x4fv_load_with_dyn(&mut get_proc_address) as usize;
        #[cfg(any(feature = "GL_NV_non_square_matrices"))]
        #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_non_square_matrices"))))]
        {
            glUniformMatrix2x4fvNV_load_with_dyn(&mut get_proc_address) as usize;
        }
        glUniformMatrix3fv_load_with_dyn(&mut get_proc_address) as usize;
        glUniformMatrix3x2fv_load_with_dyn(&mut get_proc_address) as usize;
        #[cfg(any(feature = "GL_NV_non_square_matrices"))]
        #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_non_square_matrices"))))]
        {
            glUniformMatrix3x2fvNV_load_with_dyn(&mut get_proc_address) as usize;
        }
        glUniformMatrix3x4fv_load_with_dyn(&mut get_proc_address) as usize;
        #[cfg(any(feature = "GL_NV_non_square_matrices"))]
        #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_non_square_matrices"))))]
        {
            glUniformMatrix3x4fvNV_load_with_dyn(&mut get_proc_address) as usize;
        }
        glUniformMatrix4fv_load_with_dyn(&mut get_proc_address) as usize;
        glUniformMatrix4x2fv_load_with_dyn(&mut get_proc_address) as usize;
        #[cfg(any(feature = "GL_NV_non_square_matrices"))]
        #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_non_square_matrices"))))]
        {
            glUniformMatrix4x2fvNV_load_with_dyn(&mut get_proc_address) as usize;
        }
        glUniformMatrix4x3fv_load_with_dyn(&mut get_proc_address) as usize;
        #[cfg(any(feature = "GL_NV_non_square_matrices"))]
        #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_non_square_matrices"))))]
        {
            glUniformMatrix4x3fvNV_load_with_dyn(&mut get_proc_address) as usize;
        }
        glUnmapBuffer_load_with_dyn(&mut get_proc_address) as usize;
        #[cfg(any(feature = "GL_OES_mapbuffer"))]
        #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_OES_mapbuffer"))))]
        {
            glUnmapBufferOES_load_with_dyn(&mut get_proc_address) as usize;
        }
        glUseProgram_load_with_dyn(&mut get_proc_address) as usize;
        glUseProgramStages_load_with_dyn(&mut get_proc_address) as usize;
        #[cfg(any(feature = "GL_EXT_separate_shader_objects"))]
        #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_separate_shader_objects"))))]
        {
            glUseProgramStagesEXT_load_with_dyn(&mut get_proc_address) as usize;
        }
        glValidateProgram_load_with_dyn(&mut get_proc_address) as usize;
        glValidateProgramPipeline_load_with_dyn(&mut get_proc_address) as usize;
        #[cfg(any(feature = "GL_EXT_separate_shader_objects"))]
        #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_separate_shader_objects"))))]
        {
            glValidateProgramPipelineEXT_load_with_dyn(&mut get_proc_address) as usize;
        }
        glVertexAttrib1f_load_with_dyn(&mut get_proc_address) as usize;
        glVertexAttrib1fv_load_with_dyn(&mut get_proc_address) as usize;
        glVertexAttrib2f_load_with_dyn(&mut get_proc_address) as usize;
        glVertexAttrib2fv_load_with_dyn(&mut get_proc_address) as usize;
        glVertexAttrib3f_load_with_dyn(&mut get_proc_address) as usize;
        glVertexAttrib3fv_load_with_dyn(&mut get_proc_address) as usize;
        glVertexAttrib4f_load_with_dyn(&mut get_proc_address) as usize;
        glVertexAttrib4fv_load_with_dyn(&mut get_proc_address) as usize;
        glVertexAttribBinding_load_with_dyn(&mut get_proc_address) as usize;
        glVertexAttribDivisor_load_with_dyn(&mut get_proc_address) as usize;
        #[cfg(any(feature = "GL_ANGLE_instanced_arrays"))]
        #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_ANGLE_instanced_arrays"))))]
        {
            glVertexAttribDivisorANGLE_load_with_dyn(&mut get_proc_address) as usize;
        }
        #[cfg(any(feature = "GL_EXT_instanced_arrays"))]
        #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_instanced_arrays"))))]
        {
            glVertexAttribDivisorEXT_load_with_dyn(&mut get_proc_address) as usize;
        }
        #[cfg(any(feature = "GL_NV_instanced_arrays"))]
        #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_instanced_arrays"))))]
        {
            glVertexAttribDivisorNV_load_with_dyn(&mut get_proc_address) as usize;
        }
        glVertexAttribFormat_load_with_dyn(&mut get_proc_address) as usize;
        glVertexAttribI4i_load_with_dyn(&mut get_proc_address) as usize;
        glVertexAttribI4iv_load_with_dyn(&mut get_proc_address) as usize;
        glVertexAttribI4ui_load_with_dyn(&mut get_proc_address) as usize;
        glVertexAttribI4uiv_load_with_dyn(&mut get_proc_address) as usize;
        glVertexAttribIFormat_load_with_dyn(&mut get_proc_address) as usize;
        glVertexAttribIPointer_load_with_dyn(&mut get_proc_address) as usize;
        glVertexAttribPointer_load_with_dyn(&mut get_proc_address) as usize;
        glVertexBindingDivisor_load_with_dyn(&mut get_proc_address) as usize;
        glViewport_load_with_dyn(&mut get_proc_address) as usize;
        #[cfg(any(feature = "GL_NV_viewport_array"))]
        #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_viewport_array"))))]
        {
            glViewportArrayvNV_load_with_dyn(&mut get_proc_address) as usize;
        }
        #[cfg(any(feature = "GL_OES_viewport_array"))]
        #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_OES_viewport_array"))))]
        {
            glViewportArrayvOES_load_with_dyn(&mut get_proc_address) as usize;
        }
        #[cfg(any(feature = "GL_NV_viewport_array"))]
        #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_viewport_array"))))]
        {
            glViewportIndexedfNV_load_with_dyn(&mut get_proc_address) as usize;
        }
        #[cfg(any(feature = "GL_OES_viewport_array"))]
        #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_OES_viewport_array"))))]
        {
            glViewportIndexedfOES_load_with_dyn(&mut get_proc_address) as usize;
        }
        #[cfg(any(feature = "GL_NV_viewport_array"))]
        #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_viewport_array"))))]
        {
            glViewportIndexedfvNV_load_with_dyn(&mut get_proc_address) as usize;
        }
        #[cfg(any(feature = "GL_OES_viewport_array"))]
        #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_OES_viewport_array"))))]
        {
            glViewportIndexedfvOES_load_with_dyn(&mut get_proc_address) as usize;
        }
        #[cfg(any(feature = "GL_NV_clip_space_w_scaling"))]
        #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_clip_space_w_scaling"))))]
        {
            glViewportPositionWScaleNV_load_with_dyn(&mut get_proc_address) as usize;
        }
        #[cfg(any(feature = "GL_NV_viewport_swizzle"))]
        #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_viewport_swizzle"))))]
        {
            glViewportSwizzleNV_load_with_dyn(&mut get_proc_address) as usize;
        }
        #[cfg(any(feature = "GL_EXT_semaphore"))]
        #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_semaphore"))))]
        {
            glWaitSemaphoreEXT_load_with_dyn(&mut get_proc_address) as usize;
        }
        glWaitSync_load_with_dyn(&mut get_proc_address) as usize;
        #[cfg(any(feature = "GL_APPLE_sync"))]
        #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_APPLE_sync"))))]
        {
            glWaitSyncAPPLE_load_with_dyn(&mut get_proc_address) as usize;
        }
        #[cfg(any(feature = "GL_NV_draw_vulkan_image"))]
        #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_draw_vulkan_image"))))]
        {
            glWaitVkSemaphoreNV_load_with_dyn(&mut get_proc_address) as usize;
        }
        #[cfg(any(feature = "GL_NV_path_rendering"))]
        #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_path_rendering"))))]
        {
            glWeightPathsNV_load_with_dyn(&mut get_proc_address) as usize;
        }
        #[cfg(any(feature = "GL_EXT_window_rectangles"))]
        #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_window_rectangles"))))]
        {
            glWindowRectanglesEXT_load_with_dyn(&mut get_proc_address) as usize;
        }
    }

    /// [glAcquireKeyedMutexWin32EXT](http://docs.gl/es3/glAcquireKeyedMutexWin32EXT)(memory, key, timeout)
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    #[cfg(any(feature = "GL_EXT_win32_keyed_mutex"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_win32_keyed_mutex"))))]
    pub unsafe fn glAcquireKeyedMutexWin32EXT(
        memory: GLuint,
        key: GLuint64,
        timeout: GLuint,
    ) -> GLboolean {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glAcquireKeyedMutexWin32EXT({:?}, {:?}, {:?});",
                memory,
                key,
                timeout
            );
        }
        let out = call_atomic_ptr_3arg(
            "glAcquireKeyedMutexWin32EXT",
            &glAcquireKeyedMutexWin32EXT_p,
            memory,
            key,
            timeout,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glAcquireKeyedMutexWin32EXT");
        }
        out
    }
    #[cfg(any(feature = "GL_EXT_win32_keyed_mutex"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_win32_keyed_mutex"))))]
    static glAcquireKeyedMutexWin32EXT_p: APcv = ap_None();
    /// Tries to load [`glAcquireKeyedMutexWin32EXT`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    #[cfg(any(feature = "GL_EXT_win32_keyed_mutex"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_win32_keyed_mutex"))))]
    pub unsafe fn glAcquireKeyedMutexWin32EXT_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glAcquireKeyedMutexWin32EXT\0",
            &glAcquireKeyedMutexWin32EXT_p,
        )
    }
    /// Checks if the pointer for [`glAcquireKeyedMutexWin32EXT`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    #[cfg(any(feature = "GL_EXT_win32_keyed_mutex"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_win32_keyed_mutex"))))]
    pub fn glAcquireKeyedMutexWin32EXT_is_loaded() -> bool {
        !glAcquireKeyedMutexWin32EXT_p.load(RELAX).is_null()
    }

    /// [glActiveShaderProgram](http://docs.gl/es3/glActiveShaderProgram)(pipeline, program)
    /// `pipeline` class: program pipeline
    /// `program` class: program
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn glActiveShaderProgram(pipeline: GLuint, program: GLuint) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glActiveShaderProgram({:?}, {:?});",
                pipeline,
                program
            );
        }
        let out = call_atomic_ptr_2arg(
            "glActiveShaderProgram",
            &glActiveShaderProgram_p,
            pipeline,
            program,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glActiveShaderProgram");
        }
        out
    }
    static glActiveShaderProgram_p: APcv = ap_None();
    /// Tries to load [`glActiveShaderProgram`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    pub unsafe fn glActiveShaderProgram_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glActiveShaderProgram\0",
            &glActiveShaderProgram_p,
        )
    }
    /// Checks if the pointer for [`glActiveShaderProgram`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    pub fn glActiveShaderProgram_is_loaded() -> bool {
        !glActiveShaderProgram_p.load(RELAX).is_null()
    }

    /// [glActiveShaderProgramEXT](http://docs.gl/es3/glActiveShaderProgramEXT)(pipeline, program)
    /// `pipeline` class: program pipeline
    /// `program` class: program
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    #[cfg(any(feature = "GL_EXT_separate_shader_objects"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_separate_shader_objects"))))]
    pub unsafe fn glActiveShaderProgramEXT(pipeline: GLuint, program: GLuint) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glActiveShaderProgramEXT({:?}, {:?});",
                pipeline,
                program
            );
        }
        let out = call_atomic_ptr_2arg(
            "glActiveShaderProgramEXT",
            &glActiveShaderProgramEXT_p,
            pipeline,
            program,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glActiveShaderProgramEXT");
        }
        out
    }
    #[cfg(any(feature = "GL_EXT_separate_shader_objects"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_separate_shader_objects"))))]
    static glActiveShaderProgramEXT_p: APcv = ap_None();
    /// Tries to load [`glActiveShaderProgramEXT`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    #[cfg(any(feature = "GL_EXT_separate_shader_objects"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_separate_shader_objects"))))]
    pub unsafe fn glActiveShaderProgramEXT_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glActiveShaderProgramEXT\0",
            &glActiveShaderProgramEXT_p,
        )
    }
    /// Checks if the pointer for [`glActiveShaderProgramEXT`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    #[cfg(any(feature = "GL_EXT_separate_shader_objects"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_separate_shader_objects"))))]
    pub fn glActiveShaderProgramEXT_is_loaded() -> bool {
        !glActiveShaderProgramEXT_p.load(RELAX).is_null()
    }

    /// [glActiveTexture](http://docs.gl/es3/glActiveTexture)(texture)
    /// `texture` group: TextureUnit
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn glActiveTexture(texture: GLenum) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!("calling glActiveTexture({:#X});", texture);
        }
        let out = call_atomic_ptr_1arg("glActiveTexture", &glActiveTexture_p, texture);
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glActiveTexture");
        }
        out
    }
    static glActiveTexture_p: APcv = ap_None();
    /// Tries to load [`glActiveTexture`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    pub unsafe fn glActiveTexture_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(get_proc_address, b"glActiveTexture\0", &glActiveTexture_p)
    }
    /// Checks if the pointer for [`glActiveTexture`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    pub fn glActiveTexture_is_loaded() -> bool {
        !glActiveTexture_p.load(RELAX).is_null()
    }

    /// [glAlphaFuncQCOM](http://docs.gl/es3/glAlphaFuncQCOM)(func, ref_)
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    #[cfg(any(feature = "GL_QCOM_alpha_test"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_QCOM_alpha_test"))))]
    pub unsafe fn glAlphaFuncQCOM(func: GLenum, ref_: GLclampf) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!("calling glAlphaFuncQCOM({:#X}, {:?});", func, ref_);
        }
        let out = call_atomic_ptr_2arg("glAlphaFuncQCOM", &glAlphaFuncQCOM_p, func, ref_);
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glAlphaFuncQCOM");
        }
        out
    }
    #[cfg(any(feature = "GL_QCOM_alpha_test"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_QCOM_alpha_test"))))]
    static glAlphaFuncQCOM_p: APcv = ap_None();
    /// Tries to load [`glAlphaFuncQCOM`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    #[cfg(any(feature = "GL_QCOM_alpha_test"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_QCOM_alpha_test"))))]
    pub unsafe fn glAlphaFuncQCOM_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(get_proc_address, b"glAlphaFuncQCOM\0", &glAlphaFuncQCOM_p)
    }
    /// Checks if the pointer for [`glAlphaFuncQCOM`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    #[cfg(any(feature = "GL_QCOM_alpha_test"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_QCOM_alpha_test"))))]
    pub fn glAlphaFuncQCOM_is_loaded() -> bool {
        !glAlphaFuncQCOM_p.load(RELAX).is_null()
    }

    /// [glApplyFramebufferAttachmentCMAAINTEL](http://docs.gl/es3/glApplyFramebufferAttachmentCMAAINTEL)()
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    #[cfg(any(feature = "GL_INTEL_framebuffer_CMAA"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_INTEL_framebuffer_CMAA"))))]
    pub unsafe fn glApplyFramebufferAttachmentCMAAINTEL() {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!("calling glApplyFramebufferAttachmentCMAAINTEL();",);
        }
        let out = call_atomic_ptr_0arg(
            "glApplyFramebufferAttachmentCMAAINTEL",
            &glApplyFramebufferAttachmentCMAAINTEL_p,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glApplyFramebufferAttachmentCMAAINTEL");
        }
        out
    }
    #[cfg(any(feature = "GL_INTEL_framebuffer_CMAA"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_INTEL_framebuffer_CMAA"))))]
    static glApplyFramebufferAttachmentCMAAINTEL_p: APcv = ap_None();
    /// Tries to load [`glApplyFramebufferAttachmentCMAAINTEL`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    #[cfg(any(feature = "GL_INTEL_framebuffer_CMAA"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_INTEL_framebuffer_CMAA"))))]
    pub unsafe fn glApplyFramebufferAttachmentCMAAINTEL_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glApplyFramebufferAttachmentCMAAINTEL\0",
            &glApplyFramebufferAttachmentCMAAINTEL_p,
        )
    }
    /// Checks if the pointer for [`glApplyFramebufferAttachmentCMAAINTEL`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    #[cfg(any(feature = "GL_INTEL_framebuffer_CMAA"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_INTEL_framebuffer_CMAA"))))]
    pub fn glApplyFramebufferAttachmentCMAAINTEL_is_loaded() -> bool {
        !glApplyFramebufferAttachmentCMAAINTEL_p
            .load(RELAX)
            .is_null()
    }

    /// [glAttachShader](http://docs.gl/es3/glAttachShader)(program, shader)
    /// `program` class: program
    /// `shader` class: shader
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn glAttachShader(program: GLuint, shader: GLuint) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!("calling glAttachShader({:?}, {:?});", program, shader);
        }
        let out = call_atomic_ptr_2arg("glAttachShader", &glAttachShader_p, program, shader);
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glAttachShader");
        }
        out
    }
    static glAttachShader_p: APcv = ap_None();
    /// Tries to load [`glAttachShader`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    pub unsafe fn glAttachShader_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(get_proc_address, b"glAttachShader\0", &glAttachShader_p)
    }
    /// Checks if the pointer for [`glAttachShader`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    pub fn glAttachShader_is_loaded() -> bool {
        !glAttachShader_p.load(RELAX).is_null()
    }

    /// [glBeginConditionalRenderNV](http://docs.gl/es3/glBeginConditionalRenderNV)(id, mode)
    /// `mode` group: ConditionalRenderMode
    /// alias of: [`glBeginConditionalRender`]
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    #[cfg(any(feature = "GL_NV_conditional_render"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_conditional_render"))))]
    pub unsafe fn glBeginConditionalRenderNV(id: GLuint, mode: GLenum) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!("calling glBeginConditionalRenderNV({:?}, {:#X});", id, mode);
        }
        let out = call_atomic_ptr_2arg(
            "glBeginConditionalRenderNV",
            &glBeginConditionalRenderNV_p,
            id,
            mode,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glBeginConditionalRenderNV");
        }
        out
    }
    #[cfg(any(feature = "GL_NV_conditional_render"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_conditional_render"))))]
    static glBeginConditionalRenderNV_p: APcv = ap_None();
    /// Tries to load [`glBeginConditionalRenderNV`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    #[cfg(any(feature = "GL_NV_conditional_render"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_conditional_render"))))]
    pub unsafe fn glBeginConditionalRenderNV_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glBeginConditionalRenderNV\0",
            &glBeginConditionalRenderNV_p,
        )
    }
    /// Checks if the pointer for [`glBeginConditionalRenderNV`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    #[cfg(any(feature = "GL_NV_conditional_render"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_conditional_render"))))]
    pub fn glBeginConditionalRenderNV_is_loaded() -> bool {
        !glBeginConditionalRenderNV_p.load(RELAX).is_null()
    }

    /// [glBeginPerfMonitorAMD](http://docs.gl/es3/glBeginPerfMonitorAMD)(monitor)
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    #[cfg(any(feature = "GL_AMD_performance_monitor"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_AMD_performance_monitor"))))]
    pub unsafe fn glBeginPerfMonitorAMD(monitor: GLuint) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!("calling glBeginPerfMonitorAMD({:?});", monitor);
        }
        let out = call_atomic_ptr_1arg("glBeginPerfMonitorAMD", &glBeginPerfMonitorAMD_p, monitor);
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glBeginPerfMonitorAMD");
        }
        out
    }
    #[cfg(any(feature = "GL_AMD_performance_monitor"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_AMD_performance_monitor"))))]
    static glBeginPerfMonitorAMD_p: APcv = ap_None();
    /// Tries to load [`glBeginPerfMonitorAMD`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    #[cfg(any(feature = "GL_AMD_performance_monitor"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_AMD_performance_monitor"))))]
    pub unsafe fn glBeginPerfMonitorAMD_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glBeginPerfMonitorAMD\0",
            &glBeginPerfMonitorAMD_p,
        )
    }
    /// Checks if the pointer for [`glBeginPerfMonitorAMD`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    #[cfg(any(feature = "GL_AMD_performance_monitor"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_AMD_performance_monitor"))))]
    pub fn glBeginPerfMonitorAMD_is_loaded() -> bool {
        !glBeginPerfMonitorAMD_p.load(RELAX).is_null()
    }

    /// [glBeginPerfQueryINTEL](http://docs.gl/es3/glBeginPerfQueryINTEL)(queryHandle)
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    #[cfg(any(feature = "GL_INTEL_performance_query"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_INTEL_performance_query"))))]
    pub unsafe fn glBeginPerfQueryINTEL(queryHandle: GLuint) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!("calling glBeginPerfQueryINTEL({:?});", queryHandle);
        }
        let out = call_atomic_ptr_1arg(
            "glBeginPerfQueryINTEL",
            &glBeginPerfQueryINTEL_p,
            queryHandle,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glBeginPerfQueryINTEL");
        }
        out
    }
    #[cfg(any(feature = "GL_INTEL_performance_query"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_INTEL_performance_query"))))]
    static glBeginPerfQueryINTEL_p: APcv = ap_None();
    /// Tries to load [`glBeginPerfQueryINTEL`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    #[cfg(any(feature = "GL_INTEL_performance_query"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_INTEL_performance_query"))))]
    pub unsafe fn glBeginPerfQueryINTEL_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glBeginPerfQueryINTEL\0",
            &glBeginPerfQueryINTEL_p,
        )
    }
    /// Checks if the pointer for [`glBeginPerfQueryINTEL`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    #[cfg(any(feature = "GL_INTEL_performance_query"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_INTEL_performance_query"))))]
    pub fn glBeginPerfQueryINTEL_is_loaded() -> bool {
        !glBeginPerfQueryINTEL_p.load(RELAX).is_null()
    }

    /// [glBeginQuery](http://docs.gl/es3/glBeginQuery)(target, id)
    /// `target` group: QueryTarget
    /// `id` class: query
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn glBeginQuery(target: GLenum, id: GLuint) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!("calling glBeginQuery({:#X}, {:?});", target, id);
        }
        let out = call_atomic_ptr_2arg("glBeginQuery", &glBeginQuery_p, target, id);
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glBeginQuery");
        }
        out
    }
    static glBeginQuery_p: APcv = ap_None();
    /// Tries to load [`glBeginQuery`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    pub unsafe fn glBeginQuery_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(get_proc_address, b"glBeginQuery\0", &glBeginQuery_p)
    }
    /// Checks if the pointer for [`glBeginQuery`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    pub fn glBeginQuery_is_loaded() -> bool {
        !glBeginQuery_p.load(RELAX).is_null()
    }

    /// [glBeginQueryEXT](http://docs.gl/es3/glBeginQueryEXT)(target, id)
    /// `target` group: QueryTarget
    /// `id` class: query
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    #[cfg(any(
        feature = "GL_EXT_disjoint_timer_query",
        feature = "GL_EXT_occlusion_query_boolean"
    ))]
    #[cfg_attr(
        docs_rs,
        doc(cfg(any(
            feature = "GL_EXT_disjoint_timer_query",
            feature = "GL_EXT_occlusion_query_boolean"
        )))
    )]
    pub unsafe fn glBeginQueryEXT(target: GLenum, id: GLuint) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!("calling glBeginQueryEXT({:#X}, {:?});", target, id);
        }
        let out = call_atomic_ptr_2arg("glBeginQueryEXT", &glBeginQueryEXT_p, target, id);
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glBeginQueryEXT");
        }
        out
    }
    #[cfg(any(
        feature = "GL_EXT_disjoint_timer_query",
        feature = "GL_EXT_occlusion_query_boolean"
    ))]
    #[cfg_attr(
        docs_rs,
        doc(cfg(any(
            feature = "GL_EXT_disjoint_timer_query",
            feature = "GL_EXT_occlusion_query_boolean"
        )))
    )]
    static glBeginQueryEXT_p: APcv = ap_None();
    /// Tries to load [`glBeginQueryEXT`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    #[cfg(any(
        feature = "GL_EXT_disjoint_timer_query",
        feature = "GL_EXT_occlusion_query_boolean"
    ))]
    #[cfg_attr(
        docs_rs,
        doc(cfg(any(
            feature = "GL_EXT_disjoint_timer_query",
            feature = "GL_EXT_occlusion_query_boolean"
        )))
    )]
    pub unsafe fn glBeginQueryEXT_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(get_proc_address, b"glBeginQueryEXT\0", &glBeginQueryEXT_p)
    }
    /// Checks if the pointer for [`glBeginQueryEXT`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    #[cfg(any(
        feature = "GL_EXT_disjoint_timer_query",
        feature = "GL_EXT_occlusion_query_boolean"
    ))]
    #[cfg_attr(
        docs_rs,
        doc(cfg(any(
            feature = "GL_EXT_disjoint_timer_query",
            feature = "GL_EXT_occlusion_query_boolean"
        )))
    )]
    pub fn glBeginQueryEXT_is_loaded() -> bool {
        !glBeginQueryEXT_p.load(RELAX).is_null()
    }

    /// [glBeginTransformFeedback](http://docs.gl/es3/glBeginTransformFeedback)(primitiveMode)
    /// `primitiveMode` group: PrimitiveType
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn glBeginTransformFeedback(primitiveMode: GLenum) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!("calling glBeginTransformFeedback({:#X});", primitiveMode);
        }
        let out = call_atomic_ptr_1arg(
            "glBeginTransformFeedback",
            &glBeginTransformFeedback_p,
            primitiveMode,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glBeginTransformFeedback");
        }
        out
    }
    static glBeginTransformFeedback_p: APcv = ap_None();
    /// Tries to load [`glBeginTransformFeedback`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    pub unsafe fn glBeginTransformFeedback_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glBeginTransformFeedback\0",
            &glBeginTransformFeedback_p,
        )
    }
    /// Checks if the pointer for [`glBeginTransformFeedback`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    pub fn glBeginTransformFeedback_is_loaded() -> bool {
        !glBeginTransformFeedback_p.load(RELAX).is_null()
    }

    /// [glBindAttribLocation](http://docs.gl/es3/glBindAttribLocation)(program, index, name)
    /// `program` class: program
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn glBindAttribLocation(program: GLuint, index: GLuint, name: *const GLchar) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glBindAttribLocation({:?}, {:?}, {:p});",
                program,
                index,
                name
            );
        }
        let out = call_atomic_ptr_3arg(
            "glBindAttribLocation",
            &glBindAttribLocation_p,
            program,
            index,
            name,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glBindAttribLocation");
        }
        out
    }
    static glBindAttribLocation_p: APcv = ap_None();
    /// Tries to load [`glBindAttribLocation`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    pub unsafe fn glBindAttribLocation_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glBindAttribLocation\0",
            &glBindAttribLocation_p,
        )
    }
    /// Checks if the pointer for [`glBindAttribLocation`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    pub fn glBindAttribLocation_is_loaded() -> bool {
        !glBindAttribLocation_p.load(RELAX).is_null()
    }

    /// [glBindBuffer](http://docs.gl/es3/glBindBuffer)(target, buffer)
    /// `target` group: BufferTargetARB
    /// `buffer` class: buffer
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn glBindBuffer(target: GLenum, buffer: GLuint) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!("calling glBindBuffer({:#X}, {:?});", target, buffer);
        }
        let out = call_atomic_ptr_2arg("glBindBuffer", &glBindBuffer_p, target, buffer);
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glBindBuffer");
        }
        out
    }
    static glBindBuffer_p: APcv = ap_None();
    /// Tries to load [`glBindBuffer`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    pub unsafe fn glBindBuffer_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(get_proc_address, b"glBindBuffer\0", &glBindBuffer_p)
    }
    /// Checks if the pointer for [`glBindBuffer`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    pub fn glBindBuffer_is_loaded() -> bool {
        !glBindBuffer_p.load(RELAX).is_null()
    }

    /// [glBindBufferBase](http://docs.gl/es3/glBindBufferBase)(target, index, buffer)
    /// `target` group: BufferTargetARB
    /// `buffer` class: buffer
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn glBindBufferBase(target: GLenum, index: GLuint, buffer: GLuint) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glBindBufferBase({:#X}, {:?}, {:?});",
                target,
                index,
                buffer
            );
        }
        let out = call_atomic_ptr_3arg(
            "glBindBufferBase",
            &glBindBufferBase_p,
            target,
            index,
            buffer,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glBindBufferBase");
        }
        out
    }
    static glBindBufferBase_p: APcv = ap_None();
    /// Tries to load [`glBindBufferBase`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    pub unsafe fn glBindBufferBase_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(get_proc_address, b"glBindBufferBase\0", &glBindBufferBase_p)
    }
    /// Checks if the pointer for [`glBindBufferBase`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    pub fn glBindBufferBase_is_loaded() -> bool {
        !glBindBufferBase_p.load(RELAX).is_null()
    }

    /// [glBindBufferRange](http://docs.gl/es3/glBindBufferRange)(target, index, buffer, offset, size)
    /// `target` group: BufferTargetARB
    /// `buffer` class: buffer
    /// `offset` group: BufferOffset
    /// `size` group: BufferSize
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn glBindBufferRange(
        target: GLenum,
        index: GLuint,
        buffer: GLuint,
        offset: GLintptr,
        size: GLsizeiptr,
    ) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glBindBufferRange({:#X}, {:?}, {:?}, {:?}, {:?});",
                target,
                index,
                buffer,
                offset,
                size
            );
        }
        let out = call_atomic_ptr_5arg(
            "glBindBufferRange",
            &glBindBufferRange_p,
            target,
            index,
            buffer,
            offset,
            size,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glBindBufferRange");
        }
        out
    }
    static glBindBufferRange_p: APcv = ap_None();
    /// Tries to load [`glBindBufferRange`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    pub unsafe fn glBindBufferRange_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glBindBufferRange\0",
            &glBindBufferRange_p,
        )
    }
    /// Checks if the pointer for [`glBindBufferRange`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    pub fn glBindBufferRange_is_loaded() -> bool {
        !glBindBufferRange_p.load(RELAX).is_null()
    }

    /// [glBindFragDataLocationEXT](http://docs.gl/es3/glBindFragDataLocationEXT)(program, color, name)
    /// `program` class: program
    /// `name` len: COMPSIZE(name)
    /// alias of: [`glBindFragDataLocation`]
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    #[cfg(any(feature = "GL_EXT_blend_func_extended"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_blend_func_extended"))))]
    pub unsafe fn glBindFragDataLocationEXT(program: GLuint, color: GLuint, name: *const GLchar) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glBindFragDataLocationEXT({:?}, {:?}, {:p});",
                program,
                color,
                name
            );
        }
        let out = call_atomic_ptr_3arg(
            "glBindFragDataLocationEXT",
            &glBindFragDataLocationEXT_p,
            program,
            color,
            name,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glBindFragDataLocationEXT");
        }
        out
    }
    #[cfg(any(feature = "GL_EXT_blend_func_extended"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_blend_func_extended"))))]
    static glBindFragDataLocationEXT_p: APcv = ap_None();
    /// Tries to load [`glBindFragDataLocationEXT`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    #[cfg(any(feature = "GL_EXT_blend_func_extended"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_blend_func_extended"))))]
    pub unsafe fn glBindFragDataLocationEXT_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glBindFragDataLocationEXT\0",
            &glBindFragDataLocationEXT_p,
        )
    }
    /// Checks if the pointer for [`glBindFragDataLocationEXT`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    #[cfg(any(feature = "GL_EXT_blend_func_extended"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_blend_func_extended"))))]
    pub fn glBindFragDataLocationEXT_is_loaded() -> bool {
        !glBindFragDataLocationEXT_p.load(RELAX).is_null()
    }

    /// [glBindFragDataLocationIndexedEXT](http://docs.gl/es3/glBindFragDataLocationIndexedEXT)(program, colorNumber, index, name)
    /// `program` class: program
    /// alias of: [`glBindFragDataLocationIndexed`]
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    #[cfg(any(feature = "GL_EXT_blend_func_extended"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_blend_func_extended"))))]
    pub unsafe fn glBindFragDataLocationIndexedEXT(
        program: GLuint,
        colorNumber: GLuint,
        index: GLuint,
        name: *const GLchar,
    ) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glBindFragDataLocationIndexedEXT({:?}, {:?}, {:?}, {:p});",
                program,
                colorNumber,
                index,
                name
            );
        }
        let out = call_atomic_ptr_4arg(
            "glBindFragDataLocationIndexedEXT",
            &glBindFragDataLocationIndexedEXT_p,
            program,
            colorNumber,
            index,
            name,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glBindFragDataLocationIndexedEXT");
        }
        out
    }
    #[cfg(any(feature = "GL_EXT_blend_func_extended"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_blend_func_extended"))))]
    static glBindFragDataLocationIndexedEXT_p: APcv = ap_None();
    /// Tries to load [`glBindFragDataLocationIndexedEXT`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    #[cfg(any(feature = "GL_EXT_blend_func_extended"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_blend_func_extended"))))]
    pub unsafe fn glBindFragDataLocationIndexedEXT_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glBindFragDataLocationIndexedEXT\0",
            &glBindFragDataLocationIndexedEXT_p,
        )
    }
    /// Checks if the pointer for [`glBindFragDataLocationIndexedEXT`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    #[cfg(any(feature = "GL_EXT_blend_func_extended"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_blend_func_extended"))))]
    pub fn glBindFragDataLocationIndexedEXT_is_loaded() -> bool {
        !glBindFragDataLocationIndexedEXT_p.load(RELAX).is_null()
    }

    /// [glBindFramebuffer](http://docs.gl/es3/glBindFramebuffer)(target, framebuffer)
    /// `target` group: FramebufferTarget
    /// `framebuffer` class: framebuffer
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn glBindFramebuffer(target: GLenum, framebuffer: GLuint) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glBindFramebuffer({:#X}, {:?});",
                target,
                framebuffer
            );
        }
        let out = call_atomic_ptr_2arg(
            "glBindFramebuffer",
            &glBindFramebuffer_p,
            target,
            framebuffer,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glBindFramebuffer");
        }
        out
    }
    static glBindFramebuffer_p: APcv = ap_None();
    /// Tries to load [`glBindFramebuffer`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    pub unsafe fn glBindFramebuffer_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glBindFramebuffer\0",
            &glBindFramebuffer_p,
        )
    }
    /// Checks if the pointer for [`glBindFramebuffer`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    pub fn glBindFramebuffer_is_loaded() -> bool {
        !glBindFramebuffer_p.load(RELAX).is_null()
    }

    /// [glBindImageTexture](http://docs.gl/es3/glBindImageTexture)(unit, texture, level, layered, layer, access, format)
    /// `texture` class: texture
    /// `access` group: BufferAccessARB
    /// `format` group: InternalFormat
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn glBindImageTexture(
        unit: GLuint,
        texture: GLuint,
        level: GLint,
        layered: GLboolean,
        layer: GLint,
        access: GLenum,
        format: GLenum,
    ) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glBindImageTexture({:?}, {:?}, {:?}, {:?}, {:?}, {:#X}, {:#X});",
                unit,
                texture,
                level,
                layered,
                layer,
                access,
                format
            );
        }
        let out = call_atomic_ptr_7arg(
            "glBindImageTexture",
            &glBindImageTexture_p,
            unit,
            texture,
            level,
            layered,
            layer,
            access,
            format,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glBindImageTexture");
        }
        out
    }
    static glBindImageTexture_p: APcv = ap_None();
    /// Tries to load [`glBindImageTexture`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    pub unsafe fn glBindImageTexture_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glBindImageTexture\0",
            &glBindImageTexture_p,
        )
    }
    /// Checks if the pointer for [`glBindImageTexture`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    pub fn glBindImageTexture_is_loaded() -> bool {
        !glBindImageTexture_p.load(RELAX).is_null()
    }

    /// [glBindProgramPipeline](http://docs.gl/es3/glBindProgramPipeline)(pipeline)
    /// `pipeline` class: program pipeline
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn glBindProgramPipeline(pipeline: GLuint) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!("calling glBindProgramPipeline({:?});", pipeline);
        }
        let out = call_atomic_ptr_1arg("glBindProgramPipeline", &glBindProgramPipeline_p, pipeline);
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glBindProgramPipeline");
        }
        out
    }
    static glBindProgramPipeline_p: APcv = ap_None();
    /// Tries to load [`glBindProgramPipeline`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    pub unsafe fn glBindProgramPipeline_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glBindProgramPipeline\0",
            &glBindProgramPipeline_p,
        )
    }
    /// Checks if the pointer for [`glBindProgramPipeline`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    pub fn glBindProgramPipeline_is_loaded() -> bool {
        !glBindProgramPipeline_p.load(RELAX).is_null()
    }

    /// [glBindProgramPipelineEXT](http://docs.gl/es3/glBindProgramPipelineEXT)(pipeline)
    /// `pipeline` class: program pipeline
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    #[cfg(any(feature = "GL_EXT_separate_shader_objects"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_separate_shader_objects"))))]
    pub unsafe fn glBindProgramPipelineEXT(pipeline: GLuint) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!("calling glBindProgramPipelineEXT({:?});", pipeline);
        }
        let out = call_atomic_ptr_1arg(
            "glBindProgramPipelineEXT",
            &glBindProgramPipelineEXT_p,
            pipeline,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glBindProgramPipelineEXT");
        }
        out
    }
    #[cfg(any(feature = "GL_EXT_separate_shader_objects"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_separate_shader_objects"))))]
    static glBindProgramPipelineEXT_p: APcv = ap_None();
    /// Tries to load [`glBindProgramPipelineEXT`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    #[cfg(any(feature = "GL_EXT_separate_shader_objects"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_separate_shader_objects"))))]
    pub unsafe fn glBindProgramPipelineEXT_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glBindProgramPipelineEXT\0",
            &glBindProgramPipelineEXT_p,
        )
    }
    /// Checks if the pointer for [`glBindProgramPipelineEXT`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    #[cfg(any(feature = "GL_EXT_separate_shader_objects"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_separate_shader_objects"))))]
    pub fn glBindProgramPipelineEXT_is_loaded() -> bool {
        !glBindProgramPipelineEXT_p.load(RELAX).is_null()
    }

    /// [glBindRenderbuffer](http://docs.gl/es3/glBindRenderbuffer)(target, renderbuffer)
    /// `target` group: RenderbufferTarget
    /// `renderbuffer` class: renderbuffer
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn glBindRenderbuffer(target: GLenum, renderbuffer: GLuint) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glBindRenderbuffer({:#X}, {:?});",
                target,
                renderbuffer
            );
        }
        let out = call_atomic_ptr_2arg(
            "glBindRenderbuffer",
            &glBindRenderbuffer_p,
            target,
            renderbuffer,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glBindRenderbuffer");
        }
        out
    }
    static glBindRenderbuffer_p: APcv = ap_None();
    /// Tries to load [`glBindRenderbuffer`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    pub unsafe fn glBindRenderbuffer_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glBindRenderbuffer\0",
            &glBindRenderbuffer_p,
        )
    }
    /// Checks if the pointer for [`glBindRenderbuffer`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    pub fn glBindRenderbuffer_is_loaded() -> bool {
        !glBindRenderbuffer_p.load(RELAX).is_null()
    }

    /// [glBindSampler](http://docs.gl/es3/glBindSampler)(unit, sampler)
    /// `sampler` class: sampler
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn glBindSampler(unit: GLuint, sampler: GLuint) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!("calling glBindSampler({:?}, {:?});", unit, sampler);
        }
        let out = call_atomic_ptr_2arg("glBindSampler", &glBindSampler_p, unit, sampler);
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glBindSampler");
        }
        out
    }
    static glBindSampler_p: APcv = ap_None();
    /// Tries to load [`glBindSampler`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    pub unsafe fn glBindSampler_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(get_proc_address, b"glBindSampler\0", &glBindSampler_p)
    }
    /// Checks if the pointer for [`glBindSampler`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    pub fn glBindSampler_is_loaded() -> bool {
        !glBindSampler_p.load(RELAX).is_null()
    }

    /// [glBindShadingRateImageNV](http://docs.gl/es3/glBindShadingRateImageNV)(texture)
    /// `texture` class: texture
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    #[cfg(any(feature = "GL_NV_shading_rate_image"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_shading_rate_image"))))]
    pub unsafe fn glBindShadingRateImageNV(texture: GLuint) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!("calling glBindShadingRateImageNV({:?});", texture);
        }
        let out = call_atomic_ptr_1arg(
            "glBindShadingRateImageNV",
            &glBindShadingRateImageNV_p,
            texture,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glBindShadingRateImageNV");
        }
        out
    }
    #[cfg(any(feature = "GL_NV_shading_rate_image"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_shading_rate_image"))))]
    static glBindShadingRateImageNV_p: APcv = ap_None();
    /// Tries to load [`glBindShadingRateImageNV`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    #[cfg(any(feature = "GL_NV_shading_rate_image"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_shading_rate_image"))))]
    pub unsafe fn glBindShadingRateImageNV_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glBindShadingRateImageNV\0",
            &glBindShadingRateImageNV_p,
        )
    }
    /// Checks if the pointer for [`glBindShadingRateImageNV`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    #[cfg(any(feature = "GL_NV_shading_rate_image"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_shading_rate_image"))))]
    pub fn glBindShadingRateImageNV_is_loaded() -> bool {
        !glBindShadingRateImageNV_p.load(RELAX).is_null()
    }

    /// [glBindTexture](http://docs.gl/es3/glBindTexture)(target, texture)
    /// `target` group: TextureTarget
    /// `texture` group: Texture
    /// `texture` class: texture
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn glBindTexture(target: GLenum, texture: GLuint) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!("calling glBindTexture({:#X}, {:?});", target, texture);
        }
        let out = call_atomic_ptr_2arg("glBindTexture", &glBindTexture_p, target, texture);
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glBindTexture");
        }
        out
    }
    static glBindTexture_p: APcv = ap_None();
    /// Tries to load [`glBindTexture`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    pub unsafe fn glBindTexture_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(get_proc_address, b"glBindTexture\0", &glBindTexture_p)
    }
    /// Checks if the pointer for [`glBindTexture`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    pub fn glBindTexture_is_loaded() -> bool {
        !glBindTexture_p.load(RELAX).is_null()
    }

    /// [glBindTransformFeedback](http://docs.gl/es3/glBindTransformFeedback)(target, id)
    /// `target` group: BindTransformFeedbackTarget
    /// `id` class: transform feedback
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn glBindTransformFeedback(target: GLenum, id: GLuint) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!("calling glBindTransformFeedback({:#X}, {:?});", target, id);
        }
        let out = call_atomic_ptr_2arg(
            "glBindTransformFeedback",
            &glBindTransformFeedback_p,
            target,
            id,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glBindTransformFeedback");
        }
        out
    }
    static glBindTransformFeedback_p: APcv = ap_None();
    /// Tries to load [`glBindTransformFeedback`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    pub unsafe fn glBindTransformFeedback_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glBindTransformFeedback\0",
            &glBindTransformFeedback_p,
        )
    }
    /// Checks if the pointer for [`glBindTransformFeedback`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    pub fn glBindTransformFeedback_is_loaded() -> bool {
        !glBindTransformFeedback_p.load(RELAX).is_null()
    }

    /// [glBindVertexArray](http://docs.gl/es3/glBindVertexArray)(array)
    /// `array` class: vertex array
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn glBindVertexArray(array: GLuint) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!("calling glBindVertexArray({:?});", array);
        }
        let out = call_atomic_ptr_1arg("glBindVertexArray", &glBindVertexArray_p, array);
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glBindVertexArray");
        }
        out
    }
    static glBindVertexArray_p: APcv = ap_None();
    /// Tries to load [`glBindVertexArray`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    pub unsafe fn glBindVertexArray_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glBindVertexArray\0",
            &glBindVertexArray_p,
        )
    }
    /// Checks if the pointer for [`glBindVertexArray`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    pub fn glBindVertexArray_is_loaded() -> bool {
        !glBindVertexArray_p.load(RELAX).is_null()
    }

    /// [glBindVertexArrayOES](http://docs.gl/es3/glBindVertexArrayOES)(array)
    /// `array` class: vertex array
    /// alias of: [`glBindVertexArray`]
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    #[cfg(any(feature = "GL_OES_vertex_array_object"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_OES_vertex_array_object"))))]
    pub unsafe fn glBindVertexArrayOES(array: GLuint) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!("calling glBindVertexArrayOES({:?});", array);
        }
        let out = call_atomic_ptr_1arg("glBindVertexArrayOES", &glBindVertexArrayOES_p, array);
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glBindVertexArrayOES");
        }
        out
    }
    #[cfg(any(feature = "GL_OES_vertex_array_object"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_OES_vertex_array_object"))))]
    static glBindVertexArrayOES_p: APcv = ap_None();
    /// Tries to load [`glBindVertexArrayOES`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    #[cfg(any(feature = "GL_OES_vertex_array_object"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_OES_vertex_array_object"))))]
    pub unsafe fn glBindVertexArrayOES_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glBindVertexArrayOES\0",
            &glBindVertexArrayOES_p,
        )
    }
    /// Checks if the pointer for [`glBindVertexArrayOES`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    #[cfg(any(feature = "GL_OES_vertex_array_object"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_OES_vertex_array_object"))))]
    pub fn glBindVertexArrayOES_is_loaded() -> bool {
        !glBindVertexArrayOES_p.load(RELAX).is_null()
    }

    /// [glBindVertexBuffer](http://docs.gl/es3/glBindVertexBuffer)(bindingindex, buffer, offset, stride)
    /// `buffer` class: buffer
    /// `offset` group: BufferOffset
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn glBindVertexBuffer(
        bindingindex: GLuint,
        buffer: GLuint,
        offset: GLintptr,
        stride: GLsizei,
    ) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glBindVertexBuffer({:?}, {:?}, {:?}, {:?});",
                bindingindex,
                buffer,
                offset,
                stride
            );
        }
        let out = call_atomic_ptr_4arg(
            "glBindVertexBuffer",
            &glBindVertexBuffer_p,
            bindingindex,
            buffer,
            offset,
            stride,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glBindVertexBuffer");
        }
        out
    }
    static glBindVertexBuffer_p: APcv = ap_None();
    /// Tries to load [`glBindVertexBuffer`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    pub unsafe fn glBindVertexBuffer_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glBindVertexBuffer\0",
            &glBindVertexBuffer_p,
        )
    }
    /// Checks if the pointer for [`glBindVertexBuffer`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    pub fn glBindVertexBuffer_is_loaded() -> bool {
        !glBindVertexBuffer_p.load(RELAX).is_null()
    }

    /// [glBlendBarrier](http://docs.gl/es3/glBlendBarrier)()
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn glBlendBarrier() {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!("calling glBlendBarrier();",);
        }
        let out = call_atomic_ptr_0arg("glBlendBarrier", &glBlendBarrier_p);
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glBlendBarrier");
        }
        out
    }
    static glBlendBarrier_p: APcv = ap_None();
    /// Tries to load [`glBlendBarrier`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    pub unsafe fn glBlendBarrier_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(get_proc_address, b"glBlendBarrier\0", &glBlendBarrier_p)
    }
    /// Checks if the pointer for [`glBlendBarrier`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    pub fn glBlendBarrier_is_loaded() -> bool {
        !glBlendBarrier_p.load(RELAX).is_null()
    }

    /// [glBlendBarrierKHR](http://docs.gl/es3/glBlendBarrierKHR)()
    /// alias of: [`glBlendBarrier`]
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    #[cfg(any(feature = "GL_KHR_blend_equation_advanced"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_KHR_blend_equation_advanced"))))]
    pub unsafe fn glBlendBarrierKHR() {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!("calling glBlendBarrierKHR();",);
        }
        let out = call_atomic_ptr_0arg("glBlendBarrierKHR", &glBlendBarrierKHR_p);
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glBlendBarrierKHR");
        }
        out
    }
    #[cfg(any(feature = "GL_KHR_blend_equation_advanced"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_KHR_blend_equation_advanced"))))]
    static glBlendBarrierKHR_p: APcv = ap_None();
    /// Tries to load [`glBlendBarrierKHR`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    #[cfg(any(feature = "GL_KHR_blend_equation_advanced"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_KHR_blend_equation_advanced"))))]
    pub unsafe fn glBlendBarrierKHR_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glBlendBarrierKHR\0",
            &glBlendBarrierKHR_p,
        )
    }
    /// Checks if the pointer for [`glBlendBarrierKHR`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    #[cfg(any(feature = "GL_KHR_blend_equation_advanced"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_KHR_blend_equation_advanced"))))]
    pub fn glBlendBarrierKHR_is_loaded() -> bool {
        !glBlendBarrierKHR_p.load(RELAX).is_null()
    }

    /// [glBlendBarrierNV](http://docs.gl/es3/glBlendBarrierNV)()
    /// alias of: [`glBlendBarrier`]
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    #[cfg(any(feature = "GL_NV_blend_equation_advanced"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_blend_equation_advanced"))))]
    pub unsafe fn glBlendBarrierNV() {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!("calling glBlendBarrierNV();",);
        }
        let out = call_atomic_ptr_0arg("glBlendBarrierNV", &glBlendBarrierNV_p);
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glBlendBarrierNV");
        }
        out
    }
    #[cfg(any(feature = "GL_NV_blend_equation_advanced"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_blend_equation_advanced"))))]
    static glBlendBarrierNV_p: APcv = ap_None();
    /// Tries to load [`glBlendBarrierNV`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    #[cfg(any(feature = "GL_NV_blend_equation_advanced"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_blend_equation_advanced"))))]
    pub unsafe fn glBlendBarrierNV_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(get_proc_address, b"glBlendBarrierNV\0", &glBlendBarrierNV_p)
    }
    /// Checks if the pointer for [`glBlendBarrierNV`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    #[cfg(any(feature = "GL_NV_blend_equation_advanced"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_blend_equation_advanced"))))]
    pub fn glBlendBarrierNV_is_loaded() -> bool {
        !glBlendBarrierNV_p.load(RELAX).is_null()
    }

    /// [glBlendColor](http://docs.gl/es3/glBlendColor)(red, green, blue, alpha)
    /// `red` group: ColorF
    /// `green` group: ColorF
    /// `blue` group: ColorF
    /// `alpha` group: ColorF
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn glBlendColor(red: GLfloat, green: GLfloat, blue: GLfloat, alpha: GLfloat) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glBlendColor({:?}, {:?}, {:?}, {:?});",
                red,
                green,
                blue,
                alpha
            );
        }
        let out = call_atomic_ptr_4arg("glBlendColor", &glBlendColor_p, red, green, blue, alpha);
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glBlendColor");
        }
        out
    }
    static glBlendColor_p: APcv = ap_None();
    /// Tries to load [`glBlendColor`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    pub unsafe fn glBlendColor_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(get_proc_address, b"glBlendColor\0", &glBlendColor_p)
    }
    /// Checks if the pointer for [`glBlendColor`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    pub fn glBlendColor_is_loaded() -> bool {
        !glBlendColor_p.load(RELAX).is_null()
    }

    /// [glBlendEquation](http://docs.gl/es3/glBlendEquation)(mode)
    /// `mode` group: BlendEquationModeEXT
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn glBlendEquation(mode: GLenum) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!("calling glBlendEquation({:#X});", mode);
        }
        let out = call_atomic_ptr_1arg("glBlendEquation", &glBlendEquation_p, mode);
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glBlendEquation");
        }
        out
    }
    static glBlendEquation_p: APcv = ap_None();
    /// Tries to load [`glBlendEquation`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    pub unsafe fn glBlendEquation_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(get_proc_address, b"glBlendEquation\0", &glBlendEquation_p)
    }
    /// Checks if the pointer for [`glBlendEquation`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    pub fn glBlendEquation_is_loaded() -> bool {
        !glBlendEquation_p.load(RELAX).is_null()
    }

    /// [glBlendEquationSeparate](http://docs.gl/es3/glBlendEquationSeparate)(modeRGB, modeAlpha)
    /// `modeRGB` group: BlendEquationModeEXT
    /// `modeAlpha` group: BlendEquationModeEXT
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn glBlendEquationSeparate(modeRGB: GLenum, modeAlpha: GLenum) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glBlendEquationSeparate({:#X}, {:#X});",
                modeRGB,
                modeAlpha
            );
        }
        let out = call_atomic_ptr_2arg(
            "glBlendEquationSeparate",
            &glBlendEquationSeparate_p,
            modeRGB,
            modeAlpha,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glBlendEquationSeparate");
        }
        out
    }
    static glBlendEquationSeparate_p: APcv = ap_None();
    /// Tries to load [`glBlendEquationSeparate`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    pub unsafe fn glBlendEquationSeparate_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glBlendEquationSeparate\0",
            &glBlendEquationSeparate_p,
        )
    }
    /// Checks if the pointer for [`glBlendEquationSeparate`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    pub fn glBlendEquationSeparate_is_loaded() -> bool {
        !glBlendEquationSeparate_p.load(RELAX).is_null()
    }

    /// [glBlendEquationSeparatei](http://docs.gl/es3/glBlendEquationSeparate)(buf, modeRGB, modeAlpha)
    /// `modeRGB` group: BlendEquationModeEXT
    /// `modeAlpha` group: BlendEquationModeEXT
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn glBlendEquationSeparatei(buf: GLuint, modeRGB: GLenum, modeAlpha: GLenum) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glBlendEquationSeparatei({:?}, {:#X}, {:#X});",
                buf,
                modeRGB,
                modeAlpha
            );
        }
        let out = call_atomic_ptr_3arg(
            "glBlendEquationSeparatei",
            &glBlendEquationSeparatei_p,
            buf,
            modeRGB,
            modeAlpha,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glBlendEquationSeparatei");
        }
        out
    }
    static glBlendEquationSeparatei_p: APcv = ap_None();
    /// Tries to load [`glBlendEquationSeparatei`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    pub unsafe fn glBlendEquationSeparatei_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glBlendEquationSeparatei\0",
            &glBlendEquationSeparatei_p,
        )
    }
    /// Checks if the pointer for [`glBlendEquationSeparatei`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    pub fn glBlendEquationSeparatei_is_loaded() -> bool {
        !glBlendEquationSeparatei_p.load(RELAX).is_null()
    }

    /// [glBlendEquationSeparateiEXT](http://docs.gl/es3/glBlendEquationSeparateiEXT)(buf, modeRGB, modeAlpha)
    /// `modeRGB` group: BlendEquationModeEXT
    /// `modeAlpha` group: BlendEquationModeEXT
    /// alias of: [`glBlendEquationSeparatei`]
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    #[cfg(any(feature = "GL_EXT_draw_buffers_indexed"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_draw_buffers_indexed"))))]
    pub unsafe fn glBlendEquationSeparateiEXT(buf: GLuint, modeRGB: GLenum, modeAlpha: GLenum) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glBlendEquationSeparateiEXT({:?}, {:#X}, {:#X});",
                buf,
                modeRGB,
                modeAlpha
            );
        }
        let out = call_atomic_ptr_3arg(
            "glBlendEquationSeparateiEXT",
            &glBlendEquationSeparateiEXT_p,
            buf,
            modeRGB,
            modeAlpha,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glBlendEquationSeparateiEXT");
        }
        out
    }
    #[cfg(any(feature = "GL_EXT_draw_buffers_indexed"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_draw_buffers_indexed"))))]
    static glBlendEquationSeparateiEXT_p: APcv = ap_None();
    /// Tries to load [`glBlendEquationSeparateiEXT`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    #[cfg(any(feature = "GL_EXT_draw_buffers_indexed"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_draw_buffers_indexed"))))]
    pub unsafe fn glBlendEquationSeparateiEXT_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glBlendEquationSeparateiEXT\0",
            &glBlendEquationSeparateiEXT_p,
        )
    }
    /// Checks if the pointer for [`glBlendEquationSeparateiEXT`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    #[cfg(any(feature = "GL_EXT_draw_buffers_indexed"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_draw_buffers_indexed"))))]
    pub fn glBlendEquationSeparateiEXT_is_loaded() -> bool {
        !glBlendEquationSeparateiEXT_p.load(RELAX).is_null()
    }

    /// [glBlendEquationSeparateiOES](http://docs.gl/es3/glBlendEquationSeparateiOES)(buf, modeRGB, modeAlpha)
    /// `modeRGB` group: BlendEquationModeEXT
    /// `modeAlpha` group: BlendEquationModeEXT
    /// alias of: [`glBlendEquationSeparatei`]
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    #[cfg(any(feature = "GL_OES_draw_buffers_indexed"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_OES_draw_buffers_indexed"))))]
    pub unsafe fn glBlendEquationSeparateiOES(buf: GLuint, modeRGB: GLenum, modeAlpha: GLenum) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glBlendEquationSeparateiOES({:?}, {:#X}, {:#X});",
                buf,
                modeRGB,
                modeAlpha
            );
        }
        let out = call_atomic_ptr_3arg(
            "glBlendEquationSeparateiOES",
            &glBlendEquationSeparateiOES_p,
            buf,
            modeRGB,
            modeAlpha,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glBlendEquationSeparateiOES");
        }
        out
    }
    #[cfg(any(feature = "GL_OES_draw_buffers_indexed"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_OES_draw_buffers_indexed"))))]
    static glBlendEquationSeparateiOES_p: APcv = ap_None();
    /// Tries to load [`glBlendEquationSeparateiOES`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    #[cfg(any(feature = "GL_OES_draw_buffers_indexed"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_OES_draw_buffers_indexed"))))]
    pub unsafe fn glBlendEquationSeparateiOES_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glBlendEquationSeparateiOES\0",
            &glBlendEquationSeparateiOES_p,
        )
    }
    /// Checks if the pointer for [`glBlendEquationSeparateiOES`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    #[cfg(any(feature = "GL_OES_draw_buffers_indexed"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_OES_draw_buffers_indexed"))))]
    pub fn glBlendEquationSeparateiOES_is_loaded() -> bool {
        !glBlendEquationSeparateiOES_p.load(RELAX).is_null()
    }

    /// [glBlendEquationi](http://docs.gl/es3/glBlendEquation)(buf, mode)
    /// `mode` group: BlendEquationModeEXT
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn glBlendEquationi(buf: GLuint, mode: GLenum) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!("calling glBlendEquationi({:?}, {:#X});", buf, mode);
        }
        let out = call_atomic_ptr_2arg("glBlendEquationi", &glBlendEquationi_p, buf, mode);
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glBlendEquationi");
        }
        out
    }
    static glBlendEquationi_p: APcv = ap_None();
    /// Tries to load [`glBlendEquationi`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    pub unsafe fn glBlendEquationi_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(get_proc_address, b"glBlendEquationi\0", &glBlendEquationi_p)
    }
    /// Checks if the pointer for [`glBlendEquationi`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    pub fn glBlendEquationi_is_loaded() -> bool {
        !glBlendEquationi_p.load(RELAX).is_null()
    }

    /// [glBlendEquationiEXT](http://docs.gl/es3/glBlendEquationiEXT)(buf, mode)
    /// `mode` group: BlendEquationModeEXT
    /// alias of: [`glBlendEquationi`]
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    #[cfg(any(feature = "GL_EXT_draw_buffers_indexed"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_draw_buffers_indexed"))))]
    pub unsafe fn glBlendEquationiEXT(buf: GLuint, mode: GLenum) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!("calling glBlendEquationiEXT({:?}, {:#X});", buf, mode);
        }
        let out = call_atomic_ptr_2arg("glBlendEquationiEXT", &glBlendEquationiEXT_p, buf, mode);
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glBlendEquationiEXT");
        }
        out
    }
    #[cfg(any(feature = "GL_EXT_draw_buffers_indexed"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_draw_buffers_indexed"))))]
    static glBlendEquationiEXT_p: APcv = ap_None();
    /// Tries to load [`glBlendEquationiEXT`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    #[cfg(any(feature = "GL_EXT_draw_buffers_indexed"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_draw_buffers_indexed"))))]
    pub unsafe fn glBlendEquationiEXT_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glBlendEquationiEXT\0",
            &glBlendEquationiEXT_p,
        )
    }
    /// Checks if the pointer for [`glBlendEquationiEXT`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    #[cfg(any(feature = "GL_EXT_draw_buffers_indexed"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_draw_buffers_indexed"))))]
    pub fn glBlendEquationiEXT_is_loaded() -> bool {
        !glBlendEquationiEXT_p.load(RELAX).is_null()
    }

    /// [glBlendEquationiOES](http://docs.gl/es3/glBlendEquationiOES)(buf, mode)
    /// `mode` group: BlendEquationModeEXT
    /// alias of: [`glBlendEquationi`]
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    #[cfg(any(feature = "GL_OES_draw_buffers_indexed"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_OES_draw_buffers_indexed"))))]
    pub unsafe fn glBlendEquationiOES(buf: GLuint, mode: GLenum) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!("calling glBlendEquationiOES({:?}, {:#X});", buf, mode);
        }
        let out = call_atomic_ptr_2arg("glBlendEquationiOES", &glBlendEquationiOES_p, buf, mode);
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glBlendEquationiOES");
        }
        out
    }
    #[cfg(any(feature = "GL_OES_draw_buffers_indexed"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_OES_draw_buffers_indexed"))))]
    static glBlendEquationiOES_p: APcv = ap_None();
    /// Tries to load [`glBlendEquationiOES`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    #[cfg(any(feature = "GL_OES_draw_buffers_indexed"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_OES_draw_buffers_indexed"))))]
    pub unsafe fn glBlendEquationiOES_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glBlendEquationiOES\0",
            &glBlendEquationiOES_p,
        )
    }
    /// Checks if the pointer for [`glBlendEquationiOES`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    #[cfg(any(feature = "GL_OES_draw_buffers_indexed"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_OES_draw_buffers_indexed"))))]
    pub fn glBlendEquationiOES_is_loaded() -> bool {
        !glBlendEquationiOES_p.load(RELAX).is_null()
    }

    /// [glBlendFunc](http://docs.gl/es3/glBlendFunc)(sfactor, dfactor)
    /// `sfactor` group: BlendingFactor
    /// `dfactor` group: BlendingFactor
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn glBlendFunc(sfactor: GLenum, dfactor: GLenum) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!("calling glBlendFunc({:#X}, {:#X});", sfactor, dfactor);
        }
        let out = call_atomic_ptr_2arg("glBlendFunc", &glBlendFunc_p, sfactor, dfactor);
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glBlendFunc");
        }
        out
    }
    static glBlendFunc_p: APcv = ap_None();
    /// Tries to load [`glBlendFunc`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    pub unsafe fn glBlendFunc_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(get_proc_address, b"glBlendFunc\0", &glBlendFunc_p)
    }
    /// Checks if the pointer for [`glBlendFunc`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    pub fn glBlendFunc_is_loaded() -> bool {
        !glBlendFunc_p.load(RELAX).is_null()
    }

    /// [glBlendFuncSeparate](http://docs.gl/es3/glBlendFuncSeparate)(sfactorRGB, dfactorRGB, sfactorAlpha, dfactorAlpha)
    /// `sfactorRGB` group: BlendingFactor
    /// `dfactorRGB` group: BlendingFactor
    /// `sfactorAlpha` group: BlendingFactor
    /// `dfactorAlpha` group: BlendingFactor
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn glBlendFuncSeparate(
        sfactorRGB: GLenum,
        dfactorRGB: GLenum,
        sfactorAlpha: GLenum,
        dfactorAlpha: GLenum,
    ) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glBlendFuncSeparate({:#X}, {:#X}, {:#X}, {:#X});",
                sfactorRGB,
                dfactorRGB,
                sfactorAlpha,
                dfactorAlpha
            );
        }
        let out = call_atomic_ptr_4arg(
            "glBlendFuncSeparate",
            &glBlendFuncSeparate_p,
            sfactorRGB,
            dfactorRGB,
            sfactorAlpha,
            dfactorAlpha,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glBlendFuncSeparate");
        }
        out
    }
    static glBlendFuncSeparate_p: APcv = ap_None();
    /// Tries to load [`glBlendFuncSeparate`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    pub unsafe fn glBlendFuncSeparate_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glBlendFuncSeparate\0",
            &glBlendFuncSeparate_p,
        )
    }
    /// Checks if the pointer for [`glBlendFuncSeparate`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    pub fn glBlendFuncSeparate_is_loaded() -> bool {
        !glBlendFuncSeparate_p.load(RELAX).is_null()
    }

    /// [glBlendFuncSeparatei](http://docs.gl/es3/glBlendFuncSeparate)(buf, srcRGB, dstRGB, srcAlpha, dstAlpha)
    /// `srcRGB` group: BlendingFactor
    /// `dstRGB` group: BlendingFactor
    /// `srcAlpha` group: BlendingFactor
    /// `dstAlpha` group: BlendingFactor
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn glBlendFuncSeparatei(
        buf: GLuint,
        srcRGB: GLenum,
        dstRGB: GLenum,
        srcAlpha: GLenum,
        dstAlpha: GLenum,
    ) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glBlendFuncSeparatei({:?}, {:#X}, {:#X}, {:#X}, {:#X});",
                buf,
                srcRGB,
                dstRGB,
                srcAlpha,
                dstAlpha
            );
        }
        let out = call_atomic_ptr_5arg(
            "glBlendFuncSeparatei",
            &glBlendFuncSeparatei_p,
            buf,
            srcRGB,
            dstRGB,
            srcAlpha,
            dstAlpha,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glBlendFuncSeparatei");
        }
        out
    }
    static glBlendFuncSeparatei_p: APcv = ap_None();
    /// Tries to load [`glBlendFuncSeparatei`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    pub unsafe fn glBlendFuncSeparatei_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glBlendFuncSeparatei\0",
            &glBlendFuncSeparatei_p,
        )
    }
    /// Checks if the pointer for [`glBlendFuncSeparatei`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    pub fn glBlendFuncSeparatei_is_loaded() -> bool {
        !glBlendFuncSeparatei_p.load(RELAX).is_null()
    }

    /// [glBlendFuncSeparateiEXT](http://docs.gl/es3/glBlendFuncSeparateiEXT)(buf, srcRGB, dstRGB, srcAlpha, dstAlpha)
    /// `srcRGB` group: BlendingFactor
    /// `dstRGB` group: BlendingFactor
    /// `srcAlpha` group: BlendingFactor
    /// `dstAlpha` group: BlendingFactor
    /// alias of: [`glBlendFuncSeparatei`]
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    #[cfg(any(feature = "GL_EXT_draw_buffers_indexed"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_draw_buffers_indexed"))))]
    pub unsafe fn glBlendFuncSeparateiEXT(
        buf: GLuint,
        srcRGB: GLenum,
        dstRGB: GLenum,
        srcAlpha: GLenum,
        dstAlpha: GLenum,
    ) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glBlendFuncSeparateiEXT({:?}, {:#X}, {:#X}, {:#X}, {:#X});",
                buf,
                srcRGB,
                dstRGB,
                srcAlpha,
                dstAlpha
            );
        }
        let out = call_atomic_ptr_5arg(
            "glBlendFuncSeparateiEXT",
            &glBlendFuncSeparateiEXT_p,
            buf,
            srcRGB,
            dstRGB,
            srcAlpha,
            dstAlpha,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glBlendFuncSeparateiEXT");
        }
        out
    }
    #[cfg(any(feature = "GL_EXT_draw_buffers_indexed"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_draw_buffers_indexed"))))]
    static glBlendFuncSeparateiEXT_p: APcv = ap_None();
    /// Tries to load [`glBlendFuncSeparateiEXT`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    #[cfg(any(feature = "GL_EXT_draw_buffers_indexed"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_draw_buffers_indexed"))))]
    pub unsafe fn glBlendFuncSeparateiEXT_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glBlendFuncSeparateiEXT\0",
            &glBlendFuncSeparateiEXT_p,
        )
    }
    /// Checks if the pointer for [`glBlendFuncSeparateiEXT`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    #[cfg(any(feature = "GL_EXT_draw_buffers_indexed"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_draw_buffers_indexed"))))]
    pub fn glBlendFuncSeparateiEXT_is_loaded() -> bool {
        !glBlendFuncSeparateiEXT_p.load(RELAX).is_null()
    }

    /// [glBlendFuncSeparateiOES](http://docs.gl/es3/glBlendFuncSeparateiOES)(buf, srcRGB, dstRGB, srcAlpha, dstAlpha)
    /// `srcRGB` group: BlendingFactor
    /// `dstRGB` group: BlendingFactor
    /// `srcAlpha` group: BlendingFactor
    /// `dstAlpha` group: BlendingFactor
    /// alias of: [`glBlendFuncSeparatei`]
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    #[cfg(any(feature = "GL_OES_draw_buffers_indexed"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_OES_draw_buffers_indexed"))))]
    pub unsafe fn glBlendFuncSeparateiOES(
        buf: GLuint,
        srcRGB: GLenum,
        dstRGB: GLenum,
        srcAlpha: GLenum,
        dstAlpha: GLenum,
    ) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glBlendFuncSeparateiOES({:?}, {:#X}, {:#X}, {:#X}, {:#X});",
                buf,
                srcRGB,
                dstRGB,
                srcAlpha,
                dstAlpha
            );
        }
        let out = call_atomic_ptr_5arg(
            "glBlendFuncSeparateiOES",
            &glBlendFuncSeparateiOES_p,
            buf,
            srcRGB,
            dstRGB,
            srcAlpha,
            dstAlpha,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glBlendFuncSeparateiOES");
        }
        out
    }
    #[cfg(any(feature = "GL_OES_draw_buffers_indexed"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_OES_draw_buffers_indexed"))))]
    static glBlendFuncSeparateiOES_p: APcv = ap_None();
    /// Tries to load [`glBlendFuncSeparateiOES`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    #[cfg(any(feature = "GL_OES_draw_buffers_indexed"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_OES_draw_buffers_indexed"))))]
    pub unsafe fn glBlendFuncSeparateiOES_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glBlendFuncSeparateiOES\0",
            &glBlendFuncSeparateiOES_p,
        )
    }
    /// Checks if the pointer for [`glBlendFuncSeparateiOES`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    #[cfg(any(feature = "GL_OES_draw_buffers_indexed"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_OES_draw_buffers_indexed"))))]
    pub fn glBlendFuncSeparateiOES_is_loaded() -> bool {
        !glBlendFuncSeparateiOES_p.load(RELAX).is_null()
    }

    /// [glBlendFunci](http://docs.gl/es3/glBlendFunc)(buf, src, dst)
    /// `src` group: BlendingFactor
    /// `dst` group: BlendingFactor
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn glBlendFunci(buf: GLuint, src: GLenum, dst: GLenum) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!("calling glBlendFunci({:?}, {:#X}, {:#X});", buf, src, dst);
        }
        let out = call_atomic_ptr_3arg("glBlendFunci", &glBlendFunci_p, buf, src, dst);
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glBlendFunci");
        }
        out
    }
    static glBlendFunci_p: APcv = ap_None();
    /// Tries to load [`glBlendFunci`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    pub unsafe fn glBlendFunci_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(get_proc_address, b"glBlendFunci\0", &glBlendFunci_p)
    }
    /// Checks if the pointer for [`glBlendFunci`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    pub fn glBlendFunci_is_loaded() -> bool {
        !glBlendFunci_p.load(RELAX).is_null()
    }

    /// [glBlendFunciEXT](http://docs.gl/es3/glBlendFunciEXT)(buf, src, dst)
    /// `src` group: BlendingFactor
    /// `dst` group: BlendingFactor
    /// alias of: [`glBlendFunci`]
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    #[cfg(any(feature = "GL_EXT_draw_buffers_indexed"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_draw_buffers_indexed"))))]
    pub unsafe fn glBlendFunciEXT(buf: GLuint, src: GLenum, dst: GLenum) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glBlendFunciEXT({:?}, {:#X}, {:#X});",
                buf,
                src,
                dst
            );
        }
        let out = call_atomic_ptr_3arg("glBlendFunciEXT", &glBlendFunciEXT_p, buf, src, dst);
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glBlendFunciEXT");
        }
        out
    }
    #[cfg(any(feature = "GL_EXT_draw_buffers_indexed"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_draw_buffers_indexed"))))]
    static glBlendFunciEXT_p: APcv = ap_None();
    /// Tries to load [`glBlendFunciEXT`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    #[cfg(any(feature = "GL_EXT_draw_buffers_indexed"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_draw_buffers_indexed"))))]
    pub unsafe fn glBlendFunciEXT_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(get_proc_address, b"glBlendFunciEXT\0", &glBlendFunciEXT_p)
    }
    /// Checks if the pointer for [`glBlendFunciEXT`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    #[cfg(any(feature = "GL_EXT_draw_buffers_indexed"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_draw_buffers_indexed"))))]
    pub fn glBlendFunciEXT_is_loaded() -> bool {
        !glBlendFunciEXT_p.load(RELAX).is_null()
    }

    /// [glBlendFunciOES](http://docs.gl/es3/glBlendFunciOES)(buf, src, dst)
    /// `src` group: BlendingFactor
    /// `dst` group: BlendingFactor
    /// alias of: [`glBlendFunci`]
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    #[cfg(any(feature = "GL_OES_draw_buffers_indexed"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_OES_draw_buffers_indexed"))))]
    pub unsafe fn glBlendFunciOES(buf: GLuint, src: GLenum, dst: GLenum) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glBlendFunciOES({:?}, {:#X}, {:#X});",
                buf,
                src,
                dst
            );
        }
        let out = call_atomic_ptr_3arg("glBlendFunciOES", &glBlendFunciOES_p, buf, src, dst);
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glBlendFunciOES");
        }
        out
    }
    #[cfg(any(feature = "GL_OES_draw_buffers_indexed"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_OES_draw_buffers_indexed"))))]
    static glBlendFunciOES_p: APcv = ap_None();
    /// Tries to load [`glBlendFunciOES`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    #[cfg(any(feature = "GL_OES_draw_buffers_indexed"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_OES_draw_buffers_indexed"))))]
    pub unsafe fn glBlendFunciOES_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(get_proc_address, b"glBlendFunciOES\0", &glBlendFunciOES_p)
    }
    /// Checks if the pointer for [`glBlendFunciOES`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    #[cfg(any(feature = "GL_OES_draw_buffers_indexed"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_OES_draw_buffers_indexed"))))]
    pub fn glBlendFunciOES_is_loaded() -> bool {
        !glBlendFunciOES_p.load(RELAX).is_null()
    }

    /// [glBlendParameteriNV](http://docs.gl/es3/glBlendParameteriNV)(pname, value)
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    #[cfg(any(feature = "GL_NV_blend_equation_advanced"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_blend_equation_advanced"))))]
    pub unsafe fn glBlendParameteriNV(pname: GLenum, value: GLint) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!("calling glBlendParameteriNV({:#X}, {:?});", pname, value);
        }
        let out = call_atomic_ptr_2arg("glBlendParameteriNV", &glBlendParameteriNV_p, pname, value);
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glBlendParameteriNV");
        }
        out
    }
    #[cfg(any(feature = "GL_NV_blend_equation_advanced"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_blend_equation_advanced"))))]
    static glBlendParameteriNV_p: APcv = ap_None();
    /// Tries to load [`glBlendParameteriNV`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    #[cfg(any(feature = "GL_NV_blend_equation_advanced"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_blend_equation_advanced"))))]
    pub unsafe fn glBlendParameteriNV_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glBlendParameteriNV\0",
            &glBlendParameteriNV_p,
        )
    }
    /// Checks if the pointer for [`glBlendParameteriNV`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    #[cfg(any(feature = "GL_NV_blend_equation_advanced"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_blend_equation_advanced"))))]
    pub fn glBlendParameteriNV_is_loaded() -> bool {
        !glBlendParameteriNV_p.load(RELAX).is_null()
    }

    /// [glBlitFramebuffer](http://docs.gl/es3/glBlitFramebuffer)(srcX0, srcY0, srcX1, srcY1, dstX0, dstY0, dstX1, dstY1, mask, filter)
    /// `mask` group: ClearBufferMask
    /// `filter` group: BlitFramebufferFilter
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn glBlitFramebuffer(
        srcX0: GLint,
        srcY0: GLint,
        srcX1: GLint,
        srcY1: GLint,
        dstX0: GLint,
        dstY0: GLint,
        dstX1: GLint,
        dstY1: GLint,
        mask: GLbitfield,
        filter: GLenum,
    ) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glBlitFramebuffer({:?}, {:?}, {:?}, {:?}, {:?}, {:?}, {:?}, {:?}, {:?}, {:#X});",
                srcX0,
                srcY0,
                srcX1,
                srcY1,
                dstX0,
                dstY0,
                dstX1,
                dstY1,
                mask,
                filter
            );
        }
        let out = call_atomic_ptr_10arg(
            "glBlitFramebuffer",
            &glBlitFramebuffer_p,
            srcX0,
            srcY0,
            srcX1,
            srcY1,
            dstX0,
            dstY0,
            dstX1,
            dstY1,
            mask,
            filter,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glBlitFramebuffer");
        }
        out
    }
    static glBlitFramebuffer_p: APcv = ap_None();
    /// Tries to load [`glBlitFramebuffer`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    pub unsafe fn glBlitFramebuffer_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glBlitFramebuffer\0",
            &glBlitFramebuffer_p,
        )
    }
    /// Checks if the pointer for [`glBlitFramebuffer`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    pub fn glBlitFramebuffer_is_loaded() -> bool {
        !glBlitFramebuffer_p.load(RELAX).is_null()
    }

    /// [glBlitFramebufferANGLE](http://docs.gl/es3/glBlitFramebufferANGLE)(srcX0, srcY0, srcX1, srcY1, dstX0, dstY0, dstX1, dstY1, mask, filter)
    /// `mask` group: ClearBufferMask
    /// `filter` group: BlitFramebufferFilter
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    #[cfg(any(feature = "GL_ANGLE_framebuffer_blit"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_ANGLE_framebuffer_blit"))))]
    pub unsafe fn glBlitFramebufferANGLE(
        srcX0: GLint,
        srcY0: GLint,
        srcX1: GLint,
        srcY1: GLint,
        dstX0: GLint,
        dstY0: GLint,
        dstX1: GLint,
        dstY1: GLint,
        mask: GLbitfield,
        filter: GLenum,
    ) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glBlitFramebufferANGLE({:?}, {:?}, {:?}, {:?}, {:?}, {:?}, {:?}, {:?}, {:?}, {:#X});",
                srcX0,
                srcY0,
                srcX1,
                srcY1,
                dstX0,
                dstY0,
                dstX1,
                dstY1,
                mask,
                filter
            );
        }
        let out = call_atomic_ptr_10arg(
            "glBlitFramebufferANGLE",
            &glBlitFramebufferANGLE_p,
            srcX0,
            srcY0,
            srcX1,
            srcY1,
            dstX0,
            dstY0,
            dstX1,
            dstY1,
            mask,
            filter,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glBlitFramebufferANGLE");
        }
        out
    }
    #[cfg(any(feature = "GL_ANGLE_framebuffer_blit"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_ANGLE_framebuffer_blit"))))]
    static glBlitFramebufferANGLE_p: APcv = ap_None();
    /// Tries to load [`glBlitFramebufferANGLE`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    #[cfg(any(feature = "GL_ANGLE_framebuffer_blit"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_ANGLE_framebuffer_blit"))))]
    pub unsafe fn glBlitFramebufferANGLE_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glBlitFramebufferANGLE\0",
            &glBlitFramebufferANGLE_p,
        )
    }
    /// Checks if the pointer for [`glBlitFramebufferANGLE`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    #[cfg(any(feature = "GL_ANGLE_framebuffer_blit"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_ANGLE_framebuffer_blit"))))]
    pub fn glBlitFramebufferANGLE_is_loaded() -> bool {
        !glBlitFramebufferANGLE_p.load(RELAX).is_null()
    }

    /// [glBlitFramebufferNV](http://docs.gl/es3/glBlitFramebufferNV)(srcX0, srcY0, srcX1, srcY1, dstX0, dstY0, dstX1, dstY1, mask, filter)
    /// `mask` group: ClearBufferMask
    /// `filter` group: BlitFramebufferFilter
    /// alias of: [`glBlitFramebuffer`]
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    #[cfg(any(feature = "GL_NV_framebuffer_blit"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_framebuffer_blit"))))]
    pub unsafe fn glBlitFramebufferNV(
        srcX0: GLint,
        srcY0: GLint,
        srcX1: GLint,
        srcY1: GLint,
        dstX0: GLint,
        dstY0: GLint,
        dstX1: GLint,
        dstY1: GLint,
        mask: GLbitfield,
        filter: GLenum,
    ) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glBlitFramebufferNV({:?}, {:?}, {:?}, {:?}, {:?}, {:?}, {:?}, {:?}, {:?}, {:#X});",
                srcX0,
                srcY0,
                srcX1,
                srcY1,
                dstX0,
                dstY0,
                dstX1,
                dstY1,
                mask,
                filter
            );
        }
        let out = call_atomic_ptr_10arg(
            "glBlitFramebufferNV",
            &glBlitFramebufferNV_p,
            srcX0,
            srcY0,
            srcX1,
            srcY1,
            dstX0,
            dstY0,
            dstX1,
            dstY1,
            mask,
            filter,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glBlitFramebufferNV");
        }
        out
    }
    #[cfg(any(feature = "GL_NV_framebuffer_blit"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_framebuffer_blit"))))]
    static glBlitFramebufferNV_p: APcv = ap_None();
    /// Tries to load [`glBlitFramebufferNV`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    #[cfg(any(feature = "GL_NV_framebuffer_blit"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_framebuffer_blit"))))]
    pub unsafe fn glBlitFramebufferNV_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glBlitFramebufferNV\0",
            &glBlitFramebufferNV_p,
        )
    }
    /// Checks if the pointer for [`glBlitFramebufferNV`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    #[cfg(any(feature = "GL_NV_framebuffer_blit"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_framebuffer_blit"))))]
    pub fn glBlitFramebufferNV_is_loaded() -> bool {
        !glBlitFramebufferNV_p.load(RELAX).is_null()
    }

    /// [glBufferAttachMemoryNV](http://docs.gl/es3/glBufferAttachMemoryNV)(target, memory, offset)
    /// `target` group: BufferTargetARB
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    #[cfg(any(feature = "GL_NV_memory_attachment"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_memory_attachment"))))]
    pub unsafe fn glBufferAttachMemoryNV(target: GLenum, memory: GLuint, offset: GLuint64) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glBufferAttachMemoryNV({:#X}, {:?}, {:?});",
                target,
                memory,
                offset
            );
        }
        let out = call_atomic_ptr_3arg(
            "glBufferAttachMemoryNV",
            &glBufferAttachMemoryNV_p,
            target,
            memory,
            offset,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glBufferAttachMemoryNV");
        }
        out
    }
    #[cfg(any(feature = "GL_NV_memory_attachment"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_memory_attachment"))))]
    static glBufferAttachMemoryNV_p: APcv = ap_None();
    /// Tries to load [`glBufferAttachMemoryNV`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    #[cfg(any(feature = "GL_NV_memory_attachment"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_memory_attachment"))))]
    pub unsafe fn glBufferAttachMemoryNV_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glBufferAttachMemoryNV\0",
            &glBufferAttachMemoryNV_p,
        )
    }
    /// Checks if the pointer for [`glBufferAttachMemoryNV`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    #[cfg(any(feature = "GL_NV_memory_attachment"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_memory_attachment"))))]
    pub fn glBufferAttachMemoryNV_is_loaded() -> bool {
        !glBufferAttachMemoryNV_p.load(RELAX).is_null()
    }

    /// [glBufferData](http://docs.gl/es3/glBufferData)(target, size, data, usage)
    /// `target` group: BufferTargetARB
    /// `size` group: BufferSize
    /// `data` len: size
    /// `usage` group: BufferUsageARB
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn glBufferData(
        target: GLenum,
        size: GLsizeiptr,
        data: *const c_void,
        usage: GLenum,
    ) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glBufferData({:#X}, {:?}, {:p}, {:#X});",
                target,
                size,
                data,
                usage
            );
        }
        let out = call_atomic_ptr_4arg("glBufferData", &glBufferData_p, target, size, data, usage);
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glBufferData");
        }
        out
    }
    static glBufferData_p: APcv = ap_None();
    /// Tries to load [`glBufferData`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    pub unsafe fn glBufferData_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(get_proc_address, b"glBufferData\0", &glBufferData_p)
    }
    /// Checks if the pointer for [`glBufferData`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    pub fn glBufferData_is_loaded() -> bool {
        !glBufferData_p.load(RELAX).is_null()
    }

    /// [glBufferPageCommitmentMemNV](http://docs.gl/es3/glBufferPageCommitmentMemNV)(target, offset, size, memory, memOffset, commit)
    /// `target` group: BufferStorageTarget
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    #[cfg(any(feature = "GL_NV_memory_object_sparse"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_memory_object_sparse"))))]
    pub unsafe fn glBufferPageCommitmentMemNV(
        target: GLenum,
        offset: GLintptr,
        size: GLsizeiptr,
        memory: GLuint,
        memOffset: GLuint64,
        commit: GLboolean,
    ) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glBufferPageCommitmentMemNV({:#X}, {:?}, {:?}, {:?}, {:?}, {:?});",
                target,
                offset,
                size,
                memory,
                memOffset,
                commit
            );
        }
        let out = call_atomic_ptr_6arg(
            "glBufferPageCommitmentMemNV",
            &glBufferPageCommitmentMemNV_p,
            target,
            offset,
            size,
            memory,
            memOffset,
            commit,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glBufferPageCommitmentMemNV");
        }
        out
    }
    #[cfg(any(feature = "GL_NV_memory_object_sparse"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_memory_object_sparse"))))]
    static glBufferPageCommitmentMemNV_p: APcv = ap_None();
    /// Tries to load [`glBufferPageCommitmentMemNV`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    #[cfg(any(feature = "GL_NV_memory_object_sparse"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_memory_object_sparse"))))]
    pub unsafe fn glBufferPageCommitmentMemNV_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glBufferPageCommitmentMemNV\0",
            &glBufferPageCommitmentMemNV_p,
        )
    }
    /// Checks if the pointer for [`glBufferPageCommitmentMemNV`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    #[cfg(any(feature = "GL_NV_memory_object_sparse"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_memory_object_sparse"))))]
    pub fn glBufferPageCommitmentMemNV_is_loaded() -> bool {
        !glBufferPageCommitmentMemNV_p.load(RELAX).is_null()
    }

    /// [glBufferStorageEXT](http://docs.gl/es3/glBufferStorageEXT)(target, size, data, flags)
    /// `target` group: BufferStorageTarget
    /// `data` len: size
    /// `flags` group: BufferStorageMask
    /// alias of: [`glBufferStorage`]
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    #[cfg(any(feature = "GL_EXT_buffer_storage"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_buffer_storage"))))]
    pub unsafe fn glBufferStorageEXT(
        target: GLenum,
        size: GLsizeiptr,
        data: *const c_void,
        flags: GLbitfield,
    ) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glBufferStorageEXT({:#X}, {:?}, {:p}, {:?});",
                target,
                size,
                data,
                flags
            );
        }
        let out = call_atomic_ptr_4arg(
            "glBufferStorageEXT",
            &glBufferStorageEXT_p,
            target,
            size,
            data,
            flags,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glBufferStorageEXT");
        }
        out
    }
    #[cfg(any(feature = "GL_EXT_buffer_storage"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_buffer_storage"))))]
    static glBufferStorageEXT_p: APcv = ap_None();
    /// Tries to load [`glBufferStorageEXT`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    #[cfg(any(feature = "GL_EXT_buffer_storage"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_buffer_storage"))))]
    pub unsafe fn glBufferStorageEXT_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glBufferStorageEXT\0",
            &glBufferStorageEXT_p,
        )
    }
    /// Checks if the pointer for [`glBufferStorageEXT`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    #[cfg(any(feature = "GL_EXT_buffer_storage"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_buffer_storage"))))]
    pub fn glBufferStorageEXT_is_loaded() -> bool {
        !glBufferStorageEXT_p.load(RELAX).is_null()
    }

    /// [glBufferStorageExternalEXT](http://docs.gl/es3/glBufferStorageExternalEXT)(target, offset, size, clientBuffer, flags)
    /// `flags` group: BufferStorageMask
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    #[cfg(any(feature = "GL_EXT_external_buffer"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_external_buffer"))))]
    pub unsafe fn glBufferStorageExternalEXT(
        target: GLenum,
        offset: GLintptr,
        size: GLsizeiptr,
        clientBuffer: GLeglClientBufferEXT,
        flags: GLbitfield,
    ) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glBufferStorageExternalEXT({:#X}, {:?}, {:?}, {:?}, {:?});",
                target,
                offset,
                size,
                clientBuffer,
                flags
            );
        }
        let out = call_atomic_ptr_5arg(
            "glBufferStorageExternalEXT",
            &glBufferStorageExternalEXT_p,
            target,
            offset,
            size,
            clientBuffer,
            flags,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glBufferStorageExternalEXT");
        }
        out
    }
    #[cfg(any(feature = "GL_EXT_external_buffer"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_external_buffer"))))]
    static glBufferStorageExternalEXT_p: APcv = ap_None();
    /// Tries to load [`glBufferStorageExternalEXT`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    #[cfg(any(feature = "GL_EXT_external_buffer"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_external_buffer"))))]
    pub unsafe fn glBufferStorageExternalEXT_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glBufferStorageExternalEXT\0",
            &glBufferStorageExternalEXT_p,
        )
    }
    /// Checks if the pointer for [`glBufferStorageExternalEXT`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    #[cfg(any(feature = "GL_EXT_external_buffer"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_external_buffer"))))]
    pub fn glBufferStorageExternalEXT_is_loaded() -> bool {
        !glBufferStorageExternalEXT_p.load(RELAX).is_null()
    }

    /// [glBufferStorageMemEXT](http://docs.gl/es3/glBufferStorageMemEXT)(target, size, memory, offset)
    /// `target` group: BufferTargetARB
    /// `size` group: BufferSize
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    #[cfg(any(feature = "GL_EXT_memory_object"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_memory_object"))))]
    pub unsafe fn glBufferStorageMemEXT(
        target: GLenum,
        size: GLsizeiptr,
        memory: GLuint,
        offset: GLuint64,
    ) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glBufferStorageMemEXT({:#X}, {:?}, {:?}, {:?});",
                target,
                size,
                memory,
                offset
            );
        }
        let out = call_atomic_ptr_4arg(
            "glBufferStorageMemEXT",
            &glBufferStorageMemEXT_p,
            target,
            size,
            memory,
            offset,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glBufferStorageMemEXT");
        }
        out
    }
    #[cfg(any(feature = "GL_EXT_memory_object"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_memory_object"))))]
    static glBufferStorageMemEXT_p: APcv = ap_None();
    /// Tries to load [`glBufferStorageMemEXT`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    #[cfg(any(feature = "GL_EXT_memory_object"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_memory_object"))))]
    pub unsafe fn glBufferStorageMemEXT_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glBufferStorageMemEXT\0",
            &glBufferStorageMemEXT_p,
        )
    }
    /// Checks if the pointer for [`glBufferStorageMemEXT`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    #[cfg(any(feature = "GL_EXT_memory_object"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_memory_object"))))]
    pub fn glBufferStorageMemEXT_is_loaded() -> bool {
        !glBufferStorageMemEXT_p.load(RELAX).is_null()
    }

    /// [glBufferSubData](http://docs.gl/es3/glBufferSubData)(target, offset, size, data)
    /// `target` group: BufferTargetARB
    /// `offset` group: BufferOffset
    /// `size` group: BufferSize
    /// `data` len: size
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn glBufferSubData(
        target: GLenum,
        offset: GLintptr,
        size: GLsizeiptr,
        data: *const c_void,
    ) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glBufferSubData({:#X}, {:?}, {:?}, {:p});",
                target,
                offset,
                size,
                data
            );
        }
        let out = call_atomic_ptr_4arg(
            "glBufferSubData",
            &glBufferSubData_p,
            target,
            offset,
            size,
            data,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glBufferSubData");
        }
        out
    }
    static glBufferSubData_p: APcv = ap_None();
    /// Tries to load [`glBufferSubData`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    pub unsafe fn glBufferSubData_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(get_proc_address, b"glBufferSubData\0", &glBufferSubData_p)
    }
    /// Checks if the pointer for [`glBufferSubData`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    pub fn glBufferSubData_is_loaded() -> bool {
        !glBufferSubData_p.load(RELAX).is_null()
    }

    /// [glCheckFramebufferStatus](http://docs.gl/es3/glCheckFramebufferStatus)(target)
    /// `target` group: FramebufferTarget
    /// return value group: FramebufferStatus
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn glCheckFramebufferStatus(target: GLenum) -> GLenum {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!("calling glCheckFramebufferStatus({:#X});", target);
        }
        let out = call_atomic_ptr_1arg(
            "glCheckFramebufferStatus",
            &glCheckFramebufferStatus_p,
            target,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glCheckFramebufferStatus");
        }
        out
    }
    static glCheckFramebufferStatus_p: APcv = ap_None();
    /// Tries to load [`glCheckFramebufferStatus`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    pub unsafe fn glCheckFramebufferStatus_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glCheckFramebufferStatus\0",
            &glCheckFramebufferStatus_p,
        )
    }
    /// Checks if the pointer for [`glCheckFramebufferStatus`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    pub fn glCheckFramebufferStatus_is_loaded() -> bool {
        !glCheckFramebufferStatus_p.load(RELAX).is_null()
    }

    /// [glClear](http://docs.gl/es3/glClear)(mask)
    /// `mask` group: ClearBufferMask
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn glClear(mask: GLbitfield) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!("calling glClear({:?});", mask);
        }
        let out = call_atomic_ptr_1arg("glClear", &glClear_p, mask);
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glClear");
        }
        out
    }
    static glClear_p: APcv = ap_None();
    /// Tries to load [`glClear`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    pub unsafe fn glClear_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(get_proc_address, b"glClear\0", &glClear_p)
    }
    /// Checks if the pointer for [`glClear`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    pub fn glClear_is_loaded() -> bool {
        !glClear_p.load(RELAX).is_null()
    }

    /// [glClearBufferfi](http://docs.gl/es3/glClearBuffer)(buffer, drawbuffer, depth, stencil)
    /// `buffer` group: Buffer
    /// `drawbuffer` group: DrawBufferName
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn glClearBufferfi(
        buffer: GLenum,
        drawbuffer: GLint,
        depth: GLfloat,
        stencil: GLint,
    ) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glClearBufferfi({:#X}, {:?}, {:?}, {:?});",
                buffer,
                drawbuffer,
                depth,
                stencil
            );
        }
        let out = call_atomic_ptr_4arg(
            "glClearBufferfi",
            &glClearBufferfi_p,
            buffer,
            drawbuffer,
            depth,
            stencil,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glClearBufferfi");
        }
        out
    }
    static glClearBufferfi_p: APcv = ap_None();
    /// Tries to load [`glClearBufferfi`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    pub unsafe fn glClearBufferfi_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(get_proc_address, b"glClearBufferfi\0", &glClearBufferfi_p)
    }
    /// Checks if the pointer for [`glClearBufferfi`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    pub fn glClearBufferfi_is_loaded() -> bool {
        !glClearBufferfi_p.load(RELAX).is_null()
    }

    /// [glClearBufferfv](http://docs.gl/es3/glClearBuffer)(buffer, drawbuffer, value)
    /// `buffer` group: Buffer
    /// `drawbuffer` group: DrawBufferName
    /// `value` len: COMPSIZE(buffer)
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn glClearBufferfv(buffer: GLenum, drawbuffer: GLint, value: *const GLfloat) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glClearBufferfv({:#X}, {:?}, {:p});",
                buffer,
                drawbuffer,
                value
            );
        }
        let out = call_atomic_ptr_3arg(
            "glClearBufferfv",
            &glClearBufferfv_p,
            buffer,
            drawbuffer,
            value,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glClearBufferfv");
        }
        out
    }
    static glClearBufferfv_p: APcv = ap_None();
    /// Tries to load [`glClearBufferfv`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    pub unsafe fn glClearBufferfv_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(get_proc_address, b"glClearBufferfv\0", &glClearBufferfv_p)
    }
    /// Checks if the pointer for [`glClearBufferfv`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    pub fn glClearBufferfv_is_loaded() -> bool {
        !glClearBufferfv_p.load(RELAX).is_null()
    }

    /// [glClearBufferiv](http://docs.gl/es3/glClearBuffer)(buffer, drawbuffer, value)
    /// `buffer` group: Buffer
    /// `drawbuffer` group: DrawBufferName
    /// `value` len: COMPSIZE(buffer)
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn glClearBufferiv(buffer: GLenum, drawbuffer: GLint, value: *const GLint) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glClearBufferiv({:#X}, {:?}, {:p});",
                buffer,
                drawbuffer,
                value
            );
        }
        let out = call_atomic_ptr_3arg(
            "glClearBufferiv",
            &glClearBufferiv_p,
            buffer,
            drawbuffer,
            value,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glClearBufferiv");
        }
        out
    }
    static glClearBufferiv_p: APcv = ap_None();
    /// Tries to load [`glClearBufferiv`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    pub unsafe fn glClearBufferiv_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(get_proc_address, b"glClearBufferiv\0", &glClearBufferiv_p)
    }
    /// Checks if the pointer for [`glClearBufferiv`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    pub fn glClearBufferiv_is_loaded() -> bool {
        !glClearBufferiv_p.load(RELAX).is_null()
    }

    /// [glClearBufferuiv](http://docs.gl/es3/glClearBuffer)(buffer, drawbuffer, value)
    /// `buffer` group: Buffer
    /// `drawbuffer` group: DrawBufferName
    /// `value` len: COMPSIZE(buffer)
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn glClearBufferuiv(buffer: GLenum, drawbuffer: GLint, value: *const GLuint) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glClearBufferuiv({:#X}, {:?}, {:p});",
                buffer,
                drawbuffer,
                value
            );
        }
        let out = call_atomic_ptr_3arg(
            "glClearBufferuiv",
            &glClearBufferuiv_p,
            buffer,
            drawbuffer,
            value,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glClearBufferuiv");
        }
        out
    }
    static glClearBufferuiv_p: APcv = ap_None();
    /// Tries to load [`glClearBufferuiv`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    pub unsafe fn glClearBufferuiv_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(get_proc_address, b"glClearBufferuiv\0", &glClearBufferuiv_p)
    }
    /// Checks if the pointer for [`glClearBufferuiv`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    pub fn glClearBufferuiv_is_loaded() -> bool {
        !glClearBufferuiv_p.load(RELAX).is_null()
    }

    /// [glClearColor](http://docs.gl/es3/glClearColor)(red, green, blue, alpha)
    /// `red` group: ColorF
    /// `green` group: ColorF
    /// `blue` group: ColorF
    /// `alpha` group: ColorF
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn glClearColor(red: GLfloat, green: GLfloat, blue: GLfloat, alpha: GLfloat) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glClearColor({:?}, {:?}, {:?}, {:?});",
                red,
                green,
                blue,
                alpha
            );
        }
        let out = call_atomic_ptr_4arg("glClearColor", &glClearColor_p, red, green, blue, alpha);
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glClearColor");
        }
        out
    }
    static glClearColor_p: APcv = ap_None();
    /// Tries to load [`glClearColor`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    pub unsafe fn glClearColor_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(get_proc_address, b"glClearColor\0", &glClearColor_p)
    }
    /// Checks if the pointer for [`glClearColor`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    pub fn glClearColor_is_loaded() -> bool {
        !glClearColor_p.load(RELAX).is_null()
    }

    /// [glClearDepthf](http://docs.gl/es3/glClearDepth)(d)
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn glClearDepthf(d: GLfloat) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!("calling glClearDepthf({:?});", d);
        }
        let out = call_atomic_ptr_1arg("glClearDepthf", &glClearDepthf_p, d);
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glClearDepthf");
        }
        out
    }
    static glClearDepthf_p: APcv = ap_None();
    /// Tries to load [`glClearDepthf`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    pub unsafe fn glClearDepthf_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(get_proc_address, b"glClearDepthf\0", &glClearDepthf_p)
    }
    /// Checks if the pointer for [`glClearDepthf`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    pub fn glClearDepthf_is_loaded() -> bool {
        !glClearDepthf_p.load(RELAX).is_null()
    }

    /// [glClearPixelLocalStorageuiEXT](http://docs.gl/es3/glClearPixelLocalStorageuiEXT)(offset, n, values)
    /// `values` len: n
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    #[cfg(any(feature = "GL_EXT_shader_pixel_local_storage2"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_shader_pixel_local_storage2"))))]
    pub unsafe fn glClearPixelLocalStorageuiEXT(
        offset: GLsizei,
        n: GLsizei,
        values: *const GLuint,
    ) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glClearPixelLocalStorageuiEXT({:?}, {:?}, {:p});",
                offset,
                n,
                values
            );
        }
        let out = call_atomic_ptr_3arg(
            "glClearPixelLocalStorageuiEXT",
            &glClearPixelLocalStorageuiEXT_p,
            offset,
            n,
            values,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glClearPixelLocalStorageuiEXT");
        }
        out
    }
    #[cfg(any(feature = "GL_EXT_shader_pixel_local_storage2"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_shader_pixel_local_storage2"))))]
    static glClearPixelLocalStorageuiEXT_p: APcv = ap_None();
    /// Tries to load [`glClearPixelLocalStorageuiEXT`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    #[cfg(any(feature = "GL_EXT_shader_pixel_local_storage2"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_shader_pixel_local_storage2"))))]
    pub unsafe fn glClearPixelLocalStorageuiEXT_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glClearPixelLocalStorageuiEXT\0",
            &glClearPixelLocalStorageuiEXT_p,
        )
    }
    /// Checks if the pointer for [`glClearPixelLocalStorageuiEXT`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    #[cfg(any(feature = "GL_EXT_shader_pixel_local_storage2"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_shader_pixel_local_storage2"))))]
    pub fn glClearPixelLocalStorageuiEXT_is_loaded() -> bool {
        !glClearPixelLocalStorageuiEXT_p.load(RELAX).is_null()
    }

    /// [glClearStencil](http://docs.gl/es3/glClearStencil)(s)
    /// `s` group: StencilValue
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn glClearStencil(s: GLint) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!("calling glClearStencil({:?});", s);
        }
        let out = call_atomic_ptr_1arg("glClearStencil", &glClearStencil_p, s);
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glClearStencil");
        }
        out
    }
    static glClearStencil_p: APcv = ap_None();
    /// Tries to load [`glClearStencil`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    pub unsafe fn glClearStencil_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(get_proc_address, b"glClearStencil\0", &glClearStencil_p)
    }
    /// Checks if the pointer for [`glClearStencil`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    pub fn glClearStencil_is_loaded() -> bool {
        !glClearStencil_p.load(RELAX).is_null()
    }

    /// [glClearTexImageEXT](http://docs.gl/es3/glClearTexImageEXT)(texture, level, format, type_, data)
    /// `texture` class: texture
    /// `format` group: PixelFormat
    /// `type_` group: PixelType
    /// `data` len: COMPSIZE(format,type)
    /// alias of: [`glClearTexImage`]
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    #[cfg(any(feature = "GL_EXT_clear_texture"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_clear_texture"))))]
    pub unsafe fn glClearTexImageEXT(
        texture: GLuint,
        level: GLint,
        format: GLenum,
        type_: GLenum,
        data: *const c_void,
    ) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glClearTexImageEXT({:?}, {:?}, {:#X}, {:#X}, {:p});",
                texture,
                level,
                format,
                type_,
                data
            );
        }
        let out = call_atomic_ptr_5arg(
            "glClearTexImageEXT",
            &glClearTexImageEXT_p,
            texture,
            level,
            format,
            type_,
            data,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glClearTexImageEXT");
        }
        out
    }
    #[cfg(any(feature = "GL_EXT_clear_texture"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_clear_texture"))))]
    static glClearTexImageEXT_p: APcv = ap_None();
    /// Tries to load [`glClearTexImageEXT`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    #[cfg(any(feature = "GL_EXT_clear_texture"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_clear_texture"))))]
    pub unsafe fn glClearTexImageEXT_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glClearTexImageEXT\0",
            &glClearTexImageEXT_p,
        )
    }
    /// Checks if the pointer for [`glClearTexImageEXT`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    #[cfg(any(feature = "GL_EXT_clear_texture"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_clear_texture"))))]
    pub fn glClearTexImageEXT_is_loaded() -> bool {
        !glClearTexImageEXT_p.load(RELAX).is_null()
    }

    /// [glClearTexSubImageEXT](http://docs.gl/es3/glClearTexSubImageEXT)(texture, level, xoffset, yoffset, zoffset, width, height, depth, format, type_, data)
    /// `texture` class: texture
    /// `format` group: PixelFormat
    /// `type_` group: PixelType
    /// `data` len: COMPSIZE(format,type)
    /// alias of: [`glClearTexSubImage`]
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    #[cfg(any(feature = "GL_EXT_clear_texture"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_clear_texture"))))]
    pub unsafe fn glClearTexSubImageEXT(
        texture: GLuint,
        level: GLint,
        xoffset: GLint,
        yoffset: GLint,
        zoffset: GLint,
        width: GLsizei,
        height: GLsizei,
        depth: GLsizei,
        format: GLenum,
        type_: GLenum,
        data: *const c_void,
    ) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glClearTexSubImageEXT({:?}, {:?}, {:?}, {:?}, {:?}, {:?}, {:?}, {:?}, {:#X}, {:#X}, {:p});",
                texture,
                level,
                xoffset,
                yoffset,
                zoffset,
                width,
                height,
                depth,
                format,
                type_,
                data
            );
        }
        let out = call_atomic_ptr_11arg(
            "glClearTexSubImageEXT",
            &glClearTexSubImageEXT_p,
            texture,
            level,
            xoffset,
            yoffset,
            zoffset,
            width,
            height,
            depth,
            format,
            type_,
            data,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glClearTexSubImageEXT");
        }
        out
    }
    #[cfg(any(feature = "GL_EXT_clear_texture"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_clear_texture"))))]
    static glClearTexSubImageEXT_p: APcv = ap_None();
    /// Tries to load [`glClearTexSubImageEXT`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    #[cfg(any(feature = "GL_EXT_clear_texture"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_clear_texture"))))]
    pub unsafe fn glClearTexSubImageEXT_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glClearTexSubImageEXT\0",
            &glClearTexSubImageEXT_p,
        )
    }
    /// Checks if the pointer for [`glClearTexSubImageEXT`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    #[cfg(any(feature = "GL_EXT_clear_texture"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_clear_texture"))))]
    pub fn glClearTexSubImageEXT_is_loaded() -> bool {
        !glClearTexSubImageEXT_p.load(RELAX).is_null()
    }

    /// [glClientWaitSync](http://docs.gl/es3/glClientWaitSync)(sync, flags, timeout)
    /// `sync` group: sync
    /// `sync` class: sync
    /// `flags` group: SyncObjectMask
    /// return value group: SyncStatus
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn glClientWaitSync(sync: GLsync, flags: GLbitfield, timeout: GLuint64) -> GLenum {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glClientWaitSync({:p}, {:?}, {:?});",
                sync,
                flags,
                timeout
            );
        }
        let out = call_atomic_ptr_3arg(
            "glClientWaitSync",
            &glClientWaitSync_p,
            sync,
            flags,
            timeout,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glClientWaitSync");
        }
        out
    }
    static glClientWaitSync_p: APcv = ap_None();
    /// Tries to load [`glClientWaitSync`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    pub unsafe fn glClientWaitSync_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(get_proc_address, b"glClientWaitSync\0", &glClientWaitSync_p)
    }
    /// Checks if the pointer for [`glClientWaitSync`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    pub fn glClientWaitSync_is_loaded() -> bool {
        !glClientWaitSync_p.load(RELAX).is_null()
    }

    /// [glClientWaitSyncAPPLE](http://docs.gl/es3/glClientWaitSyncAPPLE)(sync, flags, timeout)
    /// `sync` group: sync
    /// `sync` class: sync
    /// `flags` group: SyncObjectMask
    /// return value group: SyncStatus
    /// alias of: [`glClientWaitSync`]
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    #[cfg(any(feature = "GL_APPLE_sync"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_APPLE_sync"))))]
    pub unsafe fn glClientWaitSyncAPPLE(
        sync: GLsync,
        flags: GLbitfield,
        timeout: GLuint64,
    ) -> GLenum {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glClientWaitSyncAPPLE({:p}, {:?}, {:?});",
                sync,
                flags,
                timeout
            );
        }
        let out = call_atomic_ptr_3arg(
            "glClientWaitSyncAPPLE",
            &glClientWaitSyncAPPLE_p,
            sync,
            flags,
            timeout,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glClientWaitSyncAPPLE");
        }
        out
    }
    #[cfg(any(feature = "GL_APPLE_sync"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_APPLE_sync"))))]
    static glClientWaitSyncAPPLE_p: APcv = ap_None();
    /// Tries to load [`glClientWaitSyncAPPLE`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    #[cfg(any(feature = "GL_APPLE_sync"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_APPLE_sync"))))]
    pub unsafe fn glClientWaitSyncAPPLE_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glClientWaitSyncAPPLE\0",
            &glClientWaitSyncAPPLE_p,
        )
    }
    /// Checks if the pointer for [`glClientWaitSyncAPPLE`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    #[cfg(any(feature = "GL_APPLE_sync"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_APPLE_sync"))))]
    pub fn glClientWaitSyncAPPLE_is_loaded() -> bool {
        !glClientWaitSyncAPPLE_p.load(RELAX).is_null()
    }

    /// [glClipControlEXT](http://docs.gl/es3/glClipControlEXT)(origin, depth)
    /// alias of: [`glClipControl`]
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    #[cfg(any(feature = "GL_EXT_clip_control"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_clip_control"))))]
    pub unsafe fn glClipControlEXT(origin: GLenum, depth: GLenum) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!("calling glClipControlEXT({:#X}, {:#X});", origin, depth);
        }
        let out = call_atomic_ptr_2arg("glClipControlEXT", &glClipControlEXT_p, origin, depth);
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glClipControlEXT");
        }
        out
    }
    #[cfg(any(feature = "GL_EXT_clip_control"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_clip_control"))))]
    static glClipControlEXT_p: APcv = ap_None();
    /// Tries to load [`glClipControlEXT`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    #[cfg(any(feature = "GL_EXT_clip_control"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_clip_control"))))]
    pub unsafe fn glClipControlEXT_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(get_proc_address, b"glClipControlEXT\0", &glClipControlEXT_p)
    }
    /// Checks if the pointer for [`glClipControlEXT`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    #[cfg(any(feature = "GL_EXT_clip_control"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_clip_control"))))]
    pub fn glClipControlEXT_is_loaded() -> bool {
        !glClipControlEXT_p.load(RELAX).is_null()
    }

    /// [glColorMask](http://docs.gl/es3/glColorMask)(red, green, blue, alpha)
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn glColorMask(red: GLboolean, green: GLboolean, blue: GLboolean, alpha: GLboolean) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glColorMask({:?}, {:?}, {:?}, {:?});",
                red,
                green,
                blue,
                alpha
            );
        }
        let out = call_atomic_ptr_4arg("glColorMask", &glColorMask_p, red, green, blue, alpha);
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glColorMask");
        }
        out
    }
    static glColorMask_p: APcv = ap_None();
    /// Tries to load [`glColorMask`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    pub unsafe fn glColorMask_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(get_proc_address, b"glColorMask\0", &glColorMask_p)
    }
    /// Checks if the pointer for [`glColorMask`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    pub fn glColorMask_is_loaded() -> bool {
        !glColorMask_p.load(RELAX).is_null()
    }

    /// [glColorMaski](http://docs.gl/es3/glColorMask)(index, r, g, b, a)
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn glColorMaski(
        index: GLuint,
        r: GLboolean,
        g: GLboolean,
        b: GLboolean,
        a: GLboolean,
    ) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glColorMaski({:?}, {:?}, {:?}, {:?}, {:?});",
                index,
                r,
                g,
                b,
                a
            );
        }
        let out = call_atomic_ptr_5arg("glColorMaski", &glColorMaski_p, index, r, g, b, a);
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glColorMaski");
        }
        out
    }
    static glColorMaski_p: APcv = ap_None();
    /// Tries to load [`glColorMaski`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    pub unsafe fn glColorMaski_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(get_proc_address, b"glColorMaski\0", &glColorMaski_p)
    }
    /// Checks if the pointer for [`glColorMaski`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    pub fn glColorMaski_is_loaded() -> bool {
        !glColorMaski_p.load(RELAX).is_null()
    }

    /// [glColorMaskiEXT](http://docs.gl/es3/glColorMaskiEXT)(index, r, g, b, a)
    /// alias of: [`glColorMaski`]
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    #[cfg(any(feature = "GL_EXT_draw_buffers_indexed"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_draw_buffers_indexed"))))]
    pub unsafe fn glColorMaskiEXT(
        index: GLuint,
        r: GLboolean,
        g: GLboolean,
        b: GLboolean,
        a: GLboolean,
    ) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glColorMaskiEXT({:?}, {:?}, {:?}, {:?}, {:?});",
                index,
                r,
                g,
                b,
                a
            );
        }
        let out = call_atomic_ptr_5arg("glColorMaskiEXT", &glColorMaskiEXT_p, index, r, g, b, a);
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glColorMaskiEXT");
        }
        out
    }
    #[cfg(any(feature = "GL_EXT_draw_buffers_indexed"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_draw_buffers_indexed"))))]
    static glColorMaskiEXT_p: APcv = ap_None();
    /// Tries to load [`glColorMaskiEXT`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    #[cfg(any(feature = "GL_EXT_draw_buffers_indexed"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_draw_buffers_indexed"))))]
    pub unsafe fn glColorMaskiEXT_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(get_proc_address, b"glColorMaskiEXT\0", &glColorMaskiEXT_p)
    }
    /// Checks if the pointer for [`glColorMaskiEXT`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    #[cfg(any(feature = "GL_EXT_draw_buffers_indexed"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_draw_buffers_indexed"))))]
    pub fn glColorMaskiEXT_is_loaded() -> bool {
        !glColorMaskiEXT_p.load(RELAX).is_null()
    }

    /// [glColorMaskiOES](http://docs.gl/es3/glColorMaskiOES)(index, r, g, b, a)
    /// alias of: [`glColorMaski`]
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    #[cfg(any(feature = "GL_OES_draw_buffers_indexed"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_OES_draw_buffers_indexed"))))]
    pub unsafe fn glColorMaskiOES(
        index: GLuint,
        r: GLboolean,
        g: GLboolean,
        b: GLboolean,
        a: GLboolean,
    ) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glColorMaskiOES({:?}, {:?}, {:?}, {:?}, {:?});",
                index,
                r,
                g,
                b,
                a
            );
        }
        let out = call_atomic_ptr_5arg("glColorMaskiOES", &glColorMaskiOES_p, index, r, g, b, a);
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glColorMaskiOES");
        }
        out
    }
    #[cfg(any(feature = "GL_OES_draw_buffers_indexed"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_OES_draw_buffers_indexed"))))]
    static glColorMaskiOES_p: APcv = ap_None();
    /// Tries to load [`glColorMaskiOES`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    #[cfg(any(feature = "GL_OES_draw_buffers_indexed"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_OES_draw_buffers_indexed"))))]
    pub unsafe fn glColorMaskiOES_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(get_proc_address, b"glColorMaskiOES\0", &glColorMaskiOES_p)
    }
    /// Checks if the pointer for [`glColorMaskiOES`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    #[cfg(any(feature = "GL_OES_draw_buffers_indexed"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_OES_draw_buffers_indexed"))))]
    pub fn glColorMaskiOES_is_loaded() -> bool {
        !glColorMaskiOES_p.load(RELAX).is_null()
    }

    /// [glCompileShader](http://docs.gl/es3/glCompileShader)(shader)
    /// `shader` class: shader
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn glCompileShader(shader: GLuint) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!("calling glCompileShader({:?});", shader);
        }
        let out = call_atomic_ptr_1arg("glCompileShader", &glCompileShader_p, shader);
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glCompileShader");
        }
        out
    }
    static glCompileShader_p: APcv = ap_None();
    /// Tries to load [`glCompileShader`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    pub unsafe fn glCompileShader_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(get_proc_address, b"glCompileShader\0", &glCompileShader_p)
    }
    /// Checks if the pointer for [`glCompileShader`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    pub fn glCompileShader_is_loaded() -> bool {
        !glCompileShader_p.load(RELAX).is_null()
    }

    /// [glCompressedTexImage2D](http://docs.gl/es3/glCompressedTexImage2D)(target, level, internalformat, width, height, border, imageSize, data)
    /// `target` group: TextureTarget
    /// `level` group: CheckedInt32
    /// `internalformat` group: InternalFormat
    /// `border` group: CheckedInt32
    /// `data` group: CompressedTextureARB
    /// `data` len: imageSize
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn glCompressedTexImage2D(
        target: GLenum,
        level: GLint,
        internalformat: GLenum,
        width: GLsizei,
        height: GLsizei,
        border: GLint,
        imageSize: GLsizei,
        data: *const c_void,
    ) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glCompressedTexImage2D({:#X}, {:?}, {:#X}, {:?}, {:?}, {:?}, {:?}, {:p});",
                target,
                level,
                internalformat,
                width,
                height,
                border,
                imageSize,
                data
            );
        }
        let out = call_atomic_ptr_8arg(
            "glCompressedTexImage2D",
            &glCompressedTexImage2D_p,
            target,
            level,
            internalformat,
            width,
            height,
            border,
            imageSize,
            data,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glCompressedTexImage2D");
        }
        out
    }
    static glCompressedTexImage2D_p: APcv = ap_None();
    /// Tries to load [`glCompressedTexImage2D`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    pub unsafe fn glCompressedTexImage2D_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glCompressedTexImage2D\0",
            &glCompressedTexImage2D_p,
        )
    }
    /// Checks if the pointer for [`glCompressedTexImage2D`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    pub fn glCompressedTexImage2D_is_loaded() -> bool {
        !glCompressedTexImage2D_p.load(RELAX).is_null()
    }

    /// [glCompressedTexImage3D](http://docs.gl/es3/glCompressedTexImage3D)(target, level, internalformat, width, height, depth, border, imageSize, data)
    /// `target` group: TextureTarget
    /// `level` group: CheckedInt32
    /// `internalformat` group: InternalFormat
    /// `border` group: CheckedInt32
    /// `data` group: CompressedTextureARB
    /// `data` len: imageSize
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn glCompressedTexImage3D(
        target: GLenum,
        level: GLint,
        internalformat: GLenum,
        width: GLsizei,
        height: GLsizei,
        depth: GLsizei,
        border: GLint,
        imageSize: GLsizei,
        data: *const c_void,
    ) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glCompressedTexImage3D({:#X}, {:?}, {:#X}, {:?}, {:?}, {:?}, {:?}, {:?}, {:p});",
                target,
                level,
                internalformat,
                width,
                height,
                depth,
                border,
                imageSize,
                data
            );
        }
        let out = call_atomic_ptr_9arg(
            "glCompressedTexImage3D",
            &glCompressedTexImage3D_p,
            target,
            level,
            internalformat,
            width,
            height,
            depth,
            border,
            imageSize,
            data,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glCompressedTexImage3D");
        }
        out
    }
    static glCompressedTexImage3D_p: APcv = ap_None();
    /// Tries to load [`glCompressedTexImage3D`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    pub unsafe fn glCompressedTexImage3D_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glCompressedTexImage3D\0",
            &glCompressedTexImage3D_p,
        )
    }
    /// Checks if the pointer for [`glCompressedTexImage3D`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    pub fn glCompressedTexImage3D_is_loaded() -> bool {
        !glCompressedTexImage3D_p.load(RELAX).is_null()
    }

    /// [glCompressedTexImage3DOES](http://docs.gl/es3/glCompressedTexImage3DOES)(target, level, internalformat, width, height, depth, border, imageSize, data)
    /// `target` group: TextureTarget
    /// `internalformat` group: InternalFormat
    /// `data` len: imageSize
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    #[cfg(any(feature = "GL_OES_texture_3D"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_OES_texture_3D"))))]
    pub unsafe fn glCompressedTexImage3DOES(
        target: GLenum,
        level: GLint,
        internalformat: GLenum,
        width: GLsizei,
        height: GLsizei,
        depth: GLsizei,
        border: GLint,
        imageSize: GLsizei,
        data: *const c_void,
    ) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glCompressedTexImage3DOES({:#X}, {:?}, {:#X}, {:?}, {:?}, {:?}, {:?}, {:?}, {:p});",
                target,
                level,
                internalformat,
                width,
                height,
                depth,
                border,
                imageSize,
                data
            );
        }
        let out = call_atomic_ptr_9arg(
            "glCompressedTexImage3DOES",
            &glCompressedTexImage3DOES_p,
            target,
            level,
            internalformat,
            width,
            height,
            depth,
            border,
            imageSize,
            data,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glCompressedTexImage3DOES");
        }
        out
    }
    #[cfg(any(feature = "GL_OES_texture_3D"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_OES_texture_3D"))))]
    static glCompressedTexImage3DOES_p: APcv = ap_None();
    /// Tries to load [`glCompressedTexImage3DOES`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    #[cfg(any(feature = "GL_OES_texture_3D"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_OES_texture_3D"))))]
    pub unsafe fn glCompressedTexImage3DOES_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glCompressedTexImage3DOES\0",
            &glCompressedTexImage3DOES_p,
        )
    }
    /// Checks if the pointer for [`glCompressedTexImage3DOES`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    #[cfg(any(feature = "GL_OES_texture_3D"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_OES_texture_3D"))))]
    pub fn glCompressedTexImage3DOES_is_loaded() -> bool {
        !glCompressedTexImage3DOES_p.load(RELAX).is_null()
    }

    /// [glCompressedTexSubImage2D](http://docs.gl/es3/glCompressedTexSubImage2D)(target, level, xoffset, yoffset, width, height, format, imageSize, data)
    /// `target` group: TextureTarget
    /// `level` group: CheckedInt32
    /// `xoffset` group: CheckedInt32
    /// `yoffset` group: CheckedInt32
    /// `format` group: PixelFormat
    /// `data` group: CompressedTextureARB
    /// `data` len: imageSize
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn glCompressedTexSubImage2D(
        target: GLenum,
        level: GLint,
        xoffset: GLint,
        yoffset: GLint,
        width: GLsizei,
        height: GLsizei,
        format: GLenum,
        imageSize: GLsizei,
        data: *const c_void,
    ) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glCompressedTexSubImage2D({:#X}, {:?}, {:?}, {:?}, {:?}, {:?}, {:#X}, {:?}, {:p});",
                target,
                level,
                xoffset,
                yoffset,
                width,
                height,
                format,
                imageSize,
                data
            );
        }
        let out = call_atomic_ptr_9arg(
            "glCompressedTexSubImage2D",
            &glCompressedTexSubImage2D_p,
            target,
            level,
            xoffset,
            yoffset,
            width,
            height,
            format,
            imageSize,
            data,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glCompressedTexSubImage2D");
        }
        out
    }
    static glCompressedTexSubImage2D_p: APcv = ap_None();
    /// Tries to load [`glCompressedTexSubImage2D`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    pub unsafe fn glCompressedTexSubImage2D_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glCompressedTexSubImage2D\0",
            &glCompressedTexSubImage2D_p,
        )
    }
    /// Checks if the pointer for [`glCompressedTexSubImage2D`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    pub fn glCompressedTexSubImage2D_is_loaded() -> bool {
        !glCompressedTexSubImage2D_p.load(RELAX).is_null()
    }

    /// [glCompressedTexSubImage3D](http://docs.gl/es3/glCompressedTexSubImage3D)(target, level, xoffset, yoffset, zoffset, width, height, depth, format, imageSize, data)
    /// `target` group: TextureTarget
    /// `level` group: CheckedInt32
    /// `xoffset` group: CheckedInt32
    /// `yoffset` group: CheckedInt32
    /// `zoffset` group: CheckedInt32
    /// `format` group: PixelFormat
    /// `data` group: CompressedTextureARB
    /// `data` len: imageSize
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn glCompressedTexSubImage3D(
        target: GLenum,
        level: GLint,
        xoffset: GLint,
        yoffset: GLint,
        zoffset: GLint,
        width: GLsizei,
        height: GLsizei,
        depth: GLsizei,
        format: GLenum,
        imageSize: GLsizei,
        data: *const c_void,
    ) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!("calling glCompressedTexSubImage3D({:#X}, {:?}, {:?}, {:?}, {:?}, {:?}, {:?}, {:?}, {:#X}, {:?}, {:p});", target, level, xoffset, yoffset, zoffset, width, height, depth, format, imageSize, data);
        }
        let out = call_atomic_ptr_11arg(
            "glCompressedTexSubImage3D",
            &glCompressedTexSubImage3D_p,
            target,
            level,
            xoffset,
            yoffset,
            zoffset,
            width,
            height,
            depth,
            format,
            imageSize,
            data,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glCompressedTexSubImage3D");
        }
        out
    }
    static glCompressedTexSubImage3D_p: APcv = ap_None();
    /// Tries to load [`glCompressedTexSubImage3D`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    pub unsafe fn glCompressedTexSubImage3D_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glCompressedTexSubImage3D\0",
            &glCompressedTexSubImage3D_p,
        )
    }
    /// Checks if the pointer for [`glCompressedTexSubImage3D`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    pub fn glCompressedTexSubImage3D_is_loaded() -> bool {
        !glCompressedTexSubImage3D_p.load(RELAX).is_null()
    }

    /// [glCompressedTexSubImage3DOES](http://docs.gl/es3/glCompressedTexSubImage3DOES)(target, level, xoffset, yoffset, zoffset, width, height, depth, format, imageSize, data)
    /// `target` group: TextureTarget
    /// `format` group: PixelFormat
    /// `data` len: imageSize
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    #[cfg(any(feature = "GL_OES_texture_3D"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_OES_texture_3D"))))]
    pub unsafe fn glCompressedTexSubImage3DOES(
        target: GLenum,
        level: GLint,
        xoffset: GLint,
        yoffset: GLint,
        zoffset: GLint,
        width: GLsizei,
        height: GLsizei,
        depth: GLsizei,
        format: GLenum,
        imageSize: GLsizei,
        data: *const c_void,
    ) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!("calling glCompressedTexSubImage3DOES({:#X}, {:?}, {:?}, {:?}, {:?}, {:?}, {:?}, {:?}, {:#X}, {:?}, {:p});", target, level, xoffset, yoffset, zoffset, width, height, depth, format, imageSize, data);
        }
        let out = call_atomic_ptr_11arg(
            "glCompressedTexSubImage3DOES",
            &glCompressedTexSubImage3DOES_p,
            target,
            level,
            xoffset,
            yoffset,
            zoffset,
            width,
            height,
            depth,
            format,
            imageSize,
            data,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glCompressedTexSubImage3DOES");
        }
        out
    }
    #[cfg(any(feature = "GL_OES_texture_3D"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_OES_texture_3D"))))]
    static glCompressedTexSubImage3DOES_p: APcv = ap_None();
    /// Tries to load [`glCompressedTexSubImage3DOES`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    #[cfg(any(feature = "GL_OES_texture_3D"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_OES_texture_3D"))))]
    pub unsafe fn glCompressedTexSubImage3DOES_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glCompressedTexSubImage3DOES\0",
            &glCompressedTexSubImage3DOES_p,
        )
    }
    /// Checks if the pointer for [`glCompressedTexSubImage3DOES`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    #[cfg(any(feature = "GL_OES_texture_3D"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_OES_texture_3D"))))]
    pub fn glCompressedTexSubImage3DOES_is_loaded() -> bool {
        !glCompressedTexSubImage3DOES_p.load(RELAX).is_null()
    }

    /// [glConservativeRasterParameteriNV](http://docs.gl/es3/glConservativeRasterParameteriNV)(pname, param)
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    #[cfg(any(feature = "GL_NV_conservative_raster_pre_snap_triangles"))]
    #[cfg_attr(
        docs_rs,
        doc(cfg(any(feature = "GL_NV_conservative_raster_pre_snap_triangles")))
    )]
    pub unsafe fn glConservativeRasterParameteriNV(pname: GLenum, param: GLint) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glConservativeRasterParameteriNV({:#X}, {:?});",
                pname,
                param
            );
        }
        let out = call_atomic_ptr_2arg(
            "glConservativeRasterParameteriNV",
            &glConservativeRasterParameteriNV_p,
            pname,
            param,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glConservativeRasterParameteriNV");
        }
        out
    }
    #[cfg(any(feature = "GL_NV_conservative_raster_pre_snap_triangles"))]
    #[cfg_attr(
        docs_rs,
        doc(cfg(any(feature = "GL_NV_conservative_raster_pre_snap_triangles")))
    )]
    static glConservativeRasterParameteriNV_p: APcv = ap_None();
    /// Tries to load [`glConservativeRasterParameteriNV`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    #[cfg(any(feature = "GL_NV_conservative_raster_pre_snap_triangles"))]
    #[cfg_attr(
        docs_rs,
        doc(cfg(any(feature = "GL_NV_conservative_raster_pre_snap_triangles")))
    )]
    pub unsafe fn glConservativeRasterParameteriNV_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glConservativeRasterParameteriNV\0",
            &glConservativeRasterParameteriNV_p,
        )
    }
    /// Checks if the pointer for [`glConservativeRasterParameteriNV`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    #[cfg(any(feature = "GL_NV_conservative_raster_pre_snap_triangles"))]
    #[cfg_attr(
        docs_rs,
        doc(cfg(any(feature = "GL_NV_conservative_raster_pre_snap_triangles")))
    )]
    pub fn glConservativeRasterParameteriNV_is_loaded() -> bool {
        !glConservativeRasterParameteriNV_p.load(RELAX).is_null()
    }

    /// [glCopyBufferSubData](http://docs.gl/es3/glCopyBufferSubData)(readTarget, writeTarget, readOffset, writeOffset, size)
    /// `readTarget` group: CopyBufferSubDataTarget
    /// `writeTarget` group: CopyBufferSubDataTarget
    /// `readOffset` group: BufferOffset
    /// `writeOffset` group: BufferOffset
    /// `size` group: BufferSize
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn glCopyBufferSubData(
        readTarget: GLenum,
        writeTarget: GLenum,
        readOffset: GLintptr,
        writeOffset: GLintptr,
        size: GLsizeiptr,
    ) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glCopyBufferSubData({:#X}, {:#X}, {:?}, {:?}, {:?});",
                readTarget,
                writeTarget,
                readOffset,
                writeOffset,
                size
            );
        }
        let out = call_atomic_ptr_5arg(
            "glCopyBufferSubData",
            &glCopyBufferSubData_p,
            readTarget,
            writeTarget,
            readOffset,
            writeOffset,
            size,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glCopyBufferSubData");
        }
        out
    }
    static glCopyBufferSubData_p: APcv = ap_None();
    /// Tries to load [`glCopyBufferSubData`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    pub unsafe fn glCopyBufferSubData_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glCopyBufferSubData\0",
            &glCopyBufferSubData_p,
        )
    }
    /// Checks if the pointer for [`glCopyBufferSubData`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    pub fn glCopyBufferSubData_is_loaded() -> bool {
        !glCopyBufferSubData_p.load(RELAX).is_null()
    }

    /// [glCopyBufferSubDataNV](http://docs.gl/es3/glCopyBufferSubDataNV)(readTarget, writeTarget, readOffset, writeOffset, size)
    /// `readTarget` group: CopyBufferSubDataTarget
    /// `writeTarget` group: CopyBufferSubDataTarget
    /// `readOffset` group: BufferOffset
    /// `writeOffset` group: BufferOffset
    /// `size` group: BufferSize
    /// alias of: [`glCopyBufferSubData`]
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    #[cfg(any(feature = "GL_NV_copy_buffer"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_copy_buffer"))))]
    pub unsafe fn glCopyBufferSubDataNV(
        readTarget: GLenum,
        writeTarget: GLenum,
        readOffset: GLintptr,
        writeOffset: GLintptr,
        size: GLsizeiptr,
    ) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glCopyBufferSubDataNV({:#X}, {:#X}, {:?}, {:?}, {:?});",
                readTarget,
                writeTarget,
                readOffset,
                writeOffset,
                size
            );
        }
        let out = call_atomic_ptr_5arg(
            "glCopyBufferSubDataNV",
            &glCopyBufferSubDataNV_p,
            readTarget,
            writeTarget,
            readOffset,
            writeOffset,
            size,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glCopyBufferSubDataNV");
        }
        out
    }
    #[cfg(any(feature = "GL_NV_copy_buffer"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_copy_buffer"))))]
    static glCopyBufferSubDataNV_p: APcv = ap_None();
    /// Tries to load [`glCopyBufferSubDataNV`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    #[cfg(any(feature = "GL_NV_copy_buffer"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_copy_buffer"))))]
    pub unsafe fn glCopyBufferSubDataNV_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glCopyBufferSubDataNV\0",
            &glCopyBufferSubDataNV_p,
        )
    }
    /// Checks if the pointer for [`glCopyBufferSubDataNV`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    #[cfg(any(feature = "GL_NV_copy_buffer"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_copy_buffer"))))]
    pub fn glCopyBufferSubDataNV_is_loaded() -> bool {
        !glCopyBufferSubDataNV_p.load(RELAX).is_null()
    }

    /// [glCopyImageSubData](http://docs.gl/es3/glCopyImageSubData)(srcName, srcTarget, srcLevel, srcX, srcY, srcZ, dstName, dstTarget, dstLevel, dstX, dstY, dstZ, srcWidth, srcHeight, srcDepth)
    /// `srcTarget` group: CopyImageSubDataTarget
    /// `dstTarget` group: CopyImageSubDataTarget
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn glCopyImageSubData(
        srcName: GLuint,
        srcTarget: GLenum,
        srcLevel: GLint,
        srcX: GLint,
        srcY: GLint,
        srcZ: GLint,
        dstName: GLuint,
        dstTarget: GLenum,
        dstLevel: GLint,
        dstX: GLint,
        dstY: GLint,
        dstZ: GLint,
        srcWidth: GLsizei,
        srcHeight: GLsizei,
        srcDepth: GLsizei,
    ) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!("calling glCopyImageSubData({:?}, {:#X}, {:?}, {:?}, {:?}, {:?}, {:?}, {:#X}, {:?}, {:?}, {:?}, {:?}, {:?}, {:?}, {:?});", srcName, srcTarget, srcLevel, srcX, srcY, srcZ, dstName, dstTarget, dstLevel, dstX, dstY, dstZ, srcWidth, srcHeight, srcDepth);
        }
        let out = call_atomic_ptr_15arg(
            "glCopyImageSubData",
            &glCopyImageSubData_p,
            srcName,
            srcTarget,
            srcLevel,
            srcX,
            srcY,
            srcZ,
            dstName,
            dstTarget,
            dstLevel,
            dstX,
            dstY,
            dstZ,
            srcWidth,
            srcHeight,
            srcDepth,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glCopyImageSubData");
        }
        out
    }
    static glCopyImageSubData_p: APcv = ap_None();
    /// Tries to load [`glCopyImageSubData`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    pub unsafe fn glCopyImageSubData_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glCopyImageSubData\0",
            &glCopyImageSubData_p,
        )
    }
    /// Checks if the pointer for [`glCopyImageSubData`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    pub fn glCopyImageSubData_is_loaded() -> bool {
        !glCopyImageSubData_p.load(RELAX).is_null()
    }

    /// [glCopyImageSubDataEXT](http://docs.gl/es3/glCopyImageSubDataEXT)(srcName, srcTarget, srcLevel, srcX, srcY, srcZ, dstName, dstTarget, dstLevel, dstX, dstY, dstZ, srcWidth, srcHeight, srcDepth)
    /// `srcTarget` group: CopyBufferSubDataTarget
    /// `dstTarget` group: CopyBufferSubDataTarget
    /// alias of: [`glCopyImageSubData`]
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    #[cfg(any(feature = "GL_EXT_copy_image"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_copy_image"))))]
    pub unsafe fn glCopyImageSubDataEXT(
        srcName: GLuint,
        srcTarget: GLenum,
        srcLevel: GLint,
        srcX: GLint,
        srcY: GLint,
        srcZ: GLint,
        dstName: GLuint,
        dstTarget: GLenum,
        dstLevel: GLint,
        dstX: GLint,
        dstY: GLint,
        dstZ: GLint,
        srcWidth: GLsizei,
        srcHeight: GLsizei,
        srcDepth: GLsizei,
    ) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!("calling glCopyImageSubDataEXT({:?}, {:#X}, {:?}, {:?}, {:?}, {:?}, {:?}, {:#X}, {:?}, {:?}, {:?}, {:?}, {:?}, {:?}, {:?});", srcName, srcTarget, srcLevel, srcX, srcY, srcZ, dstName, dstTarget, dstLevel, dstX, dstY, dstZ, srcWidth, srcHeight, srcDepth);
        }
        let out = call_atomic_ptr_15arg(
            "glCopyImageSubDataEXT",
            &glCopyImageSubDataEXT_p,
            srcName,
            srcTarget,
            srcLevel,
            srcX,
            srcY,
            srcZ,
            dstName,
            dstTarget,
            dstLevel,
            dstX,
            dstY,
            dstZ,
            srcWidth,
            srcHeight,
            srcDepth,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glCopyImageSubDataEXT");
        }
        out
    }
    #[cfg(any(feature = "GL_EXT_copy_image"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_copy_image"))))]
    static glCopyImageSubDataEXT_p: APcv = ap_None();
    /// Tries to load [`glCopyImageSubDataEXT`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    #[cfg(any(feature = "GL_EXT_copy_image"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_copy_image"))))]
    pub unsafe fn glCopyImageSubDataEXT_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glCopyImageSubDataEXT\0",
            &glCopyImageSubDataEXT_p,
        )
    }
    /// Checks if the pointer for [`glCopyImageSubDataEXT`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    #[cfg(any(feature = "GL_EXT_copy_image"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_copy_image"))))]
    pub fn glCopyImageSubDataEXT_is_loaded() -> bool {
        !glCopyImageSubDataEXT_p.load(RELAX).is_null()
    }

    /// [glCopyImageSubDataOES](http://docs.gl/es3/glCopyImageSubDataOES)(srcName, srcTarget, srcLevel, srcX, srcY, srcZ, dstName, dstTarget, dstLevel, dstX, dstY, dstZ, srcWidth, srcHeight, srcDepth)
    /// `srcTarget` group: CopyBufferSubDataTarget
    /// `dstTarget` group: CopyBufferSubDataTarget
    /// alias of: [`glCopyImageSubData`]
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    #[cfg(any(feature = "GL_OES_copy_image"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_OES_copy_image"))))]
    pub unsafe fn glCopyImageSubDataOES(
        srcName: GLuint,
        srcTarget: GLenum,
        srcLevel: GLint,
        srcX: GLint,
        srcY: GLint,
        srcZ: GLint,
        dstName: GLuint,
        dstTarget: GLenum,
        dstLevel: GLint,
        dstX: GLint,
        dstY: GLint,
        dstZ: GLint,
        srcWidth: GLsizei,
        srcHeight: GLsizei,
        srcDepth: GLsizei,
    ) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!("calling glCopyImageSubDataOES({:?}, {:#X}, {:?}, {:?}, {:?}, {:?}, {:?}, {:#X}, {:?}, {:?}, {:?}, {:?}, {:?}, {:?}, {:?});", srcName, srcTarget, srcLevel, srcX, srcY, srcZ, dstName, dstTarget, dstLevel, dstX, dstY, dstZ, srcWidth, srcHeight, srcDepth);
        }
        let out = call_atomic_ptr_15arg(
            "glCopyImageSubDataOES",
            &glCopyImageSubDataOES_p,
            srcName,
            srcTarget,
            srcLevel,
            srcX,
            srcY,
            srcZ,
            dstName,
            dstTarget,
            dstLevel,
            dstX,
            dstY,
            dstZ,
            srcWidth,
            srcHeight,
            srcDepth,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glCopyImageSubDataOES");
        }
        out
    }
    #[cfg(any(feature = "GL_OES_copy_image"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_OES_copy_image"))))]
    static glCopyImageSubDataOES_p: APcv = ap_None();
    /// Tries to load [`glCopyImageSubDataOES`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    #[cfg(any(feature = "GL_OES_copy_image"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_OES_copy_image"))))]
    pub unsafe fn glCopyImageSubDataOES_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glCopyImageSubDataOES\0",
            &glCopyImageSubDataOES_p,
        )
    }
    /// Checks if the pointer for [`glCopyImageSubDataOES`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    #[cfg(any(feature = "GL_OES_copy_image"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_OES_copy_image"))))]
    pub fn glCopyImageSubDataOES_is_loaded() -> bool {
        !glCopyImageSubDataOES_p.load(RELAX).is_null()
    }

    /// [glCopyPathNV](http://docs.gl/es3/glCopyPathNV)(resultPath, srcPath)
    /// `resultPath` group: Path
    /// `srcPath` group: Path
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    #[cfg(any(feature = "GL_NV_path_rendering"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_path_rendering"))))]
    pub unsafe fn glCopyPathNV(resultPath: GLuint, srcPath: GLuint) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!("calling glCopyPathNV({:?}, {:?});", resultPath, srcPath);
        }
        let out = call_atomic_ptr_2arg("glCopyPathNV", &glCopyPathNV_p, resultPath, srcPath);
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glCopyPathNV");
        }
        out
    }
    #[cfg(any(feature = "GL_NV_path_rendering"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_path_rendering"))))]
    static glCopyPathNV_p: APcv = ap_None();
    /// Tries to load [`glCopyPathNV`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    #[cfg(any(feature = "GL_NV_path_rendering"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_path_rendering"))))]
    pub unsafe fn glCopyPathNV_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(get_proc_address, b"glCopyPathNV\0", &glCopyPathNV_p)
    }
    /// Checks if the pointer for [`glCopyPathNV`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    #[cfg(any(feature = "GL_NV_path_rendering"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_path_rendering"))))]
    pub fn glCopyPathNV_is_loaded() -> bool {
        !glCopyPathNV_p.load(RELAX).is_null()
    }

    /// [glCopyTexImage2D](http://docs.gl/es3/glCopyTexImage2D)(target, level, internalformat, x, y, width, height, border)
    /// `target` group: TextureTarget
    /// `level` group: CheckedInt32
    /// `internalformat` group: InternalFormat
    /// `x` group: WinCoord
    /// `y` group: WinCoord
    /// `border` group: CheckedInt32
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn glCopyTexImage2D(
        target: GLenum,
        level: GLint,
        internalformat: GLenum,
        x: GLint,
        y: GLint,
        width: GLsizei,
        height: GLsizei,
        border: GLint,
    ) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glCopyTexImage2D({:#X}, {:?}, {:#X}, {:?}, {:?}, {:?}, {:?}, {:?});",
                target,
                level,
                internalformat,
                x,
                y,
                width,
                height,
                border
            );
        }
        let out = call_atomic_ptr_8arg(
            "glCopyTexImage2D",
            &glCopyTexImage2D_p,
            target,
            level,
            internalformat,
            x,
            y,
            width,
            height,
            border,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glCopyTexImage2D");
        }
        out
    }
    static glCopyTexImage2D_p: APcv = ap_None();
    /// Tries to load [`glCopyTexImage2D`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    pub unsafe fn glCopyTexImage2D_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(get_proc_address, b"glCopyTexImage2D\0", &glCopyTexImage2D_p)
    }
    /// Checks if the pointer for [`glCopyTexImage2D`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    pub fn glCopyTexImage2D_is_loaded() -> bool {
        !glCopyTexImage2D_p.load(RELAX).is_null()
    }

    /// [glCopyTexSubImage2D](http://docs.gl/es3/glCopyTexSubImage2D)(target, level, xoffset, yoffset, x, y, width, height)
    /// `target` group: TextureTarget
    /// `level` group: CheckedInt32
    /// `xoffset` group: CheckedInt32
    /// `yoffset` group: CheckedInt32
    /// `x` group: WinCoord
    /// `y` group: WinCoord
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn glCopyTexSubImage2D(
        target: GLenum,
        level: GLint,
        xoffset: GLint,
        yoffset: GLint,
        x: GLint,
        y: GLint,
        width: GLsizei,
        height: GLsizei,
    ) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glCopyTexSubImage2D({:#X}, {:?}, {:?}, {:?}, {:?}, {:?}, {:?}, {:?});",
                target,
                level,
                xoffset,
                yoffset,
                x,
                y,
                width,
                height
            );
        }
        let out = call_atomic_ptr_8arg(
            "glCopyTexSubImage2D",
            &glCopyTexSubImage2D_p,
            target,
            level,
            xoffset,
            yoffset,
            x,
            y,
            width,
            height,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glCopyTexSubImage2D");
        }
        out
    }
    static glCopyTexSubImage2D_p: APcv = ap_None();
    /// Tries to load [`glCopyTexSubImage2D`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    pub unsafe fn glCopyTexSubImage2D_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glCopyTexSubImage2D\0",
            &glCopyTexSubImage2D_p,
        )
    }
    /// Checks if the pointer for [`glCopyTexSubImage2D`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    pub fn glCopyTexSubImage2D_is_loaded() -> bool {
        !glCopyTexSubImage2D_p.load(RELAX).is_null()
    }

    /// [glCopyTexSubImage3D](http://docs.gl/es3/glCopyTexSubImage3D)(target, level, xoffset, yoffset, zoffset, x, y, width, height)
    /// `target` group: TextureTarget
    /// `level` group: CheckedInt32
    /// `xoffset` group: CheckedInt32
    /// `yoffset` group: CheckedInt32
    /// `zoffset` group: CheckedInt32
    /// `x` group: WinCoord
    /// `y` group: WinCoord
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn glCopyTexSubImage3D(
        target: GLenum,
        level: GLint,
        xoffset: GLint,
        yoffset: GLint,
        zoffset: GLint,
        x: GLint,
        y: GLint,
        width: GLsizei,
        height: GLsizei,
    ) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glCopyTexSubImage3D({:#X}, {:?}, {:?}, {:?}, {:?}, {:?}, {:?}, {:?}, {:?});",
                target,
                level,
                xoffset,
                yoffset,
                zoffset,
                x,
                y,
                width,
                height
            );
        }
        let out = call_atomic_ptr_9arg(
            "glCopyTexSubImage3D",
            &glCopyTexSubImage3D_p,
            target,
            level,
            xoffset,
            yoffset,
            zoffset,
            x,
            y,
            width,
            height,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glCopyTexSubImage3D");
        }
        out
    }
    static glCopyTexSubImage3D_p: APcv = ap_None();
    /// Tries to load [`glCopyTexSubImage3D`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    pub unsafe fn glCopyTexSubImage3D_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glCopyTexSubImage3D\0",
            &glCopyTexSubImage3D_p,
        )
    }
    /// Checks if the pointer for [`glCopyTexSubImage3D`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    pub fn glCopyTexSubImage3D_is_loaded() -> bool {
        !glCopyTexSubImage3D_p.load(RELAX).is_null()
    }

    /// [glCopyTexSubImage3DOES](http://docs.gl/es3/glCopyTexSubImage3DOES)(target, level, xoffset, yoffset, zoffset, x, y, width, height)
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    #[cfg(any(feature = "GL_OES_texture_3D"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_OES_texture_3D"))))]
    pub unsafe fn glCopyTexSubImage3DOES(
        target: GLenum,
        level: GLint,
        xoffset: GLint,
        yoffset: GLint,
        zoffset: GLint,
        x: GLint,
        y: GLint,
        width: GLsizei,
        height: GLsizei,
    ) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glCopyTexSubImage3DOES({:#X}, {:?}, {:?}, {:?}, {:?}, {:?}, {:?}, {:?}, {:?});",
                target,
                level,
                xoffset,
                yoffset,
                zoffset,
                x,
                y,
                width,
                height
            );
        }
        let out = call_atomic_ptr_9arg(
            "glCopyTexSubImage3DOES",
            &glCopyTexSubImage3DOES_p,
            target,
            level,
            xoffset,
            yoffset,
            zoffset,
            x,
            y,
            width,
            height,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glCopyTexSubImage3DOES");
        }
        out
    }
    #[cfg(any(feature = "GL_OES_texture_3D"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_OES_texture_3D"))))]
    static glCopyTexSubImage3DOES_p: APcv = ap_None();
    /// Tries to load [`glCopyTexSubImage3DOES`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    #[cfg(any(feature = "GL_OES_texture_3D"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_OES_texture_3D"))))]
    pub unsafe fn glCopyTexSubImage3DOES_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glCopyTexSubImage3DOES\0",
            &glCopyTexSubImage3DOES_p,
        )
    }
    /// Checks if the pointer for [`glCopyTexSubImage3DOES`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    #[cfg(any(feature = "GL_OES_texture_3D"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_OES_texture_3D"))))]
    pub fn glCopyTexSubImage3DOES_is_loaded() -> bool {
        !glCopyTexSubImage3DOES_p.load(RELAX).is_null()
    }

    /// [glCopyTextureLevelsAPPLE](http://docs.gl/es3/glCopyTextureLevelsAPPLE)(destinationTexture, sourceTexture, sourceBaseLevel, sourceLevelCount)
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    #[cfg(any(feature = "GL_APPLE_copy_texture_levels"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_APPLE_copy_texture_levels"))))]
    pub unsafe fn glCopyTextureLevelsAPPLE(
        destinationTexture: GLuint,
        sourceTexture: GLuint,
        sourceBaseLevel: GLint,
        sourceLevelCount: GLsizei,
    ) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glCopyTextureLevelsAPPLE({:?}, {:?}, {:?}, {:?});",
                destinationTexture,
                sourceTexture,
                sourceBaseLevel,
                sourceLevelCount
            );
        }
        let out = call_atomic_ptr_4arg(
            "glCopyTextureLevelsAPPLE",
            &glCopyTextureLevelsAPPLE_p,
            destinationTexture,
            sourceTexture,
            sourceBaseLevel,
            sourceLevelCount,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glCopyTextureLevelsAPPLE");
        }
        out
    }
    #[cfg(any(feature = "GL_APPLE_copy_texture_levels"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_APPLE_copy_texture_levels"))))]
    static glCopyTextureLevelsAPPLE_p: APcv = ap_None();
    /// Tries to load [`glCopyTextureLevelsAPPLE`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    #[cfg(any(feature = "GL_APPLE_copy_texture_levels"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_APPLE_copy_texture_levels"))))]
    pub unsafe fn glCopyTextureLevelsAPPLE_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glCopyTextureLevelsAPPLE\0",
            &glCopyTextureLevelsAPPLE_p,
        )
    }
    /// Checks if the pointer for [`glCopyTextureLevelsAPPLE`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    #[cfg(any(feature = "GL_APPLE_copy_texture_levels"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_APPLE_copy_texture_levels"))))]
    pub fn glCopyTextureLevelsAPPLE_is_loaded() -> bool {
        !glCopyTextureLevelsAPPLE_p.load(RELAX).is_null()
    }

    /// [glCoverFillPathInstancedNV](http://docs.gl/es3/glCoverFillPathInstancedNV)(numPaths, pathNameType, paths, pathBase, coverMode, transformType, transformValues)
    /// `pathNameType` group: PathElementType
    /// `paths` group: PathElement
    /// `paths` len: COMPSIZE(numPaths,pathNameType,paths)
    /// `pathBase` group: Path
    /// `coverMode` group: PathCoverMode
    /// `transformType` group: PathTransformType
    /// `transformValues` len: COMPSIZE(numPaths,transformType)
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    #[cfg(any(feature = "GL_NV_path_rendering"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_path_rendering"))))]
    pub unsafe fn glCoverFillPathInstancedNV(
        numPaths: GLsizei,
        pathNameType: GLenum,
        paths: *const c_void,
        pathBase: GLuint,
        coverMode: GLenum,
        transformType: GLenum,
        transformValues: *const GLfloat,
    ) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glCoverFillPathInstancedNV({:?}, {:#X}, {:p}, {:?}, {:#X}, {:#X}, {:p});",
                numPaths,
                pathNameType,
                paths,
                pathBase,
                coverMode,
                transformType,
                transformValues
            );
        }
        let out = call_atomic_ptr_7arg(
            "glCoverFillPathInstancedNV",
            &glCoverFillPathInstancedNV_p,
            numPaths,
            pathNameType,
            paths,
            pathBase,
            coverMode,
            transformType,
            transformValues,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glCoverFillPathInstancedNV");
        }
        out
    }
    #[cfg(any(feature = "GL_NV_path_rendering"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_path_rendering"))))]
    static glCoverFillPathInstancedNV_p: APcv = ap_None();
    /// Tries to load [`glCoverFillPathInstancedNV`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    #[cfg(any(feature = "GL_NV_path_rendering"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_path_rendering"))))]
    pub unsafe fn glCoverFillPathInstancedNV_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glCoverFillPathInstancedNV\0",
            &glCoverFillPathInstancedNV_p,
        )
    }
    /// Checks if the pointer for [`glCoverFillPathInstancedNV`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    #[cfg(any(feature = "GL_NV_path_rendering"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_path_rendering"))))]
    pub fn glCoverFillPathInstancedNV_is_loaded() -> bool {
        !glCoverFillPathInstancedNV_p.load(RELAX).is_null()
    }

    /// [glCoverFillPathNV](http://docs.gl/es3/glCoverFillPathNV)(path, coverMode)
    /// `path` group: Path
    /// `coverMode` group: PathCoverMode
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    #[cfg(any(feature = "GL_NV_path_rendering"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_path_rendering"))))]
    pub unsafe fn glCoverFillPathNV(path: GLuint, coverMode: GLenum) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!("calling glCoverFillPathNV({:?}, {:#X});", path, coverMode);
        }
        let out = call_atomic_ptr_2arg("glCoverFillPathNV", &glCoverFillPathNV_p, path, coverMode);
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glCoverFillPathNV");
        }
        out
    }
    #[cfg(any(feature = "GL_NV_path_rendering"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_path_rendering"))))]
    static glCoverFillPathNV_p: APcv = ap_None();
    /// Tries to load [`glCoverFillPathNV`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    #[cfg(any(feature = "GL_NV_path_rendering"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_path_rendering"))))]
    pub unsafe fn glCoverFillPathNV_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glCoverFillPathNV\0",
            &glCoverFillPathNV_p,
        )
    }
    /// Checks if the pointer for [`glCoverFillPathNV`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    #[cfg(any(feature = "GL_NV_path_rendering"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_path_rendering"))))]
    pub fn glCoverFillPathNV_is_loaded() -> bool {
        !glCoverFillPathNV_p.load(RELAX).is_null()
    }

    /// [glCoverStrokePathInstancedNV](http://docs.gl/es3/glCoverStrokePathInstancedNV)(numPaths, pathNameType, paths, pathBase, coverMode, transformType, transformValues)
    /// `pathNameType` group: PathElementType
    /// `paths` group: PathElement
    /// `paths` len: COMPSIZE(numPaths,pathNameType,paths)
    /// `pathBase` group: Path
    /// `coverMode` group: PathCoverMode
    /// `transformType` group: PathTransformType
    /// `transformValues` len: COMPSIZE(numPaths,transformType)
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    #[cfg(any(feature = "GL_NV_path_rendering"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_path_rendering"))))]
    pub unsafe fn glCoverStrokePathInstancedNV(
        numPaths: GLsizei,
        pathNameType: GLenum,
        paths: *const c_void,
        pathBase: GLuint,
        coverMode: GLenum,
        transformType: GLenum,
        transformValues: *const GLfloat,
    ) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glCoverStrokePathInstancedNV({:?}, {:#X}, {:p}, {:?}, {:#X}, {:#X}, {:p});",
                numPaths,
                pathNameType,
                paths,
                pathBase,
                coverMode,
                transformType,
                transformValues
            );
        }
        let out = call_atomic_ptr_7arg(
            "glCoverStrokePathInstancedNV",
            &glCoverStrokePathInstancedNV_p,
            numPaths,
            pathNameType,
            paths,
            pathBase,
            coverMode,
            transformType,
            transformValues,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glCoverStrokePathInstancedNV");
        }
        out
    }
    #[cfg(any(feature = "GL_NV_path_rendering"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_path_rendering"))))]
    static glCoverStrokePathInstancedNV_p: APcv = ap_None();
    /// Tries to load [`glCoverStrokePathInstancedNV`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    #[cfg(any(feature = "GL_NV_path_rendering"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_path_rendering"))))]
    pub unsafe fn glCoverStrokePathInstancedNV_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glCoverStrokePathInstancedNV\0",
            &glCoverStrokePathInstancedNV_p,
        )
    }
    /// Checks if the pointer for [`glCoverStrokePathInstancedNV`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    #[cfg(any(feature = "GL_NV_path_rendering"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_path_rendering"))))]
    pub fn glCoverStrokePathInstancedNV_is_loaded() -> bool {
        !glCoverStrokePathInstancedNV_p.load(RELAX).is_null()
    }

    /// [glCoverStrokePathNV](http://docs.gl/es3/glCoverStrokePathNV)(path, coverMode)
    /// `path` group: Path
    /// `coverMode` group: PathCoverMode
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    #[cfg(any(feature = "GL_NV_path_rendering"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_path_rendering"))))]
    pub unsafe fn glCoverStrokePathNV(path: GLuint, coverMode: GLenum) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!("calling glCoverStrokePathNV({:?}, {:#X});", path, coverMode);
        }
        let out = call_atomic_ptr_2arg(
            "glCoverStrokePathNV",
            &glCoverStrokePathNV_p,
            path,
            coverMode,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glCoverStrokePathNV");
        }
        out
    }
    #[cfg(any(feature = "GL_NV_path_rendering"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_path_rendering"))))]
    static glCoverStrokePathNV_p: APcv = ap_None();
    /// Tries to load [`glCoverStrokePathNV`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    #[cfg(any(feature = "GL_NV_path_rendering"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_path_rendering"))))]
    pub unsafe fn glCoverStrokePathNV_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glCoverStrokePathNV\0",
            &glCoverStrokePathNV_p,
        )
    }
    /// Checks if the pointer for [`glCoverStrokePathNV`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    #[cfg(any(feature = "GL_NV_path_rendering"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_path_rendering"))))]
    pub fn glCoverStrokePathNV_is_loaded() -> bool {
        !glCoverStrokePathNV_p.load(RELAX).is_null()
    }

    /// [glCoverageMaskNV](http://docs.gl/es3/glCoverageMaskNV)(mask)
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    #[cfg(any(feature = "GL_NV_coverage_sample"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_coverage_sample"))))]
    pub unsafe fn glCoverageMaskNV(mask: GLboolean) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!("calling glCoverageMaskNV({:?});", mask);
        }
        let out = call_atomic_ptr_1arg("glCoverageMaskNV", &glCoverageMaskNV_p, mask);
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glCoverageMaskNV");
        }
        out
    }
    #[cfg(any(feature = "GL_NV_coverage_sample"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_coverage_sample"))))]
    static glCoverageMaskNV_p: APcv = ap_None();
    /// Tries to load [`glCoverageMaskNV`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    #[cfg(any(feature = "GL_NV_coverage_sample"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_coverage_sample"))))]
    pub unsafe fn glCoverageMaskNV_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(get_proc_address, b"glCoverageMaskNV\0", &glCoverageMaskNV_p)
    }
    /// Checks if the pointer for [`glCoverageMaskNV`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    #[cfg(any(feature = "GL_NV_coverage_sample"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_coverage_sample"))))]
    pub fn glCoverageMaskNV_is_loaded() -> bool {
        !glCoverageMaskNV_p.load(RELAX).is_null()
    }

    /// [glCoverageModulationNV](http://docs.gl/es3/glCoverageModulationNV)(components)
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    #[cfg(any(feature = "GL_NV_framebuffer_mixed_samples"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_framebuffer_mixed_samples"))))]
    pub unsafe fn glCoverageModulationNV(components: GLenum) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!("calling glCoverageModulationNV({:#X});", components);
        }
        let out = call_atomic_ptr_1arg(
            "glCoverageModulationNV",
            &glCoverageModulationNV_p,
            components,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glCoverageModulationNV");
        }
        out
    }
    #[cfg(any(feature = "GL_NV_framebuffer_mixed_samples"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_framebuffer_mixed_samples"))))]
    static glCoverageModulationNV_p: APcv = ap_None();
    /// Tries to load [`glCoverageModulationNV`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    #[cfg(any(feature = "GL_NV_framebuffer_mixed_samples"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_framebuffer_mixed_samples"))))]
    pub unsafe fn glCoverageModulationNV_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glCoverageModulationNV\0",
            &glCoverageModulationNV_p,
        )
    }
    /// Checks if the pointer for [`glCoverageModulationNV`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    #[cfg(any(feature = "GL_NV_framebuffer_mixed_samples"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_framebuffer_mixed_samples"))))]
    pub fn glCoverageModulationNV_is_loaded() -> bool {
        !glCoverageModulationNV_p.load(RELAX).is_null()
    }

    /// [glCoverageModulationTableNV](http://docs.gl/es3/glCoverageModulationTableNV)(n, v)
    /// `v` len: n
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    #[cfg(any(feature = "GL_NV_framebuffer_mixed_samples"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_framebuffer_mixed_samples"))))]
    pub unsafe fn glCoverageModulationTableNV(n: GLsizei, v: *const GLfloat) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!("calling glCoverageModulationTableNV({:?}, {:p});", n, v);
        }
        let out = call_atomic_ptr_2arg(
            "glCoverageModulationTableNV",
            &glCoverageModulationTableNV_p,
            n,
            v,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glCoverageModulationTableNV");
        }
        out
    }
    #[cfg(any(feature = "GL_NV_framebuffer_mixed_samples"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_framebuffer_mixed_samples"))))]
    static glCoverageModulationTableNV_p: APcv = ap_None();
    /// Tries to load [`glCoverageModulationTableNV`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    #[cfg(any(feature = "GL_NV_framebuffer_mixed_samples"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_framebuffer_mixed_samples"))))]
    pub unsafe fn glCoverageModulationTableNV_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glCoverageModulationTableNV\0",
            &glCoverageModulationTableNV_p,
        )
    }
    /// Checks if the pointer for [`glCoverageModulationTableNV`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    #[cfg(any(feature = "GL_NV_framebuffer_mixed_samples"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_framebuffer_mixed_samples"))))]
    pub fn glCoverageModulationTableNV_is_loaded() -> bool {
        !glCoverageModulationTableNV_p.load(RELAX).is_null()
    }

    /// [glCoverageOperationNV](http://docs.gl/es3/glCoverageOperationNV)(operation)
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    #[cfg(any(feature = "GL_NV_coverage_sample"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_coverage_sample"))))]
    pub unsafe fn glCoverageOperationNV(operation: GLenum) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!("calling glCoverageOperationNV({:#X});", operation);
        }
        let out =
            call_atomic_ptr_1arg("glCoverageOperationNV", &glCoverageOperationNV_p, operation);
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glCoverageOperationNV");
        }
        out
    }
    #[cfg(any(feature = "GL_NV_coverage_sample"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_coverage_sample"))))]
    static glCoverageOperationNV_p: APcv = ap_None();
    /// Tries to load [`glCoverageOperationNV`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    #[cfg(any(feature = "GL_NV_coverage_sample"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_coverage_sample"))))]
    pub unsafe fn glCoverageOperationNV_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glCoverageOperationNV\0",
            &glCoverageOperationNV_p,
        )
    }
    /// Checks if the pointer for [`glCoverageOperationNV`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    #[cfg(any(feature = "GL_NV_coverage_sample"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_coverage_sample"))))]
    pub fn glCoverageOperationNV_is_loaded() -> bool {
        !glCoverageOperationNV_p.load(RELAX).is_null()
    }

    /// [glCreateMemoryObjectsEXT](http://docs.gl/es3/glCreateMemoryObjectsEXT)(n, memoryObjects)
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    #[cfg(any(feature = "GL_EXT_memory_object"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_memory_object"))))]
    pub unsafe fn glCreateMemoryObjectsEXT(n: GLsizei, memoryObjects: *mut GLuint) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glCreateMemoryObjectsEXT({:?}, {:p});",
                n,
                memoryObjects
            );
        }
        let out = call_atomic_ptr_2arg(
            "glCreateMemoryObjectsEXT",
            &glCreateMemoryObjectsEXT_p,
            n,
            memoryObjects,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glCreateMemoryObjectsEXT");
        }
        out
    }
    #[cfg(any(feature = "GL_EXT_memory_object"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_memory_object"))))]
    static glCreateMemoryObjectsEXT_p: APcv = ap_None();
    /// Tries to load [`glCreateMemoryObjectsEXT`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    #[cfg(any(feature = "GL_EXT_memory_object"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_memory_object"))))]
    pub unsafe fn glCreateMemoryObjectsEXT_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glCreateMemoryObjectsEXT\0",
            &glCreateMemoryObjectsEXT_p,
        )
    }
    /// Checks if the pointer for [`glCreateMemoryObjectsEXT`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    #[cfg(any(feature = "GL_EXT_memory_object"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_memory_object"))))]
    pub fn glCreateMemoryObjectsEXT_is_loaded() -> bool {
        !glCreateMemoryObjectsEXT_p.load(RELAX).is_null()
    }

    /// [glCreatePerfQueryINTEL](http://docs.gl/es3/glCreatePerfQueryINTEL)(queryId, queryHandle)
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    #[cfg(any(feature = "GL_INTEL_performance_query"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_INTEL_performance_query"))))]
    pub unsafe fn glCreatePerfQueryINTEL(queryId: GLuint, queryHandle: *mut GLuint) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glCreatePerfQueryINTEL({:?}, {:p});",
                queryId,
                queryHandle
            );
        }
        let out = call_atomic_ptr_2arg(
            "glCreatePerfQueryINTEL",
            &glCreatePerfQueryINTEL_p,
            queryId,
            queryHandle,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glCreatePerfQueryINTEL");
        }
        out
    }
    #[cfg(any(feature = "GL_INTEL_performance_query"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_INTEL_performance_query"))))]
    static glCreatePerfQueryINTEL_p: APcv = ap_None();
    /// Tries to load [`glCreatePerfQueryINTEL`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    #[cfg(any(feature = "GL_INTEL_performance_query"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_INTEL_performance_query"))))]
    pub unsafe fn glCreatePerfQueryINTEL_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glCreatePerfQueryINTEL\0",
            &glCreatePerfQueryINTEL_p,
        )
    }
    /// Checks if the pointer for [`glCreatePerfQueryINTEL`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    #[cfg(any(feature = "GL_INTEL_performance_query"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_INTEL_performance_query"))))]
    pub fn glCreatePerfQueryINTEL_is_loaded() -> bool {
        !glCreatePerfQueryINTEL_p.load(RELAX).is_null()
    }

    /// [glCreateProgram](http://docs.gl/es3/glCreateProgram)()
    /// return value class: program
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn glCreateProgram() -> GLuint {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!("calling glCreateProgram();",);
        }
        let out = call_atomic_ptr_0arg("glCreateProgram", &glCreateProgram_p);
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glCreateProgram");
        }
        out
    }
    static glCreateProgram_p: APcv = ap_None();
    /// Tries to load [`glCreateProgram`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    pub unsafe fn glCreateProgram_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(get_proc_address, b"glCreateProgram\0", &glCreateProgram_p)
    }
    /// Checks if the pointer for [`glCreateProgram`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    pub fn glCreateProgram_is_loaded() -> bool {
        !glCreateProgram_p.load(RELAX).is_null()
    }

    /// [glCreateSemaphoresNV](http://docs.gl/es3/glCreateSemaphoresNV)(n, semaphores)
    /// `semaphores` len: n
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    #[cfg(any(feature = "GL_NV_timeline_semaphore"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_timeline_semaphore"))))]
    pub unsafe fn glCreateSemaphoresNV(n: GLsizei, semaphores: *mut GLuint) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!("calling glCreateSemaphoresNV({:?}, {:p});", n, semaphores);
        }
        let out = call_atomic_ptr_2arg(
            "glCreateSemaphoresNV",
            &glCreateSemaphoresNV_p,
            n,
            semaphores,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glCreateSemaphoresNV");
        }
        out
    }
    #[cfg(any(feature = "GL_NV_timeline_semaphore"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_timeline_semaphore"))))]
    static glCreateSemaphoresNV_p: APcv = ap_None();
    /// Tries to load [`glCreateSemaphoresNV`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    #[cfg(any(feature = "GL_NV_timeline_semaphore"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_timeline_semaphore"))))]
    pub unsafe fn glCreateSemaphoresNV_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glCreateSemaphoresNV\0",
            &glCreateSemaphoresNV_p,
        )
    }
    /// Checks if the pointer for [`glCreateSemaphoresNV`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    #[cfg(any(feature = "GL_NV_timeline_semaphore"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_timeline_semaphore"))))]
    pub fn glCreateSemaphoresNV_is_loaded() -> bool {
        !glCreateSemaphoresNV_p.load(RELAX).is_null()
    }

    /// [glCreateShader](http://docs.gl/es3/glCreateShader)(type_)
    /// `type_` group: ShaderType
    /// return value class: shader
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn glCreateShader(type_: GLenum) -> GLuint {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!("calling glCreateShader({:#X});", type_);
        }
        let out = call_atomic_ptr_1arg("glCreateShader", &glCreateShader_p, type_);
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glCreateShader");
        }
        out
    }
    static glCreateShader_p: APcv = ap_None();
    /// Tries to load [`glCreateShader`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    pub unsafe fn glCreateShader_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(get_proc_address, b"glCreateShader\0", &glCreateShader_p)
    }
    /// Checks if the pointer for [`glCreateShader`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    pub fn glCreateShader_is_loaded() -> bool {
        !glCreateShader_p.load(RELAX).is_null()
    }

    /// [glCreateShaderProgramv](http://docs.gl/es3/glCreateShaderProgramv)(type_, count, strings)
    /// `type_` group: ShaderType
    /// `strings` len: count
    /// return value class: program
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn glCreateShaderProgramv(
        type_: GLenum,
        count: GLsizei,
        strings: *const *const GLchar,
    ) -> GLuint {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glCreateShaderProgramv({:#X}, {:?}, {:p});",
                type_,
                count,
                strings
            );
        }
        let out = call_atomic_ptr_3arg(
            "glCreateShaderProgramv",
            &glCreateShaderProgramv_p,
            type_,
            count,
            strings,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glCreateShaderProgramv");
        }
        out
    }
    static glCreateShaderProgramv_p: APcv = ap_None();
    /// Tries to load [`glCreateShaderProgramv`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    pub unsafe fn glCreateShaderProgramv_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glCreateShaderProgramv\0",
            &glCreateShaderProgramv_p,
        )
    }
    /// Checks if the pointer for [`glCreateShaderProgramv`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    pub fn glCreateShaderProgramv_is_loaded() -> bool {
        !glCreateShaderProgramv_p.load(RELAX).is_null()
    }

    /// [glCreateShaderProgramvEXT](http://docs.gl/es3/glCreateShaderProgramvEXT)(type_, count, strings)
    /// `type_` group: ShaderType
    /// `strings` len: count
    /// return value class: program
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    #[cfg(any(feature = "GL_EXT_separate_shader_objects"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_separate_shader_objects"))))]
    pub unsafe fn glCreateShaderProgramvEXT(
        type_: GLenum,
        count: GLsizei,
        strings: *const GLchar,
    ) -> GLuint {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glCreateShaderProgramvEXT({:#X}, {:?}, {:p});",
                type_,
                count,
                strings
            );
        }
        let out = call_atomic_ptr_3arg(
            "glCreateShaderProgramvEXT",
            &glCreateShaderProgramvEXT_p,
            type_,
            count,
            strings,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glCreateShaderProgramvEXT");
        }
        out
    }
    #[cfg(any(feature = "GL_EXT_separate_shader_objects"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_separate_shader_objects"))))]
    static glCreateShaderProgramvEXT_p: APcv = ap_None();
    /// Tries to load [`glCreateShaderProgramvEXT`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    #[cfg(any(feature = "GL_EXT_separate_shader_objects"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_separate_shader_objects"))))]
    pub unsafe fn glCreateShaderProgramvEXT_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glCreateShaderProgramvEXT\0",
            &glCreateShaderProgramvEXT_p,
        )
    }
    /// Checks if the pointer for [`glCreateShaderProgramvEXT`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    #[cfg(any(feature = "GL_EXT_separate_shader_objects"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_separate_shader_objects"))))]
    pub fn glCreateShaderProgramvEXT_is_loaded() -> bool {
        !glCreateShaderProgramvEXT_p.load(RELAX).is_null()
    }

    /// [glCullFace](http://docs.gl/es3/glCullFace)(mode)
    /// `mode` group: CullFaceMode
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn glCullFace(mode: GLenum) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!("calling glCullFace({:#X});", mode);
        }
        let out = call_atomic_ptr_1arg("glCullFace", &glCullFace_p, mode);
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glCullFace");
        }
        out
    }
    static glCullFace_p: APcv = ap_None();
    /// Tries to load [`glCullFace`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    pub unsafe fn glCullFace_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(get_proc_address, b"glCullFace\0", &glCullFace_p)
    }
    /// Checks if the pointer for [`glCullFace`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    pub fn glCullFace_is_loaded() -> bool {
        !glCullFace_p.load(RELAX).is_null()
    }

    /// [glDebugMessageCallback](http://docs.gl/es3/glDebugMessageCallback)(callback, userParam)
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn glDebugMessageCallback(callback: GLDEBUGPROC, userParam: *const c_void) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glDebugMessageCallback({:?}, {:p});",
                transmute::<_, Option<fn()>>(callback),
                userParam
            );
        }
        let out = call_atomic_ptr_2arg(
            "glDebugMessageCallback",
            &glDebugMessageCallback_p,
            callback,
            userParam,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glDebugMessageCallback");
        }
        out
    }
    static glDebugMessageCallback_p: APcv = ap_None();
    /// Tries to load [`glDebugMessageCallback`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    pub unsafe fn glDebugMessageCallback_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glDebugMessageCallback\0",
            &glDebugMessageCallback_p,
        )
    }
    /// Checks if the pointer for [`glDebugMessageCallback`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    pub fn glDebugMessageCallback_is_loaded() -> bool {
        !glDebugMessageCallback_p.load(RELAX).is_null()
    }

    /// [glDebugMessageCallbackKHR](http://docs.gl/es3/glDebugMessageCallbackKHR)(callback, userParam)
    /// alias of: [`glDebugMessageCallback`]
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    #[cfg(any(feature = "GL_KHR_debug"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_KHR_debug"))))]
    pub unsafe fn glDebugMessageCallbackKHR(callback: GLDEBUGPROCKHR, userParam: *const c_void) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glDebugMessageCallbackKHR({:?}, {:p});",
                transmute::<_, Option<fn()>>(callback),
                userParam
            );
        }
        let out = call_atomic_ptr_2arg(
            "glDebugMessageCallbackKHR",
            &glDebugMessageCallbackKHR_p,
            callback,
            userParam,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glDebugMessageCallbackKHR");
        }
        out
    }
    #[cfg(any(feature = "GL_KHR_debug"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_KHR_debug"))))]
    static glDebugMessageCallbackKHR_p: APcv = ap_None();
    /// Tries to load [`glDebugMessageCallbackKHR`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    #[cfg(any(feature = "GL_KHR_debug"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_KHR_debug"))))]
    pub unsafe fn glDebugMessageCallbackKHR_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glDebugMessageCallbackKHR\0",
            &glDebugMessageCallbackKHR_p,
        )
    }
    /// Checks if the pointer for [`glDebugMessageCallbackKHR`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    #[cfg(any(feature = "GL_KHR_debug"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_KHR_debug"))))]
    pub fn glDebugMessageCallbackKHR_is_loaded() -> bool {
        !glDebugMessageCallbackKHR_p.load(RELAX).is_null()
    }

    /// [glDebugMessageControl](http://docs.gl/es3/glDebugMessageControl)(source, type_, severity, count, ids, enabled)
    /// `source` group: DebugSource
    /// `type_` group: DebugType
    /// `severity` group: DebugSeverity
    /// `ids` len: count
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn glDebugMessageControl(
        source: GLenum,
        type_: GLenum,
        severity: GLenum,
        count: GLsizei,
        ids: *const GLuint,
        enabled: GLboolean,
    ) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glDebugMessageControl({:#X}, {:#X}, {:#X}, {:?}, {:p}, {:?});",
                source,
                type_,
                severity,
                count,
                ids,
                enabled
            );
        }
        let out = call_atomic_ptr_6arg(
            "glDebugMessageControl",
            &glDebugMessageControl_p,
            source,
            type_,
            severity,
            count,
            ids,
            enabled,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glDebugMessageControl");
        }
        out
    }
    static glDebugMessageControl_p: APcv = ap_None();
    /// Tries to load [`glDebugMessageControl`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    pub unsafe fn glDebugMessageControl_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glDebugMessageControl\0",
            &glDebugMessageControl_p,
        )
    }
    /// Checks if the pointer for [`glDebugMessageControl`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    pub fn glDebugMessageControl_is_loaded() -> bool {
        !glDebugMessageControl_p.load(RELAX).is_null()
    }

    /// [glDebugMessageControlKHR](http://docs.gl/es3/glDebugMessageControlKHR)(source, type_, severity, count, ids, enabled)
    /// `source` group: DebugSource
    /// `type_` group: DebugType
    /// `severity` group: DebugSeverity
    /// alias of: [`glDebugMessageControl`]
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    #[cfg(any(feature = "GL_KHR_debug"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_KHR_debug"))))]
    pub unsafe fn glDebugMessageControlKHR(
        source: GLenum,
        type_: GLenum,
        severity: GLenum,
        count: GLsizei,
        ids: *const GLuint,
        enabled: GLboolean,
    ) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glDebugMessageControlKHR({:#X}, {:#X}, {:#X}, {:?}, {:p}, {:?});",
                source,
                type_,
                severity,
                count,
                ids,
                enabled
            );
        }
        let out = call_atomic_ptr_6arg(
            "glDebugMessageControlKHR",
            &glDebugMessageControlKHR_p,
            source,
            type_,
            severity,
            count,
            ids,
            enabled,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glDebugMessageControlKHR");
        }
        out
    }
    #[cfg(any(feature = "GL_KHR_debug"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_KHR_debug"))))]
    static glDebugMessageControlKHR_p: APcv = ap_None();
    /// Tries to load [`glDebugMessageControlKHR`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    #[cfg(any(feature = "GL_KHR_debug"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_KHR_debug"))))]
    pub unsafe fn glDebugMessageControlKHR_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glDebugMessageControlKHR\0",
            &glDebugMessageControlKHR_p,
        )
    }
    /// Checks if the pointer for [`glDebugMessageControlKHR`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    #[cfg(any(feature = "GL_KHR_debug"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_KHR_debug"))))]
    pub fn glDebugMessageControlKHR_is_loaded() -> bool {
        !glDebugMessageControlKHR_p.load(RELAX).is_null()
    }

    /// [glDebugMessageInsert](http://docs.gl/es3/glDebugMessageInsert)(source, type_, id, severity, length, buf)
    /// `source` group: DebugSource
    /// `type_` group: DebugType
    /// `severity` group: DebugSeverity
    /// `buf` len: COMPSIZE(buf,length)
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn glDebugMessageInsert(
        source: GLenum,
        type_: GLenum,
        id: GLuint,
        severity: GLenum,
        length: GLsizei,
        buf: *const GLchar,
    ) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glDebugMessageInsert({:#X}, {:#X}, {:?}, {:#X}, {:?}, {:p});",
                source,
                type_,
                id,
                severity,
                length,
                buf
            );
        }
        let out = call_atomic_ptr_6arg(
            "glDebugMessageInsert",
            &glDebugMessageInsert_p,
            source,
            type_,
            id,
            severity,
            length,
            buf,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glDebugMessageInsert");
        }
        out
    }
    static glDebugMessageInsert_p: APcv = ap_None();
    /// Tries to load [`glDebugMessageInsert`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    pub unsafe fn glDebugMessageInsert_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glDebugMessageInsert\0",
            &glDebugMessageInsert_p,
        )
    }
    /// Checks if the pointer for [`glDebugMessageInsert`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    pub fn glDebugMessageInsert_is_loaded() -> bool {
        !glDebugMessageInsert_p.load(RELAX).is_null()
    }

    /// [glDebugMessageInsertKHR](http://docs.gl/es3/glDebugMessageInsertKHR)(source, type_, id, severity, length, buf)
    /// `source` group: DebugSource
    /// `type_` group: DebugType
    /// `severity` group: DebugSeverity
    /// alias of: [`glDebugMessageInsert`]
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    #[cfg(any(feature = "GL_KHR_debug"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_KHR_debug"))))]
    pub unsafe fn glDebugMessageInsertKHR(
        source: GLenum,
        type_: GLenum,
        id: GLuint,
        severity: GLenum,
        length: GLsizei,
        buf: *const GLchar,
    ) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glDebugMessageInsertKHR({:#X}, {:#X}, {:?}, {:#X}, {:?}, {:p});",
                source,
                type_,
                id,
                severity,
                length,
                buf
            );
        }
        let out = call_atomic_ptr_6arg(
            "glDebugMessageInsertKHR",
            &glDebugMessageInsertKHR_p,
            source,
            type_,
            id,
            severity,
            length,
            buf,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glDebugMessageInsertKHR");
        }
        out
    }
    #[cfg(any(feature = "GL_KHR_debug"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_KHR_debug"))))]
    static glDebugMessageInsertKHR_p: APcv = ap_None();
    /// Tries to load [`glDebugMessageInsertKHR`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    #[cfg(any(feature = "GL_KHR_debug"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_KHR_debug"))))]
    pub unsafe fn glDebugMessageInsertKHR_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glDebugMessageInsertKHR\0",
            &glDebugMessageInsertKHR_p,
        )
    }
    /// Checks if the pointer for [`glDebugMessageInsertKHR`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    #[cfg(any(feature = "GL_KHR_debug"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_KHR_debug"))))]
    pub fn glDebugMessageInsertKHR_is_loaded() -> bool {
        !glDebugMessageInsertKHR_p.load(RELAX).is_null()
    }

    /// [glDeleteBuffers](http://docs.gl/es3/glDeleteBuffers)(n, buffers)
    /// `buffers` len: n
    /// `buffers` class: buffer
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn glDeleteBuffers(n: GLsizei, buffers: *const GLuint) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!("calling glDeleteBuffers({:?}, {:p});", n, buffers);
        }
        let out = call_atomic_ptr_2arg("glDeleteBuffers", &glDeleteBuffers_p, n, buffers);
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glDeleteBuffers");
        }
        out
    }
    static glDeleteBuffers_p: APcv = ap_None();
    /// Tries to load [`glDeleteBuffers`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    pub unsafe fn glDeleteBuffers_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(get_proc_address, b"glDeleteBuffers\0", &glDeleteBuffers_p)
    }
    /// Checks if the pointer for [`glDeleteBuffers`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    pub fn glDeleteBuffers_is_loaded() -> bool {
        !glDeleteBuffers_p.load(RELAX).is_null()
    }

    /// [glDeleteFencesNV](http://docs.gl/es3/glDeleteFencesNV)(n, fences)
    /// `fences` group: FenceNV
    /// `fences` len: n
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    #[cfg(any(feature = "GL_NV_fence"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_fence"))))]
    pub unsafe fn glDeleteFencesNV(n: GLsizei, fences: *const GLuint) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!("calling glDeleteFencesNV({:?}, {:p});", n, fences);
        }
        let out = call_atomic_ptr_2arg("glDeleteFencesNV", &glDeleteFencesNV_p, n, fences);
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glDeleteFencesNV");
        }
        out
    }
    #[cfg(any(feature = "GL_NV_fence"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_fence"))))]
    static glDeleteFencesNV_p: APcv = ap_None();
    /// Tries to load [`glDeleteFencesNV`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    #[cfg(any(feature = "GL_NV_fence"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_fence"))))]
    pub unsafe fn glDeleteFencesNV_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(get_proc_address, b"glDeleteFencesNV\0", &glDeleteFencesNV_p)
    }
    /// Checks if the pointer for [`glDeleteFencesNV`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    #[cfg(any(feature = "GL_NV_fence"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_fence"))))]
    pub fn glDeleteFencesNV_is_loaded() -> bool {
        !glDeleteFencesNV_p.load(RELAX).is_null()
    }

    /// [glDeleteFramebuffers](http://docs.gl/es3/glDeleteFramebuffers)(n, framebuffers)
    /// `framebuffers` len: n
    /// `framebuffers` class: framebuffer
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn glDeleteFramebuffers(n: GLsizei, framebuffers: *const GLuint) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!("calling glDeleteFramebuffers({:?}, {:p});", n, framebuffers);
        }
        let out = call_atomic_ptr_2arg(
            "glDeleteFramebuffers",
            &glDeleteFramebuffers_p,
            n,
            framebuffers,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glDeleteFramebuffers");
        }
        out
    }
    static glDeleteFramebuffers_p: APcv = ap_None();
    /// Tries to load [`glDeleteFramebuffers`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    pub unsafe fn glDeleteFramebuffers_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glDeleteFramebuffers\0",
            &glDeleteFramebuffers_p,
        )
    }
    /// Checks if the pointer for [`glDeleteFramebuffers`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    pub fn glDeleteFramebuffers_is_loaded() -> bool {
        !glDeleteFramebuffers_p.load(RELAX).is_null()
    }

    /// [glDeleteMemoryObjectsEXT](http://docs.gl/es3/glDeleteMemoryObjectsEXT)(n, memoryObjects)
    /// `memoryObjects` len: n
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    #[cfg(any(feature = "GL_EXT_memory_object"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_memory_object"))))]
    pub unsafe fn glDeleteMemoryObjectsEXT(n: GLsizei, memoryObjects: *const GLuint) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glDeleteMemoryObjectsEXT({:?}, {:p});",
                n,
                memoryObjects
            );
        }
        let out = call_atomic_ptr_2arg(
            "glDeleteMemoryObjectsEXT",
            &glDeleteMemoryObjectsEXT_p,
            n,
            memoryObjects,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glDeleteMemoryObjectsEXT");
        }
        out
    }
    #[cfg(any(feature = "GL_EXT_memory_object"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_memory_object"))))]
    static glDeleteMemoryObjectsEXT_p: APcv = ap_None();
    /// Tries to load [`glDeleteMemoryObjectsEXT`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    #[cfg(any(feature = "GL_EXT_memory_object"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_memory_object"))))]
    pub unsafe fn glDeleteMemoryObjectsEXT_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glDeleteMemoryObjectsEXT\0",
            &glDeleteMemoryObjectsEXT_p,
        )
    }
    /// Checks if the pointer for [`glDeleteMemoryObjectsEXT`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    #[cfg(any(feature = "GL_EXT_memory_object"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_memory_object"))))]
    pub fn glDeleteMemoryObjectsEXT_is_loaded() -> bool {
        !glDeleteMemoryObjectsEXT_p.load(RELAX).is_null()
    }

    /// [glDeletePathsNV](http://docs.gl/es3/glDeletePathsNV)(path, range)
    /// `path` group: Path
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    #[cfg(any(feature = "GL_NV_path_rendering"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_path_rendering"))))]
    pub unsafe fn glDeletePathsNV(path: GLuint, range: GLsizei) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!("calling glDeletePathsNV({:?}, {:?});", path, range);
        }
        let out = call_atomic_ptr_2arg("glDeletePathsNV", &glDeletePathsNV_p, path, range);
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glDeletePathsNV");
        }
        out
    }
    #[cfg(any(feature = "GL_NV_path_rendering"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_path_rendering"))))]
    static glDeletePathsNV_p: APcv = ap_None();
    /// Tries to load [`glDeletePathsNV`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    #[cfg(any(feature = "GL_NV_path_rendering"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_path_rendering"))))]
    pub unsafe fn glDeletePathsNV_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(get_proc_address, b"glDeletePathsNV\0", &glDeletePathsNV_p)
    }
    /// Checks if the pointer for [`glDeletePathsNV`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    #[cfg(any(feature = "GL_NV_path_rendering"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_path_rendering"))))]
    pub fn glDeletePathsNV_is_loaded() -> bool {
        !glDeletePathsNV_p.load(RELAX).is_null()
    }

    /// [glDeletePerfMonitorsAMD](http://docs.gl/es3/glDeletePerfMonitorsAMD)(n, monitors)
    /// `monitors` len: n
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    #[cfg(any(feature = "GL_AMD_performance_monitor"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_AMD_performance_monitor"))))]
    pub unsafe fn glDeletePerfMonitorsAMD(n: GLsizei, monitors: *mut GLuint) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!("calling glDeletePerfMonitorsAMD({:?}, {:p});", n, monitors);
        }
        let out = call_atomic_ptr_2arg(
            "glDeletePerfMonitorsAMD",
            &glDeletePerfMonitorsAMD_p,
            n,
            monitors,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glDeletePerfMonitorsAMD");
        }
        out
    }
    #[cfg(any(feature = "GL_AMD_performance_monitor"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_AMD_performance_monitor"))))]
    static glDeletePerfMonitorsAMD_p: APcv = ap_None();
    /// Tries to load [`glDeletePerfMonitorsAMD`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    #[cfg(any(feature = "GL_AMD_performance_monitor"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_AMD_performance_monitor"))))]
    pub unsafe fn glDeletePerfMonitorsAMD_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glDeletePerfMonitorsAMD\0",
            &glDeletePerfMonitorsAMD_p,
        )
    }
    /// Checks if the pointer for [`glDeletePerfMonitorsAMD`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    #[cfg(any(feature = "GL_AMD_performance_monitor"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_AMD_performance_monitor"))))]
    pub fn glDeletePerfMonitorsAMD_is_loaded() -> bool {
        !glDeletePerfMonitorsAMD_p.load(RELAX).is_null()
    }

    /// [glDeletePerfQueryINTEL](http://docs.gl/es3/glDeletePerfQueryINTEL)(queryHandle)
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    #[cfg(any(feature = "GL_INTEL_performance_query"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_INTEL_performance_query"))))]
    pub unsafe fn glDeletePerfQueryINTEL(queryHandle: GLuint) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!("calling glDeletePerfQueryINTEL({:?});", queryHandle);
        }
        let out = call_atomic_ptr_1arg(
            "glDeletePerfQueryINTEL",
            &glDeletePerfQueryINTEL_p,
            queryHandle,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glDeletePerfQueryINTEL");
        }
        out
    }
    #[cfg(any(feature = "GL_INTEL_performance_query"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_INTEL_performance_query"))))]
    static glDeletePerfQueryINTEL_p: APcv = ap_None();
    /// Tries to load [`glDeletePerfQueryINTEL`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    #[cfg(any(feature = "GL_INTEL_performance_query"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_INTEL_performance_query"))))]
    pub unsafe fn glDeletePerfQueryINTEL_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glDeletePerfQueryINTEL\0",
            &glDeletePerfQueryINTEL_p,
        )
    }
    /// Checks if the pointer for [`glDeletePerfQueryINTEL`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    #[cfg(any(feature = "GL_INTEL_performance_query"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_INTEL_performance_query"))))]
    pub fn glDeletePerfQueryINTEL_is_loaded() -> bool {
        !glDeletePerfQueryINTEL_p.load(RELAX).is_null()
    }

    /// [glDeleteProgram](http://docs.gl/es3/glDeleteProgram)(program)
    /// `program` class: program
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn glDeleteProgram(program: GLuint) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!("calling glDeleteProgram({:?});", program);
        }
        let out = call_atomic_ptr_1arg("glDeleteProgram", &glDeleteProgram_p, program);
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glDeleteProgram");
        }
        out
    }
    static glDeleteProgram_p: APcv = ap_None();
    /// Tries to load [`glDeleteProgram`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    pub unsafe fn glDeleteProgram_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(get_proc_address, b"glDeleteProgram\0", &glDeleteProgram_p)
    }
    /// Checks if the pointer for [`glDeleteProgram`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    pub fn glDeleteProgram_is_loaded() -> bool {
        !glDeleteProgram_p.load(RELAX).is_null()
    }

    /// [glDeleteProgramPipelines](http://docs.gl/es3/glDeleteProgramPipelines)(n, pipelines)
    /// `pipelines` len: n
    /// `pipelines` class: program pipeline
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn glDeleteProgramPipelines(n: GLsizei, pipelines: *const GLuint) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glDeleteProgramPipelines({:?}, {:p});",
                n,
                pipelines
            );
        }
        let out = call_atomic_ptr_2arg(
            "glDeleteProgramPipelines",
            &glDeleteProgramPipelines_p,
            n,
            pipelines,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glDeleteProgramPipelines");
        }
        out
    }
    static glDeleteProgramPipelines_p: APcv = ap_None();
    /// Tries to load [`glDeleteProgramPipelines`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    pub unsafe fn glDeleteProgramPipelines_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glDeleteProgramPipelines\0",
            &glDeleteProgramPipelines_p,
        )
    }
    /// Checks if the pointer for [`glDeleteProgramPipelines`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    pub fn glDeleteProgramPipelines_is_loaded() -> bool {
        !glDeleteProgramPipelines_p.load(RELAX).is_null()
    }

    /// [glDeleteProgramPipelinesEXT](http://docs.gl/es3/glDeleteProgramPipelinesEXT)(n, pipelines)
    /// `pipelines` len: n
    /// `pipelines` class: program pipeline
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    #[cfg(any(feature = "GL_EXT_separate_shader_objects"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_separate_shader_objects"))))]
    pub unsafe fn glDeleteProgramPipelinesEXT(n: GLsizei, pipelines: *const GLuint) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glDeleteProgramPipelinesEXT({:?}, {:p});",
                n,
                pipelines
            );
        }
        let out = call_atomic_ptr_2arg(
            "glDeleteProgramPipelinesEXT",
            &glDeleteProgramPipelinesEXT_p,
            n,
            pipelines,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glDeleteProgramPipelinesEXT");
        }
        out
    }
    #[cfg(any(feature = "GL_EXT_separate_shader_objects"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_separate_shader_objects"))))]
    static glDeleteProgramPipelinesEXT_p: APcv = ap_None();
    /// Tries to load [`glDeleteProgramPipelinesEXT`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    #[cfg(any(feature = "GL_EXT_separate_shader_objects"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_separate_shader_objects"))))]
    pub unsafe fn glDeleteProgramPipelinesEXT_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glDeleteProgramPipelinesEXT\0",
            &glDeleteProgramPipelinesEXT_p,
        )
    }
    /// Checks if the pointer for [`glDeleteProgramPipelinesEXT`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    #[cfg(any(feature = "GL_EXT_separate_shader_objects"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_separate_shader_objects"))))]
    pub fn glDeleteProgramPipelinesEXT_is_loaded() -> bool {
        !glDeleteProgramPipelinesEXT_p.load(RELAX).is_null()
    }

    /// [glDeleteQueries](http://docs.gl/es3/glDeleteQueries)(n, ids)
    /// `ids` len: n
    /// `ids` class: query
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn glDeleteQueries(n: GLsizei, ids: *const GLuint) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!("calling glDeleteQueries({:?}, {:p});", n, ids);
        }
        let out = call_atomic_ptr_2arg("glDeleteQueries", &glDeleteQueries_p, n, ids);
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glDeleteQueries");
        }
        out
    }
    static glDeleteQueries_p: APcv = ap_None();
    /// Tries to load [`glDeleteQueries`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    pub unsafe fn glDeleteQueries_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(get_proc_address, b"glDeleteQueries\0", &glDeleteQueries_p)
    }
    /// Checks if the pointer for [`glDeleteQueries`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    pub fn glDeleteQueries_is_loaded() -> bool {
        !glDeleteQueries_p.load(RELAX).is_null()
    }

    /// [glDeleteQueriesEXT](http://docs.gl/es3/glDeleteQueriesEXT)(n, ids)
    /// `ids` len: n
    /// `ids` class: query
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    #[cfg(any(
        feature = "GL_EXT_disjoint_timer_query",
        feature = "GL_EXT_occlusion_query_boolean"
    ))]
    #[cfg_attr(
        docs_rs,
        doc(cfg(any(
            feature = "GL_EXT_disjoint_timer_query",
            feature = "GL_EXT_occlusion_query_boolean"
        )))
    )]
    pub unsafe fn glDeleteQueriesEXT(n: GLsizei, ids: *const GLuint) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!("calling glDeleteQueriesEXT({:?}, {:p});", n, ids);
        }
        let out = call_atomic_ptr_2arg("glDeleteQueriesEXT", &glDeleteQueriesEXT_p, n, ids);
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glDeleteQueriesEXT");
        }
        out
    }
    #[cfg(any(
        feature = "GL_EXT_disjoint_timer_query",
        feature = "GL_EXT_occlusion_query_boolean"
    ))]
    #[cfg_attr(
        docs_rs,
        doc(cfg(any(
            feature = "GL_EXT_disjoint_timer_query",
            feature = "GL_EXT_occlusion_query_boolean"
        )))
    )]
    static glDeleteQueriesEXT_p: APcv = ap_None();
    /// Tries to load [`glDeleteQueriesEXT`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    #[cfg(any(
        feature = "GL_EXT_disjoint_timer_query",
        feature = "GL_EXT_occlusion_query_boolean"
    ))]
    #[cfg_attr(
        docs_rs,
        doc(cfg(any(
            feature = "GL_EXT_disjoint_timer_query",
            feature = "GL_EXT_occlusion_query_boolean"
        )))
    )]
    pub unsafe fn glDeleteQueriesEXT_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glDeleteQueriesEXT\0",
            &glDeleteQueriesEXT_p,
        )
    }
    /// Checks if the pointer for [`glDeleteQueriesEXT`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    #[cfg(any(
        feature = "GL_EXT_disjoint_timer_query",
        feature = "GL_EXT_occlusion_query_boolean"
    ))]
    #[cfg_attr(
        docs_rs,
        doc(cfg(any(
            feature = "GL_EXT_disjoint_timer_query",
            feature = "GL_EXT_occlusion_query_boolean"
        )))
    )]
    pub fn glDeleteQueriesEXT_is_loaded() -> bool {
        !glDeleteQueriesEXT_p.load(RELAX).is_null()
    }

    /// [glDeleteRenderbuffers](http://docs.gl/es3/glDeleteRenderbuffers)(n, renderbuffers)
    /// `renderbuffers` len: n
    /// `renderbuffers` class: renderbuffer
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn glDeleteRenderbuffers(n: GLsizei, renderbuffers: *const GLuint) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glDeleteRenderbuffers({:?}, {:p});",
                n,
                renderbuffers
            );
        }
        let out = call_atomic_ptr_2arg(
            "glDeleteRenderbuffers",
            &glDeleteRenderbuffers_p,
            n,
            renderbuffers,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glDeleteRenderbuffers");
        }
        out
    }
    static glDeleteRenderbuffers_p: APcv = ap_None();
    /// Tries to load [`glDeleteRenderbuffers`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    pub unsafe fn glDeleteRenderbuffers_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glDeleteRenderbuffers\0",
            &glDeleteRenderbuffers_p,
        )
    }
    /// Checks if the pointer for [`glDeleteRenderbuffers`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    pub fn glDeleteRenderbuffers_is_loaded() -> bool {
        !glDeleteRenderbuffers_p.load(RELAX).is_null()
    }

    /// [glDeleteSamplers](http://docs.gl/es3/glDeleteSamplers)(count, samplers)
    /// `samplers` len: count
    /// `samplers` class: sampler
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn glDeleteSamplers(count: GLsizei, samplers: *const GLuint) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!("calling glDeleteSamplers({:?}, {:p});", count, samplers);
        }
        let out = call_atomic_ptr_2arg("glDeleteSamplers", &glDeleteSamplers_p, count, samplers);
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glDeleteSamplers");
        }
        out
    }
    static glDeleteSamplers_p: APcv = ap_None();
    /// Tries to load [`glDeleteSamplers`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    pub unsafe fn glDeleteSamplers_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(get_proc_address, b"glDeleteSamplers\0", &glDeleteSamplers_p)
    }
    /// Checks if the pointer for [`glDeleteSamplers`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    pub fn glDeleteSamplers_is_loaded() -> bool {
        !glDeleteSamplers_p.load(RELAX).is_null()
    }

    /// [glDeleteSemaphoresEXT](http://docs.gl/es3/glDeleteSemaphoresEXT)(n, semaphores)
    /// `semaphores` len: n
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    #[cfg(any(feature = "GL_EXT_semaphore"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_semaphore"))))]
    pub unsafe fn glDeleteSemaphoresEXT(n: GLsizei, semaphores: *const GLuint) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!("calling glDeleteSemaphoresEXT({:?}, {:p});", n, semaphores);
        }
        let out = call_atomic_ptr_2arg(
            "glDeleteSemaphoresEXT",
            &glDeleteSemaphoresEXT_p,
            n,
            semaphores,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glDeleteSemaphoresEXT");
        }
        out
    }
    #[cfg(any(feature = "GL_EXT_semaphore"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_semaphore"))))]
    static glDeleteSemaphoresEXT_p: APcv = ap_None();
    /// Tries to load [`glDeleteSemaphoresEXT`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    #[cfg(any(feature = "GL_EXT_semaphore"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_semaphore"))))]
    pub unsafe fn glDeleteSemaphoresEXT_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glDeleteSemaphoresEXT\0",
            &glDeleteSemaphoresEXT_p,
        )
    }
    /// Checks if the pointer for [`glDeleteSemaphoresEXT`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    #[cfg(any(feature = "GL_EXT_semaphore"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_semaphore"))))]
    pub fn glDeleteSemaphoresEXT_is_loaded() -> bool {
        !glDeleteSemaphoresEXT_p.load(RELAX).is_null()
    }

    /// [glDeleteShader](http://docs.gl/es3/glDeleteShader)(shader)
    /// `shader` class: shader
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn glDeleteShader(shader: GLuint) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!("calling glDeleteShader({:?});", shader);
        }
        let out = call_atomic_ptr_1arg("glDeleteShader", &glDeleteShader_p, shader);
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glDeleteShader");
        }
        out
    }
    static glDeleteShader_p: APcv = ap_None();
    /// Tries to load [`glDeleteShader`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    pub unsafe fn glDeleteShader_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(get_proc_address, b"glDeleteShader\0", &glDeleteShader_p)
    }
    /// Checks if the pointer for [`glDeleteShader`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    pub fn glDeleteShader_is_loaded() -> bool {
        !glDeleteShader_p.load(RELAX).is_null()
    }

    /// [glDeleteSync](http://docs.gl/es3/glDeleteSync)(sync)
    /// `sync` group: sync
    /// `sync` class: sync
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn glDeleteSync(sync: GLsync) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!("calling glDeleteSync({:p});", sync);
        }
        let out = call_atomic_ptr_1arg("glDeleteSync", &glDeleteSync_p, sync);
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glDeleteSync");
        }
        out
    }
    static glDeleteSync_p: APcv = ap_None();
    /// Tries to load [`glDeleteSync`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    pub unsafe fn glDeleteSync_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(get_proc_address, b"glDeleteSync\0", &glDeleteSync_p)
    }
    /// Checks if the pointer for [`glDeleteSync`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    pub fn glDeleteSync_is_loaded() -> bool {
        !glDeleteSync_p.load(RELAX).is_null()
    }

    /// [glDeleteSyncAPPLE](http://docs.gl/es3/glDeleteSyncAPPLE)(sync)
    /// `sync` class: sync
    /// alias of: [`glDeleteSync`]
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    #[cfg(any(feature = "GL_APPLE_sync"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_APPLE_sync"))))]
    pub unsafe fn glDeleteSyncAPPLE(sync: GLsync) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!("calling glDeleteSyncAPPLE({:p});", sync);
        }
        let out = call_atomic_ptr_1arg("glDeleteSyncAPPLE", &glDeleteSyncAPPLE_p, sync);
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glDeleteSyncAPPLE");
        }
        out
    }
    #[cfg(any(feature = "GL_APPLE_sync"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_APPLE_sync"))))]
    static glDeleteSyncAPPLE_p: APcv = ap_None();
    /// Tries to load [`glDeleteSyncAPPLE`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    #[cfg(any(feature = "GL_APPLE_sync"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_APPLE_sync"))))]
    pub unsafe fn glDeleteSyncAPPLE_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glDeleteSyncAPPLE\0",
            &glDeleteSyncAPPLE_p,
        )
    }
    /// Checks if the pointer for [`glDeleteSyncAPPLE`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    #[cfg(any(feature = "GL_APPLE_sync"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_APPLE_sync"))))]
    pub fn glDeleteSyncAPPLE_is_loaded() -> bool {
        !glDeleteSyncAPPLE_p.load(RELAX).is_null()
    }

    /// [glDeleteTextures](http://docs.gl/es3/glDeleteTextures)(n, textures)
    /// `textures` group: Texture
    /// `textures` len: n
    /// `textures` class: texture
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn glDeleteTextures(n: GLsizei, textures: *const GLuint) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!("calling glDeleteTextures({:?}, {:p});", n, textures);
        }
        let out = call_atomic_ptr_2arg("glDeleteTextures", &glDeleteTextures_p, n, textures);
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glDeleteTextures");
        }
        out
    }
    static glDeleteTextures_p: APcv = ap_None();
    /// Tries to load [`glDeleteTextures`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    pub unsafe fn glDeleteTextures_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(get_proc_address, b"glDeleteTextures\0", &glDeleteTextures_p)
    }
    /// Checks if the pointer for [`glDeleteTextures`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    pub fn glDeleteTextures_is_loaded() -> bool {
        !glDeleteTextures_p.load(RELAX).is_null()
    }

    /// [glDeleteTransformFeedbacks](http://docs.gl/es3/glDeleteTransformFeedbacks)(n, ids)
    /// `ids` len: n
    /// `ids` class: transform feedback
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn glDeleteTransformFeedbacks(n: GLsizei, ids: *const GLuint) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!("calling glDeleteTransformFeedbacks({:?}, {:p});", n, ids);
        }
        let out = call_atomic_ptr_2arg(
            "glDeleteTransformFeedbacks",
            &glDeleteTransformFeedbacks_p,
            n,
            ids,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glDeleteTransformFeedbacks");
        }
        out
    }
    static glDeleteTransformFeedbacks_p: APcv = ap_None();
    /// Tries to load [`glDeleteTransformFeedbacks`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    pub unsafe fn glDeleteTransformFeedbacks_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glDeleteTransformFeedbacks\0",
            &glDeleteTransformFeedbacks_p,
        )
    }
    /// Checks if the pointer for [`glDeleteTransformFeedbacks`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    pub fn glDeleteTransformFeedbacks_is_loaded() -> bool {
        !glDeleteTransformFeedbacks_p.load(RELAX).is_null()
    }

    /// [glDeleteVertexArrays](http://docs.gl/es3/glDeleteVertexArrays)(n, arrays)
    /// `arrays` len: n
    /// `arrays` class: vertex array
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn glDeleteVertexArrays(n: GLsizei, arrays: *const GLuint) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!("calling glDeleteVertexArrays({:?}, {:p});", n, arrays);
        }
        let out = call_atomic_ptr_2arg("glDeleteVertexArrays", &glDeleteVertexArrays_p, n, arrays);
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glDeleteVertexArrays");
        }
        out
    }
    static glDeleteVertexArrays_p: APcv = ap_None();
    /// Tries to load [`glDeleteVertexArrays`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    pub unsafe fn glDeleteVertexArrays_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glDeleteVertexArrays\0",
            &glDeleteVertexArrays_p,
        )
    }
    /// Checks if the pointer for [`glDeleteVertexArrays`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    pub fn glDeleteVertexArrays_is_loaded() -> bool {
        !glDeleteVertexArrays_p.load(RELAX).is_null()
    }

    /// [glDeleteVertexArraysOES](http://docs.gl/es3/glDeleteVertexArraysOES)(n, arrays)
    /// `arrays` len: n
    /// `arrays` class: vertex array
    /// alias of: [`glDeleteVertexArrays`]
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    #[cfg(any(feature = "GL_OES_vertex_array_object"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_OES_vertex_array_object"))))]
    pub unsafe fn glDeleteVertexArraysOES(n: GLsizei, arrays: *const GLuint) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!("calling glDeleteVertexArraysOES({:?}, {:p});", n, arrays);
        }
        let out = call_atomic_ptr_2arg(
            "glDeleteVertexArraysOES",
            &glDeleteVertexArraysOES_p,
            n,
            arrays,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glDeleteVertexArraysOES");
        }
        out
    }
    #[cfg(any(feature = "GL_OES_vertex_array_object"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_OES_vertex_array_object"))))]
    static glDeleteVertexArraysOES_p: APcv = ap_None();
    /// Tries to load [`glDeleteVertexArraysOES`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    #[cfg(any(feature = "GL_OES_vertex_array_object"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_OES_vertex_array_object"))))]
    pub unsafe fn glDeleteVertexArraysOES_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glDeleteVertexArraysOES\0",
            &glDeleteVertexArraysOES_p,
        )
    }
    /// Checks if the pointer for [`glDeleteVertexArraysOES`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    #[cfg(any(feature = "GL_OES_vertex_array_object"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_OES_vertex_array_object"))))]
    pub fn glDeleteVertexArraysOES_is_loaded() -> bool {
        !glDeleteVertexArraysOES_p.load(RELAX).is_null()
    }

    /// [glDepthFunc](http://docs.gl/es3/glDepthFunc)(func)
    /// `func` group: DepthFunction
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn glDepthFunc(func: GLenum) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!("calling glDepthFunc({:#X});", func);
        }
        let out = call_atomic_ptr_1arg("glDepthFunc", &glDepthFunc_p, func);
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glDepthFunc");
        }
        out
    }
    static glDepthFunc_p: APcv = ap_None();
    /// Tries to load [`glDepthFunc`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    pub unsafe fn glDepthFunc_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(get_proc_address, b"glDepthFunc\0", &glDepthFunc_p)
    }
    /// Checks if the pointer for [`glDepthFunc`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    pub fn glDepthFunc_is_loaded() -> bool {
        !glDepthFunc_p.load(RELAX).is_null()
    }

    /// [glDepthMask](http://docs.gl/es3/glDepthMask)(flag)
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn glDepthMask(flag: GLboolean) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!("calling glDepthMask({:?});", flag);
        }
        let out = call_atomic_ptr_1arg("glDepthMask", &glDepthMask_p, flag);
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glDepthMask");
        }
        out
    }
    static glDepthMask_p: APcv = ap_None();
    /// Tries to load [`glDepthMask`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    pub unsafe fn glDepthMask_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(get_proc_address, b"glDepthMask\0", &glDepthMask_p)
    }
    /// Checks if the pointer for [`glDepthMask`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    pub fn glDepthMask_is_loaded() -> bool {
        !glDepthMask_p.load(RELAX).is_null()
    }

    /// [glDepthRangeArrayfvNV](http://docs.gl/es3/glDepthRangeArrayfvNV)(first, count, v)
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    #[cfg(any(feature = "GL_NV_viewport_array"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_viewport_array"))))]
    pub unsafe fn glDepthRangeArrayfvNV(first: GLuint, count: GLsizei, v: *const GLfloat) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glDepthRangeArrayfvNV({:?}, {:?}, {:p});",
                first,
                count,
                v
            );
        }
        let out = call_atomic_ptr_3arg(
            "glDepthRangeArrayfvNV",
            &glDepthRangeArrayfvNV_p,
            first,
            count,
            v,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glDepthRangeArrayfvNV");
        }
        out
    }
    #[cfg(any(feature = "GL_NV_viewport_array"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_viewport_array"))))]
    static glDepthRangeArrayfvNV_p: APcv = ap_None();
    /// Tries to load [`glDepthRangeArrayfvNV`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    #[cfg(any(feature = "GL_NV_viewport_array"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_viewport_array"))))]
    pub unsafe fn glDepthRangeArrayfvNV_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glDepthRangeArrayfvNV\0",
            &glDepthRangeArrayfvNV_p,
        )
    }
    /// Checks if the pointer for [`glDepthRangeArrayfvNV`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    #[cfg(any(feature = "GL_NV_viewport_array"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_viewport_array"))))]
    pub fn glDepthRangeArrayfvNV_is_loaded() -> bool {
        !glDepthRangeArrayfvNV_p.load(RELAX).is_null()
    }

    /// [glDepthRangeArrayfvOES](http://docs.gl/es3/glDepthRangeArrayfvOES)(first, count, v)
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    #[cfg(any(feature = "GL_OES_viewport_array"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_OES_viewport_array"))))]
    pub unsafe fn glDepthRangeArrayfvOES(first: GLuint, count: GLsizei, v: *const GLfloat) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glDepthRangeArrayfvOES({:?}, {:?}, {:p});",
                first,
                count,
                v
            );
        }
        let out = call_atomic_ptr_3arg(
            "glDepthRangeArrayfvOES",
            &glDepthRangeArrayfvOES_p,
            first,
            count,
            v,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glDepthRangeArrayfvOES");
        }
        out
    }
    #[cfg(any(feature = "GL_OES_viewport_array"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_OES_viewport_array"))))]
    static glDepthRangeArrayfvOES_p: APcv = ap_None();
    /// Tries to load [`glDepthRangeArrayfvOES`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    #[cfg(any(feature = "GL_OES_viewport_array"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_OES_viewport_array"))))]
    pub unsafe fn glDepthRangeArrayfvOES_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glDepthRangeArrayfvOES\0",
            &glDepthRangeArrayfvOES_p,
        )
    }
    /// Checks if the pointer for [`glDepthRangeArrayfvOES`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    #[cfg(any(feature = "GL_OES_viewport_array"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_OES_viewport_array"))))]
    pub fn glDepthRangeArrayfvOES_is_loaded() -> bool {
        !glDepthRangeArrayfvOES_p.load(RELAX).is_null()
    }

    /// [glDepthRangeIndexedfNV](http://docs.gl/es3/glDepthRangeIndexedfNV)(index, n, f)
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    #[cfg(any(feature = "GL_NV_viewport_array"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_viewport_array"))))]
    pub unsafe fn glDepthRangeIndexedfNV(index: GLuint, n: GLfloat, f: GLfloat) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glDepthRangeIndexedfNV({:?}, {:?}, {:?});",
                index,
                n,
                f
            );
        }
        let out = call_atomic_ptr_3arg(
            "glDepthRangeIndexedfNV",
            &glDepthRangeIndexedfNV_p,
            index,
            n,
            f,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glDepthRangeIndexedfNV");
        }
        out
    }
    #[cfg(any(feature = "GL_NV_viewport_array"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_viewport_array"))))]
    static glDepthRangeIndexedfNV_p: APcv = ap_None();
    /// Tries to load [`glDepthRangeIndexedfNV`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    #[cfg(any(feature = "GL_NV_viewport_array"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_viewport_array"))))]
    pub unsafe fn glDepthRangeIndexedfNV_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glDepthRangeIndexedfNV\0",
            &glDepthRangeIndexedfNV_p,
        )
    }
    /// Checks if the pointer for [`glDepthRangeIndexedfNV`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    #[cfg(any(feature = "GL_NV_viewport_array"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_viewport_array"))))]
    pub fn glDepthRangeIndexedfNV_is_loaded() -> bool {
        !glDepthRangeIndexedfNV_p.load(RELAX).is_null()
    }

    /// [glDepthRangeIndexedfOES](http://docs.gl/es3/glDepthRangeIndexedfOES)(index, n, f)
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    #[cfg(any(feature = "GL_OES_viewport_array"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_OES_viewport_array"))))]
    pub unsafe fn glDepthRangeIndexedfOES(index: GLuint, n: GLfloat, f: GLfloat) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glDepthRangeIndexedfOES({:?}, {:?}, {:?});",
                index,
                n,
                f
            );
        }
        let out = call_atomic_ptr_3arg(
            "glDepthRangeIndexedfOES",
            &glDepthRangeIndexedfOES_p,
            index,
            n,
            f,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glDepthRangeIndexedfOES");
        }
        out
    }
    #[cfg(any(feature = "GL_OES_viewport_array"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_OES_viewport_array"))))]
    static glDepthRangeIndexedfOES_p: APcv = ap_None();
    /// Tries to load [`glDepthRangeIndexedfOES`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    #[cfg(any(feature = "GL_OES_viewport_array"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_OES_viewport_array"))))]
    pub unsafe fn glDepthRangeIndexedfOES_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glDepthRangeIndexedfOES\0",
            &glDepthRangeIndexedfOES_p,
        )
    }
    /// Checks if the pointer for [`glDepthRangeIndexedfOES`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    #[cfg(any(feature = "GL_OES_viewport_array"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_OES_viewport_array"))))]
    pub fn glDepthRangeIndexedfOES_is_loaded() -> bool {
        !glDepthRangeIndexedfOES_p.load(RELAX).is_null()
    }

    /// [glDepthRangef](http://docs.gl/es3/glDepthRange)(n, f)
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn glDepthRangef(n: GLfloat, f: GLfloat) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!("calling glDepthRangef({:?}, {:?});", n, f);
        }
        let out = call_atomic_ptr_2arg("glDepthRangef", &glDepthRangef_p, n, f);
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glDepthRangef");
        }
        out
    }
    static glDepthRangef_p: APcv = ap_None();
    /// Tries to load [`glDepthRangef`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    pub unsafe fn glDepthRangef_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(get_proc_address, b"glDepthRangef\0", &glDepthRangef_p)
    }
    /// Checks if the pointer for [`glDepthRangef`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    pub fn glDepthRangef_is_loaded() -> bool {
        !glDepthRangef_p.load(RELAX).is_null()
    }

    /// [glDetachShader](http://docs.gl/es3/glDetachShader)(program, shader)
    /// `program` class: program
    /// `shader` class: shader
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn glDetachShader(program: GLuint, shader: GLuint) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!("calling glDetachShader({:?}, {:?});", program, shader);
        }
        let out = call_atomic_ptr_2arg("glDetachShader", &glDetachShader_p, program, shader);
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glDetachShader");
        }
        out
    }
    static glDetachShader_p: APcv = ap_None();
    /// Tries to load [`glDetachShader`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    pub unsafe fn glDetachShader_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(get_proc_address, b"glDetachShader\0", &glDetachShader_p)
    }
    /// Checks if the pointer for [`glDetachShader`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    pub fn glDetachShader_is_loaded() -> bool {
        !glDetachShader_p.load(RELAX).is_null()
    }

    /// [glDisable](http://docs.gl/es3/glDisable)(cap)
    /// `cap` group: EnableCap
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn glDisable(cap: GLenum) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!("calling glDisable({:#X});", cap);
        }
        let out = call_atomic_ptr_1arg("glDisable", &glDisable_p, cap);
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glDisable");
        }
        out
    }
    static glDisable_p: APcv = ap_None();
    /// Tries to load [`glDisable`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    pub unsafe fn glDisable_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(get_proc_address, b"glDisable\0", &glDisable_p)
    }
    /// Checks if the pointer for [`glDisable`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    pub fn glDisable_is_loaded() -> bool {
        !glDisable_p.load(RELAX).is_null()
    }

    /// [glDisableDriverControlQCOM](http://docs.gl/es3/glDisableDriverControlQCOM)(driverControl)
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    #[cfg(any(feature = "GL_QCOM_driver_control"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_QCOM_driver_control"))))]
    pub unsafe fn glDisableDriverControlQCOM(driverControl: GLuint) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!("calling glDisableDriverControlQCOM({:?});", driverControl);
        }
        let out = call_atomic_ptr_1arg(
            "glDisableDriverControlQCOM",
            &glDisableDriverControlQCOM_p,
            driverControl,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glDisableDriverControlQCOM");
        }
        out
    }
    #[cfg(any(feature = "GL_QCOM_driver_control"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_QCOM_driver_control"))))]
    static glDisableDriverControlQCOM_p: APcv = ap_None();
    /// Tries to load [`glDisableDriverControlQCOM`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    #[cfg(any(feature = "GL_QCOM_driver_control"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_QCOM_driver_control"))))]
    pub unsafe fn glDisableDriverControlQCOM_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glDisableDriverControlQCOM\0",
            &glDisableDriverControlQCOM_p,
        )
    }
    /// Checks if the pointer for [`glDisableDriverControlQCOM`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    #[cfg(any(feature = "GL_QCOM_driver_control"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_QCOM_driver_control"))))]
    pub fn glDisableDriverControlQCOM_is_loaded() -> bool {
        !glDisableDriverControlQCOM_p.load(RELAX).is_null()
    }

    /// [glDisableVertexAttribArray](http://docs.gl/es3/glDisableVertexAttribArray)(index)
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn glDisableVertexAttribArray(index: GLuint) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!("calling glDisableVertexAttribArray({:?});", index);
        }
        let out = call_atomic_ptr_1arg(
            "glDisableVertexAttribArray",
            &glDisableVertexAttribArray_p,
            index,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glDisableVertexAttribArray");
        }
        out
    }
    static glDisableVertexAttribArray_p: APcv = ap_None();
    /// Tries to load [`glDisableVertexAttribArray`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    pub unsafe fn glDisableVertexAttribArray_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glDisableVertexAttribArray\0",
            &glDisableVertexAttribArray_p,
        )
    }
    /// Checks if the pointer for [`glDisableVertexAttribArray`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    pub fn glDisableVertexAttribArray_is_loaded() -> bool {
        !glDisableVertexAttribArray_p.load(RELAX).is_null()
    }

    /// [glDisablei](http://docs.gl/es3/glDisable)(target, index)
    /// `target` group: EnableCap
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn glDisablei(target: GLenum, index: GLuint) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!("calling glDisablei({:#X}, {:?});", target, index);
        }
        let out = call_atomic_ptr_2arg("glDisablei", &glDisablei_p, target, index);
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glDisablei");
        }
        out
    }
    static glDisablei_p: APcv = ap_None();
    /// Tries to load [`glDisablei`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    pub unsafe fn glDisablei_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(get_proc_address, b"glDisablei\0", &glDisablei_p)
    }
    /// Checks if the pointer for [`glDisablei`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    pub fn glDisablei_is_loaded() -> bool {
        !glDisablei_p.load(RELAX).is_null()
    }

    /// [glDisableiEXT](http://docs.gl/es3/glDisableiEXT)(target, index)
    /// `target` group: EnableCap
    /// alias of: [`glDisablei`]
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    #[cfg(any(feature = "GL_EXT_draw_buffers_indexed"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_draw_buffers_indexed"))))]
    pub unsafe fn glDisableiEXT(target: GLenum, index: GLuint) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!("calling glDisableiEXT({:#X}, {:?});", target, index);
        }
        let out = call_atomic_ptr_2arg("glDisableiEXT", &glDisableiEXT_p, target, index);
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glDisableiEXT");
        }
        out
    }
    #[cfg(any(feature = "GL_EXT_draw_buffers_indexed"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_draw_buffers_indexed"))))]
    static glDisableiEXT_p: APcv = ap_None();
    /// Tries to load [`glDisableiEXT`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    #[cfg(any(feature = "GL_EXT_draw_buffers_indexed"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_draw_buffers_indexed"))))]
    pub unsafe fn glDisableiEXT_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(get_proc_address, b"glDisableiEXT\0", &glDisableiEXT_p)
    }
    /// Checks if the pointer for [`glDisableiEXT`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    #[cfg(any(feature = "GL_EXT_draw_buffers_indexed"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_draw_buffers_indexed"))))]
    pub fn glDisableiEXT_is_loaded() -> bool {
        !glDisableiEXT_p.load(RELAX).is_null()
    }

    /// [glDisableiNV](http://docs.gl/es3/glDisableiNV)(target, index)
    /// `target` group: EnableCap
    /// alias of: [`glDisablei`]
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    #[cfg(any(feature = "GL_NV_viewport_array"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_viewport_array"))))]
    pub unsafe fn glDisableiNV(target: GLenum, index: GLuint) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!("calling glDisableiNV({:#X}, {:?});", target, index);
        }
        let out = call_atomic_ptr_2arg("glDisableiNV", &glDisableiNV_p, target, index);
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glDisableiNV");
        }
        out
    }
    #[cfg(any(feature = "GL_NV_viewport_array"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_viewport_array"))))]
    static glDisableiNV_p: APcv = ap_None();
    /// Tries to load [`glDisableiNV`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    #[cfg(any(feature = "GL_NV_viewport_array"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_viewport_array"))))]
    pub unsafe fn glDisableiNV_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(get_proc_address, b"glDisableiNV\0", &glDisableiNV_p)
    }
    /// Checks if the pointer for [`glDisableiNV`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    #[cfg(any(feature = "GL_NV_viewport_array"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_viewport_array"))))]
    pub fn glDisableiNV_is_loaded() -> bool {
        !glDisableiNV_p.load(RELAX).is_null()
    }

    /// [glDisableiOES](http://docs.gl/es3/glDisableiOES)(target, index)
    /// `target` group: EnableCap
    /// alias of: [`glDisablei`]
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    #[cfg(any(
        feature = "GL_OES_draw_buffers_indexed",
        feature = "GL_OES_viewport_array"
    ))]
    #[cfg_attr(
        docs_rs,
        doc(cfg(any(
            feature = "GL_OES_draw_buffers_indexed",
            feature = "GL_OES_viewport_array"
        )))
    )]
    pub unsafe fn glDisableiOES(target: GLenum, index: GLuint) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!("calling glDisableiOES({:#X}, {:?});", target, index);
        }
        let out = call_atomic_ptr_2arg("glDisableiOES", &glDisableiOES_p, target, index);
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glDisableiOES");
        }
        out
    }
    #[cfg(any(
        feature = "GL_OES_draw_buffers_indexed",
        feature = "GL_OES_viewport_array"
    ))]
    #[cfg_attr(
        docs_rs,
        doc(cfg(any(
            feature = "GL_OES_draw_buffers_indexed",
            feature = "GL_OES_viewport_array"
        )))
    )]
    static glDisableiOES_p: APcv = ap_None();
    /// Tries to load [`glDisableiOES`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    #[cfg(any(
        feature = "GL_OES_draw_buffers_indexed",
        feature = "GL_OES_viewport_array"
    ))]
    #[cfg_attr(
        docs_rs,
        doc(cfg(any(
            feature = "GL_OES_draw_buffers_indexed",
            feature = "GL_OES_viewport_array"
        )))
    )]
    pub unsafe fn glDisableiOES_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(get_proc_address, b"glDisableiOES\0", &glDisableiOES_p)
    }
    /// Checks if the pointer for [`glDisableiOES`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    #[cfg(any(
        feature = "GL_OES_draw_buffers_indexed",
        feature = "GL_OES_viewport_array"
    ))]
    #[cfg_attr(
        docs_rs,
        doc(cfg(any(
            feature = "GL_OES_draw_buffers_indexed",
            feature = "GL_OES_viewport_array"
        )))
    )]
    pub fn glDisableiOES_is_loaded() -> bool {
        !glDisableiOES_p.load(RELAX).is_null()
    }

    /// [glDiscardFramebufferEXT](http://docs.gl/es3/glDiscardFramebufferEXT)(target, numAttachments, attachments)
    /// `target` group: FramebufferTarget
    /// `attachments` group: InvalidateFramebufferAttachment
    /// `attachments` len: numAttachments
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    #[cfg(any(feature = "GL_EXT_discard_framebuffer"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_discard_framebuffer"))))]
    pub unsafe fn glDiscardFramebufferEXT(
        target: GLenum,
        numAttachments: GLsizei,
        attachments: *const GLenum,
    ) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glDiscardFramebufferEXT({:#X}, {:?}, {:p});",
                target,
                numAttachments,
                attachments
            );
        }
        let out = call_atomic_ptr_3arg(
            "glDiscardFramebufferEXT",
            &glDiscardFramebufferEXT_p,
            target,
            numAttachments,
            attachments,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glDiscardFramebufferEXT");
        }
        out
    }
    #[cfg(any(feature = "GL_EXT_discard_framebuffer"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_discard_framebuffer"))))]
    static glDiscardFramebufferEXT_p: APcv = ap_None();
    /// Tries to load [`glDiscardFramebufferEXT`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    #[cfg(any(feature = "GL_EXT_discard_framebuffer"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_discard_framebuffer"))))]
    pub unsafe fn glDiscardFramebufferEXT_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glDiscardFramebufferEXT\0",
            &glDiscardFramebufferEXT_p,
        )
    }
    /// Checks if the pointer for [`glDiscardFramebufferEXT`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    #[cfg(any(feature = "GL_EXT_discard_framebuffer"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_discard_framebuffer"))))]
    pub fn glDiscardFramebufferEXT_is_loaded() -> bool {
        !glDiscardFramebufferEXT_p.load(RELAX).is_null()
    }

    /// [glDispatchCompute](http://docs.gl/es3/glDispatchCompute)(num_groups_x, num_groups_y, num_groups_z)
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn glDispatchCompute(
        num_groups_x: GLuint,
        num_groups_y: GLuint,
        num_groups_z: GLuint,
    ) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glDispatchCompute({:?}, {:?}, {:?});",
                num_groups_x,
                num_groups_y,
                num_groups_z
            );
        }
        let out = call_atomic_ptr_3arg(
            "glDispatchCompute",
            &glDispatchCompute_p,
            num_groups_x,
            num_groups_y,
            num_groups_z,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glDispatchCompute");
        }
        out
    }
    static glDispatchCompute_p: APcv = ap_None();
    /// Tries to load [`glDispatchCompute`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    pub unsafe fn glDispatchCompute_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glDispatchCompute\0",
            &glDispatchCompute_p,
        )
    }
    /// Checks if the pointer for [`glDispatchCompute`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    pub fn glDispatchCompute_is_loaded() -> bool {
        !glDispatchCompute_p.load(RELAX).is_null()
    }

    /// [glDispatchComputeIndirect](http://docs.gl/es3/glDispatchComputeIndirect)(indirect)
    /// `indirect` group: BufferOffset
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn glDispatchComputeIndirect(indirect: GLintptr) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!("calling glDispatchComputeIndirect({:?});", indirect);
        }
        let out = call_atomic_ptr_1arg(
            "glDispatchComputeIndirect",
            &glDispatchComputeIndirect_p,
            indirect,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glDispatchComputeIndirect");
        }
        out
    }
    static glDispatchComputeIndirect_p: APcv = ap_None();
    /// Tries to load [`glDispatchComputeIndirect`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    pub unsafe fn glDispatchComputeIndirect_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glDispatchComputeIndirect\0",
            &glDispatchComputeIndirect_p,
        )
    }
    /// Checks if the pointer for [`glDispatchComputeIndirect`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    pub fn glDispatchComputeIndirect_is_loaded() -> bool {
        !glDispatchComputeIndirect_p.load(RELAX).is_null()
    }

    /// [glDrawArrays](http://docs.gl/es3/glDrawArrays)(mode, first, count)
    /// `mode` group: PrimitiveType
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn glDrawArrays(mode: GLenum, first: GLint, count: GLsizei) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glDrawArrays({:#X}, {:?}, {:?});",
                mode,
                first,
                count
            );
        }
        let out = call_atomic_ptr_3arg("glDrawArrays", &glDrawArrays_p, mode, first, count);
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glDrawArrays");
        }
        out
    }
    static glDrawArrays_p: APcv = ap_None();
    /// Tries to load [`glDrawArrays`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    pub unsafe fn glDrawArrays_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(get_proc_address, b"glDrawArrays\0", &glDrawArrays_p)
    }
    /// Checks if the pointer for [`glDrawArrays`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    pub fn glDrawArrays_is_loaded() -> bool {
        !glDrawArrays_p.load(RELAX).is_null()
    }

    /// [glDrawArraysIndirect](http://docs.gl/es3/glDrawArraysIndirect)(mode, indirect)
    /// `mode` group: PrimitiveType
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn glDrawArraysIndirect(mode: GLenum, indirect: *const c_void) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!("calling glDrawArraysIndirect({:#X}, {:p});", mode, indirect);
        }
        let out = call_atomic_ptr_2arg(
            "glDrawArraysIndirect",
            &glDrawArraysIndirect_p,
            mode,
            indirect,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glDrawArraysIndirect");
        }
        out
    }
    static glDrawArraysIndirect_p: APcv = ap_None();
    /// Tries to load [`glDrawArraysIndirect`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    pub unsafe fn glDrawArraysIndirect_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glDrawArraysIndirect\0",
            &glDrawArraysIndirect_p,
        )
    }
    /// Checks if the pointer for [`glDrawArraysIndirect`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    pub fn glDrawArraysIndirect_is_loaded() -> bool {
        !glDrawArraysIndirect_p.load(RELAX).is_null()
    }

    /// [glDrawArraysInstanced](http://docs.gl/es3/glDrawArraysInstanced)(mode, first, count, instancecount)
    /// `mode` group: PrimitiveType
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn glDrawArraysInstanced(
        mode: GLenum,
        first: GLint,
        count: GLsizei,
        instancecount: GLsizei,
    ) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glDrawArraysInstanced({:#X}, {:?}, {:?}, {:?});",
                mode,
                first,
                count,
                instancecount
            );
        }
        let out = call_atomic_ptr_4arg(
            "glDrawArraysInstanced",
            &glDrawArraysInstanced_p,
            mode,
            first,
            count,
            instancecount,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glDrawArraysInstanced");
        }
        out
    }
    static glDrawArraysInstanced_p: APcv = ap_None();
    /// Tries to load [`glDrawArraysInstanced`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    pub unsafe fn glDrawArraysInstanced_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glDrawArraysInstanced\0",
            &glDrawArraysInstanced_p,
        )
    }
    /// Checks if the pointer for [`glDrawArraysInstanced`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    pub fn glDrawArraysInstanced_is_loaded() -> bool {
        !glDrawArraysInstanced_p.load(RELAX).is_null()
    }

    /// [glDrawArraysInstancedANGLE](http://docs.gl/es3/glDrawArraysInstancedANGLE)(mode, first, count, primcount)
    /// `mode` group: PrimitiveType
    /// alias of: [`glDrawArraysInstanced`]
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    #[cfg(any(feature = "GL_ANGLE_instanced_arrays"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_ANGLE_instanced_arrays"))))]
    pub unsafe fn glDrawArraysInstancedANGLE(
        mode: GLenum,
        first: GLint,
        count: GLsizei,
        primcount: GLsizei,
    ) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glDrawArraysInstancedANGLE({:#X}, {:?}, {:?}, {:?});",
                mode,
                first,
                count,
                primcount
            );
        }
        let out = call_atomic_ptr_4arg(
            "glDrawArraysInstancedANGLE",
            &glDrawArraysInstancedANGLE_p,
            mode,
            first,
            count,
            primcount,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glDrawArraysInstancedANGLE");
        }
        out
    }
    #[cfg(any(feature = "GL_ANGLE_instanced_arrays"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_ANGLE_instanced_arrays"))))]
    static glDrawArraysInstancedANGLE_p: APcv = ap_None();
    /// Tries to load [`glDrawArraysInstancedANGLE`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    #[cfg(any(feature = "GL_ANGLE_instanced_arrays"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_ANGLE_instanced_arrays"))))]
    pub unsafe fn glDrawArraysInstancedANGLE_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glDrawArraysInstancedANGLE\0",
            &glDrawArraysInstancedANGLE_p,
        )
    }
    /// Checks if the pointer for [`glDrawArraysInstancedANGLE`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    #[cfg(any(feature = "GL_ANGLE_instanced_arrays"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_ANGLE_instanced_arrays"))))]
    pub fn glDrawArraysInstancedANGLE_is_loaded() -> bool {
        !glDrawArraysInstancedANGLE_p.load(RELAX).is_null()
    }

    /// [glDrawArraysInstancedBaseInstanceEXT](http://docs.gl/es3/glDrawArraysInstancedBaseInstanceEXT)(mode, first, count, instancecount, baseinstance)
    /// `mode` group: PrimitiveType
    /// alias of: [`glDrawArraysInstancedBaseInstance`]
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    #[cfg(any(feature = "GL_EXT_base_instance"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_base_instance"))))]
    pub unsafe fn glDrawArraysInstancedBaseInstanceEXT(
        mode: GLenum,
        first: GLint,
        count: GLsizei,
        instancecount: GLsizei,
        baseinstance: GLuint,
    ) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glDrawArraysInstancedBaseInstanceEXT({:#X}, {:?}, {:?}, {:?}, {:?});",
                mode,
                first,
                count,
                instancecount,
                baseinstance
            );
        }
        let out = call_atomic_ptr_5arg(
            "glDrawArraysInstancedBaseInstanceEXT",
            &glDrawArraysInstancedBaseInstanceEXT_p,
            mode,
            first,
            count,
            instancecount,
            baseinstance,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glDrawArraysInstancedBaseInstanceEXT");
        }
        out
    }
    #[cfg(any(feature = "GL_EXT_base_instance"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_base_instance"))))]
    static glDrawArraysInstancedBaseInstanceEXT_p: APcv = ap_None();
    /// Tries to load [`glDrawArraysInstancedBaseInstanceEXT`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    #[cfg(any(feature = "GL_EXT_base_instance"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_base_instance"))))]
    pub unsafe fn glDrawArraysInstancedBaseInstanceEXT_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glDrawArraysInstancedBaseInstanceEXT\0",
            &glDrawArraysInstancedBaseInstanceEXT_p,
        )
    }
    /// Checks if the pointer for [`glDrawArraysInstancedBaseInstanceEXT`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    #[cfg(any(feature = "GL_EXT_base_instance"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_base_instance"))))]
    pub fn glDrawArraysInstancedBaseInstanceEXT_is_loaded() -> bool {
        !glDrawArraysInstancedBaseInstanceEXT_p.load(RELAX).is_null()
    }

    /// [glDrawArraysInstancedEXT](http://docs.gl/es3/glDrawArraysInstancedEXT)(mode, start, count, primcount)
    /// `mode` group: PrimitiveType
    /// alias of: [`glDrawArraysInstanced`]
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    #[cfg(any(feature = "GL_EXT_draw_instanced", feature = "GL_EXT_instanced_arrays"))]
    #[cfg_attr(
        docs_rs,
        doc(cfg(any(feature = "GL_EXT_draw_instanced", feature = "GL_EXT_instanced_arrays")))
    )]
    pub unsafe fn glDrawArraysInstancedEXT(
        mode: GLenum,
        start: GLint,
        count: GLsizei,
        primcount: GLsizei,
    ) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glDrawArraysInstancedEXT({:#X}, {:?}, {:?}, {:?});",
                mode,
                start,
                count,
                primcount
            );
        }
        let out = call_atomic_ptr_4arg(
            "glDrawArraysInstancedEXT",
            &glDrawArraysInstancedEXT_p,
            mode,
            start,
            count,
            primcount,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glDrawArraysInstancedEXT");
        }
        out
    }
    #[cfg(any(feature = "GL_EXT_draw_instanced", feature = "GL_EXT_instanced_arrays"))]
    #[cfg_attr(
        docs_rs,
        doc(cfg(any(feature = "GL_EXT_draw_instanced", feature = "GL_EXT_instanced_arrays")))
    )]
    static glDrawArraysInstancedEXT_p: APcv = ap_None();
    /// Tries to load [`glDrawArraysInstancedEXT`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    #[cfg(any(feature = "GL_EXT_draw_instanced", feature = "GL_EXT_instanced_arrays"))]
    #[cfg_attr(
        docs_rs,
        doc(cfg(any(feature = "GL_EXT_draw_instanced", feature = "GL_EXT_instanced_arrays")))
    )]
    pub unsafe fn glDrawArraysInstancedEXT_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glDrawArraysInstancedEXT\0",
            &glDrawArraysInstancedEXT_p,
        )
    }
    /// Checks if the pointer for [`glDrawArraysInstancedEXT`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    #[cfg(any(feature = "GL_EXT_draw_instanced", feature = "GL_EXT_instanced_arrays"))]
    #[cfg_attr(
        docs_rs,
        doc(cfg(any(feature = "GL_EXT_draw_instanced", feature = "GL_EXT_instanced_arrays")))
    )]
    pub fn glDrawArraysInstancedEXT_is_loaded() -> bool {
        !glDrawArraysInstancedEXT_p.load(RELAX).is_null()
    }

    /// [glDrawArraysInstancedNV](http://docs.gl/es3/glDrawArraysInstancedNV)(mode, first, count, primcount)
    /// `mode` group: PrimitiveType
    /// alias of: [`glDrawArraysInstanced`]
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    #[cfg(any(feature = "GL_NV_draw_instanced"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_draw_instanced"))))]
    pub unsafe fn glDrawArraysInstancedNV(
        mode: GLenum,
        first: GLint,
        count: GLsizei,
        primcount: GLsizei,
    ) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glDrawArraysInstancedNV({:#X}, {:?}, {:?}, {:?});",
                mode,
                first,
                count,
                primcount
            );
        }
        let out = call_atomic_ptr_4arg(
            "glDrawArraysInstancedNV",
            &glDrawArraysInstancedNV_p,
            mode,
            first,
            count,
            primcount,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glDrawArraysInstancedNV");
        }
        out
    }
    #[cfg(any(feature = "GL_NV_draw_instanced"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_draw_instanced"))))]
    static glDrawArraysInstancedNV_p: APcv = ap_None();
    /// Tries to load [`glDrawArraysInstancedNV`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    #[cfg(any(feature = "GL_NV_draw_instanced"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_draw_instanced"))))]
    pub unsafe fn glDrawArraysInstancedNV_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glDrawArraysInstancedNV\0",
            &glDrawArraysInstancedNV_p,
        )
    }
    /// Checks if the pointer for [`glDrawArraysInstancedNV`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    #[cfg(any(feature = "GL_NV_draw_instanced"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_draw_instanced"))))]
    pub fn glDrawArraysInstancedNV_is_loaded() -> bool {
        !glDrawArraysInstancedNV_p.load(RELAX).is_null()
    }

    /// [glDrawBuffers](http://docs.gl/es3/glDrawBuffers)(n, bufs)
    /// `bufs` group: DrawBufferMode
    /// `bufs` len: n
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn glDrawBuffers(n: GLsizei, bufs: *const GLenum) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!("calling glDrawBuffers({:?}, {:p});", n, bufs);
        }
        let out = call_atomic_ptr_2arg("glDrawBuffers", &glDrawBuffers_p, n, bufs);
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glDrawBuffers");
        }
        out
    }
    static glDrawBuffers_p: APcv = ap_None();
    /// Tries to load [`glDrawBuffers`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    pub unsafe fn glDrawBuffers_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(get_proc_address, b"glDrawBuffers\0", &glDrawBuffers_p)
    }
    /// Checks if the pointer for [`glDrawBuffers`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    pub fn glDrawBuffers_is_loaded() -> bool {
        !glDrawBuffers_p.load(RELAX).is_null()
    }

    /// [glDrawBuffersEXT](http://docs.gl/es3/glDrawBuffersEXT)(n, bufs)
    /// `bufs` len: n
    /// alias of: [`glDrawBuffers`]
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    #[cfg(any(feature = "GL_EXT_draw_buffers"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_draw_buffers"))))]
    pub unsafe fn glDrawBuffersEXT(n: GLsizei, bufs: *const GLenum) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!("calling glDrawBuffersEXT({:?}, {:p});", n, bufs);
        }
        let out = call_atomic_ptr_2arg("glDrawBuffersEXT", &glDrawBuffersEXT_p, n, bufs);
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glDrawBuffersEXT");
        }
        out
    }
    #[cfg(any(feature = "GL_EXT_draw_buffers"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_draw_buffers"))))]
    static glDrawBuffersEXT_p: APcv = ap_None();
    /// Tries to load [`glDrawBuffersEXT`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    #[cfg(any(feature = "GL_EXT_draw_buffers"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_draw_buffers"))))]
    pub unsafe fn glDrawBuffersEXT_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(get_proc_address, b"glDrawBuffersEXT\0", &glDrawBuffersEXT_p)
    }
    /// Checks if the pointer for [`glDrawBuffersEXT`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    #[cfg(any(feature = "GL_EXT_draw_buffers"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_draw_buffers"))))]
    pub fn glDrawBuffersEXT_is_loaded() -> bool {
        !glDrawBuffersEXT_p.load(RELAX).is_null()
    }

    /// [glDrawBuffersIndexedEXT](http://docs.gl/es3/glDrawBuffersIndexedEXT)(n, location, indices)
    /// `location` len: n
    /// `indices` len: n
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    #[cfg(any(feature = "GL_EXT_multiview_draw_buffers"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_multiview_draw_buffers"))))]
    pub unsafe fn glDrawBuffersIndexedEXT(
        n: GLint,
        location: *const GLenum,
        indices: *const GLint,
    ) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glDrawBuffersIndexedEXT({:?}, {:p}, {:p});",
                n,
                location,
                indices
            );
        }
        let out = call_atomic_ptr_3arg(
            "glDrawBuffersIndexedEXT",
            &glDrawBuffersIndexedEXT_p,
            n,
            location,
            indices,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glDrawBuffersIndexedEXT");
        }
        out
    }
    #[cfg(any(feature = "GL_EXT_multiview_draw_buffers"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_multiview_draw_buffers"))))]
    static glDrawBuffersIndexedEXT_p: APcv = ap_None();
    /// Tries to load [`glDrawBuffersIndexedEXT`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    #[cfg(any(feature = "GL_EXT_multiview_draw_buffers"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_multiview_draw_buffers"))))]
    pub unsafe fn glDrawBuffersIndexedEXT_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glDrawBuffersIndexedEXT\0",
            &glDrawBuffersIndexedEXT_p,
        )
    }
    /// Checks if the pointer for [`glDrawBuffersIndexedEXT`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    #[cfg(any(feature = "GL_EXT_multiview_draw_buffers"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_multiview_draw_buffers"))))]
    pub fn glDrawBuffersIndexedEXT_is_loaded() -> bool {
        !glDrawBuffersIndexedEXT_p.load(RELAX).is_null()
    }

    /// [glDrawBuffersNV](http://docs.gl/es3/glDrawBuffersNV)(n, bufs)
    /// `bufs` len: n
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    #[cfg(any(feature = "GL_NV_draw_buffers"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_draw_buffers"))))]
    pub unsafe fn glDrawBuffersNV(n: GLsizei, bufs: *const GLenum) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!("calling glDrawBuffersNV({:?}, {:p});", n, bufs);
        }
        let out = call_atomic_ptr_2arg("glDrawBuffersNV", &glDrawBuffersNV_p, n, bufs);
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glDrawBuffersNV");
        }
        out
    }
    #[cfg(any(feature = "GL_NV_draw_buffers"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_draw_buffers"))))]
    static glDrawBuffersNV_p: APcv = ap_None();
    /// Tries to load [`glDrawBuffersNV`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    #[cfg(any(feature = "GL_NV_draw_buffers"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_draw_buffers"))))]
    pub unsafe fn glDrawBuffersNV_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(get_proc_address, b"glDrawBuffersNV\0", &glDrawBuffersNV_p)
    }
    /// Checks if the pointer for [`glDrawBuffersNV`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    #[cfg(any(feature = "GL_NV_draw_buffers"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_draw_buffers"))))]
    pub fn glDrawBuffersNV_is_loaded() -> bool {
        !glDrawBuffersNV_p.load(RELAX).is_null()
    }

    /// [glDrawElements](http://docs.gl/es3/glDrawElements)(mode, count, type_, indices)
    /// `mode` group: PrimitiveType
    /// `type_` group: DrawElementsType
    /// `indices` len: COMPSIZE(count,type)
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn glDrawElements(
        mode: GLenum,
        count: GLsizei,
        type_: GLenum,
        indices: *const c_void,
    ) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glDrawElements({:#X}, {:?}, {:#X}, {:p});",
                mode,
                count,
                type_,
                indices
            );
        }
        let out = call_atomic_ptr_4arg(
            "glDrawElements",
            &glDrawElements_p,
            mode,
            count,
            type_,
            indices,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glDrawElements");
        }
        out
    }
    static glDrawElements_p: APcv = ap_None();
    /// Tries to load [`glDrawElements`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    pub unsafe fn glDrawElements_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(get_proc_address, b"glDrawElements\0", &glDrawElements_p)
    }
    /// Checks if the pointer for [`glDrawElements`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    pub fn glDrawElements_is_loaded() -> bool {
        !glDrawElements_p.load(RELAX).is_null()
    }

    /// [glDrawElementsBaseVertex](http://docs.gl/es3/glDrawElementsBaseVertex)(mode, count, type_, indices, basevertex)
    /// `mode` group: PrimitiveType
    /// `type_` group: DrawElementsType
    /// `indices` len: COMPSIZE(count,type)
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn glDrawElementsBaseVertex(
        mode: GLenum,
        count: GLsizei,
        type_: GLenum,
        indices: *const c_void,
        basevertex: GLint,
    ) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glDrawElementsBaseVertex({:#X}, {:?}, {:#X}, {:p}, {:?});",
                mode,
                count,
                type_,
                indices,
                basevertex
            );
        }
        let out = call_atomic_ptr_5arg(
            "glDrawElementsBaseVertex",
            &glDrawElementsBaseVertex_p,
            mode,
            count,
            type_,
            indices,
            basevertex,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glDrawElementsBaseVertex");
        }
        out
    }
    static glDrawElementsBaseVertex_p: APcv = ap_None();
    /// Tries to load [`glDrawElementsBaseVertex`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    pub unsafe fn glDrawElementsBaseVertex_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glDrawElementsBaseVertex\0",
            &glDrawElementsBaseVertex_p,
        )
    }
    /// Checks if the pointer for [`glDrawElementsBaseVertex`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    pub fn glDrawElementsBaseVertex_is_loaded() -> bool {
        !glDrawElementsBaseVertex_p.load(RELAX).is_null()
    }

    /// [glDrawElementsBaseVertexEXT](http://docs.gl/es3/glDrawElementsBaseVertexEXT)(mode, count, type_, indices, basevertex)
    /// `mode` group: PrimitiveType
    /// `type_` group: DrawElementsType
    /// `indices` len: COMPSIZE(count,type)
    /// alias of: [`glDrawElementsBaseVertex`]
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    #[cfg(any(feature = "GL_EXT_draw_elements_base_vertex"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_draw_elements_base_vertex"))))]
    pub unsafe fn glDrawElementsBaseVertexEXT(
        mode: GLenum,
        count: GLsizei,
        type_: GLenum,
        indices: *const c_void,
        basevertex: GLint,
    ) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glDrawElementsBaseVertexEXT({:#X}, {:?}, {:#X}, {:p}, {:?});",
                mode,
                count,
                type_,
                indices,
                basevertex
            );
        }
        let out = call_atomic_ptr_5arg(
            "glDrawElementsBaseVertexEXT",
            &glDrawElementsBaseVertexEXT_p,
            mode,
            count,
            type_,
            indices,
            basevertex,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glDrawElementsBaseVertexEXT");
        }
        out
    }
    #[cfg(any(feature = "GL_EXT_draw_elements_base_vertex"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_draw_elements_base_vertex"))))]
    static glDrawElementsBaseVertexEXT_p: APcv = ap_None();
    /// Tries to load [`glDrawElementsBaseVertexEXT`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    #[cfg(any(feature = "GL_EXT_draw_elements_base_vertex"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_draw_elements_base_vertex"))))]
    pub unsafe fn glDrawElementsBaseVertexEXT_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glDrawElementsBaseVertexEXT\0",
            &glDrawElementsBaseVertexEXT_p,
        )
    }
    /// Checks if the pointer for [`glDrawElementsBaseVertexEXT`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    #[cfg(any(feature = "GL_EXT_draw_elements_base_vertex"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_draw_elements_base_vertex"))))]
    pub fn glDrawElementsBaseVertexEXT_is_loaded() -> bool {
        !glDrawElementsBaseVertexEXT_p.load(RELAX).is_null()
    }

    /// [glDrawElementsBaseVertexOES](http://docs.gl/es3/glDrawElementsBaseVertexOES)(mode, count, type_, indices, basevertex)
    /// `mode` group: PrimitiveType
    /// `type_` group: DrawElementsType
    /// `indices` len: COMPSIZE(count,type)
    /// alias of: [`glDrawElementsBaseVertex`]
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    #[cfg(any(feature = "GL_OES_draw_elements_base_vertex"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_OES_draw_elements_base_vertex"))))]
    pub unsafe fn glDrawElementsBaseVertexOES(
        mode: GLenum,
        count: GLsizei,
        type_: GLenum,
        indices: *const c_void,
        basevertex: GLint,
    ) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glDrawElementsBaseVertexOES({:#X}, {:?}, {:#X}, {:p}, {:?});",
                mode,
                count,
                type_,
                indices,
                basevertex
            );
        }
        let out = call_atomic_ptr_5arg(
            "glDrawElementsBaseVertexOES",
            &glDrawElementsBaseVertexOES_p,
            mode,
            count,
            type_,
            indices,
            basevertex,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glDrawElementsBaseVertexOES");
        }
        out
    }
    #[cfg(any(feature = "GL_OES_draw_elements_base_vertex"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_OES_draw_elements_base_vertex"))))]
    static glDrawElementsBaseVertexOES_p: APcv = ap_None();
    /// Tries to load [`glDrawElementsBaseVertexOES`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    #[cfg(any(feature = "GL_OES_draw_elements_base_vertex"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_OES_draw_elements_base_vertex"))))]
    pub unsafe fn glDrawElementsBaseVertexOES_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glDrawElementsBaseVertexOES\0",
            &glDrawElementsBaseVertexOES_p,
        )
    }
    /// Checks if the pointer for [`glDrawElementsBaseVertexOES`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    #[cfg(any(feature = "GL_OES_draw_elements_base_vertex"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_OES_draw_elements_base_vertex"))))]
    pub fn glDrawElementsBaseVertexOES_is_loaded() -> bool {
        !glDrawElementsBaseVertexOES_p.load(RELAX).is_null()
    }

    /// [glDrawElementsIndirect](http://docs.gl/es3/glDrawElementsIndirect)(mode, type_, indirect)
    /// `mode` group: PrimitiveType
    /// `type_` group: DrawElementsType
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn glDrawElementsIndirect(mode: GLenum, type_: GLenum, indirect: *const c_void) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glDrawElementsIndirect({:#X}, {:#X}, {:p});",
                mode,
                type_,
                indirect
            );
        }
        let out = call_atomic_ptr_3arg(
            "glDrawElementsIndirect",
            &glDrawElementsIndirect_p,
            mode,
            type_,
            indirect,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glDrawElementsIndirect");
        }
        out
    }
    static glDrawElementsIndirect_p: APcv = ap_None();
    /// Tries to load [`glDrawElementsIndirect`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    pub unsafe fn glDrawElementsIndirect_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glDrawElementsIndirect\0",
            &glDrawElementsIndirect_p,
        )
    }
    /// Checks if the pointer for [`glDrawElementsIndirect`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    pub fn glDrawElementsIndirect_is_loaded() -> bool {
        !glDrawElementsIndirect_p.load(RELAX).is_null()
    }

    /// [glDrawElementsInstanced](http://docs.gl/es3/glDrawElementsInstanced)(mode, count, type_, indices, instancecount)
    /// `mode` group: PrimitiveType
    /// `type_` group: DrawElementsType
    /// `indices` len: COMPSIZE(count,type)
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn glDrawElementsInstanced(
        mode: GLenum,
        count: GLsizei,
        type_: GLenum,
        indices: *const c_void,
        instancecount: GLsizei,
    ) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glDrawElementsInstanced({:#X}, {:?}, {:#X}, {:p}, {:?});",
                mode,
                count,
                type_,
                indices,
                instancecount
            );
        }
        let out = call_atomic_ptr_5arg(
            "glDrawElementsInstanced",
            &glDrawElementsInstanced_p,
            mode,
            count,
            type_,
            indices,
            instancecount,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glDrawElementsInstanced");
        }
        out
    }
    static glDrawElementsInstanced_p: APcv = ap_None();
    /// Tries to load [`glDrawElementsInstanced`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    pub unsafe fn glDrawElementsInstanced_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glDrawElementsInstanced\0",
            &glDrawElementsInstanced_p,
        )
    }
    /// Checks if the pointer for [`glDrawElementsInstanced`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    pub fn glDrawElementsInstanced_is_loaded() -> bool {
        !glDrawElementsInstanced_p.load(RELAX).is_null()
    }

    /// [glDrawElementsInstancedANGLE](http://docs.gl/es3/glDrawElementsInstancedANGLE)(mode, count, type_, indices, primcount)
    /// `mode` group: PrimitiveType
    /// `type_` group: PrimitiveType
    /// `indices` len: COMPSIZE(count,type)
    /// alias of: [`glDrawElementsInstanced`]
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    #[cfg(any(feature = "GL_ANGLE_instanced_arrays"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_ANGLE_instanced_arrays"))))]
    pub unsafe fn glDrawElementsInstancedANGLE(
        mode: GLenum,
        count: GLsizei,
        type_: GLenum,
        indices: *const c_void,
        primcount: GLsizei,
    ) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glDrawElementsInstancedANGLE({:#X}, {:?}, {:#X}, {:p}, {:?});",
                mode,
                count,
                type_,
                indices,
                primcount
            );
        }
        let out = call_atomic_ptr_5arg(
            "glDrawElementsInstancedANGLE",
            &glDrawElementsInstancedANGLE_p,
            mode,
            count,
            type_,
            indices,
            primcount,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glDrawElementsInstancedANGLE");
        }
        out
    }
    #[cfg(any(feature = "GL_ANGLE_instanced_arrays"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_ANGLE_instanced_arrays"))))]
    static glDrawElementsInstancedANGLE_p: APcv = ap_None();
    /// Tries to load [`glDrawElementsInstancedANGLE`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    #[cfg(any(feature = "GL_ANGLE_instanced_arrays"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_ANGLE_instanced_arrays"))))]
    pub unsafe fn glDrawElementsInstancedANGLE_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glDrawElementsInstancedANGLE\0",
            &glDrawElementsInstancedANGLE_p,
        )
    }
    /// Checks if the pointer for [`glDrawElementsInstancedANGLE`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    #[cfg(any(feature = "GL_ANGLE_instanced_arrays"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_ANGLE_instanced_arrays"))))]
    pub fn glDrawElementsInstancedANGLE_is_loaded() -> bool {
        !glDrawElementsInstancedANGLE_p.load(RELAX).is_null()
    }

    /// [glDrawElementsInstancedBaseInstanceEXT](http://docs.gl/es3/glDrawElementsInstancedBaseInstanceEXT)(mode, count, type_, indices, instancecount, baseinstance)
    /// `mode` group: PrimitiveType
    /// `type_` group: PrimitiveType
    /// `indices` len: count
    /// alias of: [`glDrawElementsInstancedBaseInstance`]
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    #[cfg(any(feature = "GL_EXT_base_instance"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_base_instance"))))]
    pub unsafe fn glDrawElementsInstancedBaseInstanceEXT(
        mode: GLenum,
        count: GLsizei,
        type_: GLenum,
        indices: *const c_void,
        instancecount: GLsizei,
        baseinstance: GLuint,
    ) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glDrawElementsInstancedBaseInstanceEXT({:#X}, {:?}, {:#X}, {:p}, {:?}, {:?});",
                mode,
                count,
                type_,
                indices,
                instancecount,
                baseinstance
            );
        }
        let out = call_atomic_ptr_6arg(
            "glDrawElementsInstancedBaseInstanceEXT",
            &glDrawElementsInstancedBaseInstanceEXT_p,
            mode,
            count,
            type_,
            indices,
            instancecount,
            baseinstance,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glDrawElementsInstancedBaseInstanceEXT");
        }
        out
    }
    #[cfg(any(feature = "GL_EXT_base_instance"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_base_instance"))))]
    static glDrawElementsInstancedBaseInstanceEXT_p: APcv = ap_None();
    /// Tries to load [`glDrawElementsInstancedBaseInstanceEXT`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    #[cfg(any(feature = "GL_EXT_base_instance"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_base_instance"))))]
    pub unsafe fn glDrawElementsInstancedBaseInstanceEXT_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glDrawElementsInstancedBaseInstanceEXT\0",
            &glDrawElementsInstancedBaseInstanceEXT_p,
        )
    }
    /// Checks if the pointer for [`glDrawElementsInstancedBaseInstanceEXT`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    #[cfg(any(feature = "GL_EXT_base_instance"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_base_instance"))))]
    pub fn glDrawElementsInstancedBaseInstanceEXT_is_loaded() -> bool {
        !glDrawElementsInstancedBaseInstanceEXT_p
            .load(RELAX)
            .is_null()
    }

    /// [glDrawElementsInstancedBaseVertex](http://docs.gl/es3/glDrawElementsInstancedBaseVertex)(mode, count, type_, indices, instancecount, basevertex)
    /// `mode` group: PrimitiveType
    /// `type_` group: DrawElementsType
    /// `indices` len: COMPSIZE(count,type)
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn glDrawElementsInstancedBaseVertex(
        mode: GLenum,
        count: GLsizei,
        type_: GLenum,
        indices: *const c_void,
        instancecount: GLsizei,
        basevertex: GLint,
    ) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glDrawElementsInstancedBaseVertex({:#X}, {:?}, {:#X}, {:p}, {:?}, {:?});",
                mode,
                count,
                type_,
                indices,
                instancecount,
                basevertex
            );
        }
        let out = call_atomic_ptr_6arg(
            "glDrawElementsInstancedBaseVertex",
            &glDrawElementsInstancedBaseVertex_p,
            mode,
            count,
            type_,
            indices,
            instancecount,
            basevertex,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glDrawElementsInstancedBaseVertex");
        }
        out
    }
    static glDrawElementsInstancedBaseVertex_p: APcv = ap_None();
    /// Tries to load [`glDrawElementsInstancedBaseVertex`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    pub unsafe fn glDrawElementsInstancedBaseVertex_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glDrawElementsInstancedBaseVertex\0",
            &glDrawElementsInstancedBaseVertex_p,
        )
    }
    /// Checks if the pointer for [`glDrawElementsInstancedBaseVertex`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    pub fn glDrawElementsInstancedBaseVertex_is_loaded() -> bool {
        !glDrawElementsInstancedBaseVertex_p.load(RELAX).is_null()
    }

    /// [glDrawElementsInstancedBaseVertexBaseInstanceEXT](http://docs.gl/es3/glDrawElementsInstancedBaseVertexBaseInstanceEXT)(mode, count, type_, indices, instancecount, basevertex, baseinstance)
    /// `mode` group: PrimitiveType
    /// `type_` group: DrawElementsType
    /// `indices` len: count
    /// alias of: [`glDrawElementsInstancedBaseVertexBaseInstance`]
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    #[cfg(any(feature = "GL_EXT_base_instance"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_base_instance"))))]
    pub unsafe fn glDrawElementsInstancedBaseVertexBaseInstanceEXT(
        mode: GLenum,
        count: GLsizei,
        type_: GLenum,
        indices: *const c_void,
        instancecount: GLsizei,
        basevertex: GLint,
        baseinstance: GLuint,
    ) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glDrawElementsInstancedBaseVertexBaseInstanceEXT({:#X}, {:?}, {:#X}, {:p}, {:?}, {:?}, {:?});",
                mode,
                count,
                type_,
                indices,
                instancecount,
                basevertex,
                baseinstance
            );
        }
        let out = call_atomic_ptr_7arg(
            "glDrawElementsInstancedBaseVertexBaseInstanceEXT",
            &glDrawElementsInstancedBaseVertexBaseInstanceEXT_p,
            mode,
            count,
            type_,
            indices,
            instancecount,
            basevertex,
            baseinstance,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glDrawElementsInstancedBaseVertexBaseInstanceEXT");
        }
        out
    }
    #[cfg(any(feature = "GL_EXT_base_instance"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_base_instance"))))]
    static glDrawElementsInstancedBaseVertexBaseInstanceEXT_p: APcv = ap_None();
    /// Tries to load [`glDrawElementsInstancedBaseVertexBaseInstanceEXT`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    #[cfg(any(feature = "GL_EXT_base_instance"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_base_instance"))))]
    pub unsafe fn glDrawElementsInstancedBaseVertexBaseInstanceEXT_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glDrawElementsInstancedBaseVertexBaseInstanceEXT\0",
            &glDrawElementsInstancedBaseVertexBaseInstanceEXT_p,
        )
    }
    /// Checks if the pointer for [`glDrawElementsInstancedBaseVertexBaseInstanceEXT`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    #[cfg(any(feature = "GL_EXT_base_instance"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_base_instance"))))]
    pub fn glDrawElementsInstancedBaseVertexBaseInstanceEXT_is_loaded() -> bool {
        !glDrawElementsInstancedBaseVertexBaseInstanceEXT_p
            .load(RELAX)
            .is_null()
    }

    /// [glDrawElementsInstancedBaseVertexEXT](http://docs.gl/es3/glDrawElementsInstancedBaseVertexEXT)(mode, count, type_, indices, instancecount, basevertex)
    /// `mode` group: PrimitiveType
    /// `type_` group: DrawElementsType
    /// `indices` len: COMPSIZE(count,type)
    /// alias of: [`glDrawElementsInstancedBaseVertex`]
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    #[cfg(any(feature = "GL_EXT_draw_elements_base_vertex"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_draw_elements_base_vertex"))))]
    pub unsafe fn glDrawElementsInstancedBaseVertexEXT(
        mode: GLenum,
        count: GLsizei,
        type_: GLenum,
        indices: *const c_void,
        instancecount: GLsizei,
        basevertex: GLint,
    ) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glDrawElementsInstancedBaseVertexEXT({:#X}, {:?}, {:#X}, {:p}, {:?}, {:?});",
                mode,
                count,
                type_,
                indices,
                instancecount,
                basevertex
            );
        }
        let out = call_atomic_ptr_6arg(
            "glDrawElementsInstancedBaseVertexEXT",
            &glDrawElementsInstancedBaseVertexEXT_p,
            mode,
            count,
            type_,
            indices,
            instancecount,
            basevertex,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glDrawElementsInstancedBaseVertexEXT");
        }
        out
    }
    #[cfg(any(feature = "GL_EXT_draw_elements_base_vertex"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_draw_elements_base_vertex"))))]
    static glDrawElementsInstancedBaseVertexEXT_p: APcv = ap_None();
    /// Tries to load [`glDrawElementsInstancedBaseVertexEXT`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    #[cfg(any(feature = "GL_EXT_draw_elements_base_vertex"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_draw_elements_base_vertex"))))]
    pub unsafe fn glDrawElementsInstancedBaseVertexEXT_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glDrawElementsInstancedBaseVertexEXT\0",
            &glDrawElementsInstancedBaseVertexEXT_p,
        )
    }
    /// Checks if the pointer for [`glDrawElementsInstancedBaseVertexEXT`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    #[cfg(any(feature = "GL_EXT_draw_elements_base_vertex"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_draw_elements_base_vertex"))))]
    pub fn glDrawElementsInstancedBaseVertexEXT_is_loaded() -> bool {
        !glDrawElementsInstancedBaseVertexEXT_p.load(RELAX).is_null()
    }

    /// [glDrawElementsInstancedBaseVertexOES](http://docs.gl/es3/glDrawElementsInstancedBaseVertexOES)(mode, count, type_, indices, instancecount, basevertex)
    /// `mode` group: PrimitiveType
    /// `type_` group: DrawElementsType
    /// `indices` len: COMPSIZE(count,type)
    /// alias of: [`glDrawElementsInstancedBaseVertex`]
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    #[cfg(any(feature = "GL_OES_draw_elements_base_vertex"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_OES_draw_elements_base_vertex"))))]
    pub unsafe fn glDrawElementsInstancedBaseVertexOES(
        mode: GLenum,
        count: GLsizei,
        type_: GLenum,
        indices: *const c_void,
        instancecount: GLsizei,
        basevertex: GLint,
    ) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glDrawElementsInstancedBaseVertexOES({:#X}, {:?}, {:#X}, {:p}, {:?}, {:?});",
                mode,
                count,
                type_,
                indices,
                instancecount,
                basevertex
            );
        }
        let out = call_atomic_ptr_6arg(
            "glDrawElementsInstancedBaseVertexOES",
            &glDrawElementsInstancedBaseVertexOES_p,
            mode,
            count,
            type_,
            indices,
            instancecount,
            basevertex,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glDrawElementsInstancedBaseVertexOES");
        }
        out
    }
    #[cfg(any(feature = "GL_OES_draw_elements_base_vertex"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_OES_draw_elements_base_vertex"))))]
    static glDrawElementsInstancedBaseVertexOES_p: APcv = ap_None();
    /// Tries to load [`glDrawElementsInstancedBaseVertexOES`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    #[cfg(any(feature = "GL_OES_draw_elements_base_vertex"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_OES_draw_elements_base_vertex"))))]
    pub unsafe fn glDrawElementsInstancedBaseVertexOES_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glDrawElementsInstancedBaseVertexOES\0",
            &glDrawElementsInstancedBaseVertexOES_p,
        )
    }
    /// Checks if the pointer for [`glDrawElementsInstancedBaseVertexOES`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    #[cfg(any(feature = "GL_OES_draw_elements_base_vertex"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_OES_draw_elements_base_vertex"))))]
    pub fn glDrawElementsInstancedBaseVertexOES_is_loaded() -> bool {
        !glDrawElementsInstancedBaseVertexOES_p.load(RELAX).is_null()
    }

    /// [glDrawElementsInstancedEXT](http://docs.gl/es3/glDrawElementsInstancedEXT)(mode, count, type_, indices, primcount)
    /// `mode` group: PrimitiveType
    /// `type_` group: DrawElementsType
    /// `indices` len: COMPSIZE(count,type)
    /// alias of: [`glDrawElementsInstanced`]
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    #[cfg(any(feature = "GL_EXT_draw_instanced", feature = "GL_EXT_instanced_arrays"))]
    #[cfg_attr(
        docs_rs,
        doc(cfg(any(feature = "GL_EXT_draw_instanced", feature = "GL_EXT_instanced_arrays")))
    )]
    pub unsafe fn glDrawElementsInstancedEXT(
        mode: GLenum,
        count: GLsizei,
        type_: GLenum,
        indices: *const c_void,
        primcount: GLsizei,
    ) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glDrawElementsInstancedEXT({:#X}, {:?}, {:#X}, {:p}, {:?});",
                mode,
                count,
                type_,
                indices,
                primcount
            );
        }
        let out = call_atomic_ptr_5arg(
            "glDrawElementsInstancedEXT",
            &glDrawElementsInstancedEXT_p,
            mode,
            count,
            type_,
            indices,
            primcount,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glDrawElementsInstancedEXT");
        }
        out
    }
    #[cfg(any(feature = "GL_EXT_draw_instanced", feature = "GL_EXT_instanced_arrays"))]
    #[cfg_attr(
        docs_rs,
        doc(cfg(any(feature = "GL_EXT_draw_instanced", feature = "GL_EXT_instanced_arrays")))
    )]
    static glDrawElementsInstancedEXT_p: APcv = ap_None();
    /// Tries to load [`glDrawElementsInstancedEXT`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    #[cfg(any(feature = "GL_EXT_draw_instanced", feature = "GL_EXT_instanced_arrays"))]
    #[cfg_attr(
        docs_rs,
        doc(cfg(any(feature = "GL_EXT_draw_instanced", feature = "GL_EXT_instanced_arrays")))
    )]
    pub unsafe fn glDrawElementsInstancedEXT_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glDrawElementsInstancedEXT\0",
            &glDrawElementsInstancedEXT_p,
        )
    }
    /// Checks if the pointer for [`glDrawElementsInstancedEXT`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    #[cfg(any(feature = "GL_EXT_draw_instanced", feature = "GL_EXT_instanced_arrays"))]
    #[cfg_attr(
        docs_rs,
        doc(cfg(any(feature = "GL_EXT_draw_instanced", feature = "GL_EXT_instanced_arrays")))
    )]
    pub fn glDrawElementsInstancedEXT_is_loaded() -> bool {
        !glDrawElementsInstancedEXT_p.load(RELAX).is_null()
    }

    /// [glDrawElementsInstancedNV](http://docs.gl/es3/glDrawElementsInstancedNV)(mode, count, type_, indices, primcount)
    /// `mode` group: PrimitiveType
    /// `type_` group: PrimitiveType
    /// `indices` len: COMPSIZE(count,type)
    /// alias of: [`glDrawElementsInstanced`]
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    #[cfg(any(feature = "GL_NV_draw_instanced"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_draw_instanced"))))]
    pub unsafe fn glDrawElementsInstancedNV(
        mode: GLenum,
        count: GLsizei,
        type_: GLenum,
        indices: *const c_void,
        primcount: GLsizei,
    ) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glDrawElementsInstancedNV({:#X}, {:?}, {:#X}, {:p}, {:?});",
                mode,
                count,
                type_,
                indices,
                primcount
            );
        }
        let out = call_atomic_ptr_5arg(
            "glDrawElementsInstancedNV",
            &glDrawElementsInstancedNV_p,
            mode,
            count,
            type_,
            indices,
            primcount,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glDrawElementsInstancedNV");
        }
        out
    }
    #[cfg(any(feature = "GL_NV_draw_instanced"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_draw_instanced"))))]
    static glDrawElementsInstancedNV_p: APcv = ap_None();
    /// Tries to load [`glDrawElementsInstancedNV`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    #[cfg(any(feature = "GL_NV_draw_instanced"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_draw_instanced"))))]
    pub unsafe fn glDrawElementsInstancedNV_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glDrawElementsInstancedNV\0",
            &glDrawElementsInstancedNV_p,
        )
    }
    /// Checks if the pointer for [`glDrawElementsInstancedNV`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    #[cfg(any(feature = "GL_NV_draw_instanced"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_draw_instanced"))))]
    pub fn glDrawElementsInstancedNV_is_loaded() -> bool {
        !glDrawElementsInstancedNV_p.load(RELAX).is_null()
    }

    /// [glDrawMeshTasksIndirectNV](http://docs.gl/es3/glDrawMeshTasksIndirectNV)(indirect)
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    #[cfg(any(feature = "GL_NV_mesh_shader"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_mesh_shader"))))]
    pub unsafe fn glDrawMeshTasksIndirectNV(indirect: GLintptr) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!("calling glDrawMeshTasksIndirectNV({:?});", indirect);
        }
        let out = call_atomic_ptr_1arg(
            "glDrawMeshTasksIndirectNV",
            &glDrawMeshTasksIndirectNV_p,
            indirect,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glDrawMeshTasksIndirectNV");
        }
        out
    }
    #[cfg(any(feature = "GL_NV_mesh_shader"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_mesh_shader"))))]
    static glDrawMeshTasksIndirectNV_p: APcv = ap_None();
    /// Tries to load [`glDrawMeshTasksIndirectNV`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    #[cfg(any(feature = "GL_NV_mesh_shader"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_mesh_shader"))))]
    pub unsafe fn glDrawMeshTasksIndirectNV_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glDrawMeshTasksIndirectNV\0",
            &glDrawMeshTasksIndirectNV_p,
        )
    }
    /// Checks if the pointer for [`glDrawMeshTasksIndirectNV`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    #[cfg(any(feature = "GL_NV_mesh_shader"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_mesh_shader"))))]
    pub fn glDrawMeshTasksIndirectNV_is_loaded() -> bool {
        !glDrawMeshTasksIndirectNV_p.load(RELAX).is_null()
    }

    /// [glDrawMeshTasksNV](http://docs.gl/es3/glDrawMeshTasksNV)(first, count)
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    #[cfg(any(feature = "GL_NV_mesh_shader"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_mesh_shader"))))]
    pub unsafe fn glDrawMeshTasksNV(first: GLuint, count: GLuint) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!("calling glDrawMeshTasksNV({:?}, {:?});", first, count);
        }
        let out = call_atomic_ptr_2arg("glDrawMeshTasksNV", &glDrawMeshTasksNV_p, first, count);
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glDrawMeshTasksNV");
        }
        out
    }
    #[cfg(any(feature = "GL_NV_mesh_shader"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_mesh_shader"))))]
    static glDrawMeshTasksNV_p: APcv = ap_None();
    /// Tries to load [`glDrawMeshTasksNV`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    #[cfg(any(feature = "GL_NV_mesh_shader"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_mesh_shader"))))]
    pub unsafe fn glDrawMeshTasksNV_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glDrawMeshTasksNV\0",
            &glDrawMeshTasksNV_p,
        )
    }
    /// Checks if the pointer for [`glDrawMeshTasksNV`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    #[cfg(any(feature = "GL_NV_mesh_shader"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_mesh_shader"))))]
    pub fn glDrawMeshTasksNV_is_loaded() -> bool {
        !glDrawMeshTasksNV_p.load(RELAX).is_null()
    }

    /// [glDrawRangeElements](http://docs.gl/es3/glDrawRangeElements)(mode, start, end, count, type_, indices)
    /// `mode` group: PrimitiveType
    /// `type_` group: DrawElementsType
    /// `indices` len: COMPSIZE(count,type)
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn glDrawRangeElements(
        mode: GLenum,
        start: GLuint,
        end: GLuint,
        count: GLsizei,
        type_: GLenum,
        indices: *const c_void,
    ) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glDrawRangeElements({:#X}, {:?}, {:?}, {:?}, {:#X}, {:p});",
                mode,
                start,
                end,
                count,
                type_,
                indices
            );
        }
        let out = call_atomic_ptr_6arg(
            "glDrawRangeElements",
            &glDrawRangeElements_p,
            mode,
            start,
            end,
            count,
            type_,
            indices,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glDrawRangeElements");
        }
        out
    }
    static glDrawRangeElements_p: APcv = ap_None();
    /// Tries to load [`glDrawRangeElements`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    pub unsafe fn glDrawRangeElements_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glDrawRangeElements\0",
            &glDrawRangeElements_p,
        )
    }
    /// Checks if the pointer for [`glDrawRangeElements`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    pub fn glDrawRangeElements_is_loaded() -> bool {
        !glDrawRangeElements_p.load(RELAX).is_null()
    }

    /// [glDrawRangeElementsBaseVertex](http://docs.gl/es3/glDrawRangeElementsBaseVertex)(mode, start, end, count, type_, indices, basevertex)
    /// `mode` group: PrimitiveType
    /// `type_` group: DrawElementsType
    /// `indices` len: COMPSIZE(count,type)
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn glDrawRangeElementsBaseVertex(
        mode: GLenum,
        start: GLuint,
        end: GLuint,
        count: GLsizei,
        type_: GLenum,
        indices: *const c_void,
        basevertex: GLint,
    ) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glDrawRangeElementsBaseVertex({:#X}, {:?}, {:?}, {:?}, {:#X}, {:p}, {:?});",
                mode,
                start,
                end,
                count,
                type_,
                indices,
                basevertex
            );
        }
        let out = call_atomic_ptr_7arg(
            "glDrawRangeElementsBaseVertex",
            &glDrawRangeElementsBaseVertex_p,
            mode,
            start,
            end,
            count,
            type_,
            indices,
            basevertex,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glDrawRangeElementsBaseVertex");
        }
        out
    }
    static glDrawRangeElementsBaseVertex_p: APcv = ap_None();
    /// Tries to load [`glDrawRangeElementsBaseVertex`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    pub unsafe fn glDrawRangeElementsBaseVertex_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glDrawRangeElementsBaseVertex\0",
            &glDrawRangeElementsBaseVertex_p,
        )
    }
    /// Checks if the pointer for [`glDrawRangeElementsBaseVertex`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    pub fn glDrawRangeElementsBaseVertex_is_loaded() -> bool {
        !glDrawRangeElementsBaseVertex_p.load(RELAX).is_null()
    }

    /// [glDrawRangeElementsBaseVertexEXT](http://docs.gl/es3/glDrawRangeElementsBaseVertexEXT)(mode, start, end, count, type_, indices, basevertex)
    /// `mode` group: PrimitiveType
    /// `type_` group: DrawElementsType
    /// `indices` len: COMPSIZE(count,type)
    /// alias of: [`glDrawRangeElementsBaseVertex`]
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    #[cfg(any(feature = "GL_EXT_draw_elements_base_vertex"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_draw_elements_base_vertex"))))]
    pub unsafe fn glDrawRangeElementsBaseVertexEXT(
        mode: GLenum,
        start: GLuint,
        end: GLuint,
        count: GLsizei,
        type_: GLenum,
        indices: *const c_void,
        basevertex: GLint,
    ) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glDrawRangeElementsBaseVertexEXT({:#X}, {:?}, {:?}, {:?}, {:#X}, {:p}, {:?});",
                mode,
                start,
                end,
                count,
                type_,
                indices,
                basevertex
            );
        }
        let out = call_atomic_ptr_7arg(
            "glDrawRangeElementsBaseVertexEXT",
            &glDrawRangeElementsBaseVertexEXT_p,
            mode,
            start,
            end,
            count,
            type_,
            indices,
            basevertex,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glDrawRangeElementsBaseVertexEXT");
        }
        out
    }
    #[cfg(any(feature = "GL_EXT_draw_elements_base_vertex"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_draw_elements_base_vertex"))))]
    static glDrawRangeElementsBaseVertexEXT_p: APcv = ap_None();
    /// Tries to load [`glDrawRangeElementsBaseVertexEXT`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    #[cfg(any(feature = "GL_EXT_draw_elements_base_vertex"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_draw_elements_base_vertex"))))]
    pub unsafe fn glDrawRangeElementsBaseVertexEXT_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glDrawRangeElementsBaseVertexEXT\0",
            &glDrawRangeElementsBaseVertexEXT_p,
        )
    }
    /// Checks if the pointer for [`glDrawRangeElementsBaseVertexEXT`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    #[cfg(any(feature = "GL_EXT_draw_elements_base_vertex"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_draw_elements_base_vertex"))))]
    pub fn glDrawRangeElementsBaseVertexEXT_is_loaded() -> bool {
        !glDrawRangeElementsBaseVertexEXT_p.load(RELAX).is_null()
    }

    /// [glDrawRangeElementsBaseVertexOES](http://docs.gl/es3/glDrawRangeElementsBaseVertexOES)(mode, start, end, count, type_, indices, basevertex)
    /// `mode` group: PrimitiveType
    /// `type_` group: DrawElementsType
    /// `indices` len: COMPSIZE(count,type)
    /// alias of: [`glDrawRangeElementsBaseVertex`]
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    #[cfg(any(feature = "GL_OES_draw_elements_base_vertex"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_OES_draw_elements_base_vertex"))))]
    pub unsafe fn glDrawRangeElementsBaseVertexOES(
        mode: GLenum,
        start: GLuint,
        end: GLuint,
        count: GLsizei,
        type_: GLenum,
        indices: *const c_void,
        basevertex: GLint,
    ) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glDrawRangeElementsBaseVertexOES({:#X}, {:?}, {:?}, {:?}, {:#X}, {:p}, {:?});",
                mode,
                start,
                end,
                count,
                type_,
                indices,
                basevertex
            );
        }
        let out = call_atomic_ptr_7arg(
            "glDrawRangeElementsBaseVertexOES",
            &glDrawRangeElementsBaseVertexOES_p,
            mode,
            start,
            end,
            count,
            type_,
            indices,
            basevertex,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glDrawRangeElementsBaseVertexOES");
        }
        out
    }
    #[cfg(any(feature = "GL_OES_draw_elements_base_vertex"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_OES_draw_elements_base_vertex"))))]
    static glDrawRangeElementsBaseVertexOES_p: APcv = ap_None();
    /// Tries to load [`glDrawRangeElementsBaseVertexOES`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    #[cfg(any(feature = "GL_OES_draw_elements_base_vertex"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_OES_draw_elements_base_vertex"))))]
    pub unsafe fn glDrawRangeElementsBaseVertexOES_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glDrawRangeElementsBaseVertexOES\0",
            &glDrawRangeElementsBaseVertexOES_p,
        )
    }
    /// Checks if the pointer for [`glDrawRangeElementsBaseVertexOES`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    #[cfg(any(feature = "GL_OES_draw_elements_base_vertex"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_OES_draw_elements_base_vertex"))))]
    pub fn glDrawRangeElementsBaseVertexOES_is_loaded() -> bool {
        !glDrawRangeElementsBaseVertexOES_p.load(RELAX).is_null()
    }

    /// [glDrawTransformFeedbackEXT](http://docs.gl/es3/glDrawTransformFeedbackEXT)(mode, id)
    /// `mode` group: PrimitiveType
    /// `id` class: transform feedback
    /// alias of: [`glDrawTransformFeedback`]
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    #[cfg(any(feature = "GL_EXT_draw_transform_feedback"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_draw_transform_feedback"))))]
    pub unsafe fn glDrawTransformFeedbackEXT(mode: GLenum, id: GLuint) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!("calling glDrawTransformFeedbackEXT({:#X}, {:?});", mode, id);
        }
        let out = call_atomic_ptr_2arg(
            "glDrawTransformFeedbackEXT",
            &glDrawTransformFeedbackEXT_p,
            mode,
            id,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glDrawTransformFeedbackEXT");
        }
        out
    }
    #[cfg(any(feature = "GL_EXT_draw_transform_feedback"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_draw_transform_feedback"))))]
    static glDrawTransformFeedbackEXT_p: APcv = ap_None();
    /// Tries to load [`glDrawTransformFeedbackEXT`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    #[cfg(any(feature = "GL_EXT_draw_transform_feedback"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_draw_transform_feedback"))))]
    pub unsafe fn glDrawTransformFeedbackEXT_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glDrawTransformFeedbackEXT\0",
            &glDrawTransformFeedbackEXT_p,
        )
    }
    /// Checks if the pointer for [`glDrawTransformFeedbackEXT`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    #[cfg(any(feature = "GL_EXT_draw_transform_feedback"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_draw_transform_feedback"))))]
    pub fn glDrawTransformFeedbackEXT_is_loaded() -> bool {
        !glDrawTransformFeedbackEXT_p.load(RELAX).is_null()
    }

    /// [glDrawTransformFeedbackInstancedEXT](http://docs.gl/es3/glDrawTransformFeedbackInstancedEXT)(mode, id, instancecount)
    /// `mode` group: PrimitiveType
    /// `id` class: transform feedback
    /// alias of: [`glDrawTransformFeedbackInstanced`]
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    #[cfg(any(feature = "GL_EXT_draw_transform_feedback"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_draw_transform_feedback"))))]
    pub unsafe fn glDrawTransformFeedbackInstancedEXT(
        mode: GLenum,
        id: GLuint,
        instancecount: GLsizei,
    ) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glDrawTransformFeedbackInstancedEXT({:#X}, {:?}, {:?});",
                mode,
                id,
                instancecount
            );
        }
        let out = call_atomic_ptr_3arg(
            "glDrawTransformFeedbackInstancedEXT",
            &glDrawTransformFeedbackInstancedEXT_p,
            mode,
            id,
            instancecount,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glDrawTransformFeedbackInstancedEXT");
        }
        out
    }
    #[cfg(any(feature = "GL_EXT_draw_transform_feedback"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_draw_transform_feedback"))))]
    static glDrawTransformFeedbackInstancedEXT_p: APcv = ap_None();
    /// Tries to load [`glDrawTransformFeedbackInstancedEXT`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    #[cfg(any(feature = "GL_EXT_draw_transform_feedback"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_draw_transform_feedback"))))]
    pub unsafe fn glDrawTransformFeedbackInstancedEXT_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glDrawTransformFeedbackInstancedEXT\0",
            &glDrawTransformFeedbackInstancedEXT_p,
        )
    }
    /// Checks if the pointer for [`glDrawTransformFeedbackInstancedEXT`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    #[cfg(any(feature = "GL_EXT_draw_transform_feedback"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_draw_transform_feedback"))))]
    pub fn glDrawTransformFeedbackInstancedEXT_is_loaded() -> bool {
        !glDrawTransformFeedbackInstancedEXT_p.load(RELAX).is_null()
    }

    /// [glDrawVkImageNV](http://docs.gl/es3/glDrawVkImageNV)(vkImage, sampler, x0, y0, x1, y1, z, s0, t0, s1, t1)
    /// `sampler` class: sampler
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    #[cfg(any(feature = "GL_NV_draw_vulkan_image"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_draw_vulkan_image"))))]
    pub unsafe fn glDrawVkImageNV(
        vkImage: GLuint64,
        sampler: GLuint,
        x0: GLfloat,
        y0: GLfloat,
        x1: GLfloat,
        y1: GLfloat,
        z: GLfloat,
        s0: GLfloat,
        t0: GLfloat,
        s1: GLfloat,
        t1: GLfloat,
    ) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glDrawVkImageNV({:?}, {:?}, {:?}, {:?}, {:?}, {:?}, {:?}, {:?}, {:?}, {:?}, {:?});",
                vkImage,
                sampler,
                x0,
                y0,
                x1,
                y1,
                z,
                s0,
                t0,
                s1,
                t1
            );
        }
        let out = call_atomic_ptr_11arg(
            "glDrawVkImageNV",
            &glDrawVkImageNV_p,
            vkImage,
            sampler,
            x0,
            y0,
            x1,
            y1,
            z,
            s0,
            t0,
            s1,
            t1,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glDrawVkImageNV");
        }
        out
    }
    #[cfg(any(feature = "GL_NV_draw_vulkan_image"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_draw_vulkan_image"))))]
    static glDrawVkImageNV_p: APcv = ap_None();
    /// Tries to load [`glDrawVkImageNV`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    #[cfg(any(feature = "GL_NV_draw_vulkan_image"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_draw_vulkan_image"))))]
    pub unsafe fn glDrawVkImageNV_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(get_proc_address, b"glDrawVkImageNV\0", &glDrawVkImageNV_p)
    }
    /// Checks if the pointer for [`glDrawVkImageNV`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    #[cfg(any(feature = "GL_NV_draw_vulkan_image"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_draw_vulkan_image"))))]
    pub fn glDrawVkImageNV_is_loaded() -> bool {
        !glDrawVkImageNV_p.load(RELAX).is_null()
    }

    /// [glEGLImageTargetRenderbufferStorageOES](http://docs.gl/es3/glEGLImageTargetRenderbufferStorageOES)(target, image)
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    #[cfg(any(feature = "GL_OES_EGL_image"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_OES_EGL_image"))))]
    pub unsafe fn glEGLImageTargetRenderbufferStorageOES(target: GLenum, image: GLeglImageOES) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glEGLImageTargetRenderbufferStorageOES({:#X}, {:?});",
                target,
                image
            );
        }
        let out = call_atomic_ptr_2arg(
            "glEGLImageTargetRenderbufferStorageOES",
            &glEGLImageTargetRenderbufferStorageOES_p,
            target,
            image,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glEGLImageTargetRenderbufferStorageOES");
        }
        out
    }
    #[cfg(any(feature = "GL_OES_EGL_image"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_OES_EGL_image"))))]
    static glEGLImageTargetRenderbufferStorageOES_p: APcv = ap_None();
    /// Tries to load [`glEGLImageTargetRenderbufferStorageOES`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    #[cfg(any(feature = "GL_OES_EGL_image"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_OES_EGL_image"))))]
    pub unsafe fn glEGLImageTargetRenderbufferStorageOES_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glEGLImageTargetRenderbufferStorageOES\0",
            &glEGLImageTargetRenderbufferStorageOES_p,
        )
    }
    /// Checks if the pointer for [`glEGLImageTargetRenderbufferStorageOES`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    #[cfg(any(feature = "GL_OES_EGL_image"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_OES_EGL_image"))))]
    pub fn glEGLImageTargetRenderbufferStorageOES_is_loaded() -> bool {
        !glEGLImageTargetRenderbufferStorageOES_p
            .load(RELAX)
            .is_null()
    }

    /// [glEGLImageTargetTexStorageEXT](http://docs.gl/es3/glEGLImageTargetTexStorageEXT)(target, image, attrib_list)
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    #[cfg(any(feature = "GL_EXT_EGL_image_storage"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_EGL_image_storage"))))]
    pub unsafe fn glEGLImageTargetTexStorageEXT(
        target: GLenum,
        image: GLeglImageOES,
        attrib_list: *const GLin,
    ) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glEGLImageTargetTexStorageEXT({:#X}, {:?}, {:p});",
                target,
                image,
                attrib_list
            );
        }
        let out = call_atomic_ptr_3arg(
            "glEGLImageTargetTexStorageEXT",
            &glEGLImageTargetTexStorageEXT_p,
            target,
            image,
            attrib_list,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glEGLImageTargetTexStorageEXT");
        }
        out
    }
    #[cfg(any(feature = "GL_EXT_EGL_image_storage"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_EGL_image_storage"))))]
    static glEGLImageTargetTexStorageEXT_p: APcv = ap_None();
    /// Tries to load [`glEGLImageTargetTexStorageEXT`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    #[cfg(any(feature = "GL_EXT_EGL_image_storage"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_EGL_image_storage"))))]
    pub unsafe fn glEGLImageTargetTexStorageEXT_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glEGLImageTargetTexStorageEXT\0",
            &glEGLImageTargetTexStorageEXT_p,
        )
    }
    /// Checks if the pointer for [`glEGLImageTargetTexStorageEXT`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    #[cfg(any(feature = "GL_EXT_EGL_image_storage"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_EGL_image_storage"))))]
    pub fn glEGLImageTargetTexStorageEXT_is_loaded() -> bool {
        !glEGLImageTargetTexStorageEXT_p.load(RELAX).is_null()
    }

    /// [glEGLImageTargetTexture2DOES](http://docs.gl/es3/glEGLImageTargetTexture2DOES)(target, image)
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    #[cfg(any(feature = "GL_OES_EGL_image"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_OES_EGL_image"))))]
    pub unsafe fn glEGLImageTargetTexture2DOES(target: GLenum, image: GLeglImageOES) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glEGLImageTargetTexture2DOES({:#X}, {:?});",
                target,
                image
            );
        }
        let out = call_atomic_ptr_2arg(
            "glEGLImageTargetTexture2DOES",
            &glEGLImageTargetTexture2DOES_p,
            target,
            image,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glEGLImageTargetTexture2DOES");
        }
        out
    }
    #[cfg(any(feature = "GL_OES_EGL_image"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_OES_EGL_image"))))]
    static glEGLImageTargetTexture2DOES_p: APcv = ap_None();
    /// Tries to load [`glEGLImageTargetTexture2DOES`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    #[cfg(any(feature = "GL_OES_EGL_image"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_OES_EGL_image"))))]
    pub unsafe fn glEGLImageTargetTexture2DOES_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glEGLImageTargetTexture2DOES\0",
            &glEGLImageTargetTexture2DOES_p,
        )
    }
    /// Checks if the pointer for [`glEGLImageTargetTexture2DOES`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    #[cfg(any(feature = "GL_OES_EGL_image"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_OES_EGL_image"))))]
    pub fn glEGLImageTargetTexture2DOES_is_loaded() -> bool {
        !glEGLImageTargetTexture2DOES_p.load(RELAX).is_null()
    }

    /// [glEGLImageTargetTextureStorageEXT](http://docs.gl/es3/glEGLImageTargetTextureStorageEXT)(texture, image, attrib_list)
    /// `texture` class: texture
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    #[cfg(any(feature = "GL_EXT_EGL_image_storage"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_EGL_image_storage"))))]
    pub unsafe fn glEGLImageTargetTextureStorageEXT(
        texture: GLuint,
        image: GLeglImageOES,
        attrib_list: *const GLin,
    ) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glEGLImageTargetTextureStorageEXT({:?}, {:?}, {:p});",
                texture,
                image,
                attrib_list
            );
        }
        let out = call_atomic_ptr_3arg(
            "glEGLImageTargetTextureStorageEXT",
            &glEGLImageTargetTextureStorageEXT_p,
            texture,
            image,
            attrib_list,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glEGLImageTargetTextureStorageEXT");
        }
        out
    }
    #[cfg(any(feature = "GL_EXT_EGL_image_storage"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_EGL_image_storage"))))]
    static glEGLImageTargetTextureStorageEXT_p: APcv = ap_None();
    /// Tries to load [`glEGLImageTargetTextureStorageEXT`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    #[cfg(any(feature = "GL_EXT_EGL_image_storage"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_EGL_image_storage"))))]
    pub unsafe fn glEGLImageTargetTextureStorageEXT_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glEGLImageTargetTextureStorageEXT\0",
            &glEGLImageTargetTextureStorageEXT_p,
        )
    }
    /// Checks if the pointer for [`glEGLImageTargetTextureStorageEXT`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    #[cfg(any(feature = "GL_EXT_EGL_image_storage"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_EGL_image_storage"))))]
    pub fn glEGLImageTargetTextureStorageEXT_is_loaded() -> bool {
        !glEGLImageTargetTextureStorageEXT_p.load(RELAX).is_null()
    }

    /// [glEnable](http://docs.gl/es3/glEnable)(cap)
    /// `cap` group: EnableCap
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn glEnable(cap: GLenum) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!("calling glEnable({:#X});", cap);
        }
        let out = call_atomic_ptr_1arg("glEnable", &glEnable_p, cap);
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glEnable");
        }
        out
    }
    static glEnable_p: APcv = ap_None();
    /// Tries to load [`glEnable`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    pub unsafe fn glEnable_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(get_proc_address, b"glEnable\0", &glEnable_p)
    }
    /// Checks if the pointer for [`glEnable`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    pub fn glEnable_is_loaded() -> bool {
        !glEnable_p.load(RELAX).is_null()
    }

    /// [glEnableDriverControlQCOM](http://docs.gl/es3/glEnableDriverControlQCOM)(driverControl)
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    #[cfg(any(feature = "GL_QCOM_driver_control"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_QCOM_driver_control"))))]
    pub unsafe fn glEnableDriverControlQCOM(driverControl: GLuint) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!("calling glEnableDriverControlQCOM({:?});", driverControl);
        }
        let out = call_atomic_ptr_1arg(
            "glEnableDriverControlQCOM",
            &glEnableDriverControlQCOM_p,
            driverControl,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glEnableDriverControlQCOM");
        }
        out
    }
    #[cfg(any(feature = "GL_QCOM_driver_control"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_QCOM_driver_control"))))]
    static glEnableDriverControlQCOM_p: APcv = ap_None();
    /// Tries to load [`glEnableDriverControlQCOM`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    #[cfg(any(feature = "GL_QCOM_driver_control"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_QCOM_driver_control"))))]
    pub unsafe fn glEnableDriverControlQCOM_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glEnableDriverControlQCOM\0",
            &glEnableDriverControlQCOM_p,
        )
    }
    /// Checks if the pointer for [`glEnableDriverControlQCOM`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    #[cfg(any(feature = "GL_QCOM_driver_control"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_QCOM_driver_control"))))]
    pub fn glEnableDriverControlQCOM_is_loaded() -> bool {
        !glEnableDriverControlQCOM_p.load(RELAX).is_null()
    }

    /// [glEnableVertexAttribArray](http://docs.gl/es3/glEnableVertexAttribArray)(index)
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn glEnableVertexAttribArray(index: GLuint) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!("calling glEnableVertexAttribArray({:?});", index);
        }
        let out = call_atomic_ptr_1arg(
            "glEnableVertexAttribArray",
            &glEnableVertexAttribArray_p,
            index,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glEnableVertexAttribArray");
        }
        out
    }
    static glEnableVertexAttribArray_p: APcv = ap_None();
    /// Tries to load [`glEnableVertexAttribArray`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    pub unsafe fn glEnableVertexAttribArray_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glEnableVertexAttribArray\0",
            &glEnableVertexAttribArray_p,
        )
    }
    /// Checks if the pointer for [`glEnableVertexAttribArray`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    pub fn glEnableVertexAttribArray_is_loaded() -> bool {
        !glEnableVertexAttribArray_p.load(RELAX).is_null()
    }

    /// [glEnablei](http://docs.gl/es3/glEnable)(target, index)
    /// `target` group: EnableCap
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn glEnablei(target: GLenum, index: GLuint) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!("calling glEnablei({:#X}, {:?});", target, index);
        }
        let out = call_atomic_ptr_2arg("glEnablei", &glEnablei_p, target, index);
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glEnablei");
        }
        out
    }
    static glEnablei_p: APcv = ap_None();
    /// Tries to load [`glEnablei`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    pub unsafe fn glEnablei_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(get_proc_address, b"glEnablei\0", &glEnablei_p)
    }
    /// Checks if the pointer for [`glEnablei`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    pub fn glEnablei_is_loaded() -> bool {
        !glEnablei_p.load(RELAX).is_null()
    }

    /// [glEnableiEXT](http://docs.gl/es3/glEnableiEXT)(target, index)
    /// `target` group: EnableCap
    /// alias of: [`glEnablei`]
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    #[cfg(any(feature = "GL_EXT_draw_buffers_indexed"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_draw_buffers_indexed"))))]
    pub unsafe fn glEnableiEXT(target: GLenum, index: GLuint) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!("calling glEnableiEXT({:#X}, {:?});", target, index);
        }
        let out = call_atomic_ptr_2arg("glEnableiEXT", &glEnableiEXT_p, target, index);
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glEnableiEXT");
        }
        out
    }
    #[cfg(any(feature = "GL_EXT_draw_buffers_indexed"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_draw_buffers_indexed"))))]
    static glEnableiEXT_p: APcv = ap_None();
    /// Tries to load [`glEnableiEXT`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    #[cfg(any(feature = "GL_EXT_draw_buffers_indexed"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_draw_buffers_indexed"))))]
    pub unsafe fn glEnableiEXT_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(get_proc_address, b"glEnableiEXT\0", &glEnableiEXT_p)
    }
    /// Checks if the pointer for [`glEnableiEXT`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    #[cfg(any(feature = "GL_EXT_draw_buffers_indexed"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_draw_buffers_indexed"))))]
    pub fn glEnableiEXT_is_loaded() -> bool {
        !glEnableiEXT_p.load(RELAX).is_null()
    }

    /// [glEnableiNV](http://docs.gl/es3/glEnableiNV)(target, index)
    /// `target` group: EnableCap
    /// alias of: [`glEnablei`]
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    #[cfg(any(feature = "GL_NV_viewport_array"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_viewport_array"))))]
    pub unsafe fn glEnableiNV(target: GLenum, index: GLuint) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!("calling glEnableiNV({:#X}, {:?});", target, index);
        }
        let out = call_atomic_ptr_2arg("glEnableiNV", &glEnableiNV_p, target, index);
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glEnableiNV");
        }
        out
    }
    #[cfg(any(feature = "GL_NV_viewport_array"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_viewport_array"))))]
    static glEnableiNV_p: APcv = ap_None();
    /// Tries to load [`glEnableiNV`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    #[cfg(any(feature = "GL_NV_viewport_array"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_viewport_array"))))]
    pub unsafe fn glEnableiNV_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(get_proc_address, b"glEnableiNV\0", &glEnableiNV_p)
    }
    /// Checks if the pointer for [`glEnableiNV`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    #[cfg(any(feature = "GL_NV_viewport_array"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_viewport_array"))))]
    pub fn glEnableiNV_is_loaded() -> bool {
        !glEnableiNV_p.load(RELAX).is_null()
    }

    /// [glEnableiOES](http://docs.gl/es3/glEnableiOES)(target, index)
    /// `target` group: EnableCap
    /// alias of: [`glEnablei`]
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    #[cfg(any(
        feature = "GL_OES_draw_buffers_indexed",
        feature = "GL_OES_viewport_array"
    ))]
    #[cfg_attr(
        docs_rs,
        doc(cfg(any(
            feature = "GL_OES_draw_buffers_indexed",
            feature = "GL_OES_viewport_array"
        )))
    )]
    pub unsafe fn glEnableiOES(target: GLenum, index: GLuint) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!("calling glEnableiOES({:#X}, {:?});", target, index);
        }
        let out = call_atomic_ptr_2arg("glEnableiOES", &glEnableiOES_p, target, index);
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glEnableiOES");
        }
        out
    }
    #[cfg(any(
        feature = "GL_OES_draw_buffers_indexed",
        feature = "GL_OES_viewport_array"
    ))]
    #[cfg_attr(
        docs_rs,
        doc(cfg(any(
            feature = "GL_OES_draw_buffers_indexed",
            feature = "GL_OES_viewport_array"
        )))
    )]
    static glEnableiOES_p: APcv = ap_None();
    /// Tries to load [`glEnableiOES`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    #[cfg(any(
        feature = "GL_OES_draw_buffers_indexed",
        feature = "GL_OES_viewport_array"
    ))]
    #[cfg_attr(
        docs_rs,
        doc(cfg(any(
            feature = "GL_OES_draw_buffers_indexed",
            feature = "GL_OES_viewport_array"
        )))
    )]
    pub unsafe fn glEnableiOES_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(get_proc_address, b"glEnableiOES\0", &glEnableiOES_p)
    }
    /// Checks if the pointer for [`glEnableiOES`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    #[cfg(any(
        feature = "GL_OES_draw_buffers_indexed",
        feature = "GL_OES_viewport_array"
    ))]
    #[cfg_attr(
        docs_rs,
        doc(cfg(any(
            feature = "GL_OES_draw_buffers_indexed",
            feature = "GL_OES_viewport_array"
        )))
    )]
    pub fn glEnableiOES_is_loaded() -> bool {
        !glEnableiOES_p.load(RELAX).is_null()
    }

    /// [glEndConditionalRenderNV](http://docs.gl/es3/glEndConditionalRenderNV)()
    /// alias of: [`glEndConditionalRender`]
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    #[cfg(any(feature = "GL_NV_conditional_render"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_conditional_render"))))]
    pub unsafe fn glEndConditionalRenderNV() {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!("calling glEndConditionalRenderNV();",);
        }
        let out = call_atomic_ptr_0arg("glEndConditionalRenderNV", &glEndConditionalRenderNV_p);
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glEndConditionalRenderNV");
        }
        out
    }
    #[cfg(any(feature = "GL_NV_conditional_render"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_conditional_render"))))]
    static glEndConditionalRenderNV_p: APcv = ap_None();
    /// Tries to load [`glEndConditionalRenderNV`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    #[cfg(any(feature = "GL_NV_conditional_render"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_conditional_render"))))]
    pub unsafe fn glEndConditionalRenderNV_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glEndConditionalRenderNV\0",
            &glEndConditionalRenderNV_p,
        )
    }
    /// Checks if the pointer for [`glEndConditionalRenderNV`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    #[cfg(any(feature = "GL_NV_conditional_render"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_conditional_render"))))]
    pub fn glEndConditionalRenderNV_is_loaded() -> bool {
        !glEndConditionalRenderNV_p.load(RELAX).is_null()
    }

    /// [glEndPerfMonitorAMD](http://docs.gl/es3/glEndPerfMonitorAMD)(monitor)
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    #[cfg(any(feature = "GL_AMD_performance_monitor"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_AMD_performance_monitor"))))]
    pub unsafe fn glEndPerfMonitorAMD(monitor: GLuint) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!("calling glEndPerfMonitorAMD({:?});", monitor);
        }
        let out = call_atomic_ptr_1arg("glEndPerfMonitorAMD", &glEndPerfMonitorAMD_p, monitor);
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glEndPerfMonitorAMD");
        }
        out
    }
    #[cfg(any(feature = "GL_AMD_performance_monitor"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_AMD_performance_monitor"))))]
    static glEndPerfMonitorAMD_p: APcv = ap_None();
    /// Tries to load [`glEndPerfMonitorAMD`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    #[cfg(any(feature = "GL_AMD_performance_monitor"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_AMD_performance_monitor"))))]
    pub unsafe fn glEndPerfMonitorAMD_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glEndPerfMonitorAMD\0",
            &glEndPerfMonitorAMD_p,
        )
    }
    /// Checks if the pointer for [`glEndPerfMonitorAMD`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    #[cfg(any(feature = "GL_AMD_performance_monitor"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_AMD_performance_monitor"))))]
    pub fn glEndPerfMonitorAMD_is_loaded() -> bool {
        !glEndPerfMonitorAMD_p.load(RELAX).is_null()
    }

    /// [glEndPerfQueryINTEL](http://docs.gl/es3/glEndPerfQueryINTEL)(queryHandle)
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    #[cfg(any(feature = "GL_INTEL_performance_query"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_INTEL_performance_query"))))]
    pub unsafe fn glEndPerfQueryINTEL(queryHandle: GLuint) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!("calling glEndPerfQueryINTEL({:?});", queryHandle);
        }
        let out = call_atomic_ptr_1arg("glEndPerfQueryINTEL", &glEndPerfQueryINTEL_p, queryHandle);
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glEndPerfQueryINTEL");
        }
        out
    }
    #[cfg(any(feature = "GL_INTEL_performance_query"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_INTEL_performance_query"))))]
    static glEndPerfQueryINTEL_p: APcv = ap_None();
    /// Tries to load [`glEndPerfQueryINTEL`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    #[cfg(any(feature = "GL_INTEL_performance_query"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_INTEL_performance_query"))))]
    pub unsafe fn glEndPerfQueryINTEL_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glEndPerfQueryINTEL\0",
            &glEndPerfQueryINTEL_p,
        )
    }
    /// Checks if the pointer for [`glEndPerfQueryINTEL`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    #[cfg(any(feature = "GL_INTEL_performance_query"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_INTEL_performance_query"))))]
    pub fn glEndPerfQueryINTEL_is_loaded() -> bool {
        !glEndPerfQueryINTEL_p.load(RELAX).is_null()
    }

    /// [glEndQuery](http://docs.gl/es3/glEndQuery)(target)
    /// `target` group: QueryTarget
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn glEndQuery(target: GLenum) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!("calling glEndQuery({:#X});", target);
        }
        let out = call_atomic_ptr_1arg("glEndQuery", &glEndQuery_p, target);
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glEndQuery");
        }
        out
    }
    static glEndQuery_p: APcv = ap_None();
    /// Tries to load [`glEndQuery`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    pub unsafe fn glEndQuery_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(get_proc_address, b"glEndQuery\0", &glEndQuery_p)
    }
    /// Checks if the pointer for [`glEndQuery`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    pub fn glEndQuery_is_loaded() -> bool {
        !glEndQuery_p.load(RELAX).is_null()
    }

    /// [glEndQueryEXT](http://docs.gl/es3/glEndQueryEXT)(target)
    /// `target` group: QueryTarget
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    #[cfg(any(
        feature = "GL_EXT_disjoint_timer_query",
        feature = "GL_EXT_occlusion_query_boolean"
    ))]
    #[cfg_attr(
        docs_rs,
        doc(cfg(any(
            feature = "GL_EXT_disjoint_timer_query",
            feature = "GL_EXT_occlusion_query_boolean"
        )))
    )]
    pub unsafe fn glEndQueryEXT(target: GLenum) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!("calling glEndQueryEXT({:#X});", target);
        }
        let out = call_atomic_ptr_1arg("glEndQueryEXT", &glEndQueryEXT_p, target);
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glEndQueryEXT");
        }
        out
    }
    #[cfg(any(
        feature = "GL_EXT_disjoint_timer_query",
        feature = "GL_EXT_occlusion_query_boolean"
    ))]
    #[cfg_attr(
        docs_rs,
        doc(cfg(any(
            feature = "GL_EXT_disjoint_timer_query",
            feature = "GL_EXT_occlusion_query_boolean"
        )))
    )]
    static glEndQueryEXT_p: APcv = ap_None();
    /// Tries to load [`glEndQueryEXT`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    #[cfg(any(
        feature = "GL_EXT_disjoint_timer_query",
        feature = "GL_EXT_occlusion_query_boolean"
    ))]
    #[cfg_attr(
        docs_rs,
        doc(cfg(any(
            feature = "GL_EXT_disjoint_timer_query",
            feature = "GL_EXT_occlusion_query_boolean"
        )))
    )]
    pub unsafe fn glEndQueryEXT_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(get_proc_address, b"glEndQueryEXT\0", &glEndQueryEXT_p)
    }
    /// Checks if the pointer for [`glEndQueryEXT`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    #[cfg(any(
        feature = "GL_EXT_disjoint_timer_query",
        feature = "GL_EXT_occlusion_query_boolean"
    ))]
    #[cfg_attr(
        docs_rs,
        doc(cfg(any(
            feature = "GL_EXT_disjoint_timer_query",
            feature = "GL_EXT_occlusion_query_boolean"
        )))
    )]
    pub fn glEndQueryEXT_is_loaded() -> bool {
        !glEndQueryEXT_p.load(RELAX).is_null()
    }

    /// [glEndTilingQCOM](http://docs.gl/es3/glEndTilingQCOM)(preserveMask)
    /// `preserveMask` group: BufferBitQCOM
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    #[cfg(any(feature = "GL_QCOM_tiled_rendering"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_QCOM_tiled_rendering"))))]
    pub unsafe fn glEndTilingQCOM(preserveMask: GLbitfield) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!("calling glEndTilingQCOM({:?});", preserveMask);
        }
        let out = call_atomic_ptr_1arg("glEndTilingQCOM", &glEndTilingQCOM_p, preserveMask);
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glEndTilingQCOM");
        }
        out
    }
    #[cfg(any(feature = "GL_QCOM_tiled_rendering"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_QCOM_tiled_rendering"))))]
    static glEndTilingQCOM_p: APcv = ap_None();
    /// Tries to load [`glEndTilingQCOM`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    #[cfg(any(feature = "GL_QCOM_tiled_rendering"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_QCOM_tiled_rendering"))))]
    pub unsafe fn glEndTilingQCOM_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(get_proc_address, b"glEndTilingQCOM\0", &glEndTilingQCOM_p)
    }
    /// Checks if the pointer for [`glEndTilingQCOM`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    #[cfg(any(feature = "GL_QCOM_tiled_rendering"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_QCOM_tiled_rendering"))))]
    pub fn glEndTilingQCOM_is_loaded() -> bool {
        !glEndTilingQCOM_p.load(RELAX).is_null()
    }

    /// [glEndTransformFeedback](http://docs.gl/es3/glEndTransformFeedback)()
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn glEndTransformFeedback() {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!("calling glEndTransformFeedback();",);
        }
        let out = call_atomic_ptr_0arg("glEndTransformFeedback", &glEndTransformFeedback_p);
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glEndTransformFeedback");
        }
        out
    }
    static glEndTransformFeedback_p: APcv = ap_None();
    /// Tries to load [`glEndTransformFeedback`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    pub unsafe fn glEndTransformFeedback_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glEndTransformFeedback\0",
            &glEndTransformFeedback_p,
        )
    }
    /// Checks if the pointer for [`glEndTransformFeedback`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    pub fn glEndTransformFeedback_is_loaded() -> bool {
        !glEndTransformFeedback_p.load(RELAX).is_null()
    }

    /// [glExtGetBufferPointervQCOM](http://docs.gl/es3/glExtGetBufferPointervQCOM)(target, params)
    /// `params` len: 1
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    #[cfg(any(feature = "GL_QCOM_extended_get"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_QCOM_extended_get"))))]
    pub unsafe fn glExtGetBufferPointervQCOM(target: GLenum, params: *mut *mut c_void) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glExtGetBufferPointervQCOM({:#X}, {:p});",
                target,
                params
            );
        }
        let out = call_atomic_ptr_2arg(
            "glExtGetBufferPointervQCOM",
            &glExtGetBufferPointervQCOM_p,
            target,
            params,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glExtGetBufferPointervQCOM");
        }
        out
    }
    #[cfg(any(feature = "GL_QCOM_extended_get"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_QCOM_extended_get"))))]
    static glExtGetBufferPointervQCOM_p: APcv = ap_None();
    /// Tries to load [`glExtGetBufferPointervQCOM`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    #[cfg(any(feature = "GL_QCOM_extended_get"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_QCOM_extended_get"))))]
    pub unsafe fn glExtGetBufferPointervQCOM_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glExtGetBufferPointervQCOM\0",
            &glExtGetBufferPointervQCOM_p,
        )
    }
    /// Checks if the pointer for [`glExtGetBufferPointervQCOM`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    #[cfg(any(feature = "GL_QCOM_extended_get"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_QCOM_extended_get"))))]
    pub fn glExtGetBufferPointervQCOM_is_loaded() -> bool {
        !glExtGetBufferPointervQCOM_p.load(RELAX).is_null()
    }

    /// [glExtGetBuffersQCOM](http://docs.gl/es3/glExtGetBuffersQCOM)(buffers, maxBuffers, numBuffers)
    /// `buffers` len: maxBuffers
    /// `buffers` class: buffer
    /// `numBuffers` len: 1
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    #[cfg(any(feature = "GL_QCOM_extended_get"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_QCOM_extended_get"))))]
    pub unsafe fn glExtGetBuffersQCOM(
        buffers: *mut GLuint,
        maxBuffers: GLint,
        numBuffers: *mut GLint,
    ) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glExtGetBuffersQCOM({:p}, {:?}, {:p});",
                buffers,
                maxBuffers,
                numBuffers
            );
        }
        let out = call_atomic_ptr_3arg(
            "glExtGetBuffersQCOM",
            &glExtGetBuffersQCOM_p,
            buffers,
            maxBuffers,
            numBuffers,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glExtGetBuffersQCOM");
        }
        out
    }
    #[cfg(any(feature = "GL_QCOM_extended_get"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_QCOM_extended_get"))))]
    static glExtGetBuffersQCOM_p: APcv = ap_None();
    /// Tries to load [`glExtGetBuffersQCOM`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    #[cfg(any(feature = "GL_QCOM_extended_get"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_QCOM_extended_get"))))]
    pub unsafe fn glExtGetBuffersQCOM_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glExtGetBuffersQCOM\0",
            &glExtGetBuffersQCOM_p,
        )
    }
    /// Checks if the pointer for [`glExtGetBuffersQCOM`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    #[cfg(any(feature = "GL_QCOM_extended_get"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_QCOM_extended_get"))))]
    pub fn glExtGetBuffersQCOM_is_loaded() -> bool {
        !glExtGetBuffersQCOM_p.load(RELAX).is_null()
    }

    /// [glExtGetFramebuffersQCOM](http://docs.gl/es3/glExtGetFramebuffersQCOM)(framebuffers, maxFramebuffers, numFramebuffers)
    /// `framebuffers` len: maxFramebuffers
    /// `framebuffers` class: framebuffer
    /// `numFramebuffers` len: 1
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    #[cfg(any(feature = "GL_QCOM_extended_get"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_QCOM_extended_get"))))]
    pub unsafe fn glExtGetFramebuffersQCOM(
        framebuffers: *mut GLuint,
        maxFramebuffers: GLint,
        numFramebuffers: *mut GLint,
    ) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glExtGetFramebuffersQCOM({:p}, {:?}, {:p});",
                framebuffers,
                maxFramebuffers,
                numFramebuffers
            );
        }
        let out = call_atomic_ptr_3arg(
            "glExtGetFramebuffersQCOM",
            &glExtGetFramebuffersQCOM_p,
            framebuffers,
            maxFramebuffers,
            numFramebuffers,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glExtGetFramebuffersQCOM");
        }
        out
    }
    #[cfg(any(feature = "GL_QCOM_extended_get"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_QCOM_extended_get"))))]
    static glExtGetFramebuffersQCOM_p: APcv = ap_None();
    /// Tries to load [`glExtGetFramebuffersQCOM`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    #[cfg(any(feature = "GL_QCOM_extended_get"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_QCOM_extended_get"))))]
    pub unsafe fn glExtGetFramebuffersQCOM_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glExtGetFramebuffersQCOM\0",
            &glExtGetFramebuffersQCOM_p,
        )
    }
    /// Checks if the pointer for [`glExtGetFramebuffersQCOM`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    #[cfg(any(feature = "GL_QCOM_extended_get"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_QCOM_extended_get"))))]
    pub fn glExtGetFramebuffersQCOM_is_loaded() -> bool {
        !glExtGetFramebuffersQCOM_p.load(RELAX).is_null()
    }

    /// [glExtGetProgramBinarySourceQCOM](http://docs.gl/es3/glExtGetProgramBinarySourceQCOM)(program, shadertype, source, length)
    /// `program` class: program
    /// `shadertype` group: ShaderType
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    #[cfg(any(feature = "GL_QCOM_extended_get2"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_QCOM_extended_get2"))))]
    pub unsafe fn glExtGetProgramBinarySourceQCOM(
        program: GLuint,
        shadertype: GLenum,
        source: *mut GLchar,
        length: *mut GLint,
    ) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glExtGetProgramBinarySourceQCOM({:?}, {:#X}, {:p}, {:p});",
                program,
                shadertype,
                source,
                length
            );
        }
        let out = call_atomic_ptr_4arg(
            "glExtGetProgramBinarySourceQCOM",
            &glExtGetProgramBinarySourceQCOM_p,
            program,
            shadertype,
            source,
            length,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glExtGetProgramBinarySourceQCOM");
        }
        out
    }
    #[cfg(any(feature = "GL_QCOM_extended_get2"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_QCOM_extended_get2"))))]
    static glExtGetProgramBinarySourceQCOM_p: APcv = ap_None();
    /// Tries to load [`glExtGetProgramBinarySourceQCOM`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    #[cfg(any(feature = "GL_QCOM_extended_get2"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_QCOM_extended_get2"))))]
    pub unsafe fn glExtGetProgramBinarySourceQCOM_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glExtGetProgramBinarySourceQCOM\0",
            &glExtGetProgramBinarySourceQCOM_p,
        )
    }
    /// Checks if the pointer for [`glExtGetProgramBinarySourceQCOM`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    #[cfg(any(feature = "GL_QCOM_extended_get2"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_QCOM_extended_get2"))))]
    pub fn glExtGetProgramBinarySourceQCOM_is_loaded() -> bool {
        !glExtGetProgramBinarySourceQCOM_p.load(RELAX).is_null()
    }

    /// [glExtGetProgramsQCOM](http://docs.gl/es3/glExtGetProgramsQCOM)(programs, maxPrograms, numPrograms)
    /// `programs` len: maxPrograms
    /// `programs` class: program
    /// `numPrograms` len: 1
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    #[cfg(any(feature = "GL_QCOM_extended_get2"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_QCOM_extended_get2"))))]
    pub unsafe fn glExtGetProgramsQCOM(
        programs: *mut GLuint,
        maxPrograms: GLint,
        numPrograms: *mut GLint,
    ) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glExtGetProgramsQCOM({:p}, {:?}, {:p});",
                programs,
                maxPrograms,
                numPrograms
            );
        }
        let out = call_atomic_ptr_3arg(
            "glExtGetProgramsQCOM",
            &glExtGetProgramsQCOM_p,
            programs,
            maxPrograms,
            numPrograms,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glExtGetProgramsQCOM");
        }
        out
    }
    #[cfg(any(feature = "GL_QCOM_extended_get2"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_QCOM_extended_get2"))))]
    static glExtGetProgramsQCOM_p: APcv = ap_None();
    /// Tries to load [`glExtGetProgramsQCOM`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    #[cfg(any(feature = "GL_QCOM_extended_get2"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_QCOM_extended_get2"))))]
    pub unsafe fn glExtGetProgramsQCOM_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glExtGetProgramsQCOM\0",
            &glExtGetProgramsQCOM_p,
        )
    }
    /// Checks if the pointer for [`glExtGetProgramsQCOM`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    #[cfg(any(feature = "GL_QCOM_extended_get2"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_QCOM_extended_get2"))))]
    pub fn glExtGetProgramsQCOM_is_loaded() -> bool {
        !glExtGetProgramsQCOM_p.load(RELAX).is_null()
    }

    /// [glExtGetRenderbuffersQCOM](http://docs.gl/es3/glExtGetRenderbuffersQCOM)(renderbuffers, maxRenderbuffers, numRenderbuffers)
    /// `renderbuffers` len: maxRenderbuffers
    /// `renderbuffers` class: renderbuffer
    /// `numRenderbuffers` len: 1
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    #[cfg(any(feature = "GL_QCOM_extended_get"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_QCOM_extended_get"))))]
    pub unsafe fn glExtGetRenderbuffersQCOM(
        renderbuffers: *mut GLuint,
        maxRenderbuffers: GLint,
        numRenderbuffers: *mut GLint,
    ) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glExtGetRenderbuffersQCOM({:p}, {:?}, {:p});",
                renderbuffers,
                maxRenderbuffers,
                numRenderbuffers
            );
        }
        let out = call_atomic_ptr_3arg(
            "glExtGetRenderbuffersQCOM",
            &glExtGetRenderbuffersQCOM_p,
            renderbuffers,
            maxRenderbuffers,
            numRenderbuffers,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glExtGetRenderbuffersQCOM");
        }
        out
    }
    #[cfg(any(feature = "GL_QCOM_extended_get"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_QCOM_extended_get"))))]
    static glExtGetRenderbuffersQCOM_p: APcv = ap_None();
    /// Tries to load [`glExtGetRenderbuffersQCOM`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    #[cfg(any(feature = "GL_QCOM_extended_get"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_QCOM_extended_get"))))]
    pub unsafe fn glExtGetRenderbuffersQCOM_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glExtGetRenderbuffersQCOM\0",
            &glExtGetRenderbuffersQCOM_p,
        )
    }
    /// Checks if the pointer for [`glExtGetRenderbuffersQCOM`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    #[cfg(any(feature = "GL_QCOM_extended_get"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_QCOM_extended_get"))))]
    pub fn glExtGetRenderbuffersQCOM_is_loaded() -> bool {
        !glExtGetRenderbuffersQCOM_p.load(RELAX).is_null()
    }

    /// [glExtGetShadersQCOM](http://docs.gl/es3/glExtGetShadersQCOM)(shaders, maxShaders, numShaders)
    /// `shaders` len: maxShaders
    /// `shaders` class: shader
    /// `numShaders` len: 1
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    #[cfg(any(feature = "GL_QCOM_extended_get2"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_QCOM_extended_get2"))))]
    pub unsafe fn glExtGetShadersQCOM(
        shaders: *mut GLuint,
        maxShaders: GLint,
        numShaders: *mut GLint,
    ) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glExtGetShadersQCOM({:p}, {:?}, {:p});",
                shaders,
                maxShaders,
                numShaders
            );
        }
        let out = call_atomic_ptr_3arg(
            "glExtGetShadersQCOM",
            &glExtGetShadersQCOM_p,
            shaders,
            maxShaders,
            numShaders,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glExtGetShadersQCOM");
        }
        out
    }
    #[cfg(any(feature = "GL_QCOM_extended_get2"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_QCOM_extended_get2"))))]
    static glExtGetShadersQCOM_p: APcv = ap_None();
    /// Tries to load [`glExtGetShadersQCOM`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    #[cfg(any(feature = "GL_QCOM_extended_get2"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_QCOM_extended_get2"))))]
    pub unsafe fn glExtGetShadersQCOM_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glExtGetShadersQCOM\0",
            &glExtGetShadersQCOM_p,
        )
    }
    /// Checks if the pointer for [`glExtGetShadersQCOM`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    #[cfg(any(feature = "GL_QCOM_extended_get2"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_QCOM_extended_get2"))))]
    pub fn glExtGetShadersQCOM_is_loaded() -> bool {
        !glExtGetShadersQCOM_p.load(RELAX).is_null()
    }

    /// [glExtGetTexLevelParameterivQCOM](http://docs.gl/es3/glExtGetTexLevelParameterivQCOM)(texture, face, level, pname, params)
    /// `texture` class: texture
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    #[cfg(any(feature = "GL_QCOM_extended_get"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_QCOM_extended_get"))))]
    pub unsafe fn glExtGetTexLevelParameterivQCOM(
        texture: GLuint,
        face: GLenum,
        level: GLint,
        pname: GLenum,
        params: *mut GLint,
    ) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glExtGetTexLevelParameterivQCOM({:?}, {:#X}, {:?}, {:#X}, {:p});",
                texture,
                face,
                level,
                pname,
                params
            );
        }
        let out = call_atomic_ptr_5arg(
            "glExtGetTexLevelParameterivQCOM",
            &glExtGetTexLevelParameterivQCOM_p,
            texture,
            face,
            level,
            pname,
            params,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glExtGetTexLevelParameterivQCOM");
        }
        out
    }
    #[cfg(any(feature = "GL_QCOM_extended_get"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_QCOM_extended_get"))))]
    static glExtGetTexLevelParameterivQCOM_p: APcv = ap_None();
    /// Tries to load [`glExtGetTexLevelParameterivQCOM`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    #[cfg(any(feature = "GL_QCOM_extended_get"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_QCOM_extended_get"))))]
    pub unsafe fn glExtGetTexLevelParameterivQCOM_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glExtGetTexLevelParameterivQCOM\0",
            &glExtGetTexLevelParameterivQCOM_p,
        )
    }
    /// Checks if the pointer for [`glExtGetTexLevelParameterivQCOM`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    #[cfg(any(feature = "GL_QCOM_extended_get"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_QCOM_extended_get"))))]
    pub fn glExtGetTexLevelParameterivQCOM_is_loaded() -> bool {
        !glExtGetTexLevelParameterivQCOM_p.load(RELAX).is_null()
    }

    /// [glExtGetTexSubImageQCOM](http://docs.gl/es3/glExtGetTexSubImageQCOM)(target, level, xoffset, yoffset, zoffset, width, height, depth, format, type_, texels)
    /// `format` group: PixelFormat
    /// `type_` group: PixelType
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    #[cfg(any(feature = "GL_QCOM_extended_get"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_QCOM_extended_get"))))]
    pub unsafe fn glExtGetTexSubImageQCOM(
        target: GLenum,
        level: GLint,
        xoffset: GLint,
        yoffset: GLint,
        zoffset: GLint,
        width: GLsizei,
        height: GLsizei,
        depth: GLsizei,
        format: GLenum,
        type_: GLenum,
        texels: *mut c_void,
    ) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glExtGetTexSubImageQCOM({:#X}, {:?}, {:?}, {:?}, {:?}, {:?}, {:?}, {:?}, {:#X}, {:#X}, {:p});",
                target,
                level,
                xoffset,
                yoffset,
                zoffset,
                width,
                height,
                depth,
                format,
                type_,
                texels
            );
        }
        let out = call_atomic_ptr_11arg(
            "glExtGetTexSubImageQCOM",
            &glExtGetTexSubImageQCOM_p,
            target,
            level,
            xoffset,
            yoffset,
            zoffset,
            width,
            height,
            depth,
            format,
            type_,
            texels,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glExtGetTexSubImageQCOM");
        }
        out
    }
    #[cfg(any(feature = "GL_QCOM_extended_get"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_QCOM_extended_get"))))]
    static glExtGetTexSubImageQCOM_p: APcv = ap_None();
    /// Tries to load [`glExtGetTexSubImageQCOM`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    #[cfg(any(feature = "GL_QCOM_extended_get"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_QCOM_extended_get"))))]
    pub unsafe fn glExtGetTexSubImageQCOM_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glExtGetTexSubImageQCOM\0",
            &glExtGetTexSubImageQCOM_p,
        )
    }
    /// Checks if the pointer for [`glExtGetTexSubImageQCOM`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    #[cfg(any(feature = "GL_QCOM_extended_get"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_QCOM_extended_get"))))]
    pub fn glExtGetTexSubImageQCOM_is_loaded() -> bool {
        !glExtGetTexSubImageQCOM_p.load(RELAX).is_null()
    }

    /// [glExtGetTexturesQCOM](http://docs.gl/es3/glExtGetTexturesQCOM)(textures, maxTextures, numTextures)
    /// `textures` class: texture
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    #[cfg(any(feature = "GL_QCOM_extended_get"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_QCOM_extended_get"))))]
    pub unsafe fn glExtGetTexturesQCOM(
        textures: *mut GLuint,
        maxTextures: GLint,
        numTextures: *mut GLint,
    ) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glExtGetTexturesQCOM({:p}, {:?}, {:p});",
                textures,
                maxTextures,
                numTextures
            );
        }
        let out = call_atomic_ptr_3arg(
            "glExtGetTexturesQCOM",
            &glExtGetTexturesQCOM_p,
            textures,
            maxTextures,
            numTextures,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glExtGetTexturesQCOM");
        }
        out
    }
    #[cfg(any(feature = "GL_QCOM_extended_get"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_QCOM_extended_get"))))]
    static glExtGetTexturesQCOM_p: APcv = ap_None();
    /// Tries to load [`glExtGetTexturesQCOM`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    #[cfg(any(feature = "GL_QCOM_extended_get"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_QCOM_extended_get"))))]
    pub unsafe fn glExtGetTexturesQCOM_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glExtGetTexturesQCOM\0",
            &glExtGetTexturesQCOM_p,
        )
    }
    /// Checks if the pointer for [`glExtGetTexturesQCOM`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    #[cfg(any(feature = "GL_QCOM_extended_get"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_QCOM_extended_get"))))]
    pub fn glExtGetTexturesQCOM_is_loaded() -> bool {
        !glExtGetTexturesQCOM_p.load(RELAX).is_null()
    }

    /// [glExtIsProgramBinaryQCOM](http://docs.gl/es3/glExtIsProgramBinaryQCOM)(program)
    /// `program` class: program
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    #[cfg(any(feature = "GL_QCOM_extended_get2"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_QCOM_extended_get2"))))]
    pub unsafe fn glExtIsProgramBinaryQCOM(program: GLuint) -> GLboolean {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!("calling glExtIsProgramBinaryQCOM({:?});", program);
        }
        let out = call_atomic_ptr_1arg(
            "glExtIsProgramBinaryQCOM",
            &glExtIsProgramBinaryQCOM_p,
            program,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glExtIsProgramBinaryQCOM");
        }
        out
    }
    #[cfg(any(feature = "GL_QCOM_extended_get2"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_QCOM_extended_get2"))))]
    static glExtIsProgramBinaryQCOM_p: APcv = ap_None();
    /// Tries to load [`glExtIsProgramBinaryQCOM`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    #[cfg(any(feature = "GL_QCOM_extended_get2"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_QCOM_extended_get2"))))]
    pub unsafe fn glExtIsProgramBinaryQCOM_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glExtIsProgramBinaryQCOM\0",
            &glExtIsProgramBinaryQCOM_p,
        )
    }
    /// Checks if the pointer for [`glExtIsProgramBinaryQCOM`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    #[cfg(any(feature = "GL_QCOM_extended_get2"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_QCOM_extended_get2"))))]
    pub fn glExtIsProgramBinaryQCOM_is_loaded() -> bool {
        !glExtIsProgramBinaryQCOM_p.load(RELAX).is_null()
    }

    /// [glExtTexObjectStateOverrideiQCOM](http://docs.gl/es3/glExtTexObjectStateOverrideiQCOM)(target, pname, param)
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    #[cfg(any(feature = "GL_QCOM_extended_get"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_QCOM_extended_get"))))]
    pub unsafe fn glExtTexObjectStateOverrideiQCOM(target: GLenum, pname: GLenum, param: GLint) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glExtTexObjectStateOverrideiQCOM({:#X}, {:#X}, {:?});",
                target,
                pname,
                param
            );
        }
        let out = call_atomic_ptr_3arg(
            "glExtTexObjectStateOverrideiQCOM",
            &glExtTexObjectStateOverrideiQCOM_p,
            target,
            pname,
            param,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glExtTexObjectStateOverrideiQCOM");
        }
        out
    }
    #[cfg(any(feature = "GL_QCOM_extended_get"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_QCOM_extended_get"))))]
    static glExtTexObjectStateOverrideiQCOM_p: APcv = ap_None();
    /// Tries to load [`glExtTexObjectStateOverrideiQCOM`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    #[cfg(any(feature = "GL_QCOM_extended_get"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_QCOM_extended_get"))))]
    pub unsafe fn glExtTexObjectStateOverrideiQCOM_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glExtTexObjectStateOverrideiQCOM\0",
            &glExtTexObjectStateOverrideiQCOM_p,
        )
    }
    /// Checks if the pointer for [`glExtTexObjectStateOverrideiQCOM`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    #[cfg(any(feature = "GL_QCOM_extended_get"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_QCOM_extended_get"))))]
    pub fn glExtTexObjectStateOverrideiQCOM_is_loaded() -> bool {
        !glExtTexObjectStateOverrideiQCOM_p.load(RELAX).is_null()
    }

    /// [glExtrapolateTex2DQCOM](http://docs.gl/es3/glExtrapolateTex2DQCOM)(src1, src2, output, scaleFactor)
    /// `src1` class: texture
    /// `src2` class: texture
    /// `output` class: texture
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    #[cfg(any(feature = "GL_QCOM_frame_extrapolation"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_QCOM_frame_extrapolation"))))]
    pub unsafe fn glExtrapolateTex2DQCOM(
        src1: GLuint,
        src2: GLuint,
        output: GLuint,
        scaleFactor: GLfloat,
    ) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glExtrapolateTex2DQCOM({:?}, {:?}, {:?}, {:?});",
                src1,
                src2,
                output,
                scaleFactor
            );
        }
        let out = call_atomic_ptr_4arg(
            "glExtrapolateTex2DQCOM",
            &glExtrapolateTex2DQCOM_p,
            src1,
            src2,
            output,
            scaleFactor,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glExtrapolateTex2DQCOM");
        }
        out
    }
    #[cfg(any(feature = "GL_QCOM_frame_extrapolation"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_QCOM_frame_extrapolation"))))]
    static glExtrapolateTex2DQCOM_p: APcv = ap_None();
    /// Tries to load [`glExtrapolateTex2DQCOM`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    #[cfg(any(feature = "GL_QCOM_frame_extrapolation"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_QCOM_frame_extrapolation"))))]
    pub unsafe fn glExtrapolateTex2DQCOM_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glExtrapolateTex2DQCOM\0",
            &glExtrapolateTex2DQCOM_p,
        )
    }
    /// Checks if the pointer for [`glExtrapolateTex2DQCOM`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    #[cfg(any(feature = "GL_QCOM_frame_extrapolation"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_QCOM_frame_extrapolation"))))]
    pub fn glExtrapolateTex2DQCOM_is_loaded() -> bool {
        !glExtrapolateTex2DQCOM_p.load(RELAX).is_null()
    }

    /// [glFenceSync](http://docs.gl/es3/glFenceSync)(condition, flags)
    /// `condition` group: SyncCondition
    /// `flags` group: SyncBehaviorFlags
    /// return value group: sync
    /// return value class: sync
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn glFenceSync(condition: GLenum, flags: GLbitfield) -> GLsync {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!("calling glFenceSync({:#X}, {:?});", condition, flags);
        }
        let out = call_atomic_ptr_2arg("glFenceSync", &glFenceSync_p, condition, flags);
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glFenceSync");
        }
        out
    }
    static glFenceSync_p: APcv = ap_None();
    /// Tries to load [`glFenceSync`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    pub unsafe fn glFenceSync_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(get_proc_address, b"glFenceSync\0", &glFenceSync_p)
    }
    /// Checks if the pointer for [`glFenceSync`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    pub fn glFenceSync_is_loaded() -> bool {
        !glFenceSync_p.load(RELAX).is_null()
    }

    /// [glFenceSyncAPPLE](http://docs.gl/es3/glFenceSyncAPPLE)(condition, flags)
    /// `condition` group: SyncCondition
    /// `flags` group: SyncBehaviorFlags
    /// return value group: sync
    /// return value class: sync
    /// alias of: [`glFenceSync`]
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    #[cfg(any(feature = "GL_APPLE_sync"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_APPLE_sync"))))]
    pub unsafe fn glFenceSyncAPPLE(condition: GLenum, flags: GLbitfield) -> GLsync {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!("calling glFenceSyncAPPLE({:#X}, {:?});", condition, flags);
        }
        let out = call_atomic_ptr_2arg("glFenceSyncAPPLE", &glFenceSyncAPPLE_p, condition, flags);
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glFenceSyncAPPLE");
        }
        out
    }
    #[cfg(any(feature = "GL_APPLE_sync"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_APPLE_sync"))))]
    static glFenceSyncAPPLE_p: APcv = ap_None();
    /// Tries to load [`glFenceSyncAPPLE`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    #[cfg(any(feature = "GL_APPLE_sync"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_APPLE_sync"))))]
    pub unsafe fn glFenceSyncAPPLE_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(get_proc_address, b"glFenceSyncAPPLE\0", &glFenceSyncAPPLE_p)
    }
    /// Checks if the pointer for [`glFenceSyncAPPLE`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    #[cfg(any(feature = "GL_APPLE_sync"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_APPLE_sync"))))]
    pub fn glFenceSyncAPPLE_is_loaded() -> bool {
        !glFenceSyncAPPLE_p.load(RELAX).is_null()
    }

    /// [glFinish](http://docs.gl/es3/glFinish)()
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn glFinish() {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!("calling glFinish();",);
        }
        let out = call_atomic_ptr_0arg("glFinish", &glFinish_p);
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glFinish");
        }
        out
    }
    static glFinish_p: APcv = ap_None();
    /// Tries to load [`glFinish`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    pub unsafe fn glFinish_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(get_proc_address, b"glFinish\0", &glFinish_p)
    }
    /// Checks if the pointer for [`glFinish`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    pub fn glFinish_is_loaded() -> bool {
        !glFinish_p.load(RELAX).is_null()
    }

    /// [glFinishFenceNV](http://docs.gl/es3/glFinishFenceNV)(fence)
    /// `fence` group: FenceNV
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    #[cfg(any(feature = "GL_NV_fence"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_fence"))))]
    pub unsafe fn glFinishFenceNV(fence: GLuint) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!("calling glFinishFenceNV({:?});", fence);
        }
        let out = call_atomic_ptr_1arg("glFinishFenceNV", &glFinishFenceNV_p, fence);
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glFinishFenceNV");
        }
        out
    }
    #[cfg(any(feature = "GL_NV_fence"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_fence"))))]
    static glFinishFenceNV_p: APcv = ap_None();
    /// Tries to load [`glFinishFenceNV`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    #[cfg(any(feature = "GL_NV_fence"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_fence"))))]
    pub unsafe fn glFinishFenceNV_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(get_proc_address, b"glFinishFenceNV\0", &glFinishFenceNV_p)
    }
    /// Checks if the pointer for [`glFinishFenceNV`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    #[cfg(any(feature = "GL_NV_fence"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_fence"))))]
    pub fn glFinishFenceNV_is_loaded() -> bool {
        !glFinishFenceNV_p.load(RELAX).is_null()
    }

    /// [glFlush](http://docs.gl/es3/glFlush)()
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn glFlush() {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!("calling glFlush();",);
        }
        let out = call_atomic_ptr_0arg("glFlush", &glFlush_p);
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glFlush");
        }
        out
    }
    static glFlush_p: APcv = ap_None();
    /// Tries to load [`glFlush`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    pub unsafe fn glFlush_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(get_proc_address, b"glFlush\0", &glFlush_p)
    }
    /// Checks if the pointer for [`glFlush`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    pub fn glFlush_is_loaded() -> bool {
        !glFlush_p.load(RELAX).is_null()
    }

    /// [glFlushMappedBufferRange](http://docs.gl/es3/glFlushMappedBufferRange)(target, offset, length)
    /// `target` group: BufferTargetARB
    /// `offset` group: BufferOffset
    /// `length` group: BufferSize
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn glFlushMappedBufferRange(target: GLenum, offset: GLintptr, length: GLsizeiptr) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glFlushMappedBufferRange({:#X}, {:?}, {:?});",
                target,
                offset,
                length
            );
        }
        let out = call_atomic_ptr_3arg(
            "glFlushMappedBufferRange",
            &glFlushMappedBufferRange_p,
            target,
            offset,
            length,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glFlushMappedBufferRange");
        }
        out
    }
    static glFlushMappedBufferRange_p: APcv = ap_None();
    /// Tries to load [`glFlushMappedBufferRange`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    pub unsafe fn glFlushMappedBufferRange_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glFlushMappedBufferRange\0",
            &glFlushMappedBufferRange_p,
        )
    }
    /// Checks if the pointer for [`glFlushMappedBufferRange`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    pub fn glFlushMappedBufferRange_is_loaded() -> bool {
        !glFlushMappedBufferRange_p.load(RELAX).is_null()
    }

    /// [glFlushMappedBufferRangeEXT](http://docs.gl/es3/glFlushMappedBufferRangeEXT)(target, offset, length)
    /// `target` group: BufferTargetARB
    /// alias of: [`glFlushMappedBufferRange`]
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    #[cfg(any(feature = "GL_EXT_map_buffer_range"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_map_buffer_range"))))]
    pub unsafe fn glFlushMappedBufferRangeEXT(
        target: GLenum,
        offset: GLintptr,
        length: GLsizeiptr,
    ) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glFlushMappedBufferRangeEXT({:#X}, {:?}, {:?});",
                target,
                offset,
                length
            );
        }
        let out = call_atomic_ptr_3arg(
            "glFlushMappedBufferRangeEXT",
            &glFlushMappedBufferRangeEXT_p,
            target,
            offset,
            length,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glFlushMappedBufferRangeEXT");
        }
        out
    }
    #[cfg(any(feature = "GL_EXT_map_buffer_range"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_map_buffer_range"))))]
    static glFlushMappedBufferRangeEXT_p: APcv = ap_None();
    /// Tries to load [`glFlushMappedBufferRangeEXT`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    #[cfg(any(feature = "GL_EXT_map_buffer_range"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_map_buffer_range"))))]
    pub unsafe fn glFlushMappedBufferRangeEXT_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glFlushMappedBufferRangeEXT\0",
            &glFlushMappedBufferRangeEXT_p,
        )
    }
    /// Checks if the pointer for [`glFlushMappedBufferRangeEXT`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    #[cfg(any(feature = "GL_EXT_map_buffer_range"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_map_buffer_range"))))]
    pub fn glFlushMappedBufferRangeEXT_is_loaded() -> bool {
        !glFlushMappedBufferRangeEXT_p.load(RELAX).is_null()
    }

    /// [glFragmentCoverageColorNV](http://docs.gl/es3/glFragmentCoverageColorNV)(color)
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    #[cfg(any(feature = "GL_NV_fragment_coverage_to_color"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_fragment_coverage_to_color"))))]
    pub unsafe fn glFragmentCoverageColorNV(color: GLuint) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!("calling glFragmentCoverageColorNV({:?});", color);
        }
        let out = call_atomic_ptr_1arg(
            "glFragmentCoverageColorNV",
            &glFragmentCoverageColorNV_p,
            color,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glFragmentCoverageColorNV");
        }
        out
    }
    #[cfg(any(feature = "GL_NV_fragment_coverage_to_color"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_fragment_coverage_to_color"))))]
    static glFragmentCoverageColorNV_p: APcv = ap_None();
    /// Tries to load [`glFragmentCoverageColorNV`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    #[cfg(any(feature = "GL_NV_fragment_coverage_to_color"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_fragment_coverage_to_color"))))]
    pub unsafe fn glFragmentCoverageColorNV_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glFragmentCoverageColorNV\0",
            &glFragmentCoverageColorNV_p,
        )
    }
    /// Checks if the pointer for [`glFragmentCoverageColorNV`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    #[cfg(any(feature = "GL_NV_fragment_coverage_to_color"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_fragment_coverage_to_color"))))]
    pub fn glFragmentCoverageColorNV_is_loaded() -> bool {
        !glFragmentCoverageColorNV_p.load(RELAX).is_null()
    }

    /// [glFramebufferFetchBarrierEXT](http://docs.gl/es3/glFramebufferFetchBarrierEXT)()
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    #[cfg(any(feature = "GL_EXT_shader_framebuffer_fetch_non_coherent"))]
    #[cfg_attr(
        docs_rs,
        doc(cfg(any(feature = "GL_EXT_shader_framebuffer_fetch_non_coherent")))
    )]
    pub unsafe fn glFramebufferFetchBarrierEXT() {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!("calling glFramebufferFetchBarrierEXT();",);
        }
        let out = call_atomic_ptr_0arg(
            "glFramebufferFetchBarrierEXT",
            &glFramebufferFetchBarrierEXT_p,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glFramebufferFetchBarrierEXT");
        }
        out
    }
    #[cfg(any(feature = "GL_EXT_shader_framebuffer_fetch_non_coherent"))]
    #[cfg_attr(
        docs_rs,
        doc(cfg(any(feature = "GL_EXT_shader_framebuffer_fetch_non_coherent")))
    )]
    static glFramebufferFetchBarrierEXT_p: APcv = ap_None();
    /// Tries to load [`glFramebufferFetchBarrierEXT`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    #[cfg(any(feature = "GL_EXT_shader_framebuffer_fetch_non_coherent"))]
    #[cfg_attr(
        docs_rs,
        doc(cfg(any(feature = "GL_EXT_shader_framebuffer_fetch_non_coherent")))
    )]
    pub unsafe fn glFramebufferFetchBarrierEXT_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glFramebufferFetchBarrierEXT\0",
            &glFramebufferFetchBarrierEXT_p,
        )
    }
    /// Checks if the pointer for [`glFramebufferFetchBarrierEXT`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    #[cfg(any(feature = "GL_EXT_shader_framebuffer_fetch_non_coherent"))]
    #[cfg_attr(
        docs_rs,
        doc(cfg(any(feature = "GL_EXT_shader_framebuffer_fetch_non_coherent")))
    )]
    pub fn glFramebufferFetchBarrierEXT_is_loaded() -> bool {
        !glFramebufferFetchBarrierEXT_p.load(RELAX).is_null()
    }

    /// [glFramebufferFetchBarrierQCOM](http://docs.gl/es3/glFramebufferFetchBarrierQCOM)()
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    #[cfg(any(feature = "GL_QCOM_shader_framebuffer_fetch_noncoherent"))]
    #[cfg_attr(
        docs_rs,
        doc(cfg(any(feature = "GL_QCOM_shader_framebuffer_fetch_noncoherent")))
    )]
    pub unsafe fn glFramebufferFetchBarrierQCOM() {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!("calling glFramebufferFetchBarrierQCOM();",);
        }
        let out = call_atomic_ptr_0arg(
            "glFramebufferFetchBarrierQCOM",
            &glFramebufferFetchBarrierQCOM_p,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glFramebufferFetchBarrierQCOM");
        }
        out
    }
    #[cfg(any(feature = "GL_QCOM_shader_framebuffer_fetch_noncoherent"))]
    #[cfg_attr(
        docs_rs,
        doc(cfg(any(feature = "GL_QCOM_shader_framebuffer_fetch_noncoherent")))
    )]
    static glFramebufferFetchBarrierQCOM_p: APcv = ap_None();
    /// Tries to load [`glFramebufferFetchBarrierQCOM`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    #[cfg(any(feature = "GL_QCOM_shader_framebuffer_fetch_noncoherent"))]
    #[cfg_attr(
        docs_rs,
        doc(cfg(any(feature = "GL_QCOM_shader_framebuffer_fetch_noncoherent")))
    )]
    pub unsafe fn glFramebufferFetchBarrierQCOM_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glFramebufferFetchBarrierQCOM\0",
            &glFramebufferFetchBarrierQCOM_p,
        )
    }
    /// Checks if the pointer for [`glFramebufferFetchBarrierQCOM`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    #[cfg(any(feature = "GL_QCOM_shader_framebuffer_fetch_noncoherent"))]
    #[cfg_attr(
        docs_rs,
        doc(cfg(any(feature = "GL_QCOM_shader_framebuffer_fetch_noncoherent")))
    )]
    pub fn glFramebufferFetchBarrierQCOM_is_loaded() -> bool {
        !glFramebufferFetchBarrierQCOM_p.load(RELAX).is_null()
    }

    /// [glFramebufferFoveationConfigQCOM](http://docs.gl/es3/glFramebufferFoveationConfigQCOM)(framebuffer, numLayers, focalPointsPerLayer, requestedFeatures, providedFeatures)
    /// `framebuffer` group: Framebuffer
    /// `framebuffer` class: framebuffer
    /// `providedFeatures` len: 1
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    #[cfg(any(feature = "GL_QCOM_framebuffer_foveated"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_QCOM_framebuffer_foveated"))))]
    pub unsafe fn glFramebufferFoveationConfigQCOM(
        framebuffer: GLuint,
        numLayers: GLuint,
        focalPointsPerLayer: GLuint,
        requestedFeatures: GLuint,
        providedFeatures: *mut GLuint,
    ) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glFramebufferFoveationConfigQCOM({:?}, {:?}, {:?}, {:?}, {:p});",
                framebuffer,
                numLayers,
                focalPointsPerLayer,
                requestedFeatures,
                providedFeatures
            );
        }
        let out = call_atomic_ptr_5arg(
            "glFramebufferFoveationConfigQCOM",
            &glFramebufferFoveationConfigQCOM_p,
            framebuffer,
            numLayers,
            focalPointsPerLayer,
            requestedFeatures,
            providedFeatures,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glFramebufferFoveationConfigQCOM");
        }
        out
    }
    #[cfg(any(feature = "GL_QCOM_framebuffer_foveated"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_QCOM_framebuffer_foveated"))))]
    static glFramebufferFoveationConfigQCOM_p: APcv = ap_None();
    /// Tries to load [`glFramebufferFoveationConfigQCOM`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    #[cfg(any(feature = "GL_QCOM_framebuffer_foveated"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_QCOM_framebuffer_foveated"))))]
    pub unsafe fn glFramebufferFoveationConfigQCOM_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glFramebufferFoveationConfigQCOM\0",
            &glFramebufferFoveationConfigQCOM_p,
        )
    }
    /// Checks if the pointer for [`glFramebufferFoveationConfigQCOM`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    #[cfg(any(feature = "GL_QCOM_framebuffer_foveated"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_QCOM_framebuffer_foveated"))))]
    pub fn glFramebufferFoveationConfigQCOM_is_loaded() -> bool {
        !glFramebufferFoveationConfigQCOM_p.load(RELAX).is_null()
    }

    /// [glFramebufferFoveationParametersQCOM](http://docs.gl/es3/glFramebufferFoveationParametersQCOM)(framebuffer, layer, focalPoint, focalX, focalY, gainX, gainY, foveaArea)
    /// `framebuffer` group: Framebuffer
    /// `framebuffer` class: framebuffer
    /// `focalX` group: CheckedFloat32
    /// `focalY` group: CheckedFloat32
    /// `gainX` group: CheckedFloat32
    /// `gainY` group: CheckedFloat32
    /// `foveaArea` group: CheckedFloat32
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    #[cfg(any(feature = "GL_QCOM_framebuffer_foveated"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_QCOM_framebuffer_foveated"))))]
    pub unsafe fn glFramebufferFoveationParametersQCOM(
        framebuffer: GLuint,
        layer: GLuint,
        focalPoint: GLuint,
        focalX: GLfloat,
        focalY: GLfloat,
        gainX: GLfloat,
        gainY: GLfloat,
        foveaArea: GLfloat,
    ) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glFramebufferFoveationParametersQCOM({:?}, {:?}, {:?}, {:?}, {:?}, {:?}, {:?}, {:?});",
                framebuffer,
                layer,
                focalPoint,
                focalX,
                focalY,
                gainX,
                gainY,
                foveaArea
            );
        }
        let out = call_atomic_ptr_8arg(
            "glFramebufferFoveationParametersQCOM",
            &glFramebufferFoveationParametersQCOM_p,
            framebuffer,
            layer,
            focalPoint,
            focalX,
            focalY,
            gainX,
            gainY,
            foveaArea,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glFramebufferFoveationParametersQCOM");
        }
        out
    }
    #[cfg(any(feature = "GL_QCOM_framebuffer_foveated"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_QCOM_framebuffer_foveated"))))]
    static glFramebufferFoveationParametersQCOM_p: APcv = ap_None();
    /// Tries to load [`glFramebufferFoveationParametersQCOM`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    #[cfg(any(feature = "GL_QCOM_framebuffer_foveated"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_QCOM_framebuffer_foveated"))))]
    pub unsafe fn glFramebufferFoveationParametersQCOM_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glFramebufferFoveationParametersQCOM\0",
            &glFramebufferFoveationParametersQCOM_p,
        )
    }
    /// Checks if the pointer for [`glFramebufferFoveationParametersQCOM`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    #[cfg(any(feature = "GL_QCOM_framebuffer_foveated"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_QCOM_framebuffer_foveated"))))]
    pub fn glFramebufferFoveationParametersQCOM_is_loaded() -> bool {
        !glFramebufferFoveationParametersQCOM_p.load(RELAX).is_null()
    }

    /// [glFramebufferParameteri](http://docs.gl/es3/glFramebufferParameter)(target, pname, param)
    /// `target` group: FramebufferTarget
    /// `pname` group: FramebufferParameterName
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn glFramebufferParameteri(target: GLenum, pname: GLenum, param: GLint) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glFramebufferParameteri({:#X}, {:#X}, {:?});",
                target,
                pname,
                param
            );
        }
        let out = call_atomic_ptr_3arg(
            "glFramebufferParameteri",
            &glFramebufferParameteri_p,
            target,
            pname,
            param,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glFramebufferParameteri");
        }
        out
    }
    static glFramebufferParameteri_p: APcv = ap_None();
    /// Tries to load [`glFramebufferParameteri`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    pub unsafe fn glFramebufferParameteri_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glFramebufferParameteri\0",
            &glFramebufferParameteri_p,
        )
    }
    /// Checks if the pointer for [`glFramebufferParameteri`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    pub fn glFramebufferParameteri_is_loaded() -> bool {
        !glFramebufferParameteri_p.load(RELAX).is_null()
    }

    /// [glFramebufferParameteriMESA](http://docs.gl/es3/glFramebufferParameteriMESA)(target, pname, param)
    /// `target` group: FramebufferTarget
    /// `pname` group: FramebufferParameterName
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    #[cfg(any(feature = "GL_MESA_framebuffer_flip_y"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_MESA_framebuffer_flip_y"))))]
    pub unsafe fn glFramebufferParameteriMESA(target: GLenum, pname: GLenum, param: GLint) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glFramebufferParameteriMESA({:#X}, {:#X}, {:?});",
                target,
                pname,
                param
            );
        }
        let out = call_atomic_ptr_3arg(
            "glFramebufferParameteriMESA",
            &glFramebufferParameteriMESA_p,
            target,
            pname,
            param,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glFramebufferParameteriMESA");
        }
        out
    }
    #[cfg(any(feature = "GL_MESA_framebuffer_flip_y"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_MESA_framebuffer_flip_y"))))]
    static glFramebufferParameteriMESA_p: APcv = ap_None();
    /// Tries to load [`glFramebufferParameteriMESA`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    #[cfg(any(feature = "GL_MESA_framebuffer_flip_y"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_MESA_framebuffer_flip_y"))))]
    pub unsafe fn glFramebufferParameteriMESA_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glFramebufferParameteriMESA\0",
            &glFramebufferParameteriMESA_p,
        )
    }
    /// Checks if the pointer for [`glFramebufferParameteriMESA`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    #[cfg(any(feature = "GL_MESA_framebuffer_flip_y"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_MESA_framebuffer_flip_y"))))]
    pub fn glFramebufferParameteriMESA_is_loaded() -> bool {
        !glFramebufferParameteriMESA_p.load(RELAX).is_null()
    }

    /// [glFramebufferPixelLocalStorageSizeEXT](http://docs.gl/es3/glFramebufferPixelLocalStorageSizeEXT)(target, size)
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    #[cfg(any(feature = "GL_EXT_shader_pixel_local_storage2"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_shader_pixel_local_storage2"))))]
    pub unsafe fn glFramebufferPixelLocalStorageSizeEXT(target: GLuint, size: GLsizei) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glFramebufferPixelLocalStorageSizeEXT({:?}, {:?});",
                target,
                size
            );
        }
        let out = call_atomic_ptr_2arg(
            "glFramebufferPixelLocalStorageSizeEXT",
            &glFramebufferPixelLocalStorageSizeEXT_p,
            target,
            size,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glFramebufferPixelLocalStorageSizeEXT");
        }
        out
    }
    #[cfg(any(feature = "GL_EXT_shader_pixel_local_storage2"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_shader_pixel_local_storage2"))))]
    static glFramebufferPixelLocalStorageSizeEXT_p: APcv = ap_None();
    /// Tries to load [`glFramebufferPixelLocalStorageSizeEXT`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    #[cfg(any(feature = "GL_EXT_shader_pixel_local_storage2"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_shader_pixel_local_storage2"))))]
    pub unsafe fn glFramebufferPixelLocalStorageSizeEXT_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glFramebufferPixelLocalStorageSizeEXT\0",
            &glFramebufferPixelLocalStorageSizeEXT_p,
        )
    }
    /// Checks if the pointer for [`glFramebufferPixelLocalStorageSizeEXT`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    #[cfg(any(feature = "GL_EXT_shader_pixel_local_storage2"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_shader_pixel_local_storage2"))))]
    pub fn glFramebufferPixelLocalStorageSizeEXT_is_loaded() -> bool {
        !glFramebufferPixelLocalStorageSizeEXT_p
            .load(RELAX)
            .is_null()
    }

    /// [glFramebufferRenderbuffer](http://docs.gl/es3/glFramebufferRenderbuffer)(target, attachment, renderbuffertarget, renderbuffer)
    /// `target` group: FramebufferTarget
    /// `attachment` group: FramebufferAttachment
    /// `renderbuffertarget` group: RenderbufferTarget
    /// `renderbuffer` class: renderbuffer
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn glFramebufferRenderbuffer(
        target: GLenum,
        attachment: GLenum,
        renderbuffertarget: GLenum,
        renderbuffer: GLuint,
    ) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glFramebufferRenderbuffer({:#X}, {:#X}, {:#X}, {:?});",
                target,
                attachment,
                renderbuffertarget,
                renderbuffer
            );
        }
        let out = call_atomic_ptr_4arg(
            "glFramebufferRenderbuffer",
            &glFramebufferRenderbuffer_p,
            target,
            attachment,
            renderbuffertarget,
            renderbuffer,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glFramebufferRenderbuffer");
        }
        out
    }
    static glFramebufferRenderbuffer_p: APcv = ap_None();
    /// Tries to load [`glFramebufferRenderbuffer`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    pub unsafe fn glFramebufferRenderbuffer_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glFramebufferRenderbuffer\0",
            &glFramebufferRenderbuffer_p,
        )
    }
    /// Checks if the pointer for [`glFramebufferRenderbuffer`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    pub fn glFramebufferRenderbuffer_is_loaded() -> bool {
        !glFramebufferRenderbuffer_p.load(RELAX).is_null()
    }

    /// [glFramebufferSampleLocationsfvNV](http://docs.gl/es3/glFramebufferSampleLocationsfvNV)(target, start, count, v)
    /// `target` group: FramebufferTarget
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    #[cfg(any(feature = "GL_NV_sample_locations"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_sample_locations"))))]
    pub unsafe fn glFramebufferSampleLocationsfvNV(
        target: GLenum,
        start: GLuint,
        count: GLsizei,
        v: *const GLfloat,
    ) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glFramebufferSampleLocationsfvNV({:#X}, {:?}, {:?}, {:p});",
                target,
                start,
                count,
                v
            );
        }
        let out = call_atomic_ptr_4arg(
            "glFramebufferSampleLocationsfvNV",
            &glFramebufferSampleLocationsfvNV_p,
            target,
            start,
            count,
            v,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glFramebufferSampleLocationsfvNV");
        }
        out
    }
    #[cfg(any(feature = "GL_NV_sample_locations"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_sample_locations"))))]
    static glFramebufferSampleLocationsfvNV_p: APcv = ap_None();
    /// Tries to load [`glFramebufferSampleLocationsfvNV`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    #[cfg(any(feature = "GL_NV_sample_locations"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_sample_locations"))))]
    pub unsafe fn glFramebufferSampleLocationsfvNV_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glFramebufferSampleLocationsfvNV\0",
            &glFramebufferSampleLocationsfvNV_p,
        )
    }
    /// Checks if the pointer for [`glFramebufferSampleLocationsfvNV`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    #[cfg(any(feature = "GL_NV_sample_locations"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_sample_locations"))))]
    pub fn glFramebufferSampleLocationsfvNV_is_loaded() -> bool {
        !glFramebufferSampleLocationsfvNV_p.load(RELAX).is_null()
    }

    /// [glFramebufferTexture](http://docs.gl/es3/glFramebufferTexture)(target, attachment, texture, level)
    /// `target` group: FramebufferTarget
    /// `attachment` group: FramebufferAttachment
    /// `texture` class: texture
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn glFramebufferTexture(
        target: GLenum,
        attachment: GLenum,
        texture: GLuint,
        level: GLint,
    ) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glFramebufferTexture({:#X}, {:#X}, {:?}, {:?});",
                target,
                attachment,
                texture,
                level
            );
        }
        let out = call_atomic_ptr_4arg(
            "glFramebufferTexture",
            &glFramebufferTexture_p,
            target,
            attachment,
            texture,
            level,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glFramebufferTexture");
        }
        out
    }
    static glFramebufferTexture_p: APcv = ap_None();
    /// Tries to load [`glFramebufferTexture`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    pub unsafe fn glFramebufferTexture_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glFramebufferTexture\0",
            &glFramebufferTexture_p,
        )
    }
    /// Checks if the pointer for [`glFramebufferTexture`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    pub fn glFramebufferTexture_is_loaded() -> bool {
        !glFramebufferTexture_p.load(RELAX).is_null()
    }

    /// [glFramebufferTexture2D](http://docs.gl/es3/glFramebufferTexture2D)(target, attachment, textarget, texture, level)
    /// `target` group: FramebufferTarget
    /// `attachment` group: FramebufferAttachment
    /// `textarget` group: TextureTarget
    /// `texture` class: texture
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn glFramebufferTexture2D(
        target: GLenum,
        attachment: GLenum,
        textarget: GLenum,
        texture: GLuint,
        level: GLint,
    ) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glFramebufferTexture2D({:#X}, {:#X}, {:#X}, {:?}, {:?});",
                target,
                attachment,
                textarget,
                texture,
                level
            );
        }
        let out = call_atomic_ptr_5arg(
            "glFramebufferTexture2D",
            &glFramebufferTexture2D_p,
            target,
            attachment,
            textarget,
            texture,
            level,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glFramebufferTexture2D");
        }
        out
    }
    static glFramebufferTexture2D_p: APcv = ap_None();
    /// Tries to load [`glFramebufferTexture2D`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    pub unsafe fn glFramebufferTexture2D_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glFramebufferTexture2D\0",
            &glFramebufferTexture2D_p,
        )
    }
    /// Checks if the pointer for [`glFramebufferTexture2D`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    pub fn glFramebufferTexture2D_is_loaded() -> bool {
        !glFramebufferTexture2D_p.load(RELAX).is_null()
    }

    /// [glFramebufferTexture2DDownsampleIMG](http://docs.gl/es3/glFramebufferTexture2DDownsampleIMG)(target, attachment, textarget, texture, level, xscale, yscale)
    /// `target` group: FramebufferTarget
    /// `attachment` group: FramebufferAttachment
    /// `textarget` group: TextureTarget
    /// `texture` class: texture
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    #[cfg(any(feature = "GL_IMG_framebuffer_downsample"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_IMG_framebuffer_downsample"))))]
    pub unsafe fn glFramebufferTexture2DDownsampleIMG(
        target: GLenum,
        attachment: GLenum,
        textarget: GLenum,
        texture: GLuint,
        level: GLint,
        xscale: GLint,
        yscale: GLint,
    ) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glFramebufferTexture2DDownsampleIMG({:#X}, {:#X}, {:#X}, {:?}, {:?}, {:?}, {:?});",
                target,
                attachment,
                textarget,
                texture,
                level,
                xscale,
                yscale
            );
        }
        let out = call_atomic_ptr_7arg(
            "glFramebufferTexture2DDownsampleIMG",
            &glFramebufferTexture2DDownsampleIMG_p,
            target,
            attachment,
            textarget,
            texture,
            level,
            xscale,
            yscale,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glFramebufferTexture2DDownsampleIMG");
        }
        out
    }
    #[cfg(any(feature = "GL_IMG_framebuffer_downsample"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_IMG_framebuffer_downsample"))))]
    static glFramebufferTexture2DDownsampleIMG_p: APcv = ap_None();
    /// Tries to load [`glFramebufferTexture2DDownsampleIMG`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    #[cfg(any(feature = "GL_IMG_framebuffer_downsample"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_IMG_framebuffer_downsample"))))]
    pub unsafe fn glFramebufferTexture2DDownsampleIMG_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glFramebufferTexture2DDownsampleIMG\0",
            &glFramebufferTexture2DDownsampleIMG_p,
        )
    }
    /// Checks if the pointer for [`glFramebufferTexture2DDownsampleIMG`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    #[cfg(any(feature = "GL_IMG_framebuffer_downsample"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_IMG_framebuffer_downsample"))))]
    pub fn glFramebufferTexture2DDownsampleIMG_is_loaded() -> bool {
        !glFramebufferTexture2DDownsampleIMG_p.load(RELAX).is_null()
    }

    /// [glFramebufferTexture2DMultisampleEXT](http://docs.gl/es3/glFramebufferTexture2DMultisampleEXT)(target, attachment, textarget, texture, level, samples)
    /// `target` group: FramebufferTarget
    /// `attachment` group: FramebufferAttachment
    /// `textarget` group: TextureTarget
    /// `texture` class: texture
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    #[cfg(any(feature = "GL_EXT_multisampled_render_to_texture"))]
    #[cfg_attr(
        docs_rs,
        doc(cfg(any(feature = "GL_EXT_multisampled_render_to_texture")))
    )]
    pub unsafe fn glFramebufferTexture2DMultisampleEXT(
        target: GLenum,
        attachment: GLenum,
        textarget: GLenum,
        texture: GLuint,
        level: GLint,
        samples: GLsizei,
    ) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glFramebufferTexture2DMultisampleEXT({:#X}, {:#X}, {:#X}, {:?}, {:?}, {:?});",
                target,
                attachment,
                textarget,
                texture,
                level,
                samples
            );
        }
        let out = call_atomic_ptr_6arg(
            "glFramebufferTexture2DMultisampleEXT",
            &glFramebufferTexture2DMultisampleEXT_p,
            target,
            attachment,
            textarget,
            texture,
            level,
            samples,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glFramebufferTexture2DMultisampleEXT");
        }
        out
    }
    #[cfg(any(feature = "GL_EXT_multisampled_render_to_texture"))]
    #[cfg_attr(
        docs_rs,
        doc(cfg(any(feature = "GL_EXT_multisampled_render_to_texture")))
    )]
    static glFramebufferTexture2DMultisampleEXT_p: APcv = ap_None();
    /// Tries to load [`glFramebufferTexture2DMultisampleEXT`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    #[cfg(any(feature = "GL_EXT_multisampled_render_to_texture"))]
    #[cfg_attr(
        docs_rs,
        doc(cfg(any(feature = "GL_EXT_multisampled_render_to_texture")))
    )]
    pub unsafe fn glFramebufferTexture2DMultisampleEXT_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glFramebufferTexture2DMultisampleEXT\0",
            &glFramebufferTexture2DMultisampleEXT_p,
        )
    }
    /// Checks if the pointer for [`glFramebufferTexture2DMultisampleEXT`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    #[cfg(any(feature = "GL_EXT_multisampled_render_to_texture"))]
    #[cfg_attr(
        docs_rs,
        doc(cfg(any(feature = "GL_EXT_multisampled_render_to_texture")))
    )]
    pub fn glFramebufferTexture2DMultisampleEXT_is_loaded() -> bool {
        !glFramebufferTexture2DMultisampleEXT_p.load(RELAX).is_null()
    }

    /// [glFramebufferTexture2DMultisampleIMG](http://docs.gl/es3/glFramebufferTexture2DMultisampleIMG)(target, attachment, textarget, texture, level, samples)
    /// `target` group: FramebufferTarget
    /// `attachment` group: FramebufferAttachment
    /// `textarget` group: TextureTarget
    /// `texture` class: texture
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    #[cfg(any(feature = "GL_IMG_multisampled_render_to_texture"))]
    #[cfg_attr(
        docs_rs,
        doc(cfg(any(feature = "GL_IMG_multisampled_render_to_texture")))
    )]
    pub unsafe fn glFramebufferTexture2DMultisampleIMG(
        target: GLenum,
        attachment: GLenum,
        textarget: GLenum,
        texture: GLuint,
        level: GLint,
        samples: GLsizei,
    ) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glFramebufferTexture2DMultisampleIMG({:#X}, {:#X}, {:#X}, {:?}, {:?}, {:?});",
                target,
                attachment,
                textarget,
                texture,
                level,
                samples
            );
        }
        let out = call_atomic_ptr_6arg(
            "glFramebufferTexture2DMultisampleIMG",
            &glFramebufferTexture2DMultisampleIMG_p,
            target,
            attachment,
            textarget,
            texture,
            level,
            samples,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glFramebufferTexture2DMultisampleIMG");
        }
        out
    }
    #[cfg(any(feature = "GL_IMG_multisampled_render_to_texture"))]
    #[cfg_attr(
        docs_rs,
        doc(cfg(any(feature = "GL_IMG_multisampled_render_to_texture")))
    )]
    static glFramebufferTexture2DMultisampleIMG_p: APcv = ap_None();
    /// Tries to load [`glFramebufferTexture2DMultisampleIMG`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    #[cfg(any(feature = "GL_IMG_multisampled_render_to_texture"))]
    #[cfg_attr(
        docs_rs,
        doc(cfg(any(feature = "GL_IMG_multisampled_render_to_texture")))
    )]
    pub unsafe fn glFramebufferTexture2DMultisampleIMG_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glFramebufferTexture2DMultisampleIMG\0",
            &glFramebufferTexture2DMultisampleIMG_p,
        )
    }
    /// Checks if the pointer for [`glFramebufferTexture2DMultisampleIMG`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    #[cfg(any(feature = "GL_IMG_multisampled_render_to_texture"))]
    #[cfg_attr(
        docs_rs,
        doc(cfg(any(feature = "GL_IMG_multisampled_render_to_texture")))
    )]
    pub fn glFramebufferTexture2DMultisampleIMG_is_loaded() -> bool {
        !glFramebufferTexture2DMultisampleIMG_p.load(RELAX).is_null()
    }

    /// [glFramebufferTexture3DOES](http://docs.gl/es3/glFramebufferTexture3DOES)(target, attachment, textarget, texture, level, zoffset)
    /// `target` group: FramebufferTarget
    /// `attachment` group: FramebufferAttachment
    /// `textarget` group: TextureTarget
    /// `texture` class: texture
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    #[cfg(any(feature = "GL_OES_texture_3D"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_OES_texture_3D"))))]
    pub unsafe fn glFramebufferTexture3DOES(
        target: GLenum,
        attachment: GLenum,
        textarget: GLenum,
        texture: GLuint,
        level: GLint,
        zoffset: GLint,
    ) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glFramebufferTexture3DOES({:#X}, {:#X}, {:#X}, {:?}, {:?}, {:?});",
                target,
                attachment,
                textarget,
                texture,
                level,
                zoffset
            );
        }
        let out = call_atomic_ptr_6arg(
            "glFramebufferTexture3DOES",
            &glFramebufferTexture3DOES_p,
            target,
            attachment,
            textarget,
            texture,
            level,
            zoffset,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glFramebufferTexture3DOES");
        }
        out
    }
    #[cfg(any(feature = "GL_OES_texture_3D"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_OES_texture_3D"))))]
    static glFramebufferTexture3DOES_p: APcv = ap_None();
    /// Tries to load [`glFramebufferTexture3DOES`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    #[cfg(any(feature = "GL_OES_texture_3D"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_OES_texture_3D"))))]
    pub unsafe fn glFramebufferTexture3DOES_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glFramebufferTexture3DOES\0",
            &glFramebufferTexture3DOES_p,
        )
    }
    /// Checks if the pointer for [`glFramebufferTexture3DOES`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    #[cfg(any(feature = "GL_OES_texture_3D"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_OES_texture_3D"))))]
    pub fn glFramebufferTexture3DOES_is_loaded() -> bool {
        !glFramebufferTexture3DOES_p.load(RELAX).is_null()
    }

    /// [glFramebufferTextureEXT](http://docs.gl/es3/glFramebufferTextureEXT)(target, attachment, texture, level)
    /// `target` group: FramebufferTarget
    /// `attachment` group: FramebufferAttachment
    /// `texture` group: Texture
    /// `texture` class: texture
    /// `level` group: CheckedInt32
    /// alias of: [`glFramebufferTexture`]
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    #[cfg(any(feature = "GL_EXT_geometry_shader"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_geometry_shader"))))]
    pub unsafe fn glFramebufferTextureEXT(
        target: GLenum,
        attachment: GLenum,
        texture: GLuint,
        level: GLint,
    ) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glFramebufferTextureEXT({:#X}, {:#X}, {:?}, {:?});",
                target,
                attachment,
                texture,
                level
            );
        }
        let out = call_atomic_ptr_4arg(
            "glFramebufferTextureEXT",
            &glFramebufferTextureEXT_p,
            target,
            attachment,
            texture,
            level,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glFramebufferTextureEXT");
        }
        out
    }
    #[cfg(any(feature = "GL_EXT_geometry_shader"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_geometry_shader"))))]
    static glFramebufferTextureEXT_p: APcv = ap_None();
    /// Tries to load [`glFramebufferTextureEXT`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    #[cfg(any(feature = "GL_EXT_geometry_shader"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_geometry_shader"))))]
    pub unsafe fn glFramebufferTextureEXT_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glFramebufferTextureEXT\0",
            &glFramebufferTextureEXT_p,
        )
    }
    /// Checks if the pointer for [`glFramebufferTextureEXT`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    #[cfg(any(feature = "GL_EXT_geometry_shader"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_geometry_shader"))))]
    pub fn glFramebufferTextureEXT_is_loaded() -> bool {
        !glFramebufferTextureEXT_p.load(RELAX).is_null()
    }

    /// [glFramebufferTextureLayer](http://docs.gl/es3/glFramebufferTextureLayer)(target, attachment, texture, level, layer)
    /// `target` group: FramebufferTarget
    /// `attachment` group: FramebufferAttachment
    /// `texture` group: Texture
    /// `texture` class: texture
    /// `level` group: CheckedInt32
    /// `layer` group: CheckedInt32
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn glFramebufferTextureLayer(
        target: GLenum,
        attachment: GLenum,
        texture: GLuint,
        level: GLint,
        layer: GLint,
    ) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glFramebufferTextureLayer({:#X}, {:#X}, {:?}, {:?}, {:?});",
                target,
                attachment,
                texture,
                level,
                layer
            );
        }
        let out = call_atomic_ptr_5arg(
            "glFramebufferTextureLayer",
            &glFramebufferTextureLayer_p,
            target,
            attachment,
            texture,
            level,
            layer,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glFramebufferTextureLayer");
        }
        out
    }
    static glFramebufferTextureLayer_p: APcv = ap_None();
    /// Tries to load [`glFramebufferTextureLayer`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    pub unsafe fn glFramebufferTextureLayer_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glFramebufferTextureLayer\0",
            &glFramebufferTextureLayer_p,
        )
    }
    /// Checks if the pointer for [`glFramebufferTextureLayer`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    pub fn glFramebufferTextureLayer_is_loaded() -> bool {
        !glFramebufferTextureLayer_p.load(RELAX).is_null()
    }

    /// [glFramebufferTextureLayerDownsampleIMG](http://docs.gl/es3/glFramebufferTextureLayerDownsampleIMG)(target, attachment, texture, level, layer, xscale, yscale)
    /// `target` group: FramebufferTarget
    /// `attachment` group: FramebufferAttachment
    /// `texture` group: Texture
    /// `texture` class: texture
    /// `level` group: CheckedInt32
    /// `layer` group: CheckedInt32
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    #[cfg(any(feature = "GL_IMG_framebuffer_downsample"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_IMG_framebuffer_downsample"))))]
    pub unsafe fn glFramebufferTextureLayerDownsampleIMG(
        target: GLenum,
        attachment: GLenum,
        texture: GLuint,
        level: GLint,
        layer: GLint,
        xscale: GLint,
        yscale: GLint,
    ) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glFramebufferTextureLayerDownsampleIMG({:#X}, {:#X}, {:?}, {:?}, {:?}, {:?}, {:?});",
                target,
                attachment,
                texture,
                level,
                layer,
                xscale,
                yscale
            );
        }
        let out = call_atomic_ptr_7arg(
            "glFramebufferTextureLayerDownsampleIMG",
            &glFramebufferTextureLayerDownsampleIMG_p,
            target,
            attachment,
            texture,
            level,
            layer,
            xscale,
            yscale,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glFramebufferTextureLayerDownsampleIMG");
        }
        out
    }
    #[cfg(any(feature = "GL_IMG_framebuffer_downsample"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_IMG_framebuffer_downsample"))))]
    static glFramebufferTextureLayerDownsampleIMG_p: APcv = ap_None();
    /// Tries to load [`glFramebufferTextureLayerDownsampleIMG`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    #[cfg(any(feature = "GL_IMG_framebuffer_downsample"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_IMG_framebuffer_downsample"))))]
    pub unsafe fn glFramebufferTextureLayerDownsampleIMG_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glFramebufferTextureLayerDownsampleIMG\0",
            &glFramebufferTextureLayerDownsampleIMG_p,
        )
    }
    /// Checks if the pointer for [`glFramebufferTextureLayerDownsampleIMG`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    #[cfg(any(feature = "GL_IMG_framebuffer_downsample"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_IMG_framebuffer_downsample"))))]
    pub fn glFramebufferTextureLayerDownsampleIMG_is_loaded() -> bool {
        !glFramebufferTextureLayerDownsampleIMG_p
            .load(RELAX)
            .is_null()
    }

    /// [glFramebufferTextureMultisampleMultiviewOVR](http://docs.gl/es3/glFramebufferTextureMultisampleMultiviewOVR)(target, attachment, texture, level, samples, baseViewIndex, numViews)
    /// `target` group: FramebufferTarget
    /// `attachment` group: FramebufferAttachment
    /// `texture` group: Texture
    /// `texture` class: texture
    /// `level` group: CheckedInt32
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    #[cfg(any(feature = "GL_OVR_multiview_multisampled_render_to_texture"))]
    #[cfg_attr(
        docs_rs,
        doc(cfg(any(feature = "GL_OVR_multiview_multisampled_render_to_texture")))
    )]
    pub unsafe fn glFramebufferTextureMultisampleMultiviewOVR(
        target: GLenum,
        attachment: GLenum,
        texture: GLuint,
        level: GLint,
        samples: GLsizei,
        baseViewIndex: GLint,
        numViews: GLsizei,
    ) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glFramebufferTextureMultisampleMultiviewOVR({:#X}, {:#X}, {:?}, {:?}, {:?}, {:?}, {:?});",
                target,
                attachment,
                texture,
                level,
                samples,
                baseViewIndex,
                numViews
            );
        }
        let out = call_atomic_ptr_7arg(
            "glFramebufferTextureMultisampleMultiviewOVR",
            &glFramebufferTextureMultisampleMultiviewOVR_p,
            target,
            attachment,
            texture,
            level,
            samples,
            baseViewIndex,
            numViews,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glFramebufferTextureMultisampleMultiviewOVR");
        }
        out
    }
    #[cfg(any(feature = "GL_OVR_multiview_multisampled_render_to_texture"))]
    #[cfg_attr(
        docs_rs,
        doc(cfg(any(feature = "GL_OVR_multiview_multisampled_render_to_texture")))
    )]
    static glFramebufferTextureMultisampleMultiviewOVR_p: APcv = ap_None();
    /// Tries to load [`glFramebufferTextureMultisampleMultiviewOVR`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    #[cfg(any(feature = "GL_OVR_multiview_multisampled_render_to_texture"))]
    #[cfg_attr(
        docs_rs,
        doc(cfg(any(feature = "GL_OVR_multiview_multisampled_render_to_texture")))
    )]
    pub unsafe fn glFramebufferTextureMultisampleMultiviewOVR_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glFramebufferTextureMultisampleMultiviewOVR\0",
            &glFramebufferTextureMultisampleMultiviewOVR_p,
        )
    }
    /// Checks if the pointer for [`glFramebufferTextureMultisampleMultiviewOVR`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    #[cfg(any(feature = "GL_OVR_multiview_multisampled_render_to_texture"))]
    #[cfg_attr(
        docs_rs,
        doc(cfg(any(feature = "GL_OVR_multiview_multisampled_render_to_texture")))
    )]
    pub fn glFramebufferTextureMultisampleMultiviewOVR_is_loaded() -> bool {
        !glFramebufferTextureMultisampleMultiviewOVR_p
            .load(RELAX)
            .is_null()
    }

    /// [glFramebufferTextureMultiviewOVR](http://docs.gl/es3/glFramebufferTextureMultiviewOVR)(target, attachment, texture, level, baseViewIndex, numViews)
    /// `target` group: FramebufferTarget
    /// `attachment` group: FramebufferAttachment
    /// `texture` group: Texture
    /// `texture` class: texture
    /// `level` group: CheckedInt32
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    #[cfg(any(feature = "GL_OVR_multiview"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_OVR_multiview"))))]
    pub unsafe fn glFramebufferTextureMultiviewOVR(
        target: GLenum,
        attachment: GLenum,
        texture: GLuint,
        level: GLint,
        baseViewIndex: GLint,
        numViews: GLsizei,
    ) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glFramebufferTextureMultiviewOVR({:#X}, {:#X}, {:?}, {:?}, {:?}, {:?});",
                target,
                attachment,
                texture,
                level,
                baseViewIndex,
                numViews
            );
        }
        let out = call_atomic_ptr_6arg(
            "glFramebufferTextureMultiviewOVR",
            &glFramebufferTextureMultiviewOVR_p,
            target,
            attachment,
            texture,
            level,
            baseViewIndex,
            numViews,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glFramebufferTextureMultiviewOVR");
        }
        out
    }
    #[cfg(any(feature = "GL_OVR_multiview"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_OVR_multiview"))))]
    static glFramebufferTextureMultiviewOVR_p: APcv = ap_None();
    /// Tries to load [`glFramebufferTextureMultiviewOVR`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    #[cfg(any(feature = "GL_OVR_multiview"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_OVR_multiview"))))]
    pub unsafe fn glFramebufferTextureMultiviewOVR_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glFramebufferTextureMultiviewOVR\0",
            &glFramebufferTextureMultiviewOVR_p,
        )
    }
    /// Checks if the pointer for [`glFramebufferTextureMultiviewOVR`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    #[cfg(any(feature = "GL_OVR_multiview"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_OVR_multiview"))))]
    pub fn glFramebufferTextureMultiviewOVR_is_loaded() -> bool {
        !glFramebufferTextureMultiviewOVR_p.load(RELAX).is_null()
    }

    /// [glFramebufferTextureOES](http://docs.gl/es3/glFramebufferTextureOES)(target, attachment, texture, level)
    /// `target` group: FramebufferTarget
    /// `attachment` group: FramebufferAttachment
    /// `texture` group: Texture
    /// `texture` class: texture
    /// `level` group: CheckedInt32
    /// alias of: [`glFramebufferTexture`]
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    #[cfg(any(feature = "GL_OES_geometry_shader"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_OES_geometry_shader"))))]
    pub unsafe fn glFramebufferTextureOES(
        target: GLenum,
        attachment: GLenum,
        texture: GLuint,
        level: GLint,
    ) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glFramebufferTextureOES({:#X}, {:#X}, {:?}, {:?});",
                target,
                attachment,
                texture,
                level
            );
        }
        let out = call_atomic_ptr_4arg(
            "glFramebufferTextureOES",
            &glFramebufferTextureOES_p,
            target,
            attachment,
            texture,
            level,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glFramebufferTextureOES");
        }
        out
    }
    #[cfg(any(feature = "GL_OES_geometry_shader"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_OES_geometry_shader"))))]
    static glFramebufferTextureOES_p: APcv = ap_None();
    /// Tries to load [`glFramebufferTextureOES`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    #[cfg(any(feature = "GL_OES_geometry_shader"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_OES_geometry_shader"))))]
    pub unsafe fn glFramebufferTextureOES_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glFramebufferTextureOES\0",
            &glFramebufferTextureOES_p,
        )
    }
    /// Checks if the pointer for [`glFramebufferTextureOES`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    #[cfg(any(feature = "GL_OES_geometry_shader"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_OES_geometry_shader"))))]
    pub fn glFramebufferTextureOES_is_loaded() -> bool {
        !glFramebufferTextureOES_p.load(RELAX).is_null()
    }

    /// [glFrontFace](http://docs.gl/es3/glFrontFace)(mode)
    /// `mode` group: FrontFaceDirection
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn glFrontFace(mode: GLenum) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!("calling glFrontFace({:#X});", mode);
        }
        let out = call_atomic_ptr_1arg("glFrontFace", &glFrontFace_p, mode);
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glFrontFace");
        }
        out
    }
    static glFrontFace_p: APcv = ap_None();
    /// Tries to load [`glFrontFace`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    pub unsafe fn glFrontFace_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(get_proc_address, b"glFrontFace\0", &glFrontFace_p)
    }
    /// Checks if the pointer for [`glFrontFace`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    pub fn glFrontFace_is_loaded() -> bool {
        !glFrontFace_p.load(RELAX).is_null()
    }

    /// [glGenBuffers](http://docs.gl/es3/glGenBuffers)(n, buffers)
    /// `buffers` len: n
    /// `buffers` class: buffer
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn glGenBuffers(n: GLsizei, buffers: *mut GLuint) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!("calling glGenBuffers({:?}, {:p});", n, buffers);
        }
        let out = call_atomic_ptr_2arg("glGenBuffers", &glGenBuffers_p, n, buffers);
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glGenBuffers");
        }
        out
    }
    static glGenBuffers_p: APcv = ap_None();
    /// Tries to load [`glGenBuffers`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    pub unsafe fn glGenBuffers_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(get_proc_address, b"glGenBuffers\0", &glGenBuffers_p)
    }
    /// Checks if the pointer for [`glGenBuffers`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    pub fn glGenBuffers_is_loaded() -> bool {
        !glGenBuffers_p.load(RELAX).is_null()
    }

    /// [glGenFencesNV](http://docs.gl/es3/glGenFencesNV)(n, fences)
    /// `fences` group: FenceNV
    /// `fences` len: n
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    #[cfg(any(feature = "GL_NV_fence"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_fence"))))]
    pub unsafe fn glGenFencesNV(n: GLsizei, fences: *mut GLuint) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!("calling glGenFencesNV({:?}, {:p});", n, fences);
        }
        let out = call_atomic_ptr_2arg("glGenFencesNV", &glGenFencesNV_p, n, fences);
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glGenFencesNV");
        }
        out
    }
    #[cfg(any(feature = "GL_NV_fence"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_fence"))))]
    static glGenFencesNV_p: APcv = ap_None();
    /// Tries to load [`glGenFencesNV`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    #[cfg(any(feature = "GL_NV_fence"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_fence"))))]
    pub unsafe fn glGenFencesNV_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(get_proc_address, b"glGenFencesNV\0", &glGenFencesNV_p)
    }
    /// Checks if the pointer for [`glGenFencesNV`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    #[cfg(any(feature = "GL_NV_fence"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_fence"))))]
    pub fn glGenFencesNV_is_loaded() -> bool {
        !glGenFencesNV_p.load(RELAX).is_null()
    }

    /// [glGenFramebuffers](http://docs.gl/es3/glGenFramebuffers)(n, framebuffers)
    /// `framebuffers` len: n
    /// `framebuffers` class: framebuffer
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn glGenFramebuffers(n: GLsizei, framebuffers: *mut GLuint) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!("calling glGenFramebuffers({:?}, {:p});", n, framebuffers);
        }
        let out = call_atomic_ptr_2arg("glGenFramebuffers", &glGenFramebuffers_p, n, framebuffers);
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glGenFramebuffers");
        }
        out
    }
    static glGenFramebuffers_p: APcv = ap_None();
    /// Tries to load [`glGenFramebuffers`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    pub unsafe fn glGenFramebuffers_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glGenFramebuffers\0",
            &glGenFramebuffers_p,
        )
    }
    /// Checks if the pointer for [`glGenFramebuffers`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    pub fn glGenFramebuffers_is_loaded() -> bool {
        !glGenFramebuffers_p.load(RELAX).is_null()
    }

    /// [glGenPathsNV](http://docs.gl/es3/glGenPathsNV)(range)
    /// return value group: Path
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    #[cfg(any(feature = "GL_NV_path_rendering"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_path_rendering"))))]
    pub unsafe fn glGenPathsNV(range: GLsizei) -> GLuint {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!("calling glGenPathsNV({:?});", range);
        }
        let out = call_atomic_ptr_1arg("glGenPathsNV", &glGenPathsNV_p, range);
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glGenPathsNV");
        }
        out
    }
    #[cfg(any(feature = "GL_NV_path_rendering"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_path_rendering"))))]
    static glGenPathsNV_p: APcv = ap_None();
    /// Tries to load [`glGenPathsNV`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    #[cfg(any(feature = "GL_NV_path_rendering"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_path_rendering"))))]
    pub unsafe fn glGenPathsNV_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(get_proc_address, b"glGenPathsNV\0", &glGenPathsNV_p)
    }
    /// Checks if the pointer for [`glGenPathsNV`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    #[cfg(any(feature = "GL_NV_path_rendering"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_path_rendering"))))]
    pub fn glGenPathsNV_is_loaded() -> bool {
        !glGenPathsNV_p.load(RELAX).is_null()
    }

    /// [glGenPerfMonitorsAMD](http://docs.gl/es3/glGenPerfMonitorsAMD)(n, monitors)
    /// `monitors` len: n
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    #[cfg(any(feature = "GL_AMD_performance_monitor"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_AMD_performance_monitor"))))]
    pub unsafe fn glGenPerfMonitorsAMD(n: GLsizei, monitors: *mut GLuint) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!("calling glGenPerfMonitorsAMD({:?}, {:p});", n, monitors);
        }
        let out =
            call_atomic_ptr_2arg("glGenPerfMonitorsAMD", &glGenPerfMonitorsAMD_p, n, monitors);
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glGenPerfMonitorsAMD");
        }
        out
    }
    #[cfg(any(feature = "GL_AMD_performance_monitor"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_AMD_performance_monitor"))))]
    static glGenPerfMonitorsAMD_p: APcv = ap_None();
    /// Tries to load [`glGenPerfMonitorsAMD`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    #[cfg(any(feature = "GL_AMD_performance_monitor"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_AMD_performance_monitor"))))]
    pub unsafe fn glGenPerfMonitorsAMD_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glGenPerfMonitorsAMD\0",
            &glGenPerfMonitorsAMD_p,
        )
    }
    /// Checks if the pointer for [`glGenPerfMonitorsAMD`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    #[cfg(any(feature = "GL_AMD_performance_monitor"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_AMD_performance_monitor"))))]
    pub fn glGenPerfMonitorsAMD_is_loaded() -> bool {
        !glGenPerfMonitorsAMD_p.load(RELAX).is_null()
    }

    /// [glGenProgramPipelines](http://docs.gl/es3/glGenProgramPipelines)(n, pipelines)
    /// `pipelines` len: n
    /// `pipelines` class: program pipeline
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn glGenProgramPipelines(n: GLsizei, pipelines: *mut GLuint) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!("calling glGenProgramPipelines({:?}, {:p});", n, pipelines);
        }
        let out = call_atomic_ptr_2arg(
            "glGenProgramPipelines",
            &glGenProgramPipelines_p,
            n,
            pipelines,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glGenProgramPipelines");
        }
        out
    }
    static glGenProgramPipelines_p: APcv = ap_None();
    /// Tries to load [`glGenProgramPipelines`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    pub unsafe fn glGenProgramPipelines_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glGenProgramPipelines\0",
            &glGenProgramPipelines_p,
        )
    }
    /// Checks if the pointer for [`glGenProgramPipelines`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    pub fn glGenProgramPipelines_is_loaded() -> bool {
        !glGenProgramPipelines_p.load(RELAX).is_null()
    }

    /// [glGenProgramPipelinesEXT](http://docs.gl/es3/glGenProgramPipelinesEXT)(n, pipelines)
    /// `pipelines` len: n
    /// `pipelines` class: program pipeline
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    #[cfg(any(feature = "GL_EXT_separate_shader_objects"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_separate_shader_objects"))))]
    pub unsafe fn glGenProgramPipelinesEXT(n: GLsizei, pipelines: *mut GLuint) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glGenProgramPipelinesEXT({:?}, {:p});",
                n,
                pipelines
            );
        }
        let out = call_atomic_ptr_2arg(
            "glGenProgramPipelinesEXT",
            &glGenProgramPipelinesEXT_p,
            n,
            pipelines,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glGenProgramPipelinesEXT");
        }
        out
    }
    #[cfg(any(feature = "GL_EXT_separate_shader_objects"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_separate_shader_objects"))))]
    static glGenProgramPipelinesEXT_p: APcv = ap_None();
    /// Tries to load [`glGenProgramPipelinesEXT`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    #[cfg(any(feature = "GL_EXT_separate_shader_objects"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_separate_shader_objects"))))]
    pub unsafe fn glGenProgramPipelinesEXT_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glGenProgramPipelinesEXT\0",
            &glGenProgramPipelinesEXT_p,
        )
    }
    /// Checks if the pointer for [`glGenProgramPipelinesEXT`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    #[cfg(any(feature = "GL_EXT_separate_shader_objects"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_separate_shader_objects"))))]
    pub fn glGenProgramPipelinesEXT_is_loaded() -> bool {
        !glGenProgramPipelinesEXT_p.load(RELAX).is_null()
    }

    /// [glGenQueries](http://docs.gl/es3/glGenQueries)(n, ids)
    /// `ids` len: n
    /// `ids` class: query
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn glGenQueries(n: GLsizei, ids: *mut GLuint) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!("calling glGenQueries({:?}, {:p});", n, ids);
        }
        let out = call_atomic_ptr_2arg("glGenQueries", &glGenQueries_p, n, ids);
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glGenQueries");
        }
        out
    }
    static glGenQueries_p: APcv = ap_None();
    /// Tries to load [`glGenQueries`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    pub unsafe fn glGenQueries_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(get_proc_address, b"glGenQueries\0", &glGenQueries_p)
    }
    /// Checks if the pointer for [`glGenQueries`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    pub fn glGenQueries_is_loaded() -> bool {
        !glGenQueries_p.load(RELAX).is_null()
    }

    /// [glGenQueriesEXT](http://docs.gl/es3/glGenQueriesEXT)(n, ids)
    /// `ids` len: n
    /// `ids` class: query
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    #[cfg(any(
        feature = "GL_EXT_disjoint_timer_query",
        feature = "GL_EXT_occlusion_query_boolean"
    ))]
    #[cfg_attr(
        docs_rs,
        doc(cfg(any(
            feature = "GL_EXT_disjoint_timer_query",
            feature = "GL_EXT_occlusion_query_boolean"
        )))
    )]
    pub unsafe fn glGenQueriesEXT(n: GLsizei, ids: *mut GLuint) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!("calling glGenQueriesEXT({:?}, {:p});", n, ids);
        }
        let out = call_atomic_ptr_2arg("glGenQueriesEXT", &glGenQueriesEXT_p, n, ids);
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glGenQueriesEXT");
        }
        out
    }
    #[cfg(any(
        feature = "GL_EXT_disjoint_timer_query",
        feature = "GL_EXT_occlusion_query_boolean"
    ))]
    #[cfg_attr(
        docs_rs,
        doc(cfg(any(
            feature = "GL_EXT_disjoint_timer_query",
            feature = "GL_EXT_occlusion_query_boolean"
        )))
    )]
    static glGenQueriesEXT_p: APcv = ap_None();
    /// Tries to load [`glGenQueriesEXT`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    #[cfg(any(
        feature = "GL_EXT_disjoint_timer_query",
        feature = "GL_EXT_occlusion_query_boolean"
    ))]
    #[cfg_attr(
        docs_rs,
        doc(cfg(any(
            feature = "GL_EXT_disjoint_timer_query",
            feature = "GL_EXT_occlusion_query_boolean"
        )))
    )]
    pub unsafe fn glGenQueriesEXT_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(get_proc_address, b"glGenQueriesEXT\0", &glGenQueriesEXT_p)
    }
    /// Checks if the pointer for [`glGenQueriesEXT`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    #[cfg(any(
        feature = "GL_EXT_disjoint_timer_query",
        feature = "GL_EXT_occlusion_query_boolean"
    ))]
    #[cfg_attr(
        docs_rs,
        doc(cfg(any(
            feature = "GL_EXT_disjoint_timer_query",
            feature = "GL_EXT_occlusion_query_boolean"
        )))
    )]
    pub fn glGenQueriesEXT_is_loaded() -> bool {
        !glGenQueriesEXT_p.load(RELAX).is_null()
    }

    /// [glGenRenderbuffers](http://docs.gl/es3/glGenRenderbuffers)(n, renderbuffers)
    /// `renderbuffers` len: n
    /// `renderbuffers` class: renderbuffer
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn glGenRenderbuffers(n: GLsizei, renderbuffers: *mut GLuint) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!("calling glGenRenderbuffers({:?}, {:p});", n, renderbuffers);
        }
        let out = call_atomic_ptr_2arg(
            "glGenRenderbuffers",
            &glGenRenderbuffers_p,
            n,
            renderbuffers,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glGenRenderbuffers");
        }
        out
    }
    static glGenRenderbuffers_p: APcv = ap_None();
    /// Tries to load [`glGenRenderbuffers`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    pub unsafe fn glGenRenderbuffers_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glGenRenderbuffers\0",
            &glGenRenderbuffers_p,
        )
    }
    /// Checks if the pointer for [`glGenRenderbuffers`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    pub fn glGenRenderbuffers_is_loaded() -> bool {
        !glGenRenderbuffers_p.load(RELAX).is_null()
    }

    /// [glGenSamplers](http://docs.gl/es3/glGenSamplers)(count, samplers)
    /// `samplers` len: count
    /// `samplers` class: sampler
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn glGenSamplers(count: GLsizei, samplers: *mut GLuint) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!("calling glGenSamplers({:?}, {:p});", count, samplers);
        }
        let out = call_atomic_ptr_2arg("glGenSamplers", &glGenSamplers_p, count, samplers);
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glGenSamplers");
        }
        out
    }
    static glGenSamplers_p: APcv = ap_None();
    /// Tries to load [`glGenSamplers`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    pub unsafe fn glGenSamplers_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(get_proc_address, b"glGenSamplers\0", &glGenSamplers_p)
    }
    /// Checks if the pointer for [`glGenSamplers`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    pub fn glGenSamplers_is_loaded() -> bool {
        !glGenSamplers_p.load(RELAX).is_null()
    }

    /// [glGenSemaphoresEXT](http://docs.gl/es3/glGenSemaphoresEXT)(n, semaphores)
    /// `semaphores` len: n
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    #[cfg(any(feature = "GL_EXT_semaphore"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_semaphore"))))]
    pub unsafe fn glGenSemaphoresEXT(n: GLsizei, semaphores: *mut GLuint) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!("calling glGenSemaphoresEXT({:?}, {:p});", n, semaphores);
        }
        let out = call_atomic_ptr_2arg("glGenSemaphoresEXT", &glGenSemaphoresEXT_p, n, semaphores);
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glGenSemaphoresEXT");
        }
        out
    }
    #[cfg(any(feature = "GL_EXT_semaphore"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_semaphore"))))]
    static glGenSemaphoresEXT_p: APcv = ap_None();
    /// Tries to load [`glGenSemaphoresEXT`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    #[cfg(any(feature = "GL_EXT_semaphore"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_semaphore"))))]
    pub unsafe fn glGenSemaphoresEXT_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glGenSemaphoresEXT\0",
            &glGenSemaphoresEXT_p,
        )
    }
    /// Checks if the pointer for [`glGenSemaphoresEXT`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    #[cfg(any(feature = "GL_EXT_semaphore"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_semaphore"))))]
    pub fn glGenSemaphoresEXT_is_loaded() -> bool {
        !glGenSemaphoresEXT_p.load(RELAX).is_null()
    }

    /// [glGenTextures](http://docs.gl/es3/glGenTextures)(n, textures)
    /// `textures` group: Texture
    /// `textures` len: n
    /// `textures` class: texture
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn glGenTextures(n: GLsizei, textures: *mut GLuint) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!("calling glGenTextures({:?}, {:p});", n, textures);
        }
        let out = call_atomic_ptr_2arg("glGenTextures", &glGenTextures_p, n, textures);
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glGenTextures");
        }
        out
    }
    static glGenTextures_p: APcv = ap_None();
    /// Tries to load [`glGenTextures`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    pub unsafe fn glGenTextures_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(get_proc_address, b"glGenTextures\0", &glGenTextures_p)
    }
    /// Checks if the pointer for [`glGenTextures`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    pub fn glGenTextures_is_loaded() -> bool {
        !glGenTextures_p.load(RELAX).is_null()
    }

    /// [glGenTransformFeedbacks](http://docs.gl/es3/glGenTransformFeedbacks)(n, ids)
    /// `ids` len: n
    /// `ids` class: transform feedback
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn glGenTransformFeedbacks(n: GLsizei, ids: *mut GLuint) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!("calling glGenTransformFeedbacks({:?}, {:p});", n, ids);
        }
        let out = call_atomic_ptr_2arg(
            "glGenTransformFeedbacks",
            &glGenTransformFeedbacks_p,
            n,
            ids,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glGenTransformFeedbacks");
        }
        out
    }
    static glGenTransformFeedbacks_p: APcv = ap_None();
    /// Tries to load [`glGenTransformFeedbacks`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    pub unsafe fn glGenTransformFeedbacks_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glGenTransformFeedbacks\0",
            &glGenTransformFeedbacks_p,
        )
    }
    /// Checks if the pointer for [`glGenTransformFeedbacks`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    pub fn glGenTransformFeedbacks_is_loaded() -> bool {
        !glGenTransformFeedbacks_p.load(RELAX).is_null()
    }

    /// [glGenVertexArrays](http://docs.gl/es3/glGenVertexArrays)(n, arrays)
    /// `arrays` len: n
    /// `arrays` class: vertex array
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn glGenVertexArrays(n: GLsizei, arrays: *mut GLuint) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!("calling glGenVertexArrays({:?}, {:p});", n, arrays);
        }
        let out = call_atomic_ptr_2arg("glGenVertexArrays", &glGenVertexArrays_p, n, arrays);
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glGenVertexArrays");
        }
        out
    }
    static glGenVertexArrays_p: APcv = ap_None();
    /// Tries to load [`glGenVertexArrays`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    pub unsafe fn glGenVertexArrays_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glGenVertexArrays\0",
            &glGenVertexArrays_p,
        )
    }
    /// Checks if the pointer for [`glGenVertexArrays`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    pub fn glGenVertexArrays_is_loaded() -> bool {
        !glGenVertexArrays_p.load(RELAX).is_null()
    }

    /// [glGenVertexArraysOES](http://docs.gl/es3/glGenVertexArraysOES)(n, arrays)
    /// `arrays` len: n
    /// `arrays` class: vertex array
    /// alias of: [`glGenVertexArrays`]
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    #[cfg(any(feature = "GL_OES_vertex_array_object"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_OES_vertex_array_object"))))]
    pub unsafe fn glGenVertexArraysOES(n: GLsizei, arrays: *mut GLuint) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!("calling glGenVertexArraysOES({:?}, {:p});", n, arrays);
        }
        let out = call_atomic_ptr_2arg("glGenVertexArraysOES", &glGenVertexArraysOES_p, n, arrays);
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glGenVertexArraysOES");
        }
        out
    }
    #[cfg(any(feature = "GL_OES_vertex_array_object"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_OES_vertex_array_object"))))]
    static glGenVertexArraysOES_p: APcv = ap_None();
    /// Tries to load [`glGenVertexArraysOES`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    #[cfg(any(feature = "GL_OES_vertex_array_object"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_OES_vertex_array_object"))))]
    pub unsafe fn glGenVertexArraysOES_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glGenVertexArraysOES\0",
            &glGenVertexArraysOES_p,
        )
    }
    /// Checks if the pointer for [`glGenVertexArraysOES`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    #[cfg(any(feature = "GL_OES_vertex_array_object"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_OES_vertex_array_object"))))]
    pub fn glGenVertexArraysOES_is_loaded() -> bool {
        !glGenVertexArraysOES_p.load(RELAX).is_null()
    }

    /// [glGenerateMipmap](http://docs.gl/es3/glGenerateMipmap)(target)
    /// `target` group: TextureTarget
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn glGenerateMipmap(target: GLenum) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!("calling glGenerateMipmap({:#X});", target);
        }
        let out = call_atomic_ptr_1arg("glGenerateMipmap", &glGenerateMipmap_p, target);
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glGenerateMipmap");
        }
        out
    }
    static glGenerateMipmap_p: APcv = ap_None();
    /// Tries to load [`glGenerateMipmap`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    pub unsafe fn glGenerateMipmap_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(get_proc_address, b"glGenerateMipmap\0", &glGenerateMipmap_p)
    }
    /// Checks if the pointer for [`glGenerateMipmap`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    pub fn glGenerateMipmap_is_loaded() -> bool {
        !glGenerateMipmap_p.load(RELAX).is_null()
    }

    /// [glGetActiveAttrib](http://docs.gl/es3/glGetActiveAttrib)(program, index, bufSize, length, size, type_, name)
    /// `program` class: program
    /// `length` len: 1
    /// `size` len: 1
    /// `type_` group: AttributeType
    /// `type_` len: 1
    /// `name` len: bufSize
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn glGetActiveAttrib(
        program: GLuint,
        index: GLuint,
        bufSize: GLsizei,
        length: *mut GLsizei,
        size: *mut GLint,
        type_: *mut GLenum,
        name: *mut GLchar,
    ) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glGetActiveAttrib({:?}, {:?}, {:?}, {:p}, {:p}, {:p}, {:p});",
                program,
                index,
                bufSize,
                length,
                size,
                type_,
                name
            );
        }
        let out = call_atomic_ptr_7arg(
            "glGetActiveAttrib",
            &glGetActiveAttrib_p,
            program,
            index,
            bufSize,
            length,
            size,
            type_,
            name,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glGetActiveAttrib");
        }
        out
    }
    static glGetActiveAttrib_p: APcv = ap_None();
    /// Tries to load [`glGetActiveAttrib`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    pub unsafe fn glGetActiveAttrib_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glGetActiveAttrib\0",
            &glGetActiveAttrib_p,
        )
    }
    /// Checks if the pointer for [`glGetActiveAttrib`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    pub fn glGetActiveAttrib_is_loaded() -> bool {
        !glGetActiveAttrib_p.load(RELAX).is_null()
    }

    /// [glGetActiveUniform](http://docs.gl/es3/glGetActiveUniform)(program, index, bufSize, length, size, type_, name)
    /// `program` class: program
    /// `length` len: 1
    /// `size` len: 1
    /// `type_` group: UniformType
    /// `type_` len: 1
    /// `name` len: bufSize
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn glGetActiveUniform(
        program: GLuint,
        index: GLuint,
        bufSize: GLsizei,
        length: *mut GLsizei,
        size: *mut GLint,
        type_: *mut GLenum,
        name: *mut GLchar,
    ) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glGetActiveUniform({:?}, {:?}, {:?}, {:p}, {:p}, {:p}, {:p});",
                program,
                index,
                bufSize,
                length,
                size,
                type_,
                name
            );
        }
        let out = call_atomic_ptr_7arg(
            "glGetActiveUniform",
            &glGetActiveUniform_p,
            program,
            index,
            bufSize,
            length,
            size,
            type_,
            name,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glGetActiveUniform");
        }
        out
    }
    static glGetActiveUniform_p: APcv = ap_None();
    /// Tries to load [`glGetActiveUniform`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    pub unsafe fn glGetActiveUniform_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glGetActiveUniform\0",
            &glGetActiveUniform_p,
        )
    }
    /// Checks if the pointer for [`glGetActiveUniform`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    pub fn glGetActiveUniform_is_loaded() -> bool {
        !glGetActiveUniform_p.load(RELAX).is_null()
    }

    /// [glGetActiveUniformBlockName](http://docs.gl/es3/glGetActiveUniformBlockName)(program, uniformBlockIndex, bufSize, length, uniformBlockName)
    /// `program` class: program
    /// `length` len: 1
    /// `uniformBlockName` len: bufSize
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn glGetActiveUniformBlockName(
        program: GLuint,
        uniformBlockIndex: GLuint,
        bufSize: GLsizei,
        length: *mut GLsizei,
        uniformBlockName: *mut GLchar,
    ) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glGetActiveUniformBlockName({:?}, {:?}, {:?}, {:p}, {:p});",
                program,
                uniformBlockIndex,
                bufSize,
                length,
                uniformBlockName
            );
        }
        let out = call_atomic_ptr_5arg(
            "glGetActiveUniformBlockName",
            &glGetActiveUniformBlockName_p,
            program,
            uniformBlockIndex,
            bufSize,
            length,
            uniformBlockName,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glGetActiveUniformBlockName");
        }
        out
    }
    static glGetActiveUniformBlockName_p: APcv = ap_None();
    /// Tries to load [`glGetActiveUniformBlockName`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    pub unsafe fn glGetActiveUniformBlockName_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glGetActiveUniformBlockName\0",
            &glGetActiveUniformBlockName_p,
        )
    }
    /// Checks if the pointer for [`glGetActiveUniformBlockName`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    pub fn glGetActiveUniformBlockName_is_loaded() -> bool {
        !glGetActiveUniformBlockName_p.load(RELAX).is_null()
    }

    /// [glGetActiveUniformBlockiv](http://docs.gl/es3/glGetActiveUniformBlockiv)(program, uniformBlockIndex, pname, params)
    /// `program` class: program
    /// `pname` group: UniformBlockPName
    /// `params` len: COMPSIZE(program,uniformBlockIndex,pname)
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn glGetActiveUniformBlockiv(
        program: GLuint,
        uniformBlockIndex: GLuint,
        pname: GLenum,
        params: *mut GLint,
    ) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glGetActiveUniformBlockiv({:?}, {:?}, {:#X}, {:p});",
                program,
                uniformBlockIndex,
                pname,
                params
            );
        }
        let out = call_atomic_ptr_4arg(
            "glGetActiveUniformBlockiv",
            &glGetActiveUniformBlockiv_p,
            program,
            uniformBlockIndex,
            pname,
            params,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glGetActiveUniformBlockiv");
        }
        out
    }
    static glGetActiveUniformBlockiv_p: APcv = ap_None();
    /// Tries to load [`glGetActiveUniformBlockiv`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    pub unsafe fn glGetActiveUniformBlockiv_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glGetActiveUniformBlockiv\0",
            &glGetActiveUniformBlockiv_p,
        )
    }
    /// Checks if the pointer for [`glGetActiveUniformBlockiv`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    pub fn glGetActiveUniformBlockiv_is_loaded() -> bool {
        !glGetActiveUniformBlockiv_p.load(RELAX).is_null()
    }

    /// [glGetActiveUniformsiv](http://docs.gl/es3/glGetActiveUniformsiv)(program, uniformCount, uniformIndices, pname, params)
    /// `program` class: program
    /// `uniformIndices` len: uniformCount
    /// `pname` group: UniformPName
    /// `params` len: COMPSIZE(uniformCount,pname)
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn glGetActiveUniformsiv(
        program: GLuint,
        uniformCount: GLsizei,
        uniformIndices: *const GLuint,
        pname: GLenum,
        params: *mut GLint,
    ) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glGetActiveUniformsiv({:?}, {:?}, {:p}, {:#X}, {:p});",
                program,
                uniformCount,
                uniformIndices,
                pname,
                params
            );
        }
        let out = call_atomic_ptr_5arg(
            "glGetActiveUniformsiv",
            &glGetActiveUniformsiv_p,
            program,
            uniformCount,
            uniformIndices,
            pname,
            params,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glGetActiveUniformsiv");
        }
        out
    }
    static glGetActiveUniformsiv_p: APcv = ap_None();
    /// Tries to load [`glGetActiveUniformsiv`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    pub unsafe fn glGetActiveUniformsiv_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glGetActiveUniformsiv\0",
            &glGetActiveUniformsiv_p,
        )
    }
    /// Checks if the pointer for [`glGetActiveUniformsiv`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    pub fn glGetActiveUniformsiv_is_loaded() -> bool {
        !glGetActiveUniformsiv_p.load(RELAX).is_null()
    }

    /// [glGetAttachedShaders](http://docs.gl/es3/glGetAttachedShaders)(program, maxCount, count, shaders)
    /// `program` class: program
    /// `count` len: 1
    /// `shaders` len: maxCount
    /// `shaders` class: shader
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn glGetAttachedShaders(
        program: GLuint,
        maxCount: GLsizei,
        count: *mut GLsizei,
        shaders: *mut GLuint,
    ) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glGetAttachedShaders({:?}, {:?}, {:p}, {:p});",
                program,
                maxCount,
                count,
                shaders
            );
        }
        let out = call_atomic_ptr_4arg(
            "glGetAttachedShaders",
            &glGetAttachedShaders_p,
            program,
            maxCount,
            count,
            shaders,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glGetAttachedShaders");
        }
        out
    }
    static glGetAttachedShaders_p: APcv = ap_None();
    /// Tries to load [`glGetAttachedShaders`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    pub unsafe fn glGetAttachedShaders_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glGetAttachedShaders\0",
            &glGetAttachedShaders_p,
        )
    }
    /// Checks if the pointer for [`glGetAttachedShaders`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    pub fn glGetAttachedShaders_is_loaded() -> bool {
        !glGetAttachedShaders_p.load(RELAX).is_null()
    }

    /// [glGetAttribLocation](http://docs.gl/es3/glGetAttribLocation)(program, name)
    /// `program` class: program
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn glGetAttribLocation(program: GLuint, name: *const GLchar) -> GLint {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!("calling glGetAttribLocation({:?}, {:p});", program, name);
        }
        let out =
            call_atomic_ptr_2arg("glGetAttribLocation", &glGetAttribLocation_p, program, name);
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glGetAttribLocation");
        }
        out
    }
    static glGetAttribLocation_p: APcv = ap_None();
    /// Tries to load [`glGetAttribLocation`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    pub unsafe fn glGetAttribLocation_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glGetAttribLocation\0",
            &glGetAttribLocation_p,
        )
    }
    /// Checks if the pointer for [`glGetAttribLocation`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    pub fn glGetAttribLocation_is_loaded() -> bool {
        !glGetAttribLocation_p.load(RELAX).is_null()
    }

    /// [glGetBooleani_v](http://docs.gl/es3/glGet)(target, index, data)
    /// `target` group: BufferTargetARB
    /// `data` len: COMPSIZE(target)
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn glGetBooleani_v(target: GLenum, index: GLuint, data: *mut GLboolean) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glGetBooleani_v({:#X}, {:?}, {:p});",
                target,
                index,
                data
            );
        }
        let out = call_atomic_ptr_3arg("glGetBooleani_v", &glGetBooleani_v_p, target, index, data);
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glGetBooleani_v");
        }
        out
    }
    static glGetBooleani_v_p: APcv = ap_None();
    /// Tries to load [`glGetBooleani_v`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    pub unsafe fn glGetBooleani_v_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(get_proc_address, b"glGetBooleani_v\0", &glGetBooleani_v_p)
    }
    /// Checks if the pointer for [`glGetBooleani_v`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    pub fn glGetBooleani_v_is_loaded() -> bool {
        !glGetBooleani_v_p.load(RELAX).is_null()
    }

    /// [glGetBooleanv](http://docs.gl/es3/glGet)(pname, data)
    /// `pname` group: GetPName
    /// `data` len: COMPSIZE(pname)
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn glGetBooleanv(pname: GLenum, data: *mut GLboolean) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!("calling glGetBooleanv({:#X}, {:p});", pname, data);
        }
        let out = call_atomic_ptr_2arg("glGetBooleanv", &glGetBooleanv_p, pname, data);
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glGetBooleanv");
        }
        out
    }
    static glGetBooleanv_p: APcv = ap_None();
    /// Tries to load [`glGetBooleanv`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    pub unsafe fn glGetBooleanv_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(get_proc_address, b"glGetBooleanv\0", &glGetBooleanv_p)
    }
    /// Checks if the pointer for [`glGetBooleanv`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    pub fn glGetBooleanv_is_loaded() -> bool {
        !glGetBooleanv_p.load(RELAX).is_null()
    }

    /// [glGetBufferParameteri64v](http://docs.gl/es3/glGetBufferParameter)(target, pname, params)
    /// `target` group: BufferTargetARB
    /// `pname` group: BufferPNameARB
    /// `params` len: COMPSIZE(pname)
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn glGetBufferParameteri64v(target: GLenum, pname: GLenum, params: *mut GLint64) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glGetBufferParameteri64v({:#X}, {:#X}, {:p});",
                target,
                pname,
                params
            );
        }
        let out = call_atomic_ptr_3arg(
            "glGetBufferParameteri64v",
            &glGetBufferParameteri64v_p,
            target,
            pname,
            params,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glGetBufferParameteri64v");
        }
        out
    }
    static glGetBufferParameteri64v_p: APcv = ap_None();
    /// Tries to load [`glGetBufferParameteri64v`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    pub unsafe fn glGetBufferParameteri64v_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glGetBufferParameteri64v\0",
            &glGetBufferParameteri64v_p,
        )
    }
    /// Checks if the pointer for [`glGetBufferParameteri64v`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    pub fn glGetBufferParameteri64v_is_loaded() -> bool {
        !glGetBufferParameteri64v_p.load(RELAX).is_null()
    }

    /// [glGetBufferParameteriv](http://docs.gl/es3/glGetBufferParameter)(target, pname, params)
    /// `target` group: BufferTargetARB
    /// `pname` group: BufferPNameARB
    /// `params` len: COMPSIZE(pname)
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn glGetBufferParameteriv(target: GLenum, pname: GLenum, params: *mut GLint) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glGetBufferParameteriv({:#X}, {:#X}, {:p});",
                target,
                pname,
                params
            );
        }
        let out = call_atomic_ptr_3arg(
            "glGetBufferParameteriv",
            &glGetBufferParameteriv_p,
            target,
            pname,
            params,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glGetBufferParameteriv");
        }
        out
    }
    static glGetBufferParameteriv_p: APcv = ap_None();
    /// Tries to load [`glGetBufferParameteriv`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    pub unsafe fn glGetBufferParameteriv_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glGetBufferParameteriv\0",
            &glGetBufferParameteriv_p,
        )
    }
    /// Checks if the pointer for [`glGetBufferParameteriv`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    pub fn glGetBufferParameteriv_is_loaded() -> bool {
        !glGetBufferParameteriv_p.load(RELAX).is_null()
    }

    /// [glGetBufferPointerv](http://docs.gl/es3/glGetBufferPointerv)(target, pname, params)
    /// `target` group: BufferTargetARB
    /// `pname` group: BufferPointerNameARB
    /// `params` len: 1
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn glGetBufferPointerv(target: GLenum, pname: GLenum, params: *mut *mut c_void) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glGetBufferPointerv({:#X}, {:#X}, {:p});",
                target,
                pname,
                params
            );
        }
        let out = call_atomic_ptr_3arg(
            "glGetBufferPointerv",
            &glGetBufferPointerv_p,
            target,
            pname,
            params,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glGetBufferPointerv");
        }
        out
    }
    static glGetBufferPointerv_p: APcv = ap_None();
    /// Tries to load [`glGetBufferPointerv`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    pub unsafe fn glGetBufferPointerv_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glGetBufferPointerv\0",
            &glGetBufferPointerv_p,
        )
    }
    /// Checks if the pointer for [`glGetBufferPointerv`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    pub fn glGetBufferPointerv_is_loaded() -> bool {
        !glGetBufferPointerv_p.load(RELAX).is_null()
    }

    /// [glGetBufferPointervOES](http://docs.gl/es3/glGetBufferPointervOES)(target, pname, params)
    /// `target` group: BufferTargetARB
    /// `pname` group: BufferPointerNameARB
    /// `params` len: 1
    /// alias of: [`glGetBufferPointerv`]
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    #[cfg(any(feature = "GL_OES_mapbuffer"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_OES_mapbuffer"))))]
    pub unsafe fn glGetBufferPointervOES(target: GLenum, pname: GLenum, params: *mut *mut c_void) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glGetBufferPointervOES({:#X}, {:#X}, {:p});",
                target,
                pname,
                params
            );
        }
        let out = call_atomic_ptr_3arg(
            "glGetBufferPointervOES",
            &glGetBufferPointervOES_p,
            target,
            pname,
            params,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glGetBufferPointervOES");
        }
        out
    }
    #[cfg(any(feature = "GL_OES_mapbuffer"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_OES_mapbuffer"))))]
    static glGetBufferPointervOES_p: APcv = ap_None();
    /// Tries to load [`glGetBufferPointervOES`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    #[cfg(any(feature = "GL_OES_mapbuffer"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_OES_mapbuffer"))))]
    pub unsafe fn glGetBufferPointervOES_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glGetBufferPointervOES\0",
            &glGetBufferPointervOES_p,
        )
    }
    /// Checks if the pointer for [`glGetBufferPointervOES`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    #[cfg(any(feature = "GL_OES_mapbuffer"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_OES_mapbuffer"))))]
    pub fn glGetBufferPointervOES_is_loaded() -> bool {
        !glGetBufferPointervOES_p.load(RELAX).is_null()
    }

    /// [glGetCoverageModulationTableNV](http://docs.gl/es3/glGetCoverageModulationTableNV)(bufSize, v)
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    #[cfg(any(feature = "GL_NV_framebuffer_mixed_samples"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_framebuffer_mixed_samples"))))]
    pub unsafe fn glGetCoverageModulationTableNV(bufSize: GLsizei, v: *mut GLfloat) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glGetCoverageModulationTableNV({:?}, {:p});",
                bufSize,
                v
            );
        }
        let out = call_atomic_ptr_2arg(
            "glGetCoverageModulationTableNV",
            &glGetCoverageModulationTableNV_p,
            bufSize,
            v,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glGetCoverageModulationTableNV");
        }
        out
    }
    #[cfg(any(feature = "GL_NV_framebuffer_mixed_samples"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_framebuffer_mixed_samples"))))]
    static glGetCoverageModulationTableNV_p: APcv = ap_None();
    /// Tries to load [`glGetCoverageModulationTableNV`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    #[cfg(any(feature = "GL_NV_framebuffer_mixed_samples"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_framebuffer_mixed_samples"))))]
    pub unsafe fn glGetCoverageModulationTableNV_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glGetCoverageModulationTableNV\0",
            &glGetCoverageModulationTableNV_p,
        )
    }
    /// Checks if the pointer for [`glGetCoverageModulationTableNV`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    #[cfg(any(feature = "GL_NV_framebuffer_mixed_samples"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_framebuffer_mixed_samples"))))]
    pub fn glGetCoverageModulationTableNV_is_loaded() -> bool {
        !glGetCoverageModulationTableNV_p.load(RELAX).is_null()
    }

    /// [glGetDebugMessageLog](http://docs.gl/es3/glGetDebugMessageLog)(count, bufSize, sources, types, ids, severities, lengths, messageLog)
    /// `sources` group: DebugSource
    /// `sources` len: count
    /// `types` group: DebugType
    /// `types` len: count
    /// `ids` len: count
    /// `severities` group: DebugSeverity
    /// `severities` len: count
    /// `lengths` len: count
    /// `messageLog` len: bufSize
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn glGetDebugMessageLog(
        count: GLuint,
        bufSize: GLsizei,
        sources: *mut GLenum,
        types: *mut GLenum,
        ids: *mut GLuint,
        severities: *mut GLenum,
        lengths: *mut GLsizei,
        messageLog: *mut GLchar,
    ) -> GLuint {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glGetDebugMessageLog({:?}, {:?}, {:p}, {:p}, {:p}, {:p}, {:p}, {:p});",
                count,
                bufSize,
                sources,
                types,
                ids,
                severities,
                lengths,
                messageLog
            );
        }
        let out = call_atomic_ptr_8arg(
            "glGetDebugMessageLog",
            &glGetDebugMessageLog_p,
            count,
            bufSize,
            sources,
            types,
            ids,
            severities,
            lengths,
            messageLog,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glGetDebugMessageLog");
        }
        out
    }
    static glGetDebugMessageLog_p: APcv = ap_None();
    /// Tries to load [`glGetDebugMessageLog`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    pub unsafe fn glGetDebugMessageLog_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glGetDebugMessageLog\0",
            &glGetDebugMessageLog_p,
        )
    }
    /// Checks if the pointer for [`glGetDebugMessageLog`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    pub fn glGetDebugMessageLog_is_loaded() -> bool {
        !glGetDebugMessageLog_p.load(RELAX).is_null()
    }

    /// [glGetDebugMessageLogKHR](http://docs.gl/es3/glGetDebugMessageLogKHR)(count, bufSize, sources, types, ids, severities, lengths, messageLog)
    /// `sources` group: DebugSource
    /// `sources` len: count
    /// `types` group: DebugType
    /// `types` len: count
    /// `ids` len: count
    /// `severities` group: DebugSeverity
    /// `severities` len: count
    /// `lengths` len: count
    /// `messageLog` len: bufSize
    /// alias of: [`glGetDebugMessageLog`]
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    #[cfg(any(feature = "GL_KHR_debug"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_KHR_debug"))))]
    pub unsafe fn glGetDebugMessageLogKHR(
        count: GLuint,
        bufSize: GLsizei,
        sources: *mut GLenum,
        types: *mut GLenum,
        ids: *mut GLuint,
        severities: *mut GLenum,
        lengths: *mut GLsizei,
        messageLog: *mut GLchar,
    ) -> GLuint {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glGetDebugMessageLogKHR({:?}, {:?}, {:p}, {:p}, {:p}, {:p}, {:p}, {:p});",
                count,
                bufSize,
                sources,
                types,
                ids,
                severities,
                lengths,
                messageLog
            );
        }
        let out = call_atomic_ptr_8arg(
            "glGetDebugMessageLogKHR",
            &glGetDebugMessageLogKHR_p,
            count,
            bufSize,
            sources,
            types,
            ids,
            severities,
            lengths,
            messageLog,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glGetDebugMessageLogKHR");
        }
        out
    }
    #[cfg(any(feature = "GL_KHR_debug"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_KHR_debug"))))]
    static glGetDebugMessageLogKHR_p: APcv = ap_None();
    /// Tries to load [`glGetDebugMessageLogKHR`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    #[cfg(any(feature = "GL_KHR_debug"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_KHR_debug"))))]
    pub unsafe fn glGetDebugMessageLogKHR_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glGetDebugMessageLogKHR\0",
            &glGetDebugMessageLogKHR_p,
        )
    }
    /// Checks if the pointer for [`glGetDebugMessageLogKHR`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    #[cfg(any(feature = "GL_KHR_debug"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_KHR_debug"))))]
    pub fn glGetDebugMessageLogKHR_is_loaded() -> bool {
        !glGetDebugMessageLogKHR_p.load(RELAX).is_null()
    }

    /// [glGetDriverControlStringQCOM](http://docs.gl/es3/glGetDriverControlStringQCOM)(driverControl, bufSize, length, driverControlString)
    /// `driverControlString` len: bufSize
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    #[cfg(any(feature = "GL_QCOM_driver_control"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_QCOM_driver_control"))))]
    pub unsafe fn glGetDriverControlStringQCOM(
        driverControl: GLuint,
        bufSize: GLsizei,
        length: *mut GLsizei,
        driverControlString: *mut GLchar,
    ) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glGetDriverControlStringQCOM({:?}, {:?}, {:p}, {:p});",
                driverControl,
                bufSize,
                length,
                driverControlString
            );
        }
        let out = call_atomic_ptr_4arg(
            "glGetDriverControlStringQCOM",
            &glGetDriverControlStringQCOM_p,
            driverControl,
            bufSize,
            length,
            driverControlString,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glGetDriverControlStringQCOM");
        }
        out
    }
    #[cfg(any(feature = "GL_QCOM_driver_control"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_QCOM_driver_control"))))]
    static glGetDriverControlStringQCOM_p: APcv = ap_None();
    /// Tries to load [`glGetDriverControlStringQCOM`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    #[cfg(any(feature = "GL_QCOM_driver_control"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_QCOM_driver_control"))))]
    pub unsafe fn glGetDriverControlStringQCOM_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glGetDriverControlStringQCOM\0",
            &glGetDriverControlStringQCOM_p,
        )
    }
    /// Checks if the pointer for [`glGetDriverControlStringQCOM`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    #[cfg(any(feature = "GL_QCOM_driver_control"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_QCOM_driver_control"))))]
    pub fn glGetDriverControlStringQCOM_is_loaded() -> bool {
        !glGetDriverControlStringQCOM_p.load(RELAX).is_null()
    }

    /// [glGetDriverControlsQCOM](http://docs.gl/es3/glGetDriverControlsQCOM)(num, size, driverControls)
    /// `driverControls` len: size
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    #[cfg(any(feature = "GL_QCOM_driver_control"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_QCOM_driver_control"))))]
    pub unsafe fn glGetDriverControlsQCOM(
        num: *mut GLint,
        size: GLsizei,
        driverControls: *mut GLuint,
    ) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glGetDriverControlsQCOM({:p}, {:?}, {:p});",
                num,
                size,
                driverControls
            );
        }
        let out = call_atomic_ptr_3arg(
            "glGetDriverControlsQCOM",
            &glGetDriverControlsQCOM_p,
            num,
            size,
            driverControls,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glGetDriverControlsQCOM");
        }
        out
    }
    #[cfg(any(feature = "GL_QCOM_driver_control"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_QCOM_driver_control"))))]
    static glGetDriverControlsQCOM_p: APcv = ap_None();
    /// Tries to load [`glGetDriverControlsQCOM`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    #[cfg(any(feature = "GL_QCOM_driver_control"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_QCOM_driver_control"))))]
    pub unsafe fn glGetDriverControlsQCOM_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glGetDriverControlsQCOM\0",
            &glGetDriverControlsQCOM_p,
        )
    }
    /// Checks if the pointer for [`glGetDriverControlsQCOM`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    #[cfg(any(feature = "GL_QCOM_driver_control"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_QCOM_driver_control"))))]
    pub fn glGetDriverControlsQCOM_is_loaded() -> bool {
        !glGetDriverControlsQCOM_p.load(RELAX).is_null()
    }

    /// [glGetError](http://docs.gl/es3/glGetError)()
    /// return value group: ErrorCode
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn glGetError() -> GLenum {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!("calling glGetError();",);
        }
        let out = call_atomic_ptr_0arg("glGetError", &glGetError_p);

        out
    }
    static glGetError_p: APcv = ap_None();
    /// Tries to load [`glGetError`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    pub unsafe fn glGetError_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(get_proc_address, b"glGetError\0", &glGetError_p)
    }
    /// Checks if the pointer for [`glGetError`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    pub fn glGetError_is_loaded() -> bool {
        !glGetError_p.load(RELAX).is_null()
    }

    /// [glGetFenceivNV](http://docs.gl/es3/glGetFenceivNV)(fence, pname, params)
    /// `fence` group: FenceNV
    /// `pname` group: FenceParameterNameNV
    /// `params` len: COMPSIZE(pname)
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    #[cfg(any(feature = "GL_NV_fence"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_fence"))))]
    pub unsafe fn glGetFenceivNV(fence: GLuint, pname: GLenum, params: *mut GLint) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glGetFenceivNV({:?}, {:#X}, {:p});",
                fence,
                pname,
                params
            );
        }
        let out = call_atomic_ptr_3arg("glGetFenceivNV", &glGetFenceivNV_p, fence, pname, params);
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glGetFenceivNV");
        }
        out
    }
    #[cfg(any(feature = "GL_NV_fence"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_fence"))))]
    static glGetFenceivNV_p: APcv = ap_None();
    /// Tries to load [`glGetFenceivNV`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    #[cfg(any(feature = "GL_NV_fence"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_fence"))))]
    pub unsafe fn glGetFenceivNV_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(get_proc_address, b"glGetFenceivNV\0", &glGetFenceivNV_p)
    }
    /// Checks if the pointer for [`glGetFenceivNV`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    #[cfg(any(feature = "GL_NV_fence"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_fence"))))]
    pub fn glGetFenceivNV_is_loaded() -> bool {
        !glGetFenceivNV_p.load(RELAX).is_null()
    }

    /// [glGetFirstPerfQueryIdINTEL](http://docs.gl/es3/glGetFirstPerfQueryIdINTEL)(queryId)
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    #[cfg(any(feature = "GL_INTEL_performance_query"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_INTEL_performance_query"))))]
    pub unsafe fn glGetFirstPerfQueryIdINTEL(queryId: *mut GLuint) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!("calling glGetFirstPerfQueryIdINTEL({:p});", queryId);
        }
        let out = call_atomic_ptr_1arg(
            "glGetFirstPerfQueryIdINTEL",
            &glGetFirstPerfQueryIdINTEL_p,
            queryId,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glGetFirstPerfQueryIdINTEL");
        }
        out
    }
    #[cfg(any(feature = "GL_INTEL_performance_query"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_INTEL_performance_query"))))]
    static glGetFirstPerfQueryIdINTEL_p: APcv = ap_None();
    /// Tries to load [`glGetFirstPerfQueryIdINTEL`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    #[cfg(any(feature = "GL_INTEL_performance_query"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_INTEL_performance_query"))))]
    pub unsafe fn glGetFirstPerfQueryIdINTEL_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glGetFirstPerfQueryIdINTEL\0",
            &glGetFirstPerfQueryIdINTEL_p,
        )
    }
    /// Checks if the pointer for [`glGetFirstPerfQueryIdINTEL`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    #[cfg(any(feature = "GL_INTEL_performance_query"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_INTEL_performance_query"))))]
    pub fn glGetFirstPerfQueryIdINTEL_is_loaded() -> bool {
        !glGetFirstPerfQueryIdINTEL_p.load(RELAX).is_null()
    }

    /// [glGetFloati_vNV](http://docs.gl/es3/glGetFloati_vNV)(target, index, data)
    /// `target` group: GetPName
    /// `data` len: COMPSIZE(target)
    /// alias of: [`glGetFloati_v`]
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    #[cfg(any(feature = "GL_NV_viewport_array"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_viewport_array"))))]
    pub unsafe fn glGetFloati_vNV(target: GLenum, index: GLuint, data: *mut GLfloat) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glGetFloati_vNV({:#X}, {:?}, {:p});",
                target,
                index,
                data
            );
        }
        let out = call_atomic_ptr_3arg("glGetFloati_vNV", &glGetFloati_vNV_p, target, index, data);
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glGetFloati_vNV");
        }
        out
    }
    #[cfg(any(feature = "GL_NV_viewport_array"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_viewport_array"))))]
    static glGetFloati_vNV_p: APcv = ap_None();
    /// Tries to load [`glGetFloati_vNV`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    #[cfg(any(feature = "GL_NV_viewport_array"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_viewport_array"))))]
    pub unsafe fn glGetFloati_vNV_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(get_proc_address, b"glGetFloati_vNV\0", &glGetFloati_vNV_p)
    }
    /// Checks if the pointer for [`glGetFloati_vNV`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    #[cfg(any(feature = "GL_NV_viewport_array"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_viewport_array"))))]
    pub fn glGetFloati_vNV_is_loaded() -> bool {
        !glGetFloati_vNV_p.load(RELAX).is_null()
    }

    /// [glGetFloati_vOES](http://docs.gl/es3/glGetFloati_vOES)(target, index, data)
    /// `target` group: GetPName
    /// `data` len: COMPSIZE(target)
    /// alias of: [`glGetFloati_v`]
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    #[cfg(any(feature = "GL_OES_viewport_array"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_OES_viewport_array"))))]
    pub unsafe fn glGetFloati_vOES(target: GLenum, index: GLuint, data: *mut GLfloat) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glGetFloati_vOES({:#X}, {:?}, {:p});",
                target,
                index,
                data
            );
        }
        let out =
            call_atomic_ptr_3arg("glGetFloati_vOES", &glGetFloati_vOES_p, target, index, data);
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glGetFloati_vOES");
        }
        out
    }
    #[cfg(any(feature = "GL_OES_viewport_array"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_OES_viewport_array"))))]
    static glGetFloati_vOES_p: APcv = ap_None();
    /// Tries to load [`glGetFloati_vOES`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    #[cfg(any(feature = "GL_OES_viewport_array"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_OES_viewport_array"))))]
    pub unsafe fn glGetFloati_vOES_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(get_proc_address, b"glGetFloati_vOES\0", &glGetFloati_vOES_p)
    }
    /// Checks if the pointer for [`glGetFloati_vOES`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    #[cfg(any(feature = "GL_OES_viewport_array"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_OES_viewport_array"))))]
    pub fn glGetFloati_vOES_is_loaded() -> bool {
        !glGetFloati_vOES_p.load(RELAX).is_null()
    }

    /// [glGetFloatv](http://docs.gl/es3/glGet)(pname, data)
    /// `pname` group: GetPName
    /// `data` len: COMPSIZE(pname)
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn glGetFloatv(pname: GLenum, data: *mut GLfloat) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!("calling glGetFloatv({:#X}, {:p});", pname, data);
        }
        let out = call_atomic_ptr_2arg("glGetFloatv", &glGetFloatv_p, pname, data);
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glGetFloatv");
        }
        out
    }
    static glGetFloatv_p: APcv = ap_None();
    /// Tries to load [`glGetFloatv`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    pub unsafe fn glGetFloatv_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(get_proc_address, b"glGetFloatv\0", &glGetFloatv_p)
    }
    /// Checks if the pointer for [`glGetFloatv`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    pub fn glGetFloatv_is_loaded() -> bool {
        !glGetFloatv_p.load(RELAX).is_null()
    }

    /// [glGetFragDataIndexEXT](http://docs.gl/es3/glGetFragDataIndexEXT)(program, name)
    /// `program` class: program
    /// alias of: [`glGetFragDataIndex`]
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    #[cfg(any(feature = "GL_EXT_blend_func_extended"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_blend_func_extended"))))]
    pub unsafe fn glGetFragDataIndexEXT(program: GLuint, name: *const GLchar) -> GLint {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!("calling glGetFragDataIndexEXT({:?}, {:p});", program, name);
        }
        let out = call_atomic_ptr_2arg(
            "glGetFragDataIndexEXT",
            &glGetFragDataIndexEXT_p,
            program,
            name,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glGetFragDataIndexEXT");
        }
        out
    }
    #[cfg(any(feature = "GL_EXT_blend_func_extended"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_blend_func_extended"))))]
    static glGetFragDataIndexEXT_p: APcv = ap_None();
    /// Tries to load [`glGetFragDataIndexEXT`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    #[cfg(any(feature = "GL_EXT_blend_func_extended"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_blend_func_extended"))))]
    pub unsafe fn glGetFragDataIndexEXT_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glGetFragDataIndexEXT\0",
            &glGetFragDataIndexEXT_p,
        )
    }
    /// Checks if the pointer for [`glGetFragDataIndexEXT`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    #[cfg(any(feature = "GL_EXT_blend_func_extended"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_blend_func_extended"))))]
    pub fn glGetFragDataIndexEXT_is_loaded() -> bool {
        !glGetFragDataIndexEXT_p.load(RELAX).is_null()
    }

    /// [glGetFragDataLocation](http://docs.gl/es3/glGetFragDataLocation)(program, name)
    /// `program` class: program
    /// `name` len: COMPSIZE(name)
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn glGetFragDataLocation(program: GLuint, name: *const GLchar) -> GLint {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!("calling glGetFragDataLocation({:?}, {:p});", program, name);
        }
        let out = call_atomic_ptr_2arg(
            "glGetFragDataLocation",
            &glGetFragDataLocation_p,
            program,
            name,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glGetFragDataLocation");
        }
        out
    }
    static glGetFragDataLocation_p: APcv = ap_None();
    /// Tries to load [`glGetFragDataLocation`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    pub unsafe fn glGetFragDataLocation_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glGetFragDataLocation\0",
            &glGetFragDataLocation_p,
        )
    }
    /// Checks if the pointer for [`glGetFragDataLocation`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    pub fn glGetFragDataLocation_is_loaded() -> bool {
        !glGetFragDataLocation_p.load(RELAX).is_null()
    }

    /// [glGetFramebufferAttachmentParameteriv](http://docs.gl/es3/glGetFramebufferAttachmentParameter)(target, attachment, pname, params)
    /// `target` group: FramebufferTarget
    /// `attachment` group: FramebufferAttachment
    /// `pname` group: FramebufferAttachmentParameterName
    /// `params` len: COMPSIZE(pname)
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn glGetFramebufferAttachmentParameteriv(
        target: GLenum,
        attachment: GLenum,
        pname: GLenum,
        params: *mut GLint,
    ) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glGetFramebufferAttachmentParameteriv({:#X}, {:#X}, {:#X}, {:p});",
                target,
                attachment,
                pname,
                params
            );
        }
        let out = call_atomic_ptr_4arg(
            "glGetFramebufferAttachmentParameteriv",
            &glGetFramebufferAttachmentParameteriv_p,
            target,
            attachment,
            pname,
            params,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glGetFramebufferAttachmentParameteriv");
        }
        out
    }
    static glGetFramebufferAttachmentParameteriv_p: APcv = ap_None();
    /// Tries to load [`glGetFramebufferAttachmentParameteriv`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    pub unsafe fn glGetFramebufferAttachmentParameteriv_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glGetFramebufferAttachmentParameteriv\0",
            &glGetFramebufferAttachmentParameteriv_p,
        )
    }
    /// Checks if the pointer for [`glGetFramebufferAttachmentParameteriv`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    pub fn glGetFramebufferAttachmentParameteriv_is_loaded() -> bool {
        !glGetFramebufferAttachmentParameteriv_p
            .load(RELAX)
            .is_null()
    }

    /// [glGetFramebufferParameteriv](http://docs.gl/es3/glGetFramebufferParameter)(target, pname, params)
    /// `target` group: FramebufferTarget
    /// `pname` group: FramebufferAttachmentParameterName
    /// `params` len: COMPSIZE(pname)
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn glGetFramebufferParameteriv(target: GLenum, pname: GLenum, params: *mut GLint) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glGetFramebufferParameteriv({:#X}, {:#X}, {:p});",
                target,
                pname,
                params
            );
        }
        let out = call_atomic_ptr_3arg(
            "glGetFramebufferParameteriv",
            &glGetFramebufferParameteriv_p,
            target,
            pname,
            params,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glGetFramebufferParameteriv");
        }
        out
    }
    static glGetFramebufferParameteriv_p: APcv = ap_None();
    /// Tries to load [`glGetFramebufferParameteriv`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    pub unsafe fn glGetFramebufferParameteriv_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glGetFramebufferParameteriv\0",
            &glGetFramebufferParameteriv_p,
        )
    }
    /// Checks if the pointer for [`glGetFramebufferParameteriv`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    pub fn glGetFramebufferParameteriv_is_loaded() -> bool {
        !glGetFramebufferParameteriv_p.load(RELAX).is_null()
    }

    /// [glGetFramebufferParameterivMESA](http://docs.gl/es3/glGetFramebufferParameterivMESA)(target, pname, params)
    /// `target` group: FramebufferTarget
    /// `pname` group: FramebufferAttachmentParameterName
    /// `params` len: COMPSIZE(pname)
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    #[cfg(any(feature = "GL_MESA_framebuffer_flip_y"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_MESA_framebuffer_flip_y"))))]
    pub unsafe fn glGetFramebufferParameterivMESA(
        target: GLenum,
        pname: GLenum,
        params: *mut GLint,
    ) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glGetFramebufferParameterivMESA({:#X}, {:#X}, {:p});",
                target,
                pname,
                params
            );
        }
        let out = call_atomic_ptr_3arg(
            "glGetFramebufferParameterivMESA",
            &glGetFramebufferParameterivMESA_p,
            target,
            pname,
            params,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glGetFramebufferParameterivMESA");
        }
        out
    }
    #[cfg(any(feature = "GL_MESA_framebuffer_flip_y"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_MESA_framebuffer_flip_y"))))]
    static glGetFramebufferParameterivMESA_p: APcv = ap_None();
    /// Tries to load [`glGetFramebufferParameterivMESA`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    #[cfg(any(feature = "GL_MESA_framebuffer_flip_y"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_MESA_framebuffer_flip_y"))))]
    pub unsafe fn glGetFramebufferParameterivMESA_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glGetFramebufferParameterivMESA\0",
            &glGetFramebufferParameterivMESA_p,
        )
    }
    /// Checks if the pointer for [`glGetFramebufferParameterivMESA`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    #[cfg(any(feature = "GL_MESA_framebuffer_flip_y"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_MESA_framebuffer_flip_y"))))]
    pub fn glGetFramebufferParameterivMESA_is_loaded() -> bool {
        !glGetFramebufferParameterivMESA_p.load(RELAX).is_null()
    }

    /// [glGetFramebufferPixelLocalStorageSizeEXT](http://docs.gl/es3/glGetFramebufferPixelLocalStorageSizeEXT)(target)
    /// `target` group: FramebufferTarget
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    #[cfg(any(feature = "GL_EXT_shader_pixel_local_storage2"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_shader_pixel_local_storage2"))))]
    pub unsafe fn glGetFramebufferPixelLocalStorageSizeEXT(target: GLuint) -> GLsizei {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glGetFramebufferPixelLocalStorageSizeEXT({:?});",
                target
            );
        }
        let out = call_atomic_ptr_1arg(
            "glGetFramebufferPixelLocalStorageSizeEXT",
            &glGetFramebufferPixelLocalStorageSizeEXT_p,
            target,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glGetFramebufferPixelLocalStorageSizeEXT");
        }
        out
    }
    #[cfg(any(feature = "GL_EXT_shader_pixel_local_storage2"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_shader_pixel_local_storage2"))))]
    static glGetFramebufferPixelLocalStorageSizeEXT_p: APcv = ap_None();
    /// Tries to load [`glGetFramebufferPixelLocalStorageSizeEXT`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    #[cfg(any(feature = "GL_EXT_shader_pixel_local_storage2"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_shader_pixel_local_storage2"))))]
    pub unsafe fn glGetFramebufferPixelLocalStorageSizeEXT_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glGetFramebufferPixelLocalStorageSizeEXT\0",
            &glGetFramebufferPixelLocalStorageSizeEXT_p,
        )
    }
    /// Checks if the pointer for [`glGetFramebufferPixelLocalStorageSizeEXT`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    #[cfg(any(feature = "GL_EXT_shader_pixel_local_storage2"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_shader_pixel_local_storage2"))))]
    pub fn glGetFramebufferPixelLocalStorageSizeEXT_is_loaded() -> bool {
        !glGetFramebufferPixelLocalStorageSizeEXT_p
            .load(RELAX)
            .is_null()
    }

    /// [glGetGraphicsResetStatus](http://docs.gl/es3/glGetGraphicsResetStatus)()
    /// return value group: GraphicsResetStatus
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn glGetGraphicsResetStatus() -> GLenum {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!("calling glGetGraphicsResetStatus();",);
        }
        let out = call_atomic_ptr_0arg("glGetGraphicsResetStatus", &glGetGraphicsResetStatus_p);
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glGetGraphicsResetStatus");
        }
        out
    }
    static glGetGraphicsResetStatus_p: APcv = ap_None();
    /// Tries to load [`glGetGraphicsResetStatus`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    pub unsafe fn glGetGraphicsResetStatus_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glGetGraphicsResetStatus\0",
            &glGetGraphicsResetStatus_p,
        )
    }
    /// Checks if the pointer for [`glGetGraphicsResetStatus`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    pub fn glGetGraphicsResetStatus_is_loaded() -> bool {
        !glGetGraphicsResetStatus_p.load(RELAX).is_null()
    }

    /// [glGetGraphicsResetStatusEXT](http://docs.gl/es3/glGetGraphicsResetStatusEXT)()
    /// return value group: GraphicsResetStatus
    /// alias of: [`glGetGraphicsResetStatus`]
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    #[cfg(any(feature = "GL_EXT_robustness"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_robustness"))))]
    pub unsafe fn glGetGraphicsResetStatusEXT() -> GLenum {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!("calling glGetGraphicsResetStatusEXT();",);
        }
        let out = call_atomic_ptr_0arg(
            "glGetGraphicsResetStatusEXT",
            &glGetGraphicsResetStatusEXT_p,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glGetGraphicsResetStatusEXT");
        }
        out
    }
    #[cfg(any(feature = "GL_EXT_robustness"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_robustness"))))]
    static glGetGraphicsResetStatusEXT_p: APcv = ap_None();
    /// Tries to load [`glGetGraphicsResetStatusEXT`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    #[cfg(any(feature = "GL_EXT_robustness"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_robustness"))))]
    pub unsafe fn glGetGraphicsResetStatusEXT_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glGetGraphicsResetStatusEXT\0",
            &glGetGraphicsResetStatusEXT_p,
        )
    }
    /// Checks if the pointer for [`glGetGraphicsResetStatusEXT`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    #[cfg(any(feature = "GL_EXT_robustness"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_robustness"))))]
    pub fn glGetGraphicsResetStatusEXT_is_loaded() -> bool {
        !glGetGraphicsResetStatusEXT_p.load(RELAX).is_null()
    }

    /// [glGetGraphicsResetStatusKHR](http://docs.gl/es3/glGetGraphicsResetStatusKHR)()
    /// return value group: GraphicsResetStatus
    /// alias of: [`glGetGraphicsResetStatus`]
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    #[cfg(any(feature = "GL_KHR_robustness"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_KHR_robustness"))))]
    pub unsafe fn glGetGraphicsResetStatusKHR() -> GLenum {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!("calling glGetGraphicsResetStatusKHR();",);
        }
        let out = call_atomic_ptr_0arg(
            "glGetGraphicsResetStatusKHR",
            &glGetGraphicsResetStatusKHR_p,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glGetGraphicsResetStatusKHR");
        }
        out
    }
    #[cfg(any(feature = "GL_KHR_robustness"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_KHR_robustness"))))]
    static glGetGraphicsResetStatusKHR_p: APcv = ap_None();
    /// Tries to load [`glGetGraphicsResetStatusKHR`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    #[cfg(any(feature = "GL_KHR_robustness"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_KHR_robustness"))))]
    pub unsafe fn glGetGraphicsResetStatusKHR_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glGetGraphicsResetStatusKHR\0",
            &glGetGraphicsResetStatusKHR_p,
        )
    }
    /// Checks if the pointer for [`glGetGraphicsResetStatusKHR`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    #[cfg(any(feature = "GL_KHR_robustness"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_KHR_robustness"))))]
    pub fn glGetGraphicsResetStatusKHR_is_loaded() -> bool {
        !glGetGraphicsResetStatusKHR_p.load(RELAX).is_null()
    }

    /// [glGetImageHandleNV](http://docs.gl/es3/glGetImageHandleNV)(texture, level, layered, layer, format)
    /// `texture` class: texture
    /// `format` group: PixelFormat
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    #[cfg(any(feature = "GL_NV_bindless_texture"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_bindless_texture"))))]
    pub unsafe fn glGetImageHandleNV(
        texture: GLuint,
        level: GLint,
        layered: GLboolean,
        layer: GLint,
        format: GLenum,
    ) -> GLuint64 {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glGetImageHandleNV({:?}, {:?}, {:?}, {:?}, {:#X});",
                texture,
                level,
                layered,
                layer,
                format
            );
        }
        let out = call_atomic_ptr_5arg(
            "glGetImageHandleNV",
            &glGetImageHandleNV_p,
            texture,
            level,
            layered,
            layer,
            format,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glGetImageHandleNV");
        }
        out
    }
    #[cfg(any(feature = "GL_NV_bindless_texture"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_bindless_texture"))))]
    static glGetImageHandleNV_p: APcv = ap_None();
    /// Tries to load [`glGetImageHandleNV`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    #[cfg(any(feature = "GL_NV_bindless_texture"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_bindless_texture"))))]
    pub unsafe fn glGetImageHandleNV_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glGetImageHandleNV\0",
            &glGetImageHandleNV_p,
        )
    }
    /// Checks if the pointer for [`glGetImageHandleNV`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    #[cfg(any(feature = "GL_NV_bindless_texture"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_bindless_texture"))))]
    pub fn glGetImageHandleNV_is_loaded() -> bool {
        !glGetImageHandleNV_p.load(RELAX).is_null()
    }

    /// [glGetInteger64i_v](http://docs.gl/es3/glGet)(target, index, data)
    /// `target` group: GetPName
    /// `data` len: COMPSIZE(target)
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn glGetInteger64i_v(target: GLenum, index: GLuint, data: *mut GLint64) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glGetInteger64i_v({:#X}, {:?}, {:p});",
                target,
                index,
                data
            );
        }
        let out = call_atomic_ptr_3arg(
            "glGetInteger64i_v",
            &glGetInteger64i_v_p,
            target,
            index,
            data,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glGetInteger64i_v");
        }
        out
    }
    static glGetInteger64i_v_p: APcv = ap_None();
    /// Tries to load [`glGetInteger64i_v`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    pub unsafe fn glGetInteger64i_v_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glGetInteger64i_v\0",
            &glGetInteger64i_v_p,
        )
    }
    /// Checks if the pointer for [`glGetInteger64i_v`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    pub fn glGetInteger64i_v_is_loaded() -> bool {
        !glGetInteger64i_v_p.load(RELAX).is_null()
    }

    /// [glGetInteger64v](http://docs.gl/es3/glGet)(pname, data)
    /// `pname` group: GetPName
    /// `data` len: COMPSIZE(pname)
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn glGetInteger64v(pname: GLenum, data: *mut GLint64) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!("calling glGetInteger64v({:#X}, {:p});", pname, data);
        }
        let out = call_atomic_ptr_2arg("glGetInteger64v", &glGetInteger64v_p, pname, data);
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glGetInteger64v");
        }
        out
    }
    static glGetInteger64v_p: APcv = ap_None();
    /// Tries to load [`glGetInteger64v`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    pub unsafe fn glGetInteger64v_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(get_proc_address, b"glGetInteger64v\0", &glGetInteger64v_p)
    }
    /// Checks if the pointer for [`glGetInteger64v`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    pub fn glGetInteger64v_is_loaded() -> bool {
        !glGetInteger64v_p.load(RELAX).is_null()
    }

    /// [glGetInteger64vAPPLE](http://docs.gl/es3/glGetInteger64vAPPLE)(pname, params)
    /// `pname` group: GetPName
    /// alias of: [`glGetInteger64v`]
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    #[cfg(any(feature = "GL_APPLE_sync"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_APPLE_sync"))))]
    pub unsafe fn glGetInteger64vAPPLE(pname: GLenum, params: *mut GLint64) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!("calling glGetInteger64vAPPLE({:#X}, {:p});", pname, params);
        }
        let out = call_atomic_ptr_2arg(
            "glGetInteger64vAPPLE",
            &glGetInteger64vAPPLE_p,
            pname,
            params,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glGetInteger64vAPPLE");
        }
        out
    }
    #[cfg(any(feature = "GL_APPLE_sync"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_APPLE_sync"))))]
    static glGetInteger64vAPPLE_p: APcv = ap_None();
    /// Tries to load [`glGetInteger64vAPPLE`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    #[cfg(any(feature = "GL_APPLE_sync"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_APPLE_sync"))))]
    pub unsafe fn glGetInteger64vAPPLE_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glGetInteger64vAPPLE\0",
            &glGetInteger64vAPPLE_p,
        )
    }
    /// Checks if the pointer for [`glGetInteger64vAPPLE`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    #[cfg(any(feature = "GL_APPLE_sync"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_APPLE_sync"))))]
    pub fn glGetInteger64vAPPLE_is_loaded() -> bool {
        !glGetInteger64vAPPLE_p.load(RELAX).is_null()
    }

    /// [glGetInteger64vEXT](http://docs.gl/es3/glGetInteger64vEXT)(pname, data)
    /// `pname` group: GetPName
    /// `data` len: COMPSIZE(pname)
    /// alias of: [`glGetInteger64v`]
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    #[cfg(any(feature = "GL_EXT_disjoint_timer_query"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_disjoint_timer_query"))))]
    pub unsafe fn glGetInteger64vEXT(pname: GLenum, data: *mut GLint64) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!("calling glGetInteger64vEXT({:#X}, {:p});", pname, data);
        }
        let out = call_atomic_ptr_2arg("glGetInteger64vEXT", &glGetInteger64vEXT_p, pname, data);
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glGetInteger64vEXT");
        }
        out
    }
    #[cfg(any(feature = "GL_EXT_disjoint_timer_query"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_disjoint_timer_query"))))]
    static glGetInteger64vEXT_p: APcv = ap_None();
    /// Tries to load [`glGetInteger64vEXT`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    #[cfg(any(feature = "GL_EXT_disjoint_timer_query"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_disjoint_timer_query"))))]
    pub unsafe fn glGetInteger64vEXT_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glGetInteger64vEXT\0",
            &glGetInteger64vEXT_p,
        )
    }
    /// Checks if the pointer for [`glGetInteger64vEXT`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    #[cfg(any(feature = "GL_EXT_disjoint_timer_query"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_disjoint_timer_query"))))]
    pub fn glGetInteger64vEXT_is_loaded() -> bool {
        !glGetInteger64vEXT_p.load(RELAX).is_null()
    }

    /// [glGetIntegeri_v](http://docs.gl/es3/glGet)(target, index, data)
    /// `target` group: GetPName
    /// `data` len: COMPSIZE(target)
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn glGetIntegeri_v(target: GLenum, index: GLuint, data: *mut GLint) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glGetIntegeri_v({:#X}, {:?}, {:p});",
                target,
                index,
                data
            );
        }
        let out = call_atomic_ptr_3arg("glGetIntegeri_v", &glGetIntegeri_v_p, target, index, data);
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glGetIntegeri_v");
        }
        out
    }
    static glGetIntegeri_v_p: APcv = ap_None();
    /// Tries to load [`glGetIntegeri_v`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    pub unsafe fn glGetIntegeri_v_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(get_proc_address, b"glGetIntegeri_v\0", &glGetIntegeri_v_p)
    }
    /// Checks if the pointer for [`glGetIntegeri_v`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    pub fn glGetIntegeri_v_is_loaded() -> bool {
        !glGetIntegeri_v_p.load(RELAX).is_null()
    }

    /// [glGetIntegeri_vEXT](http://docs.gl/es3/glGetIntegeri_vEXT)(target, index, data)
    /// `target` group: GetPName
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    #[cfg(any(feature = "GL_EXT_multiview_draw_buffers"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_multiview_draw_buffers"))))]
    pub unsafe fn glGetIntegeri_vEXT(target: GLenum, index: GLuint, data: *mut GLint) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glGetIntegeri_vEXT({:#X}, {:?}, {:p});",
                target,
                index,
                data
            );
        }
        let out = call_atomic_ptr_3arg(
            "glGetIntegeri_vEXT",
            &glGetIntegeri_vEXT_p,
            target,
            index,
            data,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glGetIntegeri_vEXT");
        }
        out
    }
    #[cfg(any(feature = "GL_EXT_multiview_draw_buffers"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_multiview_draw_buffers"))))]
    static glGetIntegeri_vEXT_p: APcv = ap_None();
    /// Tries to load [`glGetIntegeri_vEXT`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    #[cfg(any(feature = "GL_EXT_multiview_draw_buffers"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_multiview_draw_buffers"))))]
    pub unsafe fn glGetIntegeri_vEXT_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glGetIntegeri_vEXT\0",
            &glGetIntegeri_vEXT_p,
        )
    }
    /// Checks if the pointer for [`glGetIntegeri_vEXT`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    #[cfg(any(feature = "GL_EXT_multiview_draw_buffers"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_multiview_draw_buffers"))))]
    pub fn glGetIntegeri_vEXT_is_loaded() -> bool {
        !glGetIntegeri_vEXT_p.load(RELAX).is_null()
    }

    /// [glGetIntegerv](http://docs.gl/es3/glGet)(pname, data)
    /// `pname` group: GetPName
    /// `data` len: COMPSIZE(pname)
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn glGetIntegerv(pname: GLenum, data: *mut GLint) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!("calling glGetIntegerv({:#X}, {:p});", pname, data);
        }
        let out = call_atomic_ptr_2arg("glGetIntegerv", &glGetIntegerv_p, pname, data);
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glGetIntegerv");
        }
        out
    }
    static glGetIntegerv_p: APcv = ap_None();
    /// Tries to load [`glGetIntegerv`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    pub unsafe fn glGetIntegerv_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(get_proc_address, b"glGetIntegerv\0", &glGetIntegerv_p)
    }
    /// Checks if the pointer for [`glGetIntegerv`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    pub fn glGetIntegerv_is_loaded() -> bool {
        !glGetIntegerv_p.load(RELAX).is_null()
    }

    /// [glGetInternalformatSampleivNV](http://docs.gl/es3/glGetInternalformatSampleivNV)(target, internalformat, samples, pname, count, params)
    /// `target` group: TextureTarget
    /// `internalformat` group: InternalFormat
    /// `pname` group: InternalFormatPName
    /// `params` len: count
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    #[cfg(any(feature = "GL_NV_internalformat_sample_query"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_internalformat_sample_query"))))]
    pub unsafe fn glGetInternalformatSampleivNV(
        target: GLenum,
        internalformat: GLenum,
        samples: GLsizei,
        pname: GLenum,
        count: GLsizei,
        params: *mut GLint,
    ) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glGetInternalformatSampleivNV({:#X}, {:#X}, {:?}, {:#X}, {:?}, {:p});",
                target,
                internalformat,
                samples,
                pname,
                count,
                params
            );
        }
        let out = call_atomic_ptr_6arg(
            "glGetInternalformatSampleivNV",
            &glGetInternalformatSampleivNV_p,
            target,
            internalformat,
            samples,
            pname,
            count,
            params,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glGetInternalformatSampleivNV");
        }
        out
    }
    #[cfg(any(feature = "GL_NV_internalformat_sample_query"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_internalformat_sample_query"))))]
    static glGetInternalformatSampleivNV_p: APcv = ap_None();
    /// Tries to load [`glGetInternalformatSampleivNV`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    #[cfg(any(feature = "GL_NV_internalformat_sample_query"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_internalformat_sample_query"))))]
    pub unsafe fn glGetInternalformatSampleivNV_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glGetInternalformatSampleivNV\0",
            &glGetInternalformatSampleivNV_p,
        )
    }
    /// Checks if the pointer for [`glGetInternalformatSampleivNV`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    #[cfg(any(feature = "GL_NV_internalformat_sample_query"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_internalformat_sample_query"))))]
    pub fn glGetInternalformatSampleivNV_is_loaded() -> bool {
        !glGetInternalformatSampleivNV_p.load(RELAX).is_null()
    }

    /// [glGetInternalformativ](http://docs.gl/es3/glGetInternalformativ)(target, internalformat, pname, count, params)
    /// `target` group: TextureTarget
    /// `internalformat` group: InternalFormat
    /// `pname` group: InternalFormatPName
    /// `params` len: count
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn glGetInternalformativ(
        target: GLenum,
        internalformat: GLenum,
        pname: GLenum,
        count: GLsizei,
        params: *mut GLint,
    ) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glGetInternalformativ({:#X}, {:#X}, {:#X}, {:?}, {:p});",
                target,
                internalformat,
                pname,
                count,
                params
            );
        }
        let out = call_atomic_ptr_5arg(
            "glGetInternalformativ",
            &glGetInternalformativ_p,
            target,
            internalformat,
            pname,
            count,
            params,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glGetInternalformativ");
        }
        out
    }
    static glGetInternalformativ_p: APcv = ap_None();
    /// Tries to load [`glGetInternalformativ`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    pub unsafe fn glGetInternalformativ_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glGetInternalformativ\0",
            &glGetInternalformativ_p,
        )
    }
    /// Checks if the pointer for [`glGetInternalformativ`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    pub fn glGetInternalformativ_is_loaded() -> bool {
        !glGetInternalformativ_p.load(RELAX).is_null()
    }

    /// [glGetMemoryObjectDetachedResourcesuivNV](http://docs.gl/es3/glGetMemoryObjectDetachedResourcesuivNV)(memory, pname, first, count, params)
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    #[cfg(any(feature = "GL_NV_memory_attachment"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_memory_attachment"))))]
    pub unsafe fn glGetMemoryObjectDetachedResourcesuivNV(
        memory: GLuint,
        pname: GLenum,
        first: GLint,
        count: GLsizei,
        params: *mut GLuint,
    ) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glGetMemoryObjectDetachedResourcesuivNV({:?}, {:#X}, {:?}, {:?}, {:p});",
                memory,
                pname,
                first,
                count,
                params
            );
        }
        let out = call_atomic_ptr_5arg(
            "glGetMemoryObjectDetachedResourcesuivNV",
            &glGetMemoryObjectDetachedResourcesuivNV_p,
            memory,
            pname,
            first,
            count,
            params,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glGetMemoryObjectDetachedResourcesuivNV");
        }
        out
    }
    #[cfg(any(feature = "GL_NV_memory_attachment"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_memory_attachment"))))]
    static glGetMemoryObjectDetachedResourcesuivNV_p: APcv = ap_None();
    /// Tries to load [`glGetMemoryObjectDetachedResourcesuivNV`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    #[cfg(any(feature = "GL_NV_memory_attachment"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_memory_attachment"))))]
    pub unsafe fn glGetMemoryObjectDetachedResourcesuivNV_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glGetMemoryObjectDetachedResourcesuivNV\0",
            &glGetMemoryObjectDetachedResourcesuivNV_p,
        )
    }
    /// Checks if the pointer for [`glGetMemoryObjectDetachedResourcesuivNV`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    #[cfg(any(feature = "GL_NV_memory_attachment"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_memory_attachment"))))]
    pub fn glGetMemoryObjectDetachedResourcesuivNV_is_loaded() -> bool {
        !glGetMemoryObjectDetachedResourcesuivNV_p
            .load(RELAX)
            .is_null()
    }

    /// [glGetMemoryObjectParameterivEXT](http://docs.gl/es3/glGetMemoryObjectParameterivEXT)(memoryObject, pname, params)
    /// `pname` group: MemoryObjectParameterName
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    #[cfg(any(feature = "GL_EXT_memory_object"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_memory_object"))))]
    pub unsafe fn glGetMemoryObjectParameterivEXT(
        memoryObject: GLuint,
        pname: GLenum,
        params: *mut GLint,
    ) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glGetMemoryObjectParameterivEXT({:?}, {:#X}, {:p});",
                memoryObject,
                pname,
                params
            );
        }
        let out = call_atomic_ptr_3arg(
            "glGetMemoryObjectParameterivEXT",
            &glGetMemoryObjectParameterivEXT_p,
            memoryObject,
            pname,
            params,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glGetMemoryObjectParameterivEXT");
        }
        out
    }
    #[cfg(any(feature = "GL_EXT_memory_object"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_memory_object"))))]
    static glGetMemoryObjectParameterivEXT_p: APcv = ap_None();
    /// Tries to load [`glGetMemoryObjectParameterivEXT`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    #[cfg(any(feature = "GL_EXT_memory_object"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_memory_object"))))]
    pub unsafe fn glGetMemoryObjectParameterivEXT_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glGetMemoryObjectParameterivEXT\0",
            &glGetMemoryObjectParameterivEXT_p,
        )
    }
    /// Checks if the pointer for [`glGetMemoryObjectParameterivEXT`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    #[cfg(any(feature = "GL_EXT_memory_object"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_memory_object"))))]
    pub fn glGetMemoryObjectParameterivEXT_is_loaded() -> bool {
        !glGetMemoryObjectParameterivEXT_p.load(RELAX).is_null()
    }

    /// [glGetMultisamplefv](http://docs.gl/es3/glGetMultisample)(pname, index, val)
    /// `pname` group: GetMultisamplePNameNV
    /// `val` len: COMPSIZE(pname)
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn glGetMultisamplefv(pname: GLenum, index: GLuint, val: *mut GLfloat) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glGetMultisamplefv({:#X}, {:?}, {:p});",
                pname,
                index,
                val
            );
        }
        let out = call_atomic_ptr_3arg(
            "glGetMultisamplefv",
            &glGetMultisamplefv_p,
            pname,
            index,
            val,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glGetMultisamplefv");
        }
        out
    }
    static glGetMultisamplefv_p: APcv = ap_None();
    /// Tries to load [`glGetMultisamplefv`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    pub unsafe fn glGetMultisamplefv_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glGetMultisamplefv\0",
            &glGetMultisamplefv_p,
        )
    }
    /// Checks if the pointer for [`glGetMultisamplefv`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    pub fn glGetMultisamplefv_is_loaded() -> bool {
        !glGetMultisamplefv_p.load(RELAX).is_null()
    }

    /// [glGetNextPerfQueryIdINTEL](http://docs.gl/es3/glGetNextPerfQueryIdINTEL)(queryId, nextQueryId)
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    #[cfg(any(feature = "GL_INTEL_performance_query"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_INTEL_performance_query"))))]
    pub unsafe fn glGetNextPerfQueryIdINTEL(queryId: GLuint, nextQueryId: *mut GLuint) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glGetNextPerfQueryIdINTEL({:?}, {:p});",
                queryId,
                nextQueryId
            );
        }
        let out = call_atomic_ptr_2arg(
            "glGetNextPerfQueryIdINTEL",
            &glGetNextPerfQueryIdINTEL_p,
            queryId,
            nextQueryId,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glGetNextPerfQueryIdINTEL");
        }
        out
    }
    #[cfg(any(feature = "GL_INTEL_performance_query"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_INTEL_performance_query"))))]
    static glGetNextPerfQueryIdINTEL_p: APcv = ap_None();
    /// Tries to load [`glGetNextPerfQueryIdINTEL`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    #[cfg(any(feature = "GL_INTEL_performance_query"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_INTEL_performance_query"))))]
    pub unsafe fn glGetNextPerfQueryIdINTEL_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glGetNextPerfQueryIdINTEL\0",
            &glGetNextPerfQueryIdINTEL_p,
        )
    }
    /// Checks if the pointer for [`glGetNextPerfQueryIdINTEL`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    #[cfg(any(feature = "GL_INTEL_performance_query"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_INTEL_performance_query"))))]
    pub fn glGetNextPerfQueryIdINTEL_is_loaded() -> bool {
        !glGetNextPerfQueryIdINTEL_p.load(RELAX).is_null()
    }

    /// [glGetObjectLabel](http://docs.gl/es3/glGetObjectLabel)(identifier, name, bufSize, length, label)
    /// `identifier` group: ObjectIdentifier
    /// `length` len: 1
    /// `label` len: bufSize
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn glGetObjectLabel(
        identifier: GLenum,
        name: GLuint,
        bufSize: GLsizei,
        length: *mut GLsizei,
        label: *mut GLchar,
    ) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glGetObjectLabel({:#X}, {:?}, {:?}, {:p}, {:p});",
                identifier,
                name,
                bufSize,
                length,
                label
            );
        }
        let out = call_atomic_ptr_5arg(
            "glGetObjectLabel",
            &glGetObjectLabel_p,
            identifier,
            name,
            bufSize,
            length,
            label,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glGetObjectLabel");
        }
        out
    }
    static glGetObjectLabel_p: APcv = ap_None();
    /// Tries to load [`glGetObjectLabel`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    pub unsafe fn glGetObjectLabel_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(get_proc_address, b"glGetObjectLabel\0", &glGetObjectLabel_p)
    }
    /// Checks if the pointer for [`glGetObjectLabel`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    pub fn glGetObjectLabel_is_loaded() -> bool {
        !glGetObjectLabel_p.load(RELAX).is_null()
    }

    /// [glGetObjectLabelEXT](http://docs.gl/es3/glGetObjectLabelEXT)(type_, object, bufSize, length, label)
    /// `length` len: 1
    /// `label` len: bufSize
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    #[cfg(any(feature = "GL_EXT_debug_label"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_debug_label"))))]
    pub unsafe fn glGetObjectLabelEXT(
        type_: GLenum,
        object: GLuint,
        bufSize: GLsizei,
        length: *mut GLsizei,
        label: *mut GLchar,
    ) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glGetObjectLabelEXT({:#X}, {:?}, {:?}, {:p}, {:p});",
                type_,
                object,
                bufSize,
                length,
                label
            );
        }
        let out = call_atomic_ptr_5arg(
            "glGetObjectLabelEXT",
            &glGetObjectLabelEXT_p,
            type_,
            object,
            bufSize,
            length,
            label,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glGetObjectLabelEXT");
        }
        out
    }
    #[cfg(any(feature = "GL_EXT_debug_label"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_debug_label"))))]
    static glGetObjectLabelEXT_p: APcv = ap_None();
    /// Tries to load [`glGetObjectLabelEXT`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    #[cfg(any(feature = "GL_EXT_debug_label"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_debug_label"))))]
    pub unsafe fn glGetObjectLabelEXT_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glGetObjectLabelEXT\0",
            &glGetObjectLabelEXT_p,
        )
    }
    /// Checks if the pointer for [`glGetObjectLabelEXT`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    #[cfg(any(feature = "GL_EXT_debug_label"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_debug_label"))))]
    pub fn glGetObjectLabelEXT_is_loaded() -> bool {
        !glGetObjectLabelEXT_p.load(RELAX).is_null()
    }

    /// [glGetObjectLabelKHR](http://docs.gl/es3/glGetObjectLabelKHR)(identifier, name, bufSize, length, label)
    /// `label` len: bufSize
    /// alias of: [`glGetObjectLabel`]
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    #[cfg(any(feature = "GL_KHR_debug"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_KHR_debug"))))]
    pub unsafe fn glGetObjectLabelKHR(
        identifier: GLenum,
        name: GLuint,
        bufSize: GLsizei,
        length: *mut GLsizei,
        label: *mut GLchar,
    ) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glGetObjectLabelKHR({:#X}, {:?}, {:?}, {:p}, {:p});",
                identifier,
                name,
                bufSize,
                length,
                label
            );
        }
        let out = call_atomic_ptr_5arg(
            "glGetObjectLabelKHR",
            &glGetObjectLabelKHR_p,
            identifier,
            name,
            bufSize,
            length,
            label,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glGetObjectLabelKHR");
        }
        out
    }
    #[cfg(any(feature = "GL_KHR_debug"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_KHR_debug"))))]
    static glGetObjectLabelKHR_p: APcv = ap_None();
    /// Tries to load [`glGetObjectLabelKHR`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    #[cfg(any(feature = "GL_KHR_debug"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_KHR_debug"))))]
    pub unsafe fn glGetObjectLabelKHR_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glGetObjectLabelKHR\0",
            &glGetObjectLabelKHR_p,
        )
    }
    /// Checks if the pointer for [`glGetObjectLabelKHR`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    #[cfg(any(feature = "GL_KHR_debug"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_KHR_debug"))))]
    pub fn glGetObjectLabelKHR_is_loaded() -> bool {
        !glGetObjectLabelKHR_p.load(RELAX).is_null()
    }

    /// [glGetObjectPtrLabel](http://docs.gl/es3/glGetObjectPtrLabel)(ptr, bufSize, length, label)
    /// `length` len: 1
    /// `label` len: bufSize
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn glGetObjectPtrLabel(
        ptr: *const c_void,
        bufSize: GLsizei,
        length: *mut GLsizei,
        label: *mut GLchar,
    ) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glGetObjectPtrLabel({:p}, {:?}, {:p}, {:p});",
                ptr,
                bufSize,
                length,
                label
            );
        }
        let out = call_atomic_ptr_4arg(
            "glGetObjectPtrLabel",
            &glGetObjectPtrLabel_p,
            ptr,
            bufSize,
            length,
            label,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glGetObjectPtrLabel");
        }
        out
    }
    static glGetObjectPtrLabel_p: APcv = ap_None();
    /// Tries to load [`glGetObjectPtrLabel`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    pub unsafe fn glGetObjectPtrLabel_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glGetObjectPtrLabel\0",
            &glGetObjectPtrLabel_p,
        )
    }
    /// Checks if the pointer for [`glGetObjectPtrLabel`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    pub fn glGetObjectPtrLabel_is_loaded() -> bool {
        !glGetObjectPtrLabel_p.load(RELAX).is_null()
    }

    /// [glGetObjectPtrLabelKHR](http://docs.gl/es3/glGetObjectPtrLabelKHR)(ptr, bufSize, length, label)
    /// `length` len: 1
    /// `label` len: bufSize
    /// alias of: [`glGetObjectPtrLabel`]
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    #[cfg(any(feature = "GL_KHR_debug"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_KHR_debug"))))]
    pub unsafe fn glGetObjectPtrLabelKHR(
        ptr: *const c_void,
        bufSize: GLsizei,
        length: *mut GLsizei,
        label: *mut GLchar,
    ) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glGetObjectPtrLabelKHR({:p}, {:?}, {:p}, {:p});",
                ptr,
                bufSize,
                length,
                label
            );
        }
        let out = call_atomic_ptr_4arg(
            "glGetObjectPtrLabelKHR",
            &glGetObjectPtrLabelKHR_p,
            ptr,
            bufSize,
            length,
            label,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glGetObjectPtrLabelKHR");
        }
        out
    }
    #[cfg(any(feature = "GL_KHR_debug"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_KHR_debug"))))]
    static glGetObjectPtrLabelKHR_p: APcv = ap_None();
    /// Tries to load [`glGetObjectPtrLabelKHR`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    #[cfg(any(feature = "GL_KHR_debug"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_KHR_debug"))))]
    pub unsafe fn glGetObjectPtrLabelKHR_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glGetObjectPtrLabelKHR\0",
            &glGetObjectPtrLabelKHR_p,
        )
    }
    /// Checks if the pointer for [`glGetObjectPtrLabelKHR`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    #[cfg(any(feature = "GL_KHR_debug"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_KHR_debug"))))]
    pub fn glGetObjectPtrLabelKHR_is_loaded() -> bool {
        !glGetObjectPtrLabelKHR_p.load(RELAX).is_null()
    }

    /// [glGetPathCommandsNV](http://docs.gl/es3/glGetPathCommandsNV)(path, commands)
    /// `path` group: Path
    /// `commands` group: PathCommand
    /// `commands` len: COMPSIZE(path)
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    #[cfg(any(feature = "GL_NV_path_rendering"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_path_rendering"))))]
    pub unsafe fn glGetPathCommandsNV(path: GLuint, commands: *mut GLubyte) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!("calling glGetPathCommandsNV({:?}, {:p});", path, commands);
        }
        let out = call_atomic_ptr_2arg(
            "glGetPathCommandsNV",
            &glGetPathCommandsNV_p,
            path,
            commands,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glGetPathCommandsNV");
        }
        out
    }
    #[cfg(any(feature = "GL_NV_path_rendering"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_path_rendering"))))]
    static glGetPathCommandsNV_p: APcv = ap_None();
    /// Tries to load [`glGetPathCommandsNV`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    #[cfg(any(feature = "GL_NV_path_rendering"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_path_rendering"))))]
    pub unsafe fn glGetPathCommandsNV_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glGetPathCommandsNV\0",
            &glGetPathCommandsNV_p,
        )
    }
    /// Checks if the pointer for [`glGetPathCommandsNV`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    #[cfg(any(feature = "GL_NV_path_rendering"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_path_rendering"))))]
    pub fn glGetPathCommandsNV_is_loaded() -> bool {
        !glGetPathCommandsNV_p.load(RELAX).is_null()
    }

    /// [glGetPathCoordsNV](http://docs.gl/es3/glGetPathCoordsNV)(path, coords)
    /// `path` group: Path
    /// `coords` len: COMPSIZE(path)
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    #[cfg(any(feature = "GL_NV_path_rendering"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_path_rendering"))))]
    pub unsafe fn glGetPathCoordsNV(path: GLuint, coords: *mut GLfloat) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!("calling glGetPathCoordsNV({:?}, {:p});", path, coords);
        }
        let out = call_atomic_ptr_2arg("glGetPathCoordsNV", &glGetPathCoordsNV_p, path, coords);
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glGetPathCoordsNV");
        }
        out
    }
    #[cfg(any(feature = "GL_NV_path_rendering"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_path_rendering"))))]
    static glGetPathCoordsNV_p: APcv = ap_None();
    /// Tries to load [`glGetPathCoordsNV`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    #[cfg(any(feature = "GL_NV_path_rendering"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_path_rendering"))))]
    pub unsafe fn glGetPathCoordsNV_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glGetPathCoordsNV\0",
            &glGetPathCoordsNV_p,
        )
    }
    /// Checks if the pointer for [`glGetPathCoordsNV`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    #[cfg(any(feature = "GL_NV_path_rendering"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_path_rendering"))))]
    pub fn glGetPathCoordsNV_is_loaded() -> bool {
        !glGetPathCoordsNV_p.load(RELAX).is_null()
    }

    /// [glGetPathDashArrayNV](http://docs.gl/es3/glGetPathDashArrayNV)(path, dashArray)
    /// `path` group: Path
    /// `dashArray` len: COMPSIZE(path)
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    #[cfg(any(feature = "GL_NV_path_rendering"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_path_rendering"))))]
    pub unsafe fn glGetPathDashArrayNV(path: GLuint, dashArray: *mut GLfloat) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!("calling glGetPathDashArrayNV({:?}, {:p});", path, dashArray);
        }
        let out = call_atomic_ptr_2arg(
            "glGetPathDashArrayNV",
            &glGetPathDashArrayNV_p,
            path,
            dashArray,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glGetPathDashArrayNV");
        }
        out
    }
    #[cfg(any(feature = "GL_NV_path_rendering"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_path_rendering"))))]
    static glGetPathDashArrayNV_p: APcv = ap_None();
    /// Tries to load [`glGetPathDashArrayNV`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    #[cfg(any(feature = "GL_NV_path_rendering"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_path_rendering"))))]
    pub unsafe fn glGetPathDashArrayNV_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glGetPathDashArrayNV\0",
            &glGetPathDashArrayNV_p,
        )
    }
    /// Checks if the pointer for [`glGetPathDashArrayNV`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    #[cfg(any(feature = "GL_NV_path_rendering"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_path_rendering"))))]
    pub fn glGetPathDashArrayNV_is_loaded() -> bool {
        !glGetPathDashArrayNV_p.load(RELAX).is_null()
    }

    /// [glGetPathLengthNV](http://docs.gl/es3/glGetPathLengthNV)(path, startSegment, numSegments)
    /// `path` group: Path
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    #[cfg(any(feature = "GL_NV_path_rendering"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_path_rendering"))))]
    pub unsafe fn glGetPathLengthNV(
        path: GLuint,
        startSegment: GLsizei,
        numSegments: GLsizei,
    ) -> GLfloat {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glGetPathLengthNV({:?}, {:?}, {:?});",
                path,
                startSegment,
                numSegments
            );
        }
        let out = call_atomic_ptr_3arg(
            "glGetPathLengthNV",
            &glGetPathLengthNV_p,
            path,
            startSegment,
            numSegments,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glGetPathLengthNV");
        }
        out
    }
    #[cfg(any(feature = "GL_NV_path_rendering"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_path_rendering"))))]
    static glGetPathLengthNV_p: APcv = ap_None();
    /// Tries to load [`glGetPathLengthNV`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    #[cfg(any(feature = "GL_NV_path_rendering"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_path_rendering"))))]
    pub unsafe fn glGetPathLengthNV_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glGetPathLengthNV\0",
            &glGetPathLengthNV_p,
        )
    }
    /// Checks if the pointer for [`glGetPathLengthNV`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    #[cfg(any(feature = "GL_NV_path_rendering"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_path_rendering"))))]
    pub fn glGetPathLengthNV_is_loaded() -> bool {
        !glGetPathLengthNV_p.load(RELAX).is_null()
    }

    /// [glGetPathMetricRangeNV](http://docs.gl/es3/glGetPathMetricRangeNV)(metricQueryMask, firstPathName, numPaths, stride, metrics)
    /// `metricQueryMask` group: PathMetricMask
    /// `firstPathName` group: Path
    /// `metrics` len: COMPSIZE(metricQueryMask,numPaths,stride)
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    #[cfg(any(feature = "GL_NV_path_rendering"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_path_rendering"))))]
    pub unsafe fn glGetPathMetricRangeNV(
        metricQueryMask: GLbitfield,
        firstPathName: GLuint,
        numPaths: GLsizei,
        stride: GLsizei,
        metrics: *mut GLfloat,
    ) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glGetPathMetricRangeNV({:?}, {:?}, {:?}, {:?}, {:p});",
                metricQueryMask,
                firstPathName,
                numPaths,
                stride,
                metrics
            );
        }
        let out = call_atomic_ptr_5arg(
            "glGetPathMetricRangeNV",
            &glGetPathMetricRangeNV_p,
            metricQueryMask,
            firstPathName,
            numPaths,
            stride,
            metrics,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glGetPathMetricRangeNV");
        }
        out
    }
    #[cfg(any(feature = "GL_NV_path_rendering"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_path_rendering"))))]
    static glGetPathMetricRangeNV_p: APcv = ap_None();
    /// Tries to load [`glGetPathMetricRangeNV`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    #[cfg(any(feature = "GL_NV_path_rendering"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_path_rendering"))))]
    pub unsafe fn glGetPathMetricRangeNV_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glGetPathMetricRangeNV\0",
            &glGetPathMetricRangeNV_p,
        )
    }
    /// Checks if the pointer for [`glGetPathMetricRangeNV`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    #[cfg(any(feature = "GL_NV_path_rendering"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_path_rendering"))))]
    pub fn glGetPathMetricRangeNV_is_loaded() -> bool {
        !glGetPathMetricRangeNV_p.load(RELAX).is_null()
    }

    /// [glGetPathMetricsNV](http://docs.gl/es3/glGetPathMetricsNV)(metricQueryMask, numPaths, pathNameType, paths, pathBase, stride, metrics)
    /// `metricQueryMask` group: PathMetricMask
    /// `pathNameType` group: PathElementType
    /// `paths` group: PathElement
    /// `paths` len: COMPSIZE(numPaths,pathNameType,paths)
    /// `pathBase` group: Path
    /// `metrics` len: COMPSIZE(metricQueryMask,numPaths,stride)
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    #[cfg(any(feature = "GL_NV_path_rendering"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_path_rendering"))))]
    pub unsafe fn glGetPathMetricsNV(
        metricQueryMask: GLbitfield,
        numPaths: GLsizei,
        pathNameType: GLenum,
        paths: *const c_void,
        pathBase: GLuint,
        stride: GLsizei,
        metrics: *mut GLfloat,
    ) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glGetPathMetricsNV({:?}, {:?}, {:#X}, {:p}, {:?}, {:?}, {:p});",
                metricQueryMask,
                numPaths,
                pathNameType,
                paths,
                pathBase,
                stride,
                metrics
            );
        }
        let out = call_atomic_ptr_7arg(
            "glGetPathMetricsNV",
            &glGetPathMetricsNV_p,
            metricQueryMask,
            numPaths,
            pathNameType,
            paths,
            pathBase,
            stride,
            metrics,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glGetPathMetricsNV");
        }
        out
    }
    #[cfg(any(feature = "GL_NV_path_rendering"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_path_rendering"))))]
    static glGetPathMetricsNV_p: APcv = ap_None();
    /// Tries to load [`glGetPathMetricsNV`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    #[cfg(any(feature = "GL_NV_path_rendering"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_path_rendering"))))]
    pub unsafe fn glGetPathMetricsNV_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glGetPathMetricsNV\0",
            &glGetPathMetricsNV_p,
        )
    }
    /// Checks if the pointer for [`glGetPathMetricsNV`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    #[cfg(any(feature = "GL_NV_path_rendering"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_path_rendering"))))]
    pub fn glGetPathMetricsNV_is_loaded() -> bool {
        !glGetPathMetricsNV_p.load(RELAX).is_null()
    }

    /// [glGetPathParameterfvNV](http://docs.gl/es3/glGetPathParameterfvNV)(path, pname, value)
    /// `path` group: Path
    /// `pname` group: PathParameter
    /// `value` len: 4
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    #[cfg(any(feature = "GL_NV_path_rendering"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_path_rendering"))))]
    pub unsafe fn glGetPathParameterfvNV(path: GLuint, pname: GLenum, value: *mut GLfloat) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glGetPathParameterfvNV({:?}, {:#X}, {:p});",
                path,
                pname,
                value
            );
        }
        let out = call_atomic_ptr_3arg(
            "glGetPathParameterfvNV",
            &glGetPathParameterfvNV_p,
            path,
            pname,
            value,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glGetPathParameterfvNV");
        }
        out
    }
    #[cfg(any(feature = "GL_NV_path_rendering"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_path_rendering"))))]
    static glGetPathParameterfvNV_p: APcv = ap_None();
    /// Tries to load [`glGetPathParameterfvNV`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    #[cfg(any(feature = "GL_NV_path_rendering"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_path_rendering"))))]
    pub unsafe fn glGetPathParameterfvNV_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glGetPathParameterfvNV\0",
            &glGetPathParameterfvNV_p,
        )
    }
    /// Checks if the pointer for [`glGetPathParameterfvNV`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    #[cfg(any(feature = "GL_NV_path_rendering"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_path_rendering"))))]
    pub fn glGetPathParameterfvNV_is_loaded() -> bool {
        !glGetPathParameterfvNV_p.load(RELAX).is_null()
    }

    /// [glGetPathParameterivNV](http://docs.gl/es3/glGetPathParameterivNV)(path, pname, value)
    /// `path` group: Path
    /// `pname` group: PathParameter
    /// `value` len: 4
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    #[cfg(any(feature = "GL_NV_path_rendering"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_path_rendering"))))]
    pub unsafe fn glGetPathParameterivNV(path: GLuint, pname: GLenum, value: *mut GLint) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glGetPathParameterivNV({:?}, {:#X}, {:p});",
                path,
                pname,
                value
            );
        }
        let out = call_atomic_ptr_3arg(
            "glGetPathParameterivNV",
            &glGetPathParameterivNV_p,
            path,
            pname,
            value,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glGetPathParameterivNV");
        }
        out
    }
    #[cfg(any(feature = "GL_NV_path_rendering"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_path_rendering"))))]
    static glGetPathParameterivNV_p: APcv = ap_None();
    /// Tries to load [`glGetPathParameterivNV`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    #[cfg(any(feature = "GL_NV_path_rendering"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_path_rendering"))))]
    pub unsafe fn glGetPathParameterivNV_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glGetPathParameterivNV\0",
            &glGetPathParameterivNV_p,
        )
    }
    /// Checks if the pointer for [`glGetPathParameterivNV`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    #[cfg(any(feature = "GL_NV_path_rendering"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_path_rendering"))))]
    pub fn glGetPathParameterivNV_is_loaded() -> bool {
        !glGetPathParameterivNV_p.load(RELAX).is_null()
    }

    /// [glGetPathSpacingNV](http://docs.gl/es3/glGetPathSpacingNV)(pathListMode, numPaths, pathNameType, paths, pathBase, advanceScale, kerningScale, transformType, returnedSpacing)
    /// `pathListMode` group: PathListMode
    /// `pathNameType` group: PathElementType
    /// `paths` group: PathElement
    /// `paths` len: COMPSIZE(numPaths,pathNameType,paths)
    /// `pathBase` group: Path
    /// `transformType` group: PathTransformType
    /// `returnedSpacing` len: COMPSIZE(pathListMode,numPaths)
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    #[cfg(any(feature = "GL_NV_path_rendering"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_path_rendering"))))]
    pub unsafe fn glGetPathSpacingNV(
        pathListMode: GLenum,
        numPaths: GLsizei,
        pathNameType: GLenum,
        paths: *const c_void,
        pathBase: GLuint,
        advanceScale: GLfloat,
        kerningScale: GLfloat,
        transformType: GLenum,
        returnedSpacing: *mut GLfloat,
    ) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glGetPathSpacingNV({:#X}, {:?}, {:#X}, {:p}, {:?}, {:?}, {:?}, {:#X}, {:p});",
                pathListMode,
                numPaths,
                pathNameType,
                paths,
                pathBase,
                advanceScale,
                kerningScale,
                transformType,
                returnedSpacing
            );
        }
        let out = call_atomic_ptr_9arg(
            "glGetPathSpacingNV",
            &glGetPathSpacingNV_p,
            pathListMode,
            numPaths,
            pathNameType,
            paths,
            pathBase,
            advanceScale,
            kerningScale,
            transformType,
            returnedSpacing,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glGetPathSpacingNV");
        }
        out
    }
    #[cfg(any(feature = "GL_NV_path_rendering"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_path_rendering"))))]
    static glGetPathSpacingNV_p: APcv = ap_None();
    /// Tries to load [`glGetPathSpacingNV`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    #[cfg(any(feature = "GL_NV_path_rendering"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_path_rendering"))))]
    pub unsafe fn glGetPathSpacingNV_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glGetPathSpacingNV\0",
            &glGetPathSpacingNV_p,
        )
    }
    /// Checks if the pointer for [`glGetPathSpacingNV`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    #[cfg(any(feature = "GL_NV_path_rendering"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_path_rendering"))))]
    pub fn glGetPathSpacingNV_is_loaded() -> bool {
        !glGetPathSpacingNV_p.load(RELAX).is_null()
    }

    /// [glGetPerfCounterInfoINTEL](http://docs.gl/es3/glGetPerfCounterInfoINTEL)(queryId, counterId, counterNameLength, counterName, counterDescLength, counterDesc, counterOffset, counterDataSize, counterTypeEnum, counterDataTypeEnum, rawCounterMaxValue)
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    #[cfg(any(feature = "GL_INTEL_performance_query"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_INTEL_performance_query"))))]
    pub unsafe fn glGetPerfCounterInfoINTEL(
        queryId: GLuint,
        counterId: GLuint,
        counterNameLength: GLuint,
        counterName: *mut GLchar,
        counterDescLength: GLuint,
        counterDesc: *mut GLchar,
        counterOffset: *mut GLuint,
        counterDataSize: *mut GLuint,
        counterTypeEnum: *mut GLuint,
        counterDataTypeEnum: *mut GLuint,
        rawCounterMaxValue: *mut GLuint64,
    ) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glGetPerfCounterInfoINTEL({:?}, {:?}, {:?}, {:p}, {:?}, {:p}, {:p}, {:p}, {:p}, {:p}, {:p});",
                queryId,
                counterId,
                counterNameLength,
                counterName,
                counterDescLength,
                counterDesc,
                counterOffset,
                counterDataSize,
                counterTypeEnum,
                counterDataTypeEnum,
                rawCounterMaxValue
            );
        }
        let out = call_atomic_ptr_11arg(
            "glGetPerfCounterInfoINTEL",
            &glGetPerfCounterInfoINTEL_p,
            queryId,
            counterId,
            counterNameLength,
            counterName,
            counterDescLength,
            counterDesc,
            counterOffset,
            counterDataSize,
            counterTypeEnum,
            counterDataTypeEnum,
            rawCounterMaxValue,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glGetPerfCounterInfoINTEL");
        }
        out
    }
    #[cfg(any(feature = "GL_INTEL_performance_query"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_INTEL_performance_query"))))]
    static glGetPerfCounterInfoINTEL_p: APcv = ap_None();
    /// Tries to load [`glGetPerfCounterInfoINTEL`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    #[cfg(any(feature = "GL_INTEL_performance_query"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_INTEL_performance_query"))))]
    pub unsafe fn glGetPerfCounterInfoINTEL_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glGetPerfCounterInfoINTEL\0",
            &glGetPerfCounterInfoINTEL_p,
        )
    }
    /// Checks if the pointer for [`glGetPerfCounterInfoINTEL`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    #[cfg(any(feature = "GL_INTEL_performance_query"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_INTEL_performance_query"))))]
    pub fn glGetPerfCounterInfoINTEL_is_loaded() -> bool {
        !glGetPerfCounterInfoINTEL_p.load(RELAX).is_null()
    }

    /// [glGetPerfMonitorCounterDataAMD](http://docs.gl/es3/glGetPerfMonitorCounterDataAMD)(monitor, pname, dataSize, data, bytesWritten)
    /// `data` len: dataSize / 4
    /// `bytesWritten` len: 1
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    #[cfg(any(feature = "GL_AMD_performance_monitor"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_AMD_performance_monitor"))))]
    pub unsafe fn glGetPerfMonitorCounterDataAMD(
        monitor: GLuint,
        pname: GLenum,
        dataSize: GLsizei,
        data: *mut GLuint,
        bytesWritten: *mut GLint,
    ) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glGetPerfMonitorCounterDataAMD({:?}, {:#X}, {:?}, {:p}, {:p});",
                monitor,
                pname,
                dataSize,
                data,
                bytesWritten
            );
        }
        let out = call_atomic_ptr_5arg(
            "glGetPerfMonitorCounterDataAMD",
            &glGetPerfMonitorCounterDataAMD_p,
            monitor,
            pname,
            dataSize,
            data,
            bytesWritten,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glGetPerfMonitorCounterDataAMD");
        }
        out
    }
    #[cfg(any(feature = "GL_AMD_performance_monitor"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_AMD_performance_monitor"))))]
    static glGetPerfMonitorCounterDataAMD_p: APcv = ap_None();
    /// Tries to load [`glGetPerfMonitorCounterDataAMD`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    #[cfg(any(feature = "GL_AMD_performance_monitor"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_AMD_performance_monitor"))))]
    pub unsafe fn glGetPerfMonitorCounterDataAMD_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glGetPerfMonitorCounterDataAMD\0",
            &glGetPerfMonitorCounterDataAMD_p,
        )
    }
    /// Checks if the pointer for [`glGetPerfMonitorCounterDataAMD`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    #[cfg(any(feature = "GL_AMD_performance_monitor"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_AMD_performance_monitor"))))]
    pub fn glGetPerfMonitorCounterDataAMD_is_loaded() -> bool {
        !glGetPerfMonitorCounterDataAMD_p.load(RELAX).is_null()
    }

    /// [glGetPerfMonitorCounterInfoAMD](http://docs.gl/es3/glGetPerfMonitorCounterInfoAMD)(group, counter, pname, data)
    /// `data` len: COMPSIZE(pname)
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    #[cfg(any(feature = "GL_AMD_performance_monitor"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_AMD_performance_monitor"))))]
    pub unsafe fn glGetPerfMonitorCounterInfoAMD(
        group: GLuint,
        counter: GLuint,
        pname: GLenum,
        data: *mut c_void,
    ) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glGetPerfMonitorCounterInfoAMD({:?}, {:?}, {:#X}, {:p});",
                group,
                counter,
                pname,
                data
            );
        }
        let out = call_atomic_ptr_4arg(
            "glGetPerfMonitorCounterInfoAMD",
            &glGetPerfMonitorCounterInfoAMD_p,
            group,
            counter,
            pname,
            data,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glGetPerfMonitorCounterInfoAMD");
        }
        out
    }
    #[cfg(any(feature = "GL_AMD_performance_monitor"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_AMD_performance_monitor"))))]
    static glGetPerfMonitorCounterInfoAMD_p: APcv = ap_None();
    /// Tries to load [`glGetPerfMonitorCounterInfoAMD`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    #[cfg(any(feature = "GL_AMD_performance_monitor"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_AMD_performance_monitor"))))]
    pub unsafe fn glGetPerfMonitorCounterInfoAMD_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glGetPerfMonitorCounterInfoAMD\0",
            &glGetPerfMonitorCounterInfoAMD_p,
        )
    }
    /// Checks if the pointer for [`glGetPerfMonitorCounterInfoAMD`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    #[cfg(any(feature = "GL_AMD_performance_monitor"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_AMD_performance_monitor"))))]
    pub fn glGetPerfMonitorCounterInfoAMD_is_loaded() -> bool {
        !glGetPerfMonitorCounterInfoAMD_p.load(RELAX).is_null()
    }

    /// [glGetPerfMonitorCounterStringAMD](http://docs.gl/es3/glGetPerfMonitorCounterStringAMD)(group, counter, bufSize, length, counterString)
    /// `length` len: 1
    /// `counterString` len: bufSize
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    #[cfg(any(feature = "GL_AMD_performance_monitor"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_AMD_performance_monitor"))))]
    pub unsafe fn glGetPerfMonitorCounterStringAMD(
        group: GLuint,
        counter: GLuint,
        bufSize: GLsizei,
        length: *mut GLsizei,
        counterString: *mut GLchar,
    ) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glGetPerfMonitorCounterStringAMD({:?}, {:?}, {:?}, {:p}, {:p});",
                group,
                counter,
                bufSize,
                length,
                counterString
            );
        }
        let out = call_atomic_ptr_5arg(
            "glGetPerfMonitorCounterStringAMD",
            &glGetPerfMonitorCounterStringAMD_p,
            group,
            counter,
            bufSize,
            length,
            counterString,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glGetPerfMonitorCounterStringAMD");
        }
        out
    }
    #[cfg(any(feature = "GL_AMD_performance_monitor"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_AMD_performance_monitor"))))]
    static glGetPerfMonitorCounterStringAMD_p: APcv = ap_None();
    /// Tries to load [`glGetPerfMonitorCounterStringAMD`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    #[cfg(any(feature = "GL_AMD_performance_monitor"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_AMD_performance_monitor"))))]
    pub unsafe fn glGetPerfMonitorCounterStringAMD_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glGetPerfMonitorCounterStringAMD\0",
            &glGetPerfMonitorCounterStringAMD_p,
        )
    }
    /// Checks if the pointer for [`glGetPerfMonitorCounterStringAMD`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    #[cfg(any(feature = "GL_AMD_performance_monitor"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_AMD_performance_monitor"))))]
    pub fn glGetPerfMonitorCounterStringAMD_is_loaded() -> bool {
        !glGetPerfMonitorCounterStringAMD_p.load(RELAX).is_null()
    }

    /// [glGetPerfMonitorCountersAMD](http://docs.gl/es3/glGetPerfMonitorCountersAMD)(group, numCounters, maxActiveCounters, counterSize, counters)
    /// `numCounters` len: 1
    /// `maxActiveCounters` len: 1
    /// `counters` len: counterSize
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    #[cfg(any(feature = "GL_AMD_performance_monitor"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_AMD_performance_monitor"))))]
    pub unsafe fn glGetPerfMonitorCountersAMD(
        group: GLuint,
        numCounters: *mut GLint,
        maxActiveCounters: *mut GLint,
        counterSize: GLsizei,
        counters: *mut GLuint,
    ) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glGetPerfMonitorCountersAMD({:?}, {:p}, {:p}, {:?}, {:p});",
                group,
                numCounters,
                maxActiveCounters,
                counterSize,
                counters
            );
        }
        let out = call_atomic_ptr_5arg(
            "glGetPerfMonitorCountersAMD",
            &glGetPerfMonitorCountersAMD_p,
            group,
            numCounters,
            maxActiveCounters,
            counterSize,
            counters,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glGetPerfMonitorCountersAMD");
        }
        out
    }
    #[cfg(any(feature = "GL_AMD_performance_monitor"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_AMD_performance_monitor"))))]
    static glGetPerfMonitorCountersAMD_p: APcv = ap_None();
    /// Tries to load [`glGetPerfMonitorCountersAMD`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    #[cfg(any(feature = "GL_AMD_performance_monitor"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_AMD_performance_monitor"))))]
    pub unsafe fn glGetPerfMonitorCountersAMD_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glGetPerfMonitorCountersAMD\0",
            &glGetPerfMonitorCountersAMD_p,
        )
    }
    /// Checks if the pointer for [`glGetPerfMonitorCountersAMD`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    #[cfg(any(feature = "GL_AMD_performance_monitor"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_AMD_performance_monitor"))))]
    pub fn glGetPerfMonitorCountersAMD_is_loaded() -> bool {
        !glGetPerfMonitorCountersAMD_p.load(RELAX).is_null()
    }

    /// [glGetPerfMonitorGroupStringAMD](http://docs.gl/es3/glGetPerfMonitorGroupStringAMD)(group, bufSize, length, groupString)
    /// `length` len: 1
    /// `groupString` len: bufSize
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    #[cfg(any(feature = "GL_AMD_performance_monitor"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_AMD_performance_monitor"))))]
    pub unsafe fn glGetPerfMonitorGroupStringAMD(
        group: GLuint,
        bufSize: GLsizei,
        length: *mut GLsizei,
        groupString: *mut GLchar,
    ) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glGetPerfMonitorGroupStringAMD({:?}, {:?}, {:p}, {:p});",
                group,
                bufSize,
                length,
                groupString
            );
        }
        let out = call_atomic_ptr_4arg(
            "glGetPerfMonitorGroupStringAMD",
            &glGetPerfMonitorGroupStringAMD_p,
            group,
            bufSize,
            length,
            groupString,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glGetPerfMonitorGroupStringAMD");
        }
        out
    }
    #[cfg(any(feature = "GL_AMD_performance_monitor"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_AMD_performance_monitor"))))]
    static glGetPerfMonitorGroupStringAMD_p: APcv = ap_None();
    /// Tries to load [`glGetPerfMonitorGroupStringAMD`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    #[cfg(any(feature = "GL_AMD_performance_monitor"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_AMD_performance_monitor"))))]
    pub unsafe fn glGetPerfMonitorGroupStringAMD_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glGetPerfMonitorGroupStringAMD\0",
            &glGetPerfMonitorGroupStringAMD_p,
        )
    }
    /// Checks if the pointer for [`glGetPerfMonitorGroupStringAMD`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    #[cfg(any(feature = "GL_AMD_performance_monitor"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_AMD_performance_monitor"))))]
    pub fn glGetPerfMonitorGroupStringAMD_is_loaded() -> bool {
        !glGetPerfMonitorGroupStringAMD_p.load(RELAX).is_null()
    }

    /// [glGetPerfMonitorGroupsAMD](http://docs.gl/es3/glGetPerfMonitorGroupsAMD)(numGroups, groupsSize, groups)
    /// `numGroups` len: 1
    /// `groups` len: groupsSize
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    #[cfg(any(feature = "GL_AMD_performance_monitor"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_AMD_performance_monitor"))))]
    pub unsafe fn glGetPerfMonitorGroupsAMD(
        numGroups: *mut GLint,
        groupsSize: GLsizei,
        groups: *mut GLuint,
    ) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glGetPerfMonitorGroupsAMD({:p}, {:?}, {:p});",
                numGroups,
                groupsSize,
                groups
            );
        }
        let out = call_atomic_ptr_3arg(
            "glGetPerfMonitorGroupsAMD",
            &glGetPerfMonitorGroupsAMD_p,
            numGroups,
            groupsSize,
            groups,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glGetPerfMonitorGroupsAMD");
        }
        out
    }
    #[cfg(any(feature = "GL_AMD_performance_monitor"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_AMD_performance_monitor"))))]
    static glGetPerfMonitorGroupsAMD_p: APcv = ap_None();
    /// Tries to load [`glGetPerfMonitorGroupsAMD`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    #[cfg(any(feature = "GL_AMD_performance_monitor"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_AMD_performance_monitor"))))]
    pub unsafe fn glGetPerfMonitorGroupsAMD_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glGetPerfMonitorGroupsAMD\0",
            &glGetPerfMonitorGroupsAMD_p,
        )
    }
    /// Checks if the pointer for [`glGetPerfMonitorGroupsAMD`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    #[cfg(any(feature = "GL_AMD_performance_monitor"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_AMD_performance_monitor"))))]
    pub fn glGetPerfMonitorGroupsAMD_is_loaded() -> bool {
        !glGetPerfMonitorGroupsAMD_p.load(RELAX).is_null()
    }

    /// [glGetPerfQueryDataINTEL](http://docs.gl/es3/glGetPerfQueryDataINTEL)(queryHandle, flags, dataSize, data, bytesWritten)
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    #[cfg(any(feature = "GL_INTEL_performance_query"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_INTEL_performance_query"))))]
    pub unsafe fn glGetPerfQueryDataINTEL(
        queryHandle: GLuint,
        flags: GLuint,
        dataSize: GLsizei,
        data: *mut c_void,
        bytesWritten: *mut GLuint,
    ) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glGetPerfQueryDataINTEL({:?}, {:?}, {:?}, {:p}, {:p});",
                queryHandle,
                flags,
                dataSize,
                data,
                bytesWritten
            );
        }
        let out = call_atomic_ptr_5arg(
            "glGetPerfQueryDataINTEL",
            &glGetPerfQueryDataINTEL_p,
            queryHandle,
            flags,
            dataSize,
            data,
            bytesWritten,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glGetPerfQueryDataINTEL");
        }
        out
    }
    #[cfg(any(feature = "GL_INTEL_performance_query"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_INTEL_performance_query"))))]
    static glGetPerfQueryDataINTEL_p: APcv = ap_None();
    /// Tries to load [`glGetPerfQueryDataINTEL`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    #[cfg(any(feature = "GL_INTEL_performance_query"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_INTEL_performance_query"))))]
    pub unsafe fn glGetPerfQueryDataINTEL_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glGetPerfQueryDataINTEL\0",
            &glGetPerfQueryDataINTEL_p,
        )
    }
    /// Checks if the pointer for [`glGetPerfQueryDataINTEL`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    #[cfg(any(feature = "GL_INTEL_performance_query"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_INTEL_performance_query"))))]
    pub fn glGetPerfQueryDataINTEL_is_loaded() -> bool {
        !glGetPerfQueryDataINTEL_p.load(RELAX).is_null()
    }

    /// [glGetPerfQueryIdByNameINTEL](http://docs.gl/es3/glGetPerfQueryIdByNameINTEL)(queryName, queryId)
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    #[cfg(any(feature = "GL_INTEL_performance_query"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_INTEL_performance_query"))))]
    pub unsafe fn glGetPerfQueryIdByNameINTEL(queryName: *mut GLchar, queryId: *mut GLuint) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glGetPerfQueryIdByNameINTEL({:p}, {:p});",
                queryName,
                queryId
            );
        }
        let out = call_atomic_ptr_2arg(
            "glGetPerfQueryIdByNameINTEL",
            &glGetPerfQueryIdByNameINTEL_p,
            queryName,
            queryId,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glGetPerfQueryIdByNameINTEL");
        }
        out
    }
    #[cfg(any(feature = "GL_INTEL_performance_query"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_INTEL_performance_query"))))]
    static glGetPerfQueryIdByNameINTEL_p: APcv = ap_None();
    /// Tries to load [`glGetPerfQueryIdByNameINTEL`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    #[cfg(any(feature = "GL_INTEL_performance_query"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_INTEL_performance_query"))))]
    pub unsafe fn glGetPerfQueryIdByNameINTEL_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glGetPerfQueryIdByNameINTEL\0",
            &glGetPerfQueryIdByNameINTEL_p,
        )
    }
    /// Checks if the pointer for [`glGetPerfQueryIdByNameINTEL`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    #[cfg(any(feature = "GL_INTEL_performance_query"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_INTEL_performance_query"))))]
    pub fn glGetPerfQueryIdByNameINTEL_is_loaded() -> bool {
        !glGetPerfQueryIdByNameINTEL_p.load(RELAX).is_null()
    }

    /// [glGetPerfQueryInfoINTEL](http://docs.gl/es3/glGetPerfQueryInfoINTEL)(queryId, queryNameLength, queryName, dataSize, noCounters, noInstances, capsMask)
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    #[cfg(any(feature = "GL_INTEL_performance_query"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_INTEL_performance_query"))))]
    pub unsafe fn glGetPerfQueryInfoINTEL(
        queryId: GLuint,
        queryNameLength: GLuint,
        queryName: *mut GLchar,
        dataSize: *mut GLuint,
        noCounters: *mut GLuint,
        noInstances: *mut GLuint,
        capsMask: *mut GLuint,
    ) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glGetPerfQueryInfoINTEL({:?}, {:?}, {:p}, {:p}, {:p}, {:p}, {:p});",
                queryId,
                queryNameLength,
                queryName,
                dataSize,
                noCounters,
                noInstances,
                capsMask
            );
        }
        let out = call_atomic_ptr_7arg(
            "glGetPerfQueryInfoINTEL",
            &glGetPerfQueryInfoINTEL_p,
            queryId,
            queryNameLength,
            queryName,
            dataSize,
            noCounters,
            noInstances,
            capsMask,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glGetPerfQueryInfoINTEL");
        }
        out
    }
    #[cfg(any(feature = "GL_INTEL_performance_query"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_INTEL_performance_query"))))]
    static glGetPerfQueryInfoINTEL_p: APcv = ap_None();
    /// Tries to load [`glGetPerfQueryInfoINTEL`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    #[cfg(any(feature = "GL_INTEL_performance_query"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_INTEL_performance_query"))))]
    pub unsafe fn glGetPerfQueryInfoINTEL_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glGetPerfQueryInfoINTEL\0",
            &glGetPerfQueryInfoINTEL_p,
        )
    }
    /// Checks if the pointer for [`glGetPerfQueryInfoINTEL`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    #[cfg(any(feature = "GL_INTEL_performance_query"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_INTEL_performance_query"))))]
    pub fn glGetPerfQueryInfoINTEL_is_loaded() -> bool {
        !glGetPerfQueryInfoINTEL_p.load(RELAX).is_null()
    }

    /// [glGetPointerv](http://docs.gl/es3/glGetPointerv)(pname, params)
    /// `pname` group: GetPointervPName
    /// `params` len: 1
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn glGetPointerv(pname: GLenum, params: *mut *mut c_void) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!("calling glGetPointerv({:#X}, {:p});", pname, params);
        }
        let out = call_atomic_ptr_2arg("glGetPointerv", &glGetPointerv_p, pname, params);
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glGetPointerv");
        }
        out
    }
    static glGetPointerv_p: APcv = ap_None();
    /// Tries to load [`glGetPointerv`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    pub unsafe fn glGetPointerv_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(get_proc_address, b"glGetPointerv\0", &glGetPointerv_p)
    }
    /// Checks if the pointer for [`glGetPointerv`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    pub fn glGetPointerv_is_loaded() -> bool {
        !glGetPointerv_p.load(RELAX).is_null()
    }

    /// [glGetPointervKHR](http://docs.gl/es3/glGetPointervKHR)(pname, params)
    /// `params` len: 1
    /// alias of: [`glGetPointerv`]
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    #[cfg(any(feature = "GL_KHR_debug"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_KHR_debug"))))]
    pub unsafe fn glGetPointervKHR(pname: GLenum, params: *mut *mut c_void) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!("calling glGetPointervKHR({:#X}, {:p});", pname, params);
        }
        let out = call_atomic_ptr_2arg("glGetPointervKHR", &glGetPointervKHR_p, pname, params);
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glGetPointervKHR");
        }
        out
    }
    #[cfg(any(feature = "GL_KHR_debug"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_KHR_debug"))))]
    static glGetPointervKHR_p: APcv = ap_None();
    /// Tries to load [`glGetPointervKHR`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    #[cfg(any(feature = "GL_KHR_debug"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_KHR_debug"))))]
    pub unsafe fn glGetPointervKHR_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(get_proc_address, b"glGetPointervKHR\0", &glGetPointervKHR_p)
    }
    /// Checks if the pointer for [`glGetPointervKHR`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    #[cfg(any(feature = "GL_KHR_debug"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_KHR_debug"))))]
    pub fn glGetPointervKHR_is_loaded() -> bool {
        !glGetPointervKHR_p.load(RELAX).is_null()
    }

    /// [glGetProgramBinary](http://docs.gl/es3/glGetProgramBinary)(program, bufSize, length, binaryFormat, binary)
    /// `program` class: program
    /// `length` len: 1
    /// `binaryFormat` len: 1
    /// `binary` len: bufSize
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn glGetProgramBinary(
        program: GLuint,
        bufSize: GLsizei,
        length: *mut GLsizei,
        binaryFormat: *mut GLenum,
        binary: *mut c_void,
    ) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glGetProgramBinary({:?}, {:?}, {:p}, {:p}, {:p});",
                program,
                bufSize,
                length,
                binaryFormat,
                binary
            );
        }
        let out = call_atomic_ptr_5arg(
            "glGetProgramBinary",
            &glGetProgramBinary_p,
            program,
            bufSize,
            length,
            binaryFormat,
            binary,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glGetProgramBinary");
        }
        out
    }
    static glGetProgramBinary_p: APcv = ap_None();
    /// Tries to load [`glGetProgramBinary`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    pub unsafe fn glGetProgramBinary_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glGetProgramBinary\0",
            &glGetProgramBinary_p,
        )
    }
    /// Checks if the pointer for [`glGetProgramBinary`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    pub fn glGetProgramBinary_is_loaded() -> bool {
        !glGetProgramBinary_p.load(RELAX).is_null()
    }

    /// [glGetProgramBinaryOES](http://docs.gl/es3/glGetProgramBinaryOES)(program, bufSize, length, binaryFormat, binary)
    /// `program` class: program
    /// `length` len: 1
    /// `binaryFormat` len: 1
    /// `binary` len: bufSize
    /// alias of: [`glGetProgramBinary`]
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    #[cfg(any(feature = "GL_OES_get_program_binary"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_OES_get_program_binary"))))]
    pub unsafe fn glGetProgramBinaryOES(
        program: GLuint,
        bufSize: GLsizei,
        length: *mut GLsizei,
        binaryFormat: *mut GLenum,
        binary: *mut c_void,
    ) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glGetProgramBinaryOES({:?}, {:?}, {:p}, {:p}, {:p});",
                program,
                bufSize,
                length,
                binaryFormat,
                binary
            );
        }
        let out = call_atomic_ptr_5arg(
            "glGetProgramBinaryOES",
            &glGetProgramBinaryOES_p,
            program,
            bufSize,
            length,
            binaryFormat,
            binary,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glGetProgramBinaryOES");
        }
        out
    }
    #[cfg(any(feature = "GL_OES_get_program_binary"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_OES_get_program_binary"))))]
    static glGetProgramBinaryOES_p: APcv = ap_None();
    /// Tries to load [`glGetProgramBinaryOES`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    #[cfg(any(feature = "GL_OES_get_program_binary"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_OES_get_program_binary"))))]
    pub unsafe fn glGetProgramBinaryOES_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glGetProgramBinaryOES\0",
            &glGetProgramBinaryOES_p,
        )
    }
    /// Checks if the pointer for [`glGetProgramBinaryOES`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    #[cfg(any(feature = "GL_OES_get_program_binary"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_OES_get_program_binary"))))]
    pub fn glGetProgramBinaryOES_is_loaded() -> bool {
        !glGetProgramBinaryOES_p.load(RELAX).is_null()
    }

    /// [glGetProgramInfoLog](http://docs.gl/es3/glGetProgramInfoLog)(program, bufSize, length, infoLog)
    /// `program` class: program
    /// `length` len: 1
    /// `infoLog` len: bufSize
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn glGetProgramInfoLog(
        program: GLuint,
        bufSize: GLsizei,
        length: *mut GLsizei,
        infoLog: *mut GLchar,
    ) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glGetProgramInfoLog({:?}, {:?}, {:p}, {:p});",
                program,
                bufSize,
                length,
                infoLog
            );
        }
        let out = call_atomic_ptr_4arg(
            "glGetProgramInfoLog",
            &glGetProgramInfoLog_p,
            program,
            bufSize,
            length,
            infoLog,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glGetProgramInfoLog");
        }
        out
    }
    static glGetProgramInfoLog_p: APcv = ap_None();
    /// Tries to load [`glGetProgramInfoLog`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    pub unsafe fn glGetProgramInfoLog_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glGetProgramInfoLog\0",
            &glGetProgramInfoLog_p,
        )
    }
    /// Checks if the pointer for [`glGetProgramInfoLog`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    pub fn glGetProgramInfoLog_is_loaded() -> bool {
        !glGetProgramInfoLog_p.load(RELAX).is_null()
    }

    /// [glGetProgramInterfaceiv](http://docs.gl/es3/glGetProgramInterface)(program, programInterface, pname, params)
    /// `program` class: program
    /// `programInterface` group: ProgramInterface
    /// `pname` group: ProgramInterfacePName
    /// `params` len: COMPSIZE(pname)
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn glGetProgramInterfaceiv(
        program: GLuint,
        programInterface: GLenum,
        pname: GLenum,
        params: *mut GLint,
    ) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glGetProgramInterfaceiv({:?}, {:#X}, {:#X}, {:p});",
                program,
                programInterface,
                pname,
                params
            );
        }
        let out = call_atomic_ptr_4arg(
            "glGetProgramInterfaceiv",
            &glGetProgramInterfaceiv_p,
            program,
            programInterface,
            pname,
            params,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glGetProgramInterfaceiv");
        }
        out
    }
    static glGetProgramInterfaceiv_p: APcv = ap_None();
    /// Tries to load [`glGetProgramInterfaceiv`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    pub unsafe fn glGetProgramInterfaceiv_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glGetProgramInterfaceiv\0",
            &glGetProgramInterfaceiv_p,
        )
    }
    /// Checks if the pointer for [`glGetProgramInterfaceiv`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    pub fn glGetProgramInterfaceiv_is_loaded() -> bool {
        !glGetProgramInterfaceiv_p.load(RELAX).is_null()
    }

    /// [glGetProgramPipelineInfoLog](http://docs.gl/es3/glGetProgramPipelineInfoLog)(pipeline, bufSize, length, infoLog)
    /// `pipeline` class: program pipeline
    /// `length` len: 1
    /// `infoLog` len: bufSize
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn glGetProgramPipelineInfoLog(
        pipeline: GLuint,
        bufSize: GLsizei,
        length: *mut GLsizei,
        infoLog: *mut GLchar,
    ) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glGetProgramPipelineInfoLog({:?}, {:?}, {:p}, {:p});",
                pipeline,
                bufSize,
                length,
                infoLog
            );
        }
        let out = call_atomic_ptr_4arg(
            "glGetProgramPipelineInfoLog",
            &glGetProgramPipelineInfoLog_p,
            pipeline,
            bufSize,
            length,
            infoLog,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glGetProgramPipelineInfoLog");
        }
        out
    }
    static glGetProgramPipelineInfoLog_p: APcv = ap_None();
    /// Tries to load [`glGetProgramPipelineInfoLog`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    pub unsafe fn glGetProgramPipelineInfoLog_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glGetProgramPipelineInfoLog\0",
            &glGetProgramPipelineInfoLog_p,
        )
    }
    /// Checks if the pointer for [`glGetProgramPipelineInfoLog`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    pub fn glGetProgramPipelineInfoLog_is_loaded() -> bool {
        !glGetProgramPipelineInfoLog_p.load(RELAX).is_null()
    }

    /// [glGetProgramPipelineInfoLogEXT](http://docs.gl/es3/glGetProgramPipelineInfoLogEXT)(pipeline, bufSize, length, infoLog)
    /// `pipeline` class: program pipeline
    /// `length` len: 1
    /// `infoLog` len: bufSize
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    #[cfg(any(feature = "GL_EXT_separate_shader_objects"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_separate_shader_objects"))))]
    pub unsafe fn glGetProgramPipelineInfoLogEXT(
        pipeline: GLuint,
        bufSize: GLsizei,
        length: *mut GLsizei,
        infoLog: *mut GLchar,
    ) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glGetProgramPipelineInfoLogEXT({:?}, {:?}, {:p}, {:p});",
                pipeline,
                bufSize,
                length,
                infoLog
            );
        }
        let out = call_atomic_ptr_4arg(
            "glGetProgramPipelineInfoLogEXT",
            &glGetProgramPipelineInfoLogEXT_p,
            pipeline,
            bufSize,
            length,
            infoLog,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glGetProgramPipelineInfoLogEXT");
        }
        out
    }
    #[cfg(any(feature = "GL_EXT_separate_shader_objects"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_separate_shader_objects"))))]
    static glGetProgramPipelineInfoLogEXT_p: APcv = ap_None();
    /// Tries to load [`glGetProgramPipelineInfoLogEXT`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    #[cfg(any(feature = "GL_EXT_separate_shader_objects"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_separate_shader_objects"))))]
    pub unsafe fn glGetProgramPipelineInfoLogEXT_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glGetProgramPipelineInfoLogEXT\0",
            &glGetProgramPipelineInfoLogEXT_p,
        )
    }
    /// Checks if the pointer for [`glGetProgramPipelineInfoLogEXT`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    #[cfg(any(feature = "GL_EXT_separate_shader_objects"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_separate_shader_objects"))))]
    pub fn glGetProgramPipelineInfoLogEXT_is_loaded() -> bool {
        !glGetProgramPipelineInfoLogEXT_p.load(RELAX).is_null()
    }

    /// [glGetProgramPipelineiv](http://docs.gl/es3/glGetProgramPipeline)(pipeline, pname, params)
    /// `pipeline` class: program pipeline
    /// `pname` group: PipelineParameterName
    /// `params` len: COMPSIZE(pname)
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn glGetProgramPipelineiv(pipeline: GLuint, pname: GLenum, params: *mut GLint) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glGetProgramPipelineiv({:?}, {:#X}, {:p});",
                pipeline,
                pname,
                params
            );
        }
        let out = call_atomic_ptr_3arg(
            "glGetProgramPipelineiv",
            &glGetProgramPipelineiv_p,
            pipeline,
            pname,
            params,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glGetProgramPipelineiv");
        }
        out
    }
    static glGetProgramPipelineiv_p: APcv = ap_None();
    /// Tries to load [`glGetProgramPipelineiv`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    pub unsafe fn glGetProgramPipelineiv_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glGetProgramPipelineiv\0",
            &glGetProgramPipelineiv_p,
        )
    }
    /// Checks if the pointer for [`glGetProgramPipelineiv`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    pub fn glGetProgramPipelineiv_is_loaded() -> bool {
        !glGetProgramPipelineiv_p.load(RELAX).is_null()
    }

    /// [glGetProgramPipelineivEXT](http://docs.gl/es3/glGetProgramPipelineivEXT)(pipeline, pname, params)
    /// `pipeline` class: program pipeline
    /// `pname` group: PipelineParameterName
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    #[cfg(any(feature = "GL_EXT_separate_shader_objects"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_separate_shader_objects"))))]
    pub unsafe fn glGetProgramPipelineivEXT(pipeline: GLuint, pname: GLenum, params: *mut GLint) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glGetProgramPipelineivEXT({:?}, {:#X}, {:p});",
                pipeline,
                pname,
                params
            );
        }
        let out = call_atomic_ptr_3arg(
            "glGetProgramPipelineivEXT",
            &glGetProgramPipelineivEXT_p,
            pipeline,
            pname,
            params,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glGetProgramPipelineivEXT");
        }
        out
    }
    #[cfg(any(feature = "GL_EXT_separate_shader_objects"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_separate_shader_objects"))))]
    static glGetProgramPipelineivEXT_p: APcv = ap_None();
    /// Tries to load [`glGetProgramPipelineivEXT`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    #[cfg(any(feature = "GL_EXT_separate_shader_objects"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_separate_shader_objects"))))]
    pub unsafe fn glGetProgramPipelineivEXT_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glGetProgramPipelineivEXT\0",
            &glGetProgramPipelineivEXT_p,
        )
    }
    /// Checks if the pointer for [`glGetProgramPipelineivEXT`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    #[cfg(any(feature = "GL_EXT_separate_shader_objects"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_separate_shader_objects"))))]
    pub fn glGetProgramPipelineivEXT_is_loaded() -> bool {
        !glGetProgramPipelineivEXT_p.load(RELAX).is_null()
    }

    /// [glGetProgramResourceIndex](http://docs.gl/es3/glGetProgramResourceIndex)(program, programInterface, name)
    /// `program` class: program
    /// `programInterface` group: ProgramInterface
    /// `name` len: COMPSIZE(name)
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn glGetProgramResourceIndex(
        program: GLuint,
        programInterface: GLenum,
        name: *const GLchar,
    ) -> GLuint {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glGetProgramResourceIndex({:?}, {:#X}, {:p});",
                program,
                programInterface,
                name
            );
        }
        let out = call_atomic_ptr_3arg(
            "glGetProgramResourceIndex",
            &glGetProgramResourceIndex_p,
            program,
            programInterface,
            name,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glGetProgramResourceIndex");
        }
        out
    }
    static glGetProgramResourceIndex_p: APcv = ap_None();
    /// Tries to load [`glGetProgramResourceIndex`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    pub unsafe fn glGetProgramResourceIndex_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glGetProgramResourceIndex\0",
            &glGetProgramResourceIndex_p,
        )
    }
    /// Checks if the pointer for [`glGetProgramResourceIndex`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    pub fn glGetProgramResourceIndex_is_loaded() -> bool {
        !glGetProgramResourceIndex_p.load(RELAX).is_null()
    }

    /// [glGetProgramResourceLocation](http://docs.gl/es3/glGetProgramResourceLocation)(program, programInterface, name)
    /// `program` class: program
    /// `programInterface` group: ProgramInterface
    /// `name` len: COMPSIZE(name)
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn glGetProgramResourceLocation(
        program: GLuint,
        programInterface: GLenum,
        name: *const GLchar,
    ) -> GLint {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glGetProgramResourceLocation({:?}, {:#X}, {:p});",
                program,
                programInterface,
                name
            );
        }
        let out = call_atomic_ptr_3arg(
            "glGetProgramResourceLocation",
            &glGetProgramResourceLocation_p,
            program,
            programInterface,
            name,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glGetProgramResourceLocation");
        }
        out
    }
    static glGetProgramResourceLocation_p: APcv = ap_None();
    /// Tries to load [`glGetProgramResourceLocation`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    pub unsafe fn glGetProgramResourceLocation_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glGetProgramResourceLocation\0",
            &glGetProgramResourceLocation_p,
        )
    }
    /// Checks if the pointer for [`glGetProgramResourceLocation`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    pub fn glGetProgramResourceLocation_is_loaded() -> bool {
        !glGetProgramResourceLocation_p.load(RELAX).is_null()
    }

    /// [glGetProgramResourceLocationIndexEXT](http://docs.gl/es3/glGetProgramResourceLocationIndexEXT)(program, programInterface, name)
    /// `program` class: program
    /// `programInterface` group: ProgramInterface
    /// `name` len: COMPSIZE(name)
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    #[cfg(any(feature = "GL_EXT_blend_func_extended"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_blend_func_extended"))))]
    pub unsafe fn glGetProgramResourceLocationIndexEXT(
        program: GLuint,
        programInterface: GLenum,
        name: *const GLchar,
    ) -> GLint {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glGetProgramResourceLocationIndexEXT({:?}, {:#X}, {:p});",
                program,
                programInterface,
                name
            );
        }
        let out = call_atomic_ptr_3arg(
            "glGetProgramResourceLocationIndexEXT",
            &glGetProgramResourceLocationIndexEXT_p,
            program,
            programInterface,
            name,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glGetProgramResourceLocationIndexEXT");
        }
        out
    }
    #[cfg(any(feature = "GL_EXT_blend_func_extended"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_blend_func_extended"))))]
    static glGetProgramResourceLocationIndexEXT_p: APcv = ap_None();
    /// Tries to load [`glGetProgramResourceLocationIndexEXT`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    #[cfg(any(feature = "GL_EXT_blend_func_extended"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_blend_func_extended"))))]
    pub unsafe fn glGetProgramResourceLocationIndexEXT_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glGetProgramResourceLocationIndexEXT\0",
            &glGetProgramResourceLocationIndexEXT_p,
        )
    }
    /// Checks if the pointer for [`glGetProgramResourceLocationIndexEXT`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    #[cfg(any(feature = "GL_EXT_blend_func_extended"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_blend_func_extended"))))]
    pub fn glGetProgramResourceLocationIndexEXT_is_loaded() -> bool {
        !glGetProgramResourceLocationIndexEXT_p.load(RELAX).is_null()
    }

    /// [glGetProgramResourceName](http://docs.gl/es3/glGetProgramResourceName)(program, programInterface, index, bufSize, length, name)
    /// `program` class: program
    /// `programInterface` group: ProgramInterface
    /// `length` len: 1
    /// `name` len: bufSize
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn glGetProgramResourceName(
        program: GLuint,
        programInterface: GLenum,
        index: GLuint,
        bufSize: GLsizei,
        length: *mut GLsizei,
        name: *mut GLchar,
    ) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glGetProgramResourceName({:?}, {:#X}, {:?}, {:?}, {:p}, {:p});",
                program,
                programInterface,
                index,
                bufSize,
                length,
                name
            );
        }
        let out = call_atomic_ptr_6arg(
            "glGetProgramResourceName",
            &glGetProgramResourceName_p,
            program,
            programInterface,
            index,
            bufSize,
            length,
            name,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glGetProgramResourceName");
        }
        out
    }
    static glGetProgramResourceName_p: APcv = ap_None();
    /// Tries to load [`glGetProgramResourceName`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    pub unsafe fn glGetProgramResourceName_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glGetProgramResourceName\0",
            &glGetProgramResourceName_p,
        )
    }
    /// Checks if the pointer for [`glGetProgramResourceName`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    pub fn glGetProgramResourceName_is_loaded() -> bool {
        !glGetProgramResourceName_p.load(RELAX).is_null()
    }

    /// [glGetProgramResourcefvNV](http://docs.gl/es3/glGetProgramResourcefvNV)(program, programInterface, index, propCount, props, count, length, params)
    /// `program` class: program
    /// `programInterface` group: ProgramInterface
    /// `length` len: 1
    /// `params` len: count
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    #[cfg(any(feature = "GL_NV_path_rendering"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_path_rendering"))))]
    pub unsafe fn glGetProgramResourcefvNV(
        program: GLuint,
        programInterface: GLenum,
        index: GLuint,
        propCount: GLsizei,
        props: *const GLenum,
        count: GLsizei,
        length: *mut GLsizei,
        params: *mut GLfloat,
    ) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glGetProgramResourcefvNV({:?}, {:#X}, {:?}, {:?}, {:p}, {:?}, {:p}, {:p});",
                program,
                programInterface,
                index,
                propCount,
                props,
                count,
                length,
                params
            );
        }
        let out = call_atomic_ptr_8arg(
            "glGetProgramResourcefvNV",
            &glGetProgramResourcefvNV_p,
            program,
            programInterface,
            index,
            propCount,
            props,
            count,
            length,
            params,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glGetProgramResourcefvNV");
        }
        out
    }
    #[cfg(any(feature = "GL_NV_path_rendering"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_path_rendering"))))]
    static glGetProgramResourcefvNV_p: APcv = ap_None();
    /// Tries to load [`glGetProgramResourcefvNV`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    #[cfg(any(feature = "GL_NV_path_rendering"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_path_rendering"))))]
    pub unsafe fn glGetProgramResourcefvNV_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glGetProgramResourcefvNV\0",
            &glGetProgramResourcefvNV_p,
        )
    }
    /// Checks if the pointer for [`glGetProgramResourcefvNV`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    #[cfg(any(feature = "GL_NV_path_rendering"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_path_rendering"))))]
    pub fn glGetProgramResourcefvNV_is_loaded() -> bool {
        !glGetProgramResourcefvNV_p.load(RELAX).is_null()
    }

    /// [glGetProgramResourceiv](http://docs.gl/es3/glGetProgramResource)(program, programInterface, index, propCount, props, count, length, params)
    /// `program` class: program
    /// `programInterface` group: ProgramInterface
    /// `props` group: ProgramResourceProperty
    /// `props` len: propCount
    /// `length` len: 1
    /// `params` len: count
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn glGetProgramResourceiv(
        program: GLuint,
        programInterface: GLenum,
        index: GLuint,
        propCount: GLsizei,
        props: *const GLenum,
        count: GLsizei,
        length: *mut GLsizei,
        params: *mut GLint,
    ) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glGetProgramResourceiv({:?}, {:#X}, {:?}, {:?}, {:p}, {:?}, {:p}, {:p});",
                program,
                programInterface,
                index,
                propCount,
                props,
                count,
                length,
                params
            );
        }
        let out = call_atomic_ptr_8arg(
            "glGetProgramResourceiv",
            &glGetProgramResourceiv_p,
            program,
            programInterface,
            index,
            propCount,
            props,
            count,
            length,
            params,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glGetProgramResourceiv");
        }
        out
    }
    static glGetProgramResourceiv_p: APcv = ap_None();
    /// Tries to load [`glGetProgramResourceiv`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    pub unsafe fn glGetProgramResourceiv_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glGetProgramResourceiv\0",
            &glGetProgramResourceiv_p,
        )
    }
    /// Checks if the pointer for [`glGetProgramResourceiv`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    pub fn glGetProgramResourceiv_is_loaded() -> bool {
        !glGetProgramResourceiv_p.load(RELAX).is_null()
    }

    /// [glGetProgramiv](http://docs.gl/es3/glGetProgram)(program, pname, params)
    /// `program` class: program
    /// `pname` group: ProgramPropertyARB
    /// `params` len: COMPSIZE(pname)
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn glGetProgramiv(program: GLuint, pname: GLenum, params: *mut GLint) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glGetProgramiv({:?}, {:#X}, {:p});",
                program,
                pname,
                params
            );
        }
        let out = call_atomic_ptr_3arg("glGetProgramiv", &glGetProgramiv_p, program, pname, params);
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glGetProgramiv");
        }
        out
    }
    static glGetProgramiv_p: APcv = ap_None();
    /// Tries to load [`glGetProgramiv`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    pub unsafe fn glGetProgramiv_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(get_proc_address, b"glGetProgramiv\0", &glGetProgramiv_p)
    }
    /// Checks if the pointer for [`glGetProgramiv`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    pub fn glGetProgramiv_is_loaded() -> bool {
        !glGetProgramiv_p.load(RELAX).is_null()
    }

    /// [glGetQueryObjecti64vEXT](http://docs.gl/es3/glGetQueryObjecti64vEXT)(id, pname, params)
    /// `id` class: query
    /// `pname` group: QueryObjectParameterName
    /// `params` len: COMPSIZE(pname)
    /// alias of: [`glGetQueryObjecti64v`]
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    #[cfg(any(feature = "GL_EXT_disjoint_timer_query"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_disjoint_timer_query"))))]
    pub unsafe fn glGetQueryObjecti64vEXT(id: GLuint, pname: GLenum, params: *mut GLint64) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glGetQueryObjecti64vEXT({:?}, {:#X}, {:p});",
                id,
                pname,
                params
            );
        }
        let out = call_atomic_ptr_3arg(
            "glGetQueryObjecti64vEXT",
            &glGetQueryObjecti64vEXT_p,
            id,
            pname,
            params,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glGetQueryObjecti64vEXT");
        }
        out
    }
    #[cfg(any(feature = "GL_EXT_disjoint_timer_query"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_disjoint_timer_query"))))]
    static glGetQueryObjecti64vEXT_p: APcv = ap_None();
    /// Tries to load [`glGetQueryObjecti64vEXT`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    #[cfg(any(feature = "GL_EXT_disjoint_timer_query"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_disjoint_timer_query"))))]
    pub unsafe fn glGetQueryObjecti64vEXT_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glGetQueryObjecti64vEXT\0",
            &glGetQueryObjecti64vEXT_p,
        )
    }
    /// Checks if the pointer for [`glGetQueryObjecti64vEXT`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    #[cfg(any(feature = "GL_EXT_disjoint_timer_query"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_disjoint_timer_query"))))]
    pub fn glGetQueryObjecti64vEXT_is_loaded() -> bool {
        !glGetQueryObjecti64vEXT_p.load(RELAX).is_null()
    }

    /// [glGetQueryObjectivEXT](http://docs.gl/es3/glGetQueryObjectivEXT)(id, pname, params)
    /// `id` class: query
    /// `pname` group: QueryObjectParameterName
    /// `params` len: COMPSIZE(pname)
    /// alias of: [`glGetQueryObjectiv`]
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    #[cfg(any(feature = "GL_EXT_disjoint_timer_query"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_disjoint_timer_query"))))]
    pub unsafe fn glGetQueryObjectivEXT(id: GLuint, pname: GLenum, params: *mut GLint) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glGetQueryObjectivEXT({:?}, {:#X}, {:p});",
                id,
                pname,
                params
            );
        }
        let out = call_atomic_ptr_3arg(
            "glGetQueryObjectivEXT",
            &glGetQueryObjectivEXT_p,
            id,
            pname,
            params,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glGetQueryObjectivEXT");
        }
        out
    }
    #[cfg(any(feature = "GL_EXT_disjoint_timer_query"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_disjoint_timer_query"))))]
    static glGetQueryObjectivEXT_p: APcv = ap_None();
    /// Tries to load [`glGetQueryObjectivEXT`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    #[cfg(any(feature = "GL_EXT_disjoint_timer_query"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_disjoint_timer_query"))))]
    pub unsafe fn glGetQueryObjectivEXT_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glGetQueryObjectivEXT\0",
            &glGetQueryObjectivEXT_p,
        )
    }
    /// Checks if the pointer for [`glGetQueryObjectivEXT`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    #[cfg(any(feature = "GL_EXT_disjoint_timer_query"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_disjoint_timer_query"))))]
    pub fn glGetQueryObjectivEXT_is_loaded() -> bool {
        !glGetQueryObjectivEXT_p.load(RELAX).is_null()
    }

    /// [glGetQueryObjectui64vEXT](http://docs.gl/es3/glGetQueryObjectui64vEXT)(id, pname, params)
    /// `id` class: query
    /// `pname` group: QueryObjectParameterName
    /// `params` len: COMPSIZE(pname)
    /// alias of: [`glGetQueryObjectui64v`]
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    #[cfg(any(feature = "GL_EXT_disjoint_timer_query"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_disjoint_timer_query"))))]
    pub unsafe fn glGetQueryObjectui64vEXT(id: GLuint, pname: GLenum, params: *mut GLuint64) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glGetQueryObjectui64vEXT({:?}, {:#X}, {:p});",
                id,
                pname,
                params
            );
        }
        let out = call_atomic_ptr_3arg(
            "glGetQueryObjectui64vEXT",
            &glGetQueryObjectui64vEXT_p,
            id,
            pname,
            params,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glGetQueryObjectui64vEXT");
        }
        out
    }
    #[cfg(any(feature = "GL_EXT_disjoint_timer_query"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_disjoint_timer_query"))))]
    static glGetQueryObjectui64vEXT_p: APcv = ap_None();
    /// Tries to load [`glGetQueryObjectui64vEXT`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    #[cfg(any(feature = "GL_EXT_disjoint_timer_query"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_disjoint_timer_query"))))]
    pub unsafe fn glGetQueryObjectui64vEXT_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glGetQueryObjectui64vEXT\0",
            &glGetQueryObjectui64vEXT_p,
        )
    }
    /// Checks if the pointer for [`glGetQueryObjectui64vEXT`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    #[cfg(any(feature = "GL_EXT_disjoint_timer_query"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_disjoint_timer_query"))))]
    pub fn glGetQueryObjectui64vEXT_is_loaded() -> bool {
        !glGetQueryObjectui64vEXT_p.load(RELAX).is_null()
    }

    /// [glGetQueryObjectuiv](http://docs.gl/es3/glGetQueryObject)(id, pname, params)
    /// `id` class: query
    /// `pname` group: QueryObjectParameterName
    /// `params` len: COMPSIZE(pname)
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn glGetQueryObjectuiv(id: GLuint, pname: GLenum, params: *mut GLuint) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glGetQueryObjectuiv({:?}, {:#X}, {:p});",
                id,
                pname,
                params
            );
        }
        let out = call_atomic_ptr_3arg(
            "glGetQueryObjectuiv",
            &glGetQueryObjectuiv_p,
            id,
            pname,
            params,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glGetQueryObjectuiv");
        }
        out
    }
    static glGetQueryObjectuiv_p: APcv = ap_None();
    /// Tries to load [`glGetQueryObjectuiv`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    pub unsafe fn glGetQueryObjectuiv_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glGetQueryObjectuiv\0",
            &glGetQueryObjectuiv_p,
        )
    }
    /// Checks if the pointer for [`glGetQueryObjectuiv`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    pub fn glGetQueryObjectuiv_is_loaded() -> bool {
        !glGetQueryObjectuiv_p.load(RELAX).is_null()
    }

    /// [glGetQueryObjectuivEXT](http://docs.gl/es3/glGetQueryObjectuivEXT)(id, pname, params)
    /// `id` class: query
    /// `pname` group: QueryObjectParameterName
    /// `params` len: COMPSIZE(pname)
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    #[cfg(any(
        feature = "GL_EXT_disjoint_timer_query",
        feature = "GL_EXT_occlusion_query_boolean"
    ))]
    #[cfg_attr(
        docs_rs,
        doc(cfg(any(
            feature = "GL_EXT_disjoint_timer_query",
            feature = "GL_EXT_occlusion_query_boolean"
        )))
    )]
    pub unsafe fn glGetQueryObjectuivEXT(id: GLuint, pname: GLenum, params: *mut GLuint) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glGetQueryObjectuivEXT({:?}, {:#X}, {:p});",
                id,
                pname,
                params
            );
        }
        let out = call_atomic_ptr_3arg(
            "glGetQueryObjectuivEXT",
            &glGetQueryObjectuivEXT_p,
            id,
            pname,
            params,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glGetQueryObjectuivEXT");
        }
        out
    }
    #[cfg(any(
        feature = "GL_EXT_disjoint_timer_query",
        feature = "GL_EXT_occlusion_query_boolean"
    ))]
    #[cfg_attr(
        docs_rs,
        doc(cfg(any(
            feature = "GL_EXT_disjoint_timer_query",
            feature = "GL_EXT_occlusion_query_boolean"
        )))
    )]
    static glGetQueryObjectuivEXT_p: APcv = ap_None();
    /// Tries to load [`glGetQueryObjectuivEXT`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    #[cfg(any(
        feature = "GL_EXT_disjoint_timer_query",
        feature = "GL_EXT_occlusion_query_boolean"
    ))]
    #[cfg_attr(
        docs_rs,
        doc(cfg(any(
            feature = "GL_EXT_disjoint_timer_query",
            feature = "GL_EXT_occlusion_query_boolean"
        )))
    )]
    pub unsafe fn glGetQueryObjectuivEXT_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glGetQueryObjectuivEXT\0",
            &glGetQueryObjectuivEXT_p,
        )
    }
    /// Checks if the pointer for [`glGetQueryObjectuivEXT`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    #[cfg(any(
        feature = "GL_EXT_disjoint_timer_query",
        feature = "GL_EXT_occlusion_query_boolean"
    ))]
    #[cfg_attr(
        docs_rs,
        doc(cfg(any(
            feature = "GL_EXT_disjoint_timer_query",
            feature = "GL_EXT_occlusion_query_boolean"
        )))
    )]
    pub fn glGetQueryObjectuivEXT_is_loaded() -> bool {
        !glGetQueryObjectuivEXT_p.load(RELAX).is_null()
    }

    /// [glGetQueryiv](http://docs.gl/es3/glGetQuery)(target, pname, params)
    /// `target` group: QueryTarget
    /// `pname` group: QueryParameterName
    /// `params` len: COMPSIZE(pname)
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn glGetQueryiv(target: GLenum, pname: GLenum, params: *mut GLint) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glGetQueryiv({:#X}, {:#X}, {:p});",
                target,
                pname,
                params
            );
        }
        let out = call_atomic_ptr_3arg("glGetQueryiv", &glGetQueryiv_p, target, pname, params);
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glGetQueryiv");
        }
        out
    }
    static glGetQueryiv_p: APcv = ap_None();
    /// Tries to load [`glGetQueryiv`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    pub unsafe fn glGetQueryiv_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(get_proc_address, b"glGetQueryiv\0", &glGetQueryiv_p)
    }
    /// Checks if the pointer for [`glGetQueryiv`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    pub fn glGetQueryiv_is_loaded() -> bool {
        !glGetQueryiv_p.load(RELAX).is_null()
    }

    /// [glGetQueryivEXT](http://docs.gl/es3/glGetQueryivEXT)(target, pname, params)
    /// `target` group: QueryTarget
    /// `pname` group: QueryParameterName
    /// `params` len: COMPSIZE(pname)
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    #[cfg(any(
        feature = "GL_EXT_disjoint_timer_query",
        feature = "GL_EXT_occlusion_query_boolean"
    ))]
    #[cfg_attr(
        docs_rs,
        doc(cfg(any(
            feature = "GL_EXT_disjoint_timer_query",
            feature = "GL_EXT_occlusion_query_boolean"
        )))
    )]
    pub unsafe fn glGetQueryivEXT(target: GLenum, pname: GLenum, params: *mut GLint) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glGetQueryivEXT({:#X}, {:#X}, {:p});",
                target,
                pname,
                params
            );
        }
        let out =
            call_atomic_ptr_3arg("glGetQueryivEXT", &glGetQueryivEXT_p, target, pname, params);
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glGetQueryivEXT");
        }
        out
    }
    #[cfg(any(
        feature = "GL_EXT_disjoint_timer_query",
        feature = "GL_EXT_occlusion_query_boolean"
    ))]
    #[cfg_attr(
        docs_rs,
        doc(cfg(any(
            feature = "GL_EXT_disjoint_timer_query",
            feature = "GL_EXT_occlusion_query_boolean"
        )))
    )]
    static glGetQueryivEXT_p: APcv = ap_None();
    /// Tries to load [`glGetQueryivEXT`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    #[cfg(any(
        feature = "GL_EXT_disjoint_timer_query",
        feature = "GL_EXT_occlusion_query_boolean"
    ))]
    #[cfg_attr(
        docs_rs,
        doc(cfg(any(
            feature = "GL_EXT_disjoint_timer_query",
            feature = "GL_EXT_occlusion_query_boolean"
        )))
    )]
    pub unsafe fn glGetQueryivEXT_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(get_proc_address, b"glGetQueryivEXT\0", &glGetQueryivEXT_p)
    }
    /// Checks if the pointer for [`glGetQueryivEXT`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    #[cfg(any(
        feature = "GL_EXT_disjoint_timer_query",
        feature = "GL_EXT_occlusion_query_boolean"
    ))]
    #[cfg_attr(
        docs_rs,
        doc(cfg(any(
            feature = "GL_EXT_disjoint_timer_query",
            feature = "GL_EXT_occlusion_query_boolean"
        )))
    )]
    pub fn glGetQueryivEXT_is_loaded() -> bool {
        !glGetQueryivEXT_p.load(RELAX).is_null()
    }

    /// [glGetRenderbufferParameteriv](http://docs.gl/es3/glGetRenderbufferParameter)(target, pname, params)
    /// `target` group: RenderbufferTarget
    /// `pname` group: RenderbufferParameterName
    /// `params` len: COMPSIZE(pname)
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn glGetRenderbufferParameteriv(target: GLenum, pname: GLenum, params: *mut GLint) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glGetRenderbufferParameteriv({:#X}, {:#X}, {:p});",
                target,
                pname,
                params
            );
        }
        let out = call_atomic_ptr_3arg(
            "glGetRenderbufferParameteriv",
            &glGetRenderbufferParameteriv_p,
            target,
            pname,
            params,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glGetRenderbufferParameteriv");
        }
        out
    }
    static glGetRenderbufferParameteriv_p: APcv = ap_None();
    /// Tries to load [`glGetRenderbufferParameteriv`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    pub unsafe fn glGetRenderbufferParameteriv_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glGetRenderbufferParameteriv\0",
            &glGetRenderbufferParameteriv_p,
        )
    }
    /// Checks if the pointer for [`glGetRenderbufferParameteriv`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    pub fn glGetRenderbufferParameteriv_is_loaded() -> bool {
        !glGetRenderbufferParameteriv_p.load(RELAX).is_null()
    }

    /// [glGetSamplerParameterIiv](http://docs.gl/es3/glGetSamplerParameter)(sampler, pname, params)
    /// `sampler` class: sampler
    /// `pname` group: SamplerParameterI
    /// `params` len: COMPSIZE(pname)
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn glGetSamplerParameterIiv(sampler: GLuint, pname: GLenum, params: *mut GLint) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glGetSamplerParameterIiv({:?}, {:#X}, {:p});",
                sampler,
                pname,
                params
            );
        }
        let out = call_atomic_ptr_3arg(
            "glGetSamplerParameterIiv",
            &glGetSamplerParameterIiv_p,
            sampler,
            pname,
            params,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glGetSamplerParameterIiv");
        }
        out
    }
    static glGetSamplerParameterIiv_p: APcv = ap_None();
    /// Tries to load [`glGetSamplerParameterIiv`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    pub unsafe fn glGetSamplerParameterIiv_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glGetSamplerParameterIiv\0",
            &glGetSamplerParameterIiv_p,
        )
    }
    /// Checks if the pointer for [`glGetSamplerParameterIiv`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    pub fn glGetSamplerParameterIiv_is_loaded() -> bool {
        !glGetSamplerParameterIiv_p.load(RELAX).is_null()
    }

    /// [glGetSamplerParameterIivEXT](http://docs.gl/es3/glGetSamplerParameterIivEXT)(sampler, pname, params)
    /// `sampler` class: sampler
    /// `pname` group: SamplerParameterI
    /// `params` len: COMPSIZE(pname)
    /// alias of: [`glGetSamplerParameterIiv`]
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    #[cfg(any(feature = "GL_EXT_texture_border_clamp"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_texture_border_clamp"))))]
    pub unsafe fn glGetSamplerParameterIivEXT(sampler: GLuint, pname: GLenum, params: *mut GLint) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glGetSamplerParameterIivEXT({:?}, {:#X}, {:p});",
                sampler,
                pname,
                params
            );
        }
        let out = call_atomic_ptr_3arg(
            "glGetSamplerParameterIivEXT",
            &glGetSamplerParameterIivEXT_p,
            sampler,
            pname,
            params,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glGetSamplerParameterIivEXT");
        }
        out
    }
    #[cfg(any(feature = "GL_EXT_texture_border_clamp"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_texture_border_clamp"))))]
    static glGetSamplerParameterIivEXT_p: APcv = ap_None();
    /// Tries to load [`glGetSamplerParameterIivEXT`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    #[cfg(any(feature = "GL_EXT_texture_border_clamp"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_texture_border_clamp"))))]
    pub unsafe fn glGetSamplerParameterIivEXT_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glGetSamplerParameterIivEXT\0",
            &glGetSamplerParameterIivEXT_p,
        )
    }
    /// Checks if the pointer for [`glGetSamplerParameterIivEXT`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    #[cfg(any(feature = "GL_EXT_texture_border_clamp"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_texture_border_clamp"))))]
    pub fn glGetSamplerParameterIivEXT_is_loaded() -> bool {
        !glGetSamplerParameterIivEXT_p.load(RELAX).is_null()
    }

    /// [glGetSamplerParameterIivOES](http://docs.gl/es3/glGetSamplerParameterIivOES)(sampler, pname, params)
    /// `sampler` class: sampler
    /// `pname` group: SamplerParameterI
    /// `params` len: COMPSIZE(pname)
    /// alias of: [`glGetSamplerParameterIiv`]
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    #[cfg(any(feature = "GL_OES_texture_border_clamp"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_OES_texture_border_clamp"))))]
    pub unsafe fn glGetSamplerParameterIivOES(sampler: GLuint, pname: GLenum, params: *mut GLint) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glGetSamplerParameterIivOES({:?}, {:#X}, {:p});",
                sampler,
                pname,
                params
            );
        }
        let out = call_atomic_ptr_3arg(
            "glGetSamplerParameterIivOES",
            &glGetSamplerParameterIivOES_p,
            sampler,
            pname,
            params,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glGetSamplerParameterIivOES");
        }
        out
    }
    #[cfg(any(feature = "GL_OES_texture_border_clamp"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_OES_texture_border_clamp"))))]
    static glGetSamplerParameterIivOES_p: APcv = ap_None();
    /// Tries to load [`glGetSamplerParameterIivOES`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    #[cfg(any(feature = "GL_OES_texture_border_clamp"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_OES_texture_border_clamp"))))]
    pub unsafe fn glGetSamplerParameterIivOES_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glGetSamplerParameterIivOES\0",
            &glGetSamplerParameterIivOES_p,
        )
    }
    /// Checks if the pointer for [`glGetSamplerParameterIivOES`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    #[cfg(any(feature = "GL_OES_texture_border_clamp"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_OES_texture_border_clamp"))))]
    pub fn glGetSamplerParameterIivOES_is_loaded() -> bool {
        !glGetSamplerParameterIivOES_p.load(RELAX).is_null()
    }

    /// [glGetSamplerParameterIuiv](http://docs.gl/es3/glGetSamplerParameter)(sampler, pname, params)
    /// `sampler` class: sampler
    /// `pname` group: SamplerParameterI
    /// `params` len: COMPSIZE(pname)
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn glGetSamplerParameterIuiv(sampler: GLuint, pname: GLenum, params: *mut GLuint) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glGetSamplerParameterIuiv({:?}, {:#X}, {:p});",
                sampler,
                pname,
                params
            );
        }
        let out = call_atomic_ptr_3arg(
            "glGetSamplerParameterIuiv",
            &glGetSamplerParameterIuiv_p,
            sampler,
            pname,
            params,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glGetSamplerParameterIuiv");
        }
        out
    }
    static glGetSamplerParameterIuiv_p: APcv = ap_None();
    /// Tries to load [`glGetSamplerParameterIuiv`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    pub unsafe fn glGetSamplerParameterIuiv_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glGetSamplerParameterIuiv\0",
            &glGetSamplerParameterIuiv_p,
        )
    }
    /// Checks if the pointer for [`glGetSamplerParameterIuiv`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    pub fn glGetSamplerParameterIuiv_is_loaded() -> bool {
        !glGetSamplerParameterIuiv_p.load(RELAX).is_null()
    }

    /// [glGetSamplerParameterIuivEXT](http://docs.gl/es3/glGetSamplerParameterIuivEXT)(sampler, pname, params)
    /// `sampler` class: sampler
    /// `pname` group: SamplerParameterI
    /// `params` len: COMPSIZE(pname)
    /// alias of: [`glGetSamplerParameterIuiv`]
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    #[cfg(any(feature = "GL_EXT_texture_border_clamp"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_texture_border_clamp"))))]
    pub unsafe fn glGetSamplerParameterIuivEXT(
        sampler: GLuint,
        pname: GLenum,
        params: *mut GLuint,
    ) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glGetSamplerParameterIuivEXT({:?}, {:#X}, {:p});",
                sampler,
                pname,
                params
            );
        }
        let out = call_atomic_ptr_3arg(
            "glGetSamplerParameterIuivEXT",
            &glGetSamplerParameterIuivEXT_p,
            sampler,
            pname,
            params,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glGetSamplerParameterIuivEXT");
        }
        out
    }
    #[cfg(any(feature = "GL_EXT_texture_border_clamp"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_texture_border_clamp"))))]
    static glGetSamplerParameterIuivEXT_p: APcv = ap_None();
    /// Tries to load [`glGetSamplerParameterIuivEXT`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    #[cfg(any(feature = "GL_EXT_texture_border_clamp"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_texture_border_clamp"))))]
    pub unsafe fn glGetSamplerParameterIuivEXT_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glGetSamplerParameterIuivEXT\0",
            &glGetSamplerParameterIuivEXT_p,
        )
    }
    /// Checks if the pointer for [`glGetSamplerParameterIuivEXT`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    #[cfg(any(feature = "GL_EXT_texture_border_clamp"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_texture_border_clamp"))))]
    pub fn glGetSamplerParameterIuivEXT_is_loaded() -> bool {
        !glGetSamplerParameterIuivEXT_p.load(RELAX).is_null()
    }

    /// [glGetSamplerParameterIuivOES](http://docs.gl/es3/glGetSamplerParameterIuivOES)(sampler, pname, params)
    /// `sampler` class: sampler
    /// `pname` group: SamplerParameterI
    /// `params` len: COMPSIZE(pname)
    /// alias of: [`glGetSamplerParameterIuiv`]
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    #[cfg(any(feature = "GL_OES_texture_border_clamp"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_OES_texture_border_clamp"))))]
    pub unsafe fn glGetSamplerParameterIuivOES(
        sampler: GLuint,
        pname: GLenum,
        params: *mut GLuint,
    ) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glGetSamplerParameterIuivOES({:?}, {:#X}, {:p});",
                sampler,
                pname,
                params
            );
        }
        let out = call_atomic_ptr_3arg(
            "glGetSamplerParameterIuivOES",
            &glGetSamplerParameterIuivOES_p,
            sampler,
            pname,
            params,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glGetSamplerParameterIuivOES");
        }
        out
    }
    #[cfg(any(feature = "GL_OES_texture_border_clamp"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_OES_texture_border_clamp"))))]
    static glGetSamplerParameterIuivOES_p: APcv = ap_None();
    /// Tries to load [`glGetSamplerParameterIuivOES`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    #[cfg(any(feature = "GL_OES_texture_border_clamp"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_OES_texture_border_clamp"))))]
    pub unsafe fn glGetSamplerParameterIuivOES_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glGetSamplerParameterIuivOES\0",
            &glGetSamplerParameterIuivOES_p,
        )
    }
    /// Checks if the pointer for [`glGetSamplerParameterIuivOES`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    #[cfg(any(feature = "GL_OES_texture_border_clamp"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_OES_texture_border_clamp"))))]
    pub fn glGetSamplerParameterIuivOES_is_loaded() -> bool {
        !glGetSamplerParameterIuivOES_p.load(RELAX).is_null()
    }

    /// [glGetSamplerParameterfv](http://docs.gl/es3/glGetSamplerParameter)(sampler, pname, params)
    /// `sampler` class: sampler
    /// `pname` group: SamplerParameterF
    /// `params` len: COMPSIZE(pname)
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn glGetSamplerParameterfv(sampler: GLuint, pname: GLenum, params: *mut GLfloat) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glGetSamplerParameterfv({:?}, {:#X}, {:p});",
                sampler,
                pname,
                params
            );
        }
        let out = call_atomic_ptr_3arg(
            "glGetSamplerParameterfv",
            &glGetSamplerParameterfv_p,
            sampler,
            pname,
            params,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glGetSamplerParameterfv");
        }
        out
    }
    static glGetSamplerParameterfv_p: APcv = ap_None();
    /// Tries to load [`glGetSamplerParameterfv`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    pub unsafe fn glGetSamplerParameterfv_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glGetSamplerParameterfv\0",
            &glGetSamplerParameterfv_p,
        )
    }
    /// Checks if the pointer for [`glGetSamplerParameterfv`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    pub fn glGetSamplerParameterfv_is_loaded() -> bool {
        !glGetSamplerParameterfv_p.load(RELAX).is_null()
    }

    /// [glGetSamplerParameteriv](http://docs.gl/es3/glGetSamplerParameter)(sampler, pname, params)
    /// `sampler` class: sampler
    /// `pname` group: SamplerParameterI
    /// `params` len: COMPSIZE(pname)
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn glGetSamplerParameteriv(sampler: GLuint, pname: GLenum, params: *mut GLint) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glGetSamplerParameteriv({:?}, {:#X}, {:p});",
                sampler,
                pname,
                params
            );
        }
        let out = call_atomic_ptr_3arg(
            "glGetSamplerParameteriv",
            &glGetSamplerParameteriv_p,
            sampler,
            pname,
            params,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glGetSamplerParameteriv");
        }
        out
    }
    static glGetSamplerParameteriv_p: APcv = ap_None();
    /// Tries to load [`glGetSamplerParameteriv`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    pub unsafe fn glGetSamplerParameteriv_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glGetSamplerParameteriv\0",
            &glGetSamplerParameteriv_p,
        )
    }
    /// Checks if the pointer for [`glGetSamplerParameteriv`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    pub fn glGetSamplerParameteriv_is_loaded() -> bool {
        !glGetSamplerParameteriv_p.load(RELAX).is_null()
    }

    /// [glGetSemaphoreParameterivNV](http://docs.gl/es3/glGetSemaphoreParameterivNV)(semaphore, pname, params)
    /// `pname` group: SemaphoreParameterName
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    #[cfg(any(feature = "GL_NV_timeline_semaphore"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_timeline_semaphore"))))]
    pub unsafe fn glGetSemaphoreParameterivNV(
        semaphore: GLuint,
        pname: GLenum,
        params: *mut GLint,
    ) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glGetSemaphoreParameterivNV({:?}, {:#X}, {:p});",
                semaphore,
                pname,
                params
            );
        }
        let out = call_atomic_ptr_3arg(
            "glGetSemaphoreParameterivNV",
            &glGetSemaphoreParameterivNV_p,
            semaphore,
            pname,
            params,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glGetSemaphoreParameterivNV");
        }
        out
    }
    #[cfg(any(feature = "GL_NV_timeline_semaphore"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_timeline_semaphore"))))]
    static glGetSemaphoreParameterivNV_p: APcv = ap_None();
    /// Tries to load [`glGetSemaphoreParameterivNV`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    #[cfg(any(feature = "GL_NV_timeline_semaphore"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_timeline_semaphore"))))]
    pub unsafe fn glGetSemaphoreParameterivNV_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glGetSemaphoreParameterivNV\0",
            &glGetSemaphoreParameterivNV_p,
        )
    }
    /// Checks if the pointer for [`glGetSemaphoreParameterivNV`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    #[cfg(any(feature = "GL_NV_timeline_semaphore"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_timeline_semaphore"))))]
    pub fn glGetSemaphoreParameterivNV_is_loaded() -> bool {
        !glGetSemaphoreParameterivNV_p.load(RELAX).is_null()
    }

    /// [glGetSemaphoreParameterui64vEXT](http://docs.gl/es3/glGetSemaphoreParameterui64vEXT)(semaphore, pname, params)
    /// `pname` group: SemaphoreParameterName
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    #[cfg(any(feature = "GL_EXT_semaphore"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_semaphore"))))]
    pub unsafe fn glGetSemaphoreParameterui64vEXT(
        semaphore: GLuint,
        pname: GLenum,
        params: *mut GLuint64,
    ) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glGetSemaphoreParameterui64vEXT({:?}, {:#X}, {:p});",
                semaphore,
                pname,
                params
            );
        }
        let out = call_atomic_ptr_3arg(
            "glGetSemaphoreParameterui64vEXT",
            &glGetSemaphoreParameterui64vEXT_p,
            semaphore,
            pname,
            params,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glGetSemaphoreParameterui64vEXT");
        }
        out
    }
    #[cfg(any(feature = "GL_EXT_semaphore"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_semaphore"))))]
    static glGetSemaphoreParameterui64vEXT_p: APcv = ap_None();
    /// Tries to load [`glGetSemaphoreParameterui64vEXT`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    #[cfg(any(feature = "GL_EXT_semaphore"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_semaphore"))))]
    pub unsafe fn glGetSemaphoreParameterui64vEXT_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glGetSemaphoreParameterui64vEXT\0",
            &glGetSemaphoreParameterui64vEXT_p,
        )
    }
    /// Checks if the pointer for [`glGetSemaphoreParameterui64vEXT`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    #[cfg(any(feature = "GL_EXT_semaphore"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_semaphore"))))]
    pub fn glGetSemaphoreParameterui64vEXT_is_loaded() -> bool {
        !glGetSemaphoreParameterui64vEXT_p.load(RELAX).is_null()
    }

    /// [glGetShaderInfoLog](http://docs.gl/es3/glGetShaderInfoLog)(shader, bufSize, length, infoLog)
    /// `shader` class: shader
    /// `length` len: 1
    /// `infoLog` len: bufSize
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn glGetShaderInfoLog(
        shader: GLuint,
        bufSize: GLsizei,
        length: *mut GLsizei,
        infoLog: *mut GLchar,
    ) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glGetShaderInfoLog({:?}, {:?}, {:p}, {:p});",
                shader,
                bufSize,
                length,
                infoLog
            );
        }
        let out = call_atomic_ptr_4arg(
            "glGetShaderInfoLog",
            &glGetShaderInfoLog_p,
            shader,
            bufSize,
            length,
            infoLog,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glGetShaderInfoLog");
        }
        out
    }
    static glGetShaderInfoLog_p: APcv = ap_None();
    /// Tries to load [`glGetShaderInfoLog`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    pub unsafe fn glGetShaderInfoLog_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glGetShaderInfoLog\0",
            &glGetShaderInfoLog_p,
        )
    }
    /// Checks if the pointer for [`glGetShaderInfoLog`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    pub fn glGetShaderInfoLog_is_loaded() -> bool {
        !glGetShaderInfoLog_p.load(RELAX).is_null()
    }

    /// [glGetShaderPrecisionFormat](http://docs.gl/es3/glGetShaderPrecisionFormat)(shadertype, precisiontype, range, precision)
    /// `shadertype` group: ShaderType
    /// `precisiontype` group: PrecisionType
    /// `range` len: 2
    /// `precision` len: 1
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn glGetShaderPrecisionFormat(
        shadertype: GLenum,
        precisiontype: GLenum,
        range: *mut GLint,
        precision: *mut GLint,
    ) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glGetShaderPrecisionFormat({:#X}, {:#X}, {:p}, {:p});",
                shadertype,
                precisiontype,
                range,
                precision
            );
        }
        let out = call_atomic_ptr_4arg(
            "glGetShaderPrecisionFormat",
            &glGetShaderPrecisionFormat_p,
            shadertype,
            precisiontype,
            range,
            precision,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glGetShaderPrecisionFormat");
        }
        out
    }
    static glGetShaderPrecisionFormat_p: APcv = ap_None();
    /// Tries to load [`glGetShaderPrecisionFormat`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    pub unsafe fn glGetShaderPrecisionFormat_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glGetShaderPrecisionFormat\0",
            &glGetShaderPrecisionFormat_p,
        )
    }
    /// Checks if the pointer for [`glGetShaderPrecisionFormat`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    pub fn glGetShaderPrecisionFormat_is_loaded() -> bool {
        !glGetShaderPrecisionFormat_p.load(RELAX).is_null()
    }

    /// [glGetShaderSource](http://docs.gl/es3/glGetShaderSource)(shader, bufSize, length, source)
    /// `shader` class: shader
    /// `length` len: 1
    /// `source` len: bufSize
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn glGetShaderSource(
        shader: GLuint,
        bufSize: GLsizei,
        length: *mut GLsizei,
        source: *mut GLchar,
    ) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glGetShaderSource({:?}, {:?}, {:p}, {:p});",
                shader,
                bufSize,
                length,
                source
            );
        }
        let out = call_atomic_ptr_4arg(
            "glGetShaderSource",
            &glGetShaderSource_p,
            shader,
            bufSize,
            length,
            source,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glGetShaderSource");
        }
        out
    }
    static glGetShaderSource_p: APcv = ap_None();
    /// Tries to load [`glGetShaderSource`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    pub unsafe fn glGetShaderSource_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glGetShaderSource\0",
            &glGetShaderSource_p,
        )
    }
    /// Checks if the pointer for [`glGetShaderSource`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    pub fn glGetShaderSource_is_loaded() -> bool {
        !glGetShaderSource_p.load(RELAX).is_null()
    }

    /// [glGetShaderiv](http://docs.gl/es3/glGetShaderiv)(shader, pname, params)
    /// `shader` class: shader
    /// `pname` group: ShaderParameterName
    /// `params` len: COMPSIZE(pname)
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn glGetShaderiv(shader: GLuint, pname: GLenum, params: *mut GLint) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glGetShaderiv({:?}, {:#X}, {:p});",
                shader,
                pname,
                params
            );
        }
        let out = call_atomic_ptr_3arg("glGetShaderiv", &glGetShaderiv_p, shader, pname, params);
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glGetShaderiv");
        }
        out
    }
    static glGetShaderiv_p: APcv = ap_None();
    /// Tries to load [`glGetShaderiv`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    pub unsafe fn glGetShaderiv_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(get_proc_address, b"glGetShaderiv\0", &glGetShaderiv_p)
    }
    /// Checks if the pointer for [`glGetShaderiv`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    pub fn glGetShaderiv_is_loaded() -> bool {
        !glGetShaderiv_p.load(RELAX).is_null()
    }

    /// [glGetShadingRateImagePaletteNV](http://docs.gl/es3/glGetShadingRateImagePaletteNV)(viewport, entry, rate)
    /// `rate` len: 1
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    #[cfg(any(feature = "GL_NV_shading_rate_image"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_shading_rate_image"))))]
    pub unsafe fn glGetShadingRateImagePaletteNV(
        viewport: GLuint,
        entry: GLuint,
        rate: *mut GLenum,
    ) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glGetShadingRateImagePaletteNV({:?}, {:?}, {:p});",
                viewport,
                entry,
                rate
            );
        }
        let out = call_atomic_ptr_3arg(
            "glGetShadingRateImagePaletteNV",
            &glGetShadingRateImagePaletteNV_p,
            viewport,
            entry,
            rate,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glGetShadingRateImagePaletteNV");
        }
        out
    }
    #[cfg(any(feature = "GL_NV_shading_rate_image"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_shading_rate_image"))))]
    static glGetShadingRateImagePaletteNV_p: APcv = ap_None();
    /// Tries to load [`glGetShadingRateImagePaletteNV`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    #[cfg(any(feature = "GL_NV_shading_rate_image"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_shading_rate_image"))))]
    pub unsafe fn glGetShadingRateImagePaletteNV_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glGetShadingRateImagePaletteNV\0",
            &glGetShadingRateImagePaletteNV_p,
        )
    }
    /// Checks if the pointer for [`glGetShadingRateImagePaletteNV`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    #[cfg(any(feature = "GL_NV_shading_rate_image"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_shading_rate_image"))))]
    pub fn glGetShadingRateImagePaletteNV_is_loaded() -> bool {
        !glGetShadingRateImagePaletteNV_p.load(RELAX).is_null()
    }

    /// [glGetShadingRateSampleLocationivNV](http://docs.gl/es3/glGetShadingRateSampleLocationivNV)(rate, samples, index, location)
    /// `location` len: 3
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    #[cfg(any(feature = "GL_NV_shading_rate_image"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_shading_rate_image"))))]
    pub unsafe fn glGetShadingRateSampleLocationivNV(
        rate: GLenum,
        samples: GLuint,
        index: GLuint,
        location: *mut GLint,
    ) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glGetShadingRateSampleLocationivNV({:#X}, {:?}, {:?}, {:p});",
                rate,
                samples,
                index,
                location
            );
        }
        let out = call_atomic_ptr_4arg(
            "glGetShadingRateSampleLocationivNV",
            &glGetShadingRateSampleLocationivNV_p,
            rate,
            samples,
            index,
            location,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glGetShadingRateSampleLocationivNV");
        }
        out
    }
    #[cfg(any(feature = "GL_NV_shading_rate_image"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_shading_rate_image"))))]
    static glGetShadingRateSampleLocationivNV_p: APcv = ap_None();
    /// Tries to load [`glGetShadingRateSampleLocationivNV`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    #[cfg(any(feature = "GL_NV_shading_rate_image"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_shading_rate_image"))))]
    pub unsafe fn glGetShadingRateSampleLocationivNV_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glGetShadingRateSampleLocationivNV\0",
            &glGetShadingRateSampleLocationivNV_p,
        )
    }
    /// Checks if the pointer for [`glGetShadingRateSampleLocationivNV`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    #[cfg(any(feature = "GL_NV_shading_rate_image"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_shading_rate_image"))))]
    pub fn glGetShadingRateSampleLocationivNV_is_loaded() -> bool {
        !glGetShadingRateSampleLocationivNV_p.load(RELAX).is_null()
    }

    /// [glGetString](http://docs.gl/es3/glGetString)(name)
    /// `name` group: StringName
    /// return value group: String
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn glGetString(name: GLenum) -> *const GLubyte {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!("calling glGetString({:#X});", name);
        }
        let out = call_atomic_ptr_1arg("glGetString", &glGetString_p, name);
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glGetString");
        }
        out
    }
    static glGetString_p: APcv = ap_None();
    /// Tries to load [`glGetString`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    pub unsafe fn glGetString_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(get_proc_address, b"glGetString\0", &glGetString_p)
    }
    /// Checks if the pointer for [`glGetString`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    pub fn glGetString_is_loaded() -> bool {
        !glGetString_p.load(RELAX).is_null()
    }

    /// [glGetStringi](http://docs.gl/es3/glGetString)(name, index)
    /// `name` group: StringName
    /// return value group: String
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn glGetStringi(name: GLenum, index: GLuint) -> *const GLubyte {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!("calling glGetStringi({:#X}, {:?});", name, index);
        }
        let out = call_atomic_ptr_2arg("glGetStringi", &glGetStringi_p, name, index);
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glGetStringi");
        }
        out
    }
    static glGetStringi_p: APcv = ap_None();
    /// Tries to load [`glGetStringi`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    pub unsafe fn glGetStringi_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(get_proc_address, b"glGetStringi\0", &glGetStringi_p)
    }
    /// Checks if the pointer for [`glGetStringi`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    pub fn glGetStringi_is_loaded() -> bool {
        !glGetStringi_p.load(RELAX).is_null()
    }

    /// [glGetSynciv](http://docs.gl/es3/glGetSync)(sync, pname, count, length, values)
    /// `sync` group: sync
    /// `sync` class: sync
    /// `pname` group: SyncParameterName
    /// `length` len: 1
    /// `values` len: count
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn glGetSynciv(
        sync: GLsync,
        pname: GLenum,
        count: GLsizei,
        length: *mut GLsizei,
        values: *mut GLint,
    ) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glGetSynciv({:p}, {:#X}, {:?}, {:p}, {:p});",
                sync,
                pname,
                count,
                length,
                values
            );
        }
        let out = call_atomic_ptr_5arg(
            "glGetSynciv",
            &glGetSynciv_p,
            sync,
            pname,
            count,
            length,
            values,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glGetSynciv");
        }
        out
    }
    static glGetSynciv_p: APcv = ap_None();
    /// Tries to load [`glGetSynciv`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    pub unsafe fn glGetSynciv_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(get_proc_address, b"glGetSynciv\0", &glGetSynciv_p)
    }
    /// Checks if the pointer for [`glGetSynciv`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    pub fn glGetSynciv_is_loaded() -> bool {
        !glGetSynciv_p.load(RELAX).is_null()
    }

    /// [glGetSyncivAPPLE](http://docs.gl/es3/glGetSyncivAPPLE)(sync, pname, count, length, values)
    /// `sync` class: sync
    /// `pname` group: SyncParameterName
    /// `values` len: count
    /// alias of: [`glGetSynciv`]
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    #[cfg(any(feature = "GL_APPLE_sync"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_APPLE_sync"))))]
    pub unsafe fn glGetSyncivAPPLE(
        sync: GLsync,
        pname: GLenum,
        count: GLsizei,
        length: *mut GLsizei,
        values: *mut GLint,
    ) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glGetSyncivAPPLE({:p}, {:#X}, {:?}, {:p}, {:p});",
                sync,
                pname,
                count,
                length,
                values
            );
        }
        let out = call_atomic_ptr_5arg(
            "glGetSyncivAPPLE",
            &glGetSyncivAPPLE_p,
            sync,
            pname,
            count,
            length,
            values,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glGetSyncivAPPLE");
        }
        out
    }
    #[cfg(any(feature = "GL_APPLE_sync"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_APPLE_sync"))))]
    static glGetSyncivAPPLE_p: APcv = ap_None();
    /// Tries to load [`glGetSyncivAPPLE`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    #[cfg(any(feature = "GL_APPLE_sync"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_APPLE_sync"))))]
    pub unsafe fn glGetSyncivAPPLE_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(get_proc_address, b"glGetSyncivAPPLE\0", &glGetSyncivAPPLE_p)
    }
    /// Checks if the pointer for [`glGetSyncivAPPLE`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    #[cfg(any(feature = "GL_APPLE_sync"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_APPLE_sync"))))]
    pub fn glGetSyncivAPPLE_is_loaded() -> bool {
        !glGetSyncivAPPLE_p.load(RELAX).is_null()
    }

    /// [glGetTexLevelParameterfv](http://docs.gl/es3/glGetTexLevelParameter)(target, level, pname, params)
    /// `target` group: TextureTarget
    /// `level` group: CheckedInt32
    /// `pname` group: GetTextureParameter
    /// `params` len: COMPSIZE(pname)
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn glGetTexLevelParameterfv(
        target: GLenum,
        level: GLint,
        pname: GLenum,
        params: *mut GLfloat,
    ) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glGetTexLevelParameterfv({:#X}, {:?}, {:#X}, {:p});",
                target,
                level,
                pname,
                params
            );
        }
        let out = call_atomic_ptr_4arg(
            "glGetTexLevelParameterfv",
            &glGetTexLevelParameterfv_p,
            target,
            level,
            pname,
            params,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glGetTexLevelParameterfv");
        }
        out
    }
    static glGetTexLevelParameterfv_p: APcv = ap_None();
    /// Tries to load [`glGetTexLevelParameterfv`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    pub unsafe fn glGetTexLevelParameterfv_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glGetTexLevelParameterfv\0",
            &glGetTexLevelParameterfv_p,
        )
    }
    /// Checks if the pointer for [`glGetTexLevelParameterfv`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    pub fn glGetTexLevelParameterfv_is_loaded() -> bool {
        !glGetTexLevelParameterfv_p.load(RELAX).is_null()
    }

    /// [glGetTexLevelParameteriv](http://docs.gl/es3/glGetTexLevelParameter)(target, level, pname, params)
    /// `target` group: TextureTarget
    /// `level` group: CheckedInt32
    /// `pname` group: GetTextureParameter
    /// `params` len: COMPSIZE(pname)
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn glGetTexLevelParameteriv(
        target: GLenum,
        level: GLint,
        pname: GLenum,
        params: *mut GLint,
    ) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glGetTexLevelParameteriv({:#X}, {:?}, {:#X}, {:p});",
                target,
                level,
                pname,
                params
            );
        }
        let out = call_atomic_ptr_4arg(
            "glGetTexLevelParameteriv",
            &glGetTexLevelParameteriv_p,
            target,
            level,
            pname,
            params,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glGetTexLevelParameteriv");
        }
        out
    }
    static glGetTexLevelParameteriv_p: APcv = ap_None();
    /// Tries to load [`glGetTexLevelParameteriv`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    pub unsafe fn glGetTexLevelParameteriv_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glGetTexLevelParameteriv\0",
            &glGetTexLevelParameteriv_p,
        )
    }
    /// Checks if the pointer for [`glGetTexLevelParameteriv`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    pub fn glGetTexLevelParameteriv_is_loaded() -> bool {
        !glGetTexLevelParameteriv_p.load(RELAX).is_null()
    }

    /// [glGetTexParameterIiv](http://docs.gl/es3/glGetTexParameter)(target, pname, params)
    /// `target` group: TextureTarget
    /// `pname` group: GetTextureParameter
    /// `params` len: COMPSIZE(pname)
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn glGetTexParameterIiv(target: GLenum, pname: GLenum, params: *mut GLint) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glGetTexParameterIiv({:#X}, {:#X}, {:p});",
                target,
                pname,
                params
            );
        }
        let out = call_atomic_ptr_3arg(
            "glGetTexParameterIiv",
            &glGetTexParameterIiv_p,
            target,
            pname,
            params,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glGetTexParameterIiv");
        }
        out
    }
    static glGetTexParameterIiv_p: APcv = ap_None();
    /// Tries to load [`glGetTexParameterIiv`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    pub unsafe fn glGetTexParameterIiv_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glGetTexParameterIiv\0",
            &glGetTexParameterIiv_p,
        )
    }
    /// Checks if the pointer for [`glGetTexParameterIiv`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    pub fn glGetTexParameterIiv_is_loaded() -> bool {
        !glGetTexParameterIiv_p.load(RELAX).is_null()
    }

    /// [glGetTexParameterIivEXT](http://docs.gl/es3/glGetTexParameterIivEXT)(target, pname, params)
    /// `target` group: TextureTarget
    /// `pname` group: GetTextureParameter
    /// `params` len: COMPSIZE(pname)
    /// alias of: [`glGetTexParameterIiv`]
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    #[cfg(any(feature = "GL_EXT_texture_border_clamp"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_texture_border_clamp"))))]
    pub unsafe fn glGetTexParameterIivEXT(target: GLenum, pname: GLenum, params: *mut GLint) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glGetTexParameterIivEXT({:#X}, {:#X}, {:p});",
                target,
                pname,
                params
            );
        }
        let out = call_atomic_ptr_3arg(
            "glGetTexParameterIivEXT",
            &glGetTexParameterIivEXT_p,
            target,
            pname,
            params,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glGetTexParameterIivEXT");
        }
        out
    }
    #[cfg(any(feature = "GL_EXT_texture_border_clamp"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_texture_border_clamp"))))]
    static glGetTexParameterIivEXT_p: APcv = ap_None();
    /// Tries to load [`glGetTexParameterIivEXT`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    #[cfg(any(feature = "GL_EXT_texture_border_clamp"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_texture_border_clamp"))))]
    pub unsafe fn glGetTexParameterIivEXT_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glGetTexParameterIivEXT\0",
            &glGetTexParameterIivEXT_p,
        )
    }
    /// Checks if the pointer for [`glGetTexParameterIivEXT`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    #[cfg(any(feature = "GL_EXT_texture_border_clamp"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_texture_border_clamp"))))]
    pub fn glGetTexParameterIivEXT_is_loaded() -> bool {
        !glGetTexParameterIivEXT_p.load(RELAX).is_null()
    }

    /// [glGetTexParameterIivOES](http://docs.gl/es3/glGetTexParameterIivOES)(target, pname, params)
    /// `target` group: TextureTarget
    /// `pname` group: GetTextureParameter
    /// `params` len: COMPSIZE(pname)
    /// alias of: [`glGetTexParameterIiv`]
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    #[cfg(any(feature = "GL_OES_texture_border_clamp"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_OES_texture_border_clamp"))))]
    pub unsafe fn glGetTexParameterIivOES(target: GLenum, pname: GLenum, params: *mut GLint) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glGetTexParameterIivOES({:#X}, {:#X}, {:p});",
                target,
                pname,
                params
            );
        }
        let out = call_atomic_ptr_3arg(
            "glGetTexParameterIivOES",
            &glGetTexParameterIivOES_p,
            target,
            pname,
            params,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glGetTexParameterIivOES");
        }
        out
    }
    #[cfg(any(feature = "GL_OES_texture_border_clamp"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_OES_texture_border_clamp"))))]
    static glGetTexParameterIivOES_p: APcv = ap_None();
    /// Tries to load [`glGetTexParameterIivOES`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    #[cfg(any(feature = "GL_OES_texture_border_clamp"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_OES_texture_border_clamp"))))]
    pub unsafe fn glGetTexParameterIivOES_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glGetTexParameterIivOES\0",
            &glGetTexParameterIivOES_p,
        )
    }
    /// Checks if the pointer for [`glGetTexParameterIivOES`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    #[cfg(any(feature = "GL_OES_texture_border_clamp"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_OES_texture_border_clamp"))))]
    pub fn glGetTexParameterIivOES_is_loaded() -> bool {
        !glGetTexParameterIivOES_p.load(RELAX).is_null()
    }

    /// [glGetTexParameterIuiv](http://docs.gl/es3/glGetTexParameter)(target, pname, params)
    /// `target` group: TextureTarget
    /// `pname` group: GetTextureParameter
    /// `params` len: COMPSIZE(pname)
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn glGetTexParameterIuiv(target: GLenum, pname: GLenum, params: *mut GLuint) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glGetTexParameterIuiv({:#X}, {:#X}, {:p});",
                target,
                pname,
                params
            );
        }
        let out = call_atomic_ptr_3arg(
            "glGetTexParameterIuiv",
            &glGetTexParameterIuiv_p,
            target,
            pname,
            params,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glGetTexParameterIuiv");
        }
        out
    }
    static glGetTexParameterIuiv_p: APcv = ap_None();
    /// Tries to load [`glGetTexParameterIuiv`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    pub unsafe fn glGetTexParameterIuiv_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glGetTexParameterIuiv\0",
            &glGetTexParameterIuiv_p,
        )
    }
    /// Checks if the pointer for [`glGetTexParameterIuiv`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    pub fn glGetTexParameterIuiv_is_loaded() -> bool {
        !glGetTexParameterIuiv_p.load(RELAX).is_null()
    }

    /// [glGetTexParameterIuivEXT](http://docs.gl/es3/glGetTexParameterIuivEXT)(target, pname, params)
    /// `target` group: TextureTarget
    /// `pname` group: GetTextureParameter
    /// `params` len: COMPSIZE(pname)
    /// alias of: [`glGetTexParameterIuiv`]
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    #[cfg(any(feature = "GL_EXT_texture_border_clamp"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_texture_border_clamp"))))]
    pub unsafe fn glGetTexParameterIuivEXT(target: GLenum, pname: GLenum, params: *mut GLuint) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glGetTexParameterIuivEXT({:#X}, {:#X}, {:p});",
                target,
                pname,
                params
            );
        }
        let out = call_atomic_ptr_3arg(
            "glGetTexParameterIuivEXT",
            &glGetTexParameterIuivEXT_p,
            target,
            pname,
            params,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glGetTexParameterIuivEXT");
        }
        out
    }
    #[cfg(any(feature = "GL_EXT_texture_border_clamp"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_texture_border_clamp"))))]
    static glGetTexParameterIuivEXT_p: APcv = ap_None();
    /// Tries to load [`glGetTexParameterIuivEXT`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    #[cfg(any(feature = "GL_EXT_texture_border_clamp"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_texture_border_clamp"))))]
    pub unsafe fn glGetTexParameterIuivEXT_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glGetTexParameterIuivEXT\0",
            &glGetTexParameterIuivEXT_p,
        )
    }
    /// Checks if the pointer for [`glGetTexParameterIuivEXT`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    #[cfg(any(feature = "GL_EXT_texture_border_clamp"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_texture_border_clamp"))))]
    pub fn glGetTexParameterIuivEXT_is_loaded() -> bool {
        !glGetTexParameterIuivEXT_p.load(RELAX).is_null()
    }

    /// [glGetTexParameterIuivOES](http://docs.gl/es3/glGetTexParameterIuivOES)(target, pname, params)
    /// `target` group: TextureTarget
    /// `pname` group: GetTextureParameter
    /// `params` len: COMPSIZE(pname)
    /// alias of: [`glGetTexParameterIuiv`]
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    #[cfg(any(feature = "GL_OES_texture_border_clamp"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_OES_texture_border_clamp"))))]
    pub unsafe fn glGetTexParameterIuivOES(target: GLenum, pname: GLenum, params: *mut GLuint) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glGetTexParameterIuivOES({:#X}, {:#X}, {:p});",
                target,
                pname,
                params
            );
        }
        let out = call_atomic_ptr_3arg(
            "glGetTexParameterIuivOES",
            &glGetTexParameterIuivOES_p,
            target,
            pname,
            params,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glGetTexParameterIuivOES");
        }
        out
    }
    #[cfg(any(feature = "GL_OES_texture_border_clamp"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_OES_texture_border_clamp"))))]
    static glGetTexParameterIuivOES_p: APcv = ap_None();
    /// Tries to load [`glGetTexParameterIuivOES`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    #[cfg(any(feature = "GL_OES_texture_border_clamp"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_OES_texture_border_clamp"))))]
    pub unsafe fn glGetTexParameterIuivOES_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glGetTexParameterIuivOES\0",
            &glGetTexParameterIuivOES_p,
        )
    }
    /// Checks if the pointer for [`glGetTexParameterIuivOES`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    #[cfg(any(feature = "GL_OES_texture_border_clamp"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_OES_texture_border_clamp"))))]
    pub fn glGetTexParameterIuivOES_is_loaded() -> bool {
        !glGetTexParameterIuivOES_p.load(RELAX).is_null()
    }

    /// [glGetTexParameterfv](http://docs.gl/es3/glGetTexParameter)(target, pname, params)
    /// `target` group: TextureTarget
    /// `pname` group: GetTextureParameter
    /// `params` len: COMPSIZE(pname)
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn glGetTexParameterfv(target: GLenum, pname: GLenum, params: *mut GLfloat) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glGetTexParameterfv({:#X}, {:#X}, {:p});",
                target,
                pname,
                params
            );
        }
        let out = call_atomic_ptr_3arg(
            "glGetTexParameterfv",
            &glGetTexParameterfv_p,
            target,
            pname,
            params,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glGetTexParameterfv");
        }
        out
    }
    static glGetTexParameterfv_p: APcv = ap_None();
    /// Tries to load [`glGetTexParameterfv`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    pub unsafe fn glGetTexParameterfv_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glGetTexParameterfv\0",
            &glGetTexParameterfv_p,
        )
    }
    /// Checks if the pointer for [`glGetTexParameterfv`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    pub fn glGetTexParameterfv_is_loaded() -> bool {
        !glGetTexParameterfv_p.load(RELAX).is_null()
    }

    /// [glGetTexParameteriv](http://docs.gl/es3/glGetTexParameter)(target, pname, params)
    /// `target` group: TextureTarget
    /// `pname` group: GetTextureParameter
    /// `params` len: COMPSIZE(pname)
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn glGetTexParameteriv(target: GLenum, pname: GLenum, params: *mut GLint) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glGetTexParameteriv({:#X}, {:#X}, {:p});",
                target,
                pname,
                params
            );
        }
        let out = call_atomic_ptr_3arg(
            "glGetTexParameteriv",
            &glGetTexParameteriv_p,
            target,
            pname,
            params,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glGetTexParameteriv");
        }
        out
    }
    static glGetTexParameteriv_p: APcv = ap_None();
    /// Tries to load [`glGetTexParameteriv`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    pub unsafe fn glGetTexParameteriv_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glGetTexParameteriv\0",
            &glGetTexParameteriv_p,
        )
    }
    /// Checks if the pointer for [`glGetTexParameteriv`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    pub fn glGetTexParameteriv_is_loaded() -> bool {
        !glGetTexParameteriv_p.load(RELAX).is_null()
    }

    /// [glGetTextureHandleIMG](http://docs.gl/es3/glGetTextureHandleIMG)(texture)
    /// `texture` class: texture
    /// alias of: [`glGetTextureHandleARB`]
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    #[cfg(any(feature = "GL_IMG_bindless_texture"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_IMG_bindless_texture"))))]
    pub unsafe fn glGetTextureHandleIMG(texture: GLuint) -> GLuint64 {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!("calling glGetTextureHandleIMG({:?});", texture);
        }
        let out = call_atomic_ptr_1arg("glGetTextureHandleIMG", &glGetTextureHandleIMG_p, texture);
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glGetTextureHandleIMG");
        }
        out
    }
    #[cfg(any(feature = "GL_IMG_bindless_texture"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_IMG_bindless_texture"))))]
    static glGetTextureHandleIMG_p: APcv = ap_None();
    /// Tries to load [`glGetTextureHandleIMG`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    #[cfg(any(feature = "GL_IMG_bindless_texture"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_IMG_bindless_texture"))))]
    pub unsafe fn glGetTextureHandleIMG_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glGetTextureHandleIMG\0",
            &glGetTextureHandleIMG_p,
        )
    }
    /// Checks if the pointer for [`glGetTextureHandleIMG`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    #[cfg(any(feature = "GL_IMG_bindless_texture"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_IMG_bindless_texture"))))]
    pub fn glGetTextureHandleIMG_is_loaded() -> bool {
        !glGetTextureHandleIMG_p.load(RELAX).is_null()
    }

    /// [glGetTextureHandleNV](http://docs.gl/es3/glGetTextureHandleNV)(texture)
    /// `texture` class: texture
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    #[cfg(any(feature = "GL_NV_bindless_texture"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_bindless_texture"))))]
    pub unsafe fn glGetTextureHandleNV(texture: GLuint) -> GLuint64 {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!("calling glGetTextureHandleNV({:?});", texture);
        }
        let out = call_atomic_ptr_1arg("glGetTextureHandleNV", &glGetTextureHandleNV_p, texture);
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glGetTextureHandleNV");
        }
        out
    }
    #[cfg(any(feature = "GL_NV_bindless_texture"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_bindless_texture"))))]
    static glGetTextureHandleNV_p: APcv = ap_None();
    /// Tries to load [`glGetTextureHandleNV`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    #[cfg(any(feature = "GL_NV_bindless_texture"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_bindless_texture"))))]
    pub unsafe fn glGetTextureHandleNV_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glGetTextureHandleNV\0",
            &glGetTextureHandleNV_p,
        )
    }
    /// Checks if the pointer for [`glGetTextureHandleNV`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    #[cfg(any(feature = "GL_NV_bindless_texture"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_bindless_texture"))))]
    pub fn glGetTextureHandleNV_is_loaded() -> bool {
        !glGetTextureHandleNV_p.load(RELAX).is_null()
    }

    /// [glGetTextureSamplerHandleIMG](http://docs.gl/es3/glGetTextureSamplerHandleIMG)(texture, sampler)
    /// `texture` class: texture
    /// `sampler` class: sampler
    /// alias of: [`glGetTextureSamplerHandleARB`]
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    #[cfg(any(feature = "GL_IMG_bindless_texture"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_IMG_bindless_texture"))))]
    pub unsafe fn glGetTextureSamplerHandleIMG(texture: GLuint, sampler: GLuint) -> GLuint64 {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glGetTextureSamplerHandleIMG({:?}, {:?});",
                texture,
                sampler
            );
        }
        let out = call_atomic_ptr_2arg(
            "glGetTextureSamplerHandleIMG",
            &glGetTextureSamplerHandleIMG_p,
            texture,
            sampler,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glGetTextureSamplerHandleIMG");
        }
        out
    }
    #[cfg(any(feature = "GL_IMG_bindless_texture"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_IMG_bindless_texture"))))]
    static glGetTextureSamplerHandleIMG_p: APcv = ap_None();
    /// Tries to load [`glGetTextureSamplerHandleIMG`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    #[cfg(any(feature = "GL_IMG_bindless_texture"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_IMG_bindless_texture"))))]
    pub unsafe fn glGetTextureSamplerHandleIMG_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glGetTextureSamplerHandleIMG\0",
            &glGetTextureSamplerHandleIMG_p,
        )
    }
    /// Checks if the pointer for [`glGetTextureSamplerHandleIMG`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    #[cfg(any(feature = "GL_IMG_bindless_texture"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_IMG_bindless_texture"))))]
    pub fn glGetTextureSamplerHandleIMG_is_loaded() -> bool {
        !glGetTextureSamplerHandleIMG_p.load(RELAX).is_null()
    }

    /// [glGetTextureSamplerHandleNV](http://docs.gl/es3/glGetTextureSamplerHandleNV)(texture, sampler)
    /// `texture` class: texture
    /// `sampler` class: sampler
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    #[cfg(any(feature = "GL_NV_bindless_texture"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_bindless_texture"))))]
    pub unsafe fn glGetTextureSamplerHandleNV(texture: GLuint, sampler: GLuint) -> GLuint64 {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glGetTextureSamplerHandleNV({:?}, {:?});",
                texture,
                sampler
            );
        }
        let out = call_atomic_ptr_2arg(
            "glGetTextureSamplerHandleNV",
            &glGetTextureSamplerHandleNV_p,
            texture,
            sampler,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glGetTextureSamplerHandleNV");
        }
        out
    }
    #[cfg(any(feature = "GL_NV_bindless_texture"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_bindless_texture"))))]
    static glGetTextureSamplerHandleNV_p: APcv = ap_None();
    /// Tries to load [`glGetTextureSamplerHandleNV`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    #[cfg(any(feature = "GL_NV_bindless_texture"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_bindless_texture"))))]
    pub unsafe fn glGetTextureSamplerHandleNV_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glGetTextureSamplerHandleNV\0",
            &glGetTextureSamplerHandleNV_p,
        )
    }
    /// Checks if the pointer for [`glGetTextureSamplerHandleNV`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    #[cfg(any(feature = "GL_NV_bindless_texture"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_bindless_texture"))))]
    pub fn glGetTextureSamplerHandleNV_is_loaded() -> bool {
        !glGetTextureSamplerHandleNV_p.load(RELAX).is_null()
    }

    /// [glGetTransformFeedbackVarying](http://docs.gl/es3/glGetTransformFeedbackVarying)(program, index, bufSize, length, size, type_, name)
    /// `program` class: program
    /// `length` len: 1
    /// `size` len: 1
    /// `type_` group: AttributeType
    /// `type_` len: 1
    /// `name` len: bufSize
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn glGetTransformFeedbackVarying(
        program: GLuint,
        index: GLuint,
        bufSize: GLsizei,
        length: *mut GLsizei,
        size: *mut GLsizei,
        type_: *mut GLenum,
        name: *mut GLchar,
    ) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glGetTransformFeedbackVarying({:?}, {:?}, {:?}, {:p}, {:p}, {:p}, {:p});",
                program,
                index,
                bufSize,
                length,
                size,
                type_,
                name
            );
        }
        let out = call_atomic_ptr_7arg(
            "glGetTransformFeedbackVarying",
            &glGetTransformFeedbackVarying_p,
            program,
            index,
            bufSize,
            length,
            size,
            type_,
            name,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glGetTransformFeedbackVarying");
        }
        out
    }
    static glGetTransformFeedbackVarying_p: APcv = ap_None();
    /// Tries to load [`glGetTransformFeedbackVarying`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    pub unsafe fn glGetTransformFeedbackVarying_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glGetTransformFeedbackVarying\0",
            &glGetTransformFeedbackVarying_p,
        )
    }
    /// Checks if the pointer for [`glGetTransformFeedbackVarying`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    pub fn glGetTransformFeedbackVarying_is_loaded() -> bool {
        !glGetTransformFeedbackVarying_p.load(RELAX).is_null()
    }

    /// [glGetTranslatedShaderSourceANGLE](http://docs.gl/es3/glGetTranslatedShaderSourceANGLE)(shader, bufSize, length, source)
    /// `shader` class: shader
    /// `length` len: 1
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    #[cfg(any(feature = "GL_ANGLE_translated_shader_source"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_ANGLE_translated_shader_source"))))]
    pub unsafe fn glGetTranslatedShaderSourceANGLE(
        shader: GLuint,
        bufSize: GLsizei,
        length: *mut GLsizei,
        source: *mut GLchar,
    ) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glGetTranslatedShaderSourceANGLE({:?}, {:?}, {:p}, {:p});",
                shader,
                bufSize,
                length,
                source
            );
        }
        let out = call_atomic_ptr_4arg(
            "glGetTranslatedShaderSourceANGLE",
            &glGetTranslatedShaderSourceANGLE_p,
            shader,
            bufSize,
            length,
            source,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glGetTranslatedShaderSourceANGLE");
        }
        out
    }
    #[cfg(any(feature = "GL_ANGLE_translated_shader_source"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_ANGLE_translated_shader_source"))))]
    static glGetTranslatedShaderSourceANGLE_p: APcv = ap_None();
    /// Tries to load [`glGetTranslatedShaderSourceANGLE`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    #[cfg(any(feature = "GL_ANGLE_translated_shader_source"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_ANGLE_translated_shader_source"))))]
    pub unsafe fn glGetTranslatedShaderSourceANGLE_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glGetTranslatedShaderSourceANGLE\0",
            &glGetTranslatedShaderSourceANGLE_p,
        )
    }
    /// Checks if the pointer for [`glGetTranslatedShaderSourceANGLE`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    #[cfg(any(feature = "GL_ANGLE_translated_shader_source"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_ANGLE_translated_shader_source"))))]
    pub fn glGetTranslatedShaderSourceANGLE_is_loaded() -> bool {
        !glGetTranslatedShaderSourceANGLE_p.load(RELAX).is_null()
    }

    /// [glGetUniformBlockIndex](http://docs.gl/es3/glGetUniformBlockIndex)(program, uniformBlockName)
    /// `program` class: program
    /// `uniformBlockName` len: COMPSIZE()
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn glGetUniformBlockIndex(
        program: GLuint,
        uniformBlockName: *const GLchar,
    ) -> GLuint {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glGetUniformBlockIndex({:?}, {:p});",
                program,
                uniformBlockName
            );
        }
        let out = call_atomic_ptr_2arg(
            "glGetUniformBlockIndex",
            &glGetUniformBlockIndex_p,
            program,
            uniformBlockName,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glGetUniformBlockIndex");
        }
        out
    }
    static glGetUniformBlockIndex_p: APcv = ap_None();
    /// Tries to load [`glGetUniformBlockIndex`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    pub unsafe fn glGetUniformBlockIndex_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glGetUniformBlockIndex\0",
            &glGetUniformBlockIndex_p,
        )
    }
    /// Checks if the pointer for [`glGetUniformBlockIndex`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    pub fn glGetUniformBlockIndex_is_loaded() -> bool {
        !glGetUniformBlockIndex_p.load(RELAX).is_null()
    }

    /// [glGetUniformIndices](http://docs.gl/es3/glGetUniformIndices)(program, uniformCount, uniformNames, uniformIndices)
    /// `program` class: program
    /// `uniformNames` len: COMPSIZE(uniformCount)
    /// `uniformIndices` len: COMPSIZE(uniformCount)
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn glGetUniformIndices(
        program: GLuint,
        uniformCount: GLsizei,
        uniformNames: *const *const GLchar,
        uniformIndices: *mut GLuint,
    ) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glGetUniformIndices({:?}, {:?}, {:p}, {:p});",
                program,
                uniformCount,
                uniformNames,
                uniformIndices
            );
        }
        let out = call_atomic_ptr_4arg(
            "glGetUniformIndices",
            &glGetUniformIndices_p,
            program,
            uniformCount,
            uniformNames,
            uniformIndices,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glGetUniformIndices");
        }
        out
    }
    static glGetUniformIndices_p: APcv = ap_None();
    /// Tries to load [`glGetUniformIndices`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    pub unsafe fn glGetUniformIndices_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glGetUniformIndices\0",
            &glGetUniformIndices_p,
        )
    }
    /// Checks if the pointer for [`glGetUniformIndices`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    pub fn glGetUniformIndices_is_loaded() -> bool {
        !glGetUniformIndices_p.load(RELAX).is_null()
    }

    /// [glGetUniformLocation](http://docs.gl/es3/glGetUniformLocation)(program, name)
    /// `program` class: program
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn glGetUniformLocation(program: GLuint, name: *const GLchar) -> GLint {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!("calling glGetUniformLocation({:?}, {:p});", program, name);
        }
        let out = call_atomic_ptr_2arg(
            "glGetUniformLocation",
            &glGetUniformLocation_p,
            program,
            name,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glGetUniformLocation");
        }
        out
    }
    static glGetUniformLocation_p: APcv = ap_None();
    /// Tries to load [`glGetUniformLocation`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    pub unsafe fn glGetUniformLocation_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glGetUniformLocation\0",
            &glGetUniformLocation_p,
        )
    }
    /// Checks if the pointer for [`glGetUniformLocation`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    pub fn glGetUniformLocation_is_loaded() -> bool {
        !glGetUniformLocation_p.load(RELAX).is_null()
    }

    /// [glGetUniformfv](http://docs.gl/es3/glGetUniform)(program, location, params)
    /// `program` class: program
    /// `params` len: COMPSIZE(program,location)
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn glGetUniformfv(program: GLuint, location: GLint, params: *mut GLfloat) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glGetUniformfv({:?}, {:?}, {:p});",
                program,
                location,
                params
            );
        }
        let out = call_atomic_ptr_3arg(
            "glGetUniformfv",
            &glGetUniformfv_p,
            program,
            location,
            params,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glGetUniformfv");
        }
        out
    }
    static glGetUniformfv_p: APcv = ap_None();
    /// Tries to load [`glGetUniformfv`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    pub unsafe fn glGetUniformfv_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(get_proc_address, b"glGetUniformfv\0", &glGetUniformfv_p)
    }
    /// Checks if the pointer for [`glGetUniformfv`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    pub fn glGetUniformfv_is_loaded() -> bool {
        !glGetUniformfv_p.load(RELAX).is_null()
    }

    /// [glGetUniformi64vNV](http://docs.gl/es3/glGetUniformi64vNV)(program, location, params)
    /// `program` class: program
    /// `params` len: COMPSIZE(program,location)
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    #[cfg(any(feature = "GL_NV_gpu_shader5"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_gpu_shader5"))))]
    pub unsafe fn glGetUniformi64vNV(program: GLuint, location: GLint, params: *mut GLint64EXT) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glGetUniformi64vNV({:?}, {:?}, {:p});",
                program,
                location,
                params
            );
        }
        let out = call_atomic_ptr_3arg(
            "glGetUniformi64vNV",
            &glGetUniformi64vNV_p,
            program,
            location,
            params,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glGetUniformi64vNV");
        }
        out
    }
    #[cfg(any(feature = "GL_NV_gpu_shader5"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_gpu_shader5"))))]
    static glGetUniformi64vNV_p: APcv = ap_None();
    /// Tries to load [`glGetUniformi64vNV`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    #[cfg(any(feature = "GL_NV_gpu_shader5"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_gpu_shader5"))))]
    pub unsafe fn glGetUniformi64vNV_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glGetUniformi64vNV\0",
            &glGetUniformi64vNV_p,
        )
    }
    /// Checks if the pointer for [`glGetUniformi64vNV`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    #[cfg(any(feature = "GL_NV_gpu_shader5"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_gpu_shader5"))))]
    pub fn glGetUniformi64vNV_is_loaded() -> bool {
        !glGetUniformi64vNV_p.load(RELAX).is_null()
    }

    /// [glGetUniformiv](http://docs.gl/es3/glGetUniform)(program, location, params)
    /// `program` class: program
    /// `params` len: COMPSIZE(program,location)
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn glGetUniformiv(program: GLuint, location: GLint, params: *mut GLint) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glGetUniformiv({:?}, {:?}, {:p});",
                program,
                location,
                params
            );
        }
        let out = call_atomic_ptr_3arg(
            "glGetUniformiv",
            &glGetUniformiv_p,
            program,
            location,
            params,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glGetUniformiv");
        }
        out
    }
    static glGetUniformiv_p: APcv = ap_None();
    /// Tries to load [`glGetUniformiv`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    pub unsafe fn glGetUniformiv_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(get_proc_address, b"glGetUniformiv\0", &glGetUniformiv_p)
    }
    /// Checks if the pointer for [`glGetUniformiv`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    pub fn glGetUniformiv_is_loaded() -> bool {
        !glGetUniformiv_p.load(RELAX).is_null()
    }

    /// [glGetUniformuiv](http://docs.gl/es3/glGetUniform)(program, location, params)
    /// `program` class: program
    /// `params` len: COMPSIZE(program,location)
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn glGetUniformuiv(program: GLuint, location: GLint, params: *mut GLuint) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glGetUniformuiv({:?}, {:?}, {:p});",
                program,
                location,
                params
            );
        }
        let out = call_atomic_ptr_3arg(
            "glGetUniformuiv",
            &glGetUniformuiv_p,
            program,
            location,
            params,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glGetUniformuiv");
        }
        out
    }
    static glGetUniformuiv_p: APcv = ap_None();
    /// Tries to load [`glGetUniformuiv`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    pub unsafe fn glGetUniformuiv_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(get_proc_address, b"glGetUniformuiv\0", &glGetUniformuiv_p)
    }
    /// Checks if the pointer for [`glGetUniformuiv`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    pub fn glGetUniformuiv_is_loaded() -> bool {
        !glGetUniformuiv_p.load(RELAX).is_null()
    }

    /// [glGetUnsignedBytei_vEXT](http://docs.gl/es3/glGetUnsignedBytei_vEXT)(target, index, data)
    /// `data` len: COMPSIZE(target)
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    #[cfg(any(feature = "GL_EXT_memory_object", feature = "GL_EXT_semaphore"))]
    #[cfg_attr(
        docs_rs,
        doc(cfg(any(feature = "GL_EXT_memory_object", feature = "GL_EXT_semaphore")))
    )]
    pub unsafe fn glGetUnsignedBytei_vEXT(target: GLenum, index: GLuint, data: *mut GLubyte) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glGetUnsignedBytei_vEXT({:#X}, {:?}, {:p});",
                target,
                index,
                data
            );
        }
        let out = call_atomic_ptr_3arg(
            "glGetUnsignedBytei_vEXT",
            &glGetUnsignedBytei_vEXT_p,
            target,
            index,
            data,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glGetUnsignedBytei_vEXT");
        }
        out
    }
    #[cfg(any(feature = "GL_EXT_memory_object", feature = "GL_EXT_semaphore"))]
    #[cfg_attr(
        docs_rs,
        doc(cfg(any(feature = "GL_EXT_memory_object", feature = "GL_EXT_semaphore")))
    )]
    static glGetUnsignedBytei_vEXT_p: APcv = ap_None();
    /// Tries to load [`glGetUnsignedBytei_vEXT`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    #[cfg(any(feature = "GL_EXT_memory_object", feature = "GL_EXT_semaphore"))]
    #[cfg_attr(
        docs_rs,
        doc(cfg(any(feature = "GL_EXT_memory_object", feature = "GL_EXT_semaphore")))
    )]
    pub unsafe fn glGetUnsignedBytei_vEXT_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glGetUnsignedBytei_vEXT\0",
            &glGetUnsignedBytei_vEXT_p,
        )
    }
    /// Checks if the pointer for [`glGetUnsignedBytei_vEXT`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    #[cfg(any(feature = "GL_EXT_memory_object", feature = "GL_EXT_semaphore"))]
    #[cfg_attr(
        docs_rs,
        doc(cfg(any(feature = "GL_EXT_memory_object", feature = "GL_EXT_semaphore")))
    )]
    pub fn glGetUnsignedBytei_vEXT_is_loaded() -> bool {
        !glGetUnsignedBytei_vEXT_p.load(RELAX).is_null()
    }

    /// [glGetUnsignedBytevEXT](http://docs.gl/es3/glGetUnsignedBytevEXT)(pname, data)
    /// `pname` group: GetPName
    /// `data` len: COMPSIZE(pname)
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    #[cfg(any(feature = "GL_EXT_memory_object", feature = "GL_EXT_semaphore"))]
    #[cfg_attr(
        docs_rs,
        doc(cfg(any(feature = "GL_EXT_memory_object", feature = "GL_EXT_semaphore")))
    )]
    pub unsafe fn glGetUnsignedBytevEXT(pname: GLenum, data: *mut GLubyte) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!("calling glGetUnsignedBytevEXT({:#X}, {:p});", pname, data);
        }
        let out = call_atomic_ptr_2arg(
            "glGetUnsignedBytevEXT",
            &glGetUnsignedBytevEXT_p,
            pname,
            data,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glGetUnsignedBytevEXT");
        }
        out
    }
    #[cfg(any(feature = "GL_EXT_memory_object", feature = "GL_EXT_semaphore"))]
    #[cfg_attr(
        docs_rs,
        doc(cfg(any(feature = "GL_EXT_memory_object", feature = "GL_EXT_semaphore")))
    )]
    static glGetUnsignedBytevEXT_p: APcv = ap_None();
    /// Tries to load [`glGetUnsignedBytevEXT`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    #[cfg(any(feature = "GL_EXT_memory_object", feature = "GL_EXT_semaphore"))]
    #[cfg_attr(
        docs_rs,
        doc(cfg(any(feature = "GL_EXT_memory_object", feature = "GL_EXT_semaphore")))
    )]
    pub unsafe fn glGetUnsignedBytevEXT_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glGetUnsignedBytevEXT\0",
            &glGetUnsignedBytevEXT_p,
        )
    }
    /// Checks if the pointer for [`glGetUnsignedBytevEXT`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    #[cfg(any(feature = "GL_EXT_memory_object", feature = "GL_EXT_semaphore"))]
    #[cfg_attr(
        docs_rs,
        doc(cfg(any(feature = "GL_EXT_memory_object", feature = "GL_EXT_semaphore")))
    )]
    pub fn glGetUnsignedBytevEXT_is_loaded() -> bool {
        !glGetUnsignedBytevEXT_p.load(RELAX).is_null()
    }

    /// [glGetVertexAttribIiv](http://docs.gl/es3/glGetVertexAttrib)(index, pname, params)
    /// `pname` group: VertexAttribEnum
    /// `params` len: 1
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn glGetVertexAttribIiv(index: GLuint, pname: GLenum, params: *mut GLint) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glGetVertexAttribIiv({:?}, {:#X}, {:p});",
                index,
                pname,
                params
            );
        }
        let out = call_atomic_ptr_3arg(
            "glGetVertexAttribIiv",
            &glGetVertexAttribIiv_p,
            index,
            pname,
            params,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glGetVertexAttribIiv");
        }
        out
    }
    static glGetVertexAttribIiv_p: APcv = ap_None();
    /// Tries to load [`glGetVertexAttribIiv`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    pub unsafe fn glGetVertexAttribIiv_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glGetVertexAttribIiv\0",
            &glGetVertexAttribIiv_p,
        )
    }
    /// Checks if the pointer for [`glGetVertexAttribIiv`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    pub fn glGetVertexAttribIiv_is_loaded() -> bool {
        !glGetVertexAttribIiv_p.load(RELAX).is_null()
    }

    /// [glGetVertexAttribIuiv](http://docs.gl/es3/glGetVertexAttrib)(index, pname, params)
    /// `pname` group: VertexAttribEnum
    /// `params` len: 1
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn glGetVertexAttribIuiv(index: GLuint, pname: GLenum, params: *mut GLuint) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glGetVertexAttribIuiv({:?}, {:#X}, {:p});",
                index,
                pname,
                params
            );
        }
        let out = call_atomic_ptr_3arg(
            "glGetVertexAttribIuiv",
            &glGetVertexAttribIuiv_p,
            index,
            pname,
            params,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glGetVertexAttribIuiv");
        }
        out
    }
    static glGetVertexAttribIuiv_p: APcv = ap_None();
    /// Tries to load [`glGetVertexAttribIuiv`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    pub unsafe fn glGetVertexAttribIuiv_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glGetVertexAttribIuiv\0",
            &glGetVertexAttribIuiv_p,
        )
    }
    /// Checks if the pointer for [`glGetVertexAttribIuiv`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    pub fn glGetVertexAttribIuiv_is_loaded() -> bool {
        !glGetVertexAttribIuiv_p.load(RELAX).is_null()
    }

    /// [glGetVertexAttribPointerv](http://docs.gl/es3/glGetVertexAttribPointerv)(index, pname, pointer)
    /// `pname` group: VertexAttribPointerPropertyARB
    /// `pointer` len: 1
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn glGetVertexAttribPointerv(
        index: GLuint,
        pname: GLenum,
        pointer: *mut *mut c_void,
    ) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glGetVertexAttribPointerv({:?}, {:#X}, {:p});",
                index,
                pname,
                pointer
            );
        }
        let out = call_atomic_ptr_3arg(
            "glGetVertexAttribPointerv",
            &glGetVertexAttribPointerv_p,
            index,
            pname,
            pointer,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glGetVertexAttribPointerv");
        }
        out
    }
    static glGetVertexAttribPointerv_p: APcv = ap_None();
    /// Tries to load [`glGetVertexAttribPointerv`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    pub unsafe fn glGetVertexAttribPointerv_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glGetVertexAttribPointerv\0",
            &glGetVertexAttribPointerv_p,
        )
    }
    /// Checks if the pointer for [`glGetVertexAttribPointerv`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    pub fn glGetVertexAttribPointerv_is_loaded() -> bool {
        !glGetVertexAttribPointerv_p.load(RELAX).is_null()
    }

    /// [glGetVertexAttribfv](http://docs.gl/es3/glGetVertexAttrib)(index, pname, params)
    /// `pname` group: VertexAttribPropertyARB
    /// `params` len: 4
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn glGetVertexAttribfv(index: GLuint, pname: GLenum, params: *mut GLfloat) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glGetVertexAttribfv({:?}, {:#X}, {:p});",
                index,
                pname,
                params
            );
        }
        let out = call_atomic_ptr_3arg(
            "glGetVertexAttribfv",
            &glGetVertexAttribfv_p,
            index,
            pname,
            params,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glGetVertexAttribfv");
        }
        out
    }
    static glGetVertexAttribfv_p: APcv = ap_None();
    /// Tries to load [`glGetVertexAttribfv`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    pub unsafe fn glGetVertexAttribfv_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glGetVertexAttribfv\0",
            &glGetVertexAttribfv_p,
        )
    }
    /// Checks if the pointer for [`glGetVertexAttribfv`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    pub fn glGetVertexAttribfv_is_loaded() -> bool {
        !glGetVertexAttribfv_p.load(RELAX).is_null()
    }

    /// [glGetVertexAttribiv](http://docs.gl/es3/glGetVertexAttrib)(index, pname, params)
    /// `pname` group: VertexAttribPropertyARB
    /// `params` len: 4
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn glGetVertexAttribiv(index: GLuint, pname: GLenum, params: *mut GLint) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glGetVertexAttribiv({:?}, {:#X}, {:p});",
                index,
                pname,
                params
            );
        }
        let out = call_atomic_ptr_3arg(
            "glGetVertexAttribiv",
            &glGetVertexAttribiv_p,
            index,
            pname,
            params,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glGetVertexAttribiv");
        }
        out
    }
    static glGetVertexAttribiv_p: APcv = ap_None();
    /// Tries to load [`glGetVertexAttribiv`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    pub unsafe fn glGetVertexAttribiv_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glGetVertexAttribiv\0",
            &glGetVertexAttribiv_p,
        )
    }
    /// Checks if the pointer for [`glGetVertexAttribiv`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    pub fn glGetVertexAttribiv_is_loaded() -> bool {
        !glGetVertexAttribiv_p.load(RELAX).is_null()
    }

    /// [glGetVkProcAddrNV](http://docs.gl/es3/glGetVkProcAddrNV)(name)
    /// `name` len: COMPSIZE(name)
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    #[cfg(any(feature = "GL_NV_draw_vulkan_image"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_draw_vulkan_image"))))]
    pub unsafe fn glGetVkProcAddrNV(name: *const GLchar) -> GLVULKANPROCNV {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!("calling glGetVkProcAddrNV({:p});", name);
        }
        let out = call_atomic_ptr_1arg("glGetVkProcAddrNV", &glGetVkProcAddrNV_p, name);
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glGetVkProcAddrNV");
        }
        out
    }
    #[cfg(any(feature = "GL_NV_draw_vulkan_image"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_draw_vulkan_image"))))]
    static glGetVkProcAddrNV_p: APcv = ap_None();
    /// Tries to load [`glGetVkProcAddrNV`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    #[cfg(any(feature = "GL_NV_draw_vulkan_image"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_draw_vulkan_image"))))]
    pub unsafe fn glGetVkProcAddrNV_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glGetVkProcAddrNV\0",
            &glGetVkProcAddrNV_p,
        )
    }
    /// Checks if the pointer for [`glGetVkProcAddrNV`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    #[cfg(any(feature = "GL_NV_draw_vulkan_image"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_draw_vulkan_image"))))]
    pub fn glGetVkProcAddrNV_is_loaded() -> bool {
        !glGetVkProcAddrNV_p.load(RELAX).is_null()
    }

    /// [glGetnUniformfv](http://docs.gl/es3/glGetnUniform)(program, location, bufSize, params)
    /// `program` class: program
    /// `params` len: bufSize / 4
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn glGetnUniformfv(
        program: GLuint,
        location: GLint,
        bufSize: GLsizei,
        params: *mut GLfloat,
    ) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glGetnUniformfv({:?}, {:?}, {:?}, {:p});",
                program,
                location,
                bufSize,
                params
            );
        }
        let out = call_atomic_ptr_4arg(
            "glGetnUniformfv",
            &glGetnUniformfv_p,
            program,
            location,
            bufSize,
            params,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glGetnUniformfv");
        }
        out
    }
    static glGetnUniformfv_p: APcv = ap_None();
    /// Tries to load [`glGetnUniformfv`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    pub unsafe fn glGetnUniformfv_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(get_proc_address, b"glGetnUniformfv\0", &glGetnUniformfv_p)
    }
    /// Checks if the pointer for [`glGetnUniformfv`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    pub fn glGetnUniformfv_is_loaded() -> bool {
        !glGetnUniformfv_p.load(RELAX).is_null()
    }

    /// [glGetnUniformfvEXT](http://docs.gl/es3/glGetnUniformfvEXT)(program, location, bufSize, params)
    /// `program` class: program
    /// `params` len: bufSize / 4
    /// alias of: [`glGetnUniformfv`]
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    #[cfg(any(feature = "GL_EXT_robustness"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_robustness"))))]
    pub unsafe fn glGetnUniformfvEXT(
        program: GLuint,
        location: GLint,
        bufSize: GLsizei,
        params: *mut GLfloat,
    ) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glGetnUniformfvEXT({:?}, {:?}, {:?}, {:p});",
                program,
                location,
                bufSize,
                params
            );
        }
        let out = call_atomic_ptr_4arg(
            "glGetnUniformfvEXT",
            &glGetnUniformfvEXT_p,
            program,
            location,
            bufSize,
            params,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glGetnUniformfvEXT");
        }
        out
    }
    #[cfg(any(feature = "GL_EXT_robustness"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_robustness"))))]
    static glGetnUniformfvEXT_p: APcv = ap_None();
    /// Tries to load [`glGetnUniformfvEXT`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    #[cfg(any(feature = "GL_EXT_robustness"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_robustness"))))]
    pub unsafe fn glGetnUniformfvEXT_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glGetnUniformfvEXT\0",
            &glGetnUniformfvEXT_p,
        )
    }
    /// Checks if the pointer for [`glGetnUniformfvEXT`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    #[cfg(any(feature = "GL_EXT_robustness"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_robustness"))))]
    pub fn glGetnUniformfvEXT_is_loaded() -> bool {
        !glGetnUniformfvEXT_p.load(RELAX).is_null()
    }

    /// [glGetnUniformfvKHR](http://docs.gl/es3/glGetnUniformfvKHR)(program, location, bufSize, params)
    /// `program` class: program
    /// `params` len: bufSize / 4
    /// alias of: [`glGetnUniformfv`]
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    #[cfg(any(feature = "GL_KHR_robustness"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_KHR_robustness"))))]
    pub unsafe fn glGetnUniformfvKHR(
        program: GLuint,
        location: GLint,
        bufSize: GLsizei,
        params: *mut GLfloat,
    ) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glGetnUniformfvKHR({:?}, {:?}, {:?}, {:p});",
                program,
                location,
                bufSize,
                params
            );
        }
        let out = call_atomic_ptr_4arg(
            "glGetnUniformfvKHR",
            &glGetnUniformfvKHR_p,
            program,
            location,
            bufSize,
            params,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glGetnUniformfvKHR");
        }
        out
    }
    #[cfg(any(feature = "GL_KHR_robustness"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_KHR_robustness"))))]
    static glGetnUniformfvKHR_p: APcv = ap_None();
    /// Tries to load [`glGetnUniformfvKHR`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    #[cfg(any(feature = "GL_KHR_robustness"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_KHR_robustness"))))]
    pub unsafe fn glGetnUniformfvKHR_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glGetnUniformfvKHR\0",
            &glGetnUniformfvKHR_p,
        )
    }
    /// Checks if the pointer for [`glGetnUniformfvKHR`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    #[cfg(any(feature = "GL_KHR_robustness"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_KHR_robustness"))))]
    pub fn glGetnUniformfvKHR_is_loaded() -> bool {
        !glGetnUniformfvKHR_p.load(RELAX).is_null()
    }

    /// [glGetnUniformiv](http://docs.gl/es3/glGetnUniform)(program, location, bufSize, params)
    /// `program` class: program
    /// `params` len: bufSize / 4
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn glGetnUniformiv(
        program: GLuint,
        location: GLint,
        bufSize: GLsizei,
        params: *mut GLint,
    ) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glGetnUniformiv({:?}, {:?}, {:?}, {:p});",
                program,
                location,
                bufSize,
                params
            );
        }
        let out = call_atomic_ptr_4arg(
            "glGetnUniformiv",
            &glGetnUniformiv_p,
            program,
            location,
            bufSize,
            params,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glGetnUniformiv");
        }
        out
    }
    static glGetnUniformiv_p: APcv = ap_None();
    /// Tries to load [`glGetnUniformiv`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    pub unsafe fn glGetnUniformiv_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(get_proc_address, b"glGetnUniformiv\0", &glGetnUniformiv_p)
    }
    /// Checks if the pointer for [`glGetnUniformiv`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    pub fn glGetnUniformiv_is_loaded() -> bool {
        !glGetnUniformiv_p.load(RELAX).is_null()
    }

    /// [glGetnUniformivEXT](http://docs.gl/es3/glGetnUniformivEXT)(program, location, bufSize, params)
    /// `program` class: program
    /// `params` len: bufSize / 4
    /// alias of: [`glGetnUniformiv`]
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    #[cfg(any(feature = "GL_EXT_robustness"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_robustness"))))]
    pub unsafe fn glGetnUniformivEXT(
        program: GLuint,
        location: GLint,
        bufSize: GLsizei,
        params: *mut GLint,
    ) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glGetnUniformivEXT({:?}, {:?}, {:?}, {:p});",
                program,
                location,
                bufSize,
                params
            );
        }
        let out = call_atomic_ptr_4arg(
            "glGetnUniformivEXT",
            &glGetnUniformivEXT_p,
            program,
            location,
            bufSize,
            params,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glGetnUniformivEXT");
        }
        out
    }
    #[cfg(any(feature = "GL_EXT_robustness"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_robustness"))))]
    static glGetnUniformivEXT_p: APcv = ap_None();
    /// Tries to load [`glGetnUniformivEXT`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    #[cfg(any(feature = "GL_EXT_robustness"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_robustness"))))]
    pub unsafe fn glGetnUniformivEXT_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glGetnUniformivEXT\0",
            &glGetnUniformivEXT_p,
        )
    }
    /// Checks if the pointer for [`glGetnUniformivEXT`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    #[cfg(any(feature = "GL_EXT_robustness"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_robustness"))))]
    pub fn glGetnUniformivEXT_is_loaded() -> bool {
        !glGetnUniformivEXT_p.load(RELAX).is_null()
    }

    /// [glGetnUniformivKHR](http://docs.gl/es3/glGetnUniformivKHR)(program, location, bufSize, params)
    /// `program` class: program
    /// `params` len: bufSize / 4
    /// alias of: [`glGetnUniformiv`]
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    #[cfg(any(feature = "GL_KHR_robustness"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_KHR_robustness"))))]
    pub unsafe fn glGetnUniformivKHR(
        program: GLuint,
        location: GLint,
        bufSize: GLsizei,
        params: *mut GLint,
    ) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glGetnUniformivKHR({:?}, {:?}, {:?}, {:p});",
                program,
                location,
                bufSize,
                params
            );
        }
        let out = call_atomic_ptr_4arg(
            "glGetnUniformivKHR",
            &glGetnUniformivKHR_p,
            program,
            location,
            bufSize,
            params,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glGetnUniformivKHR");
        }
        out
    }
    #[cfg(any(feature = "GL_KHR_robustness"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_KHR_robustness"))))]
    static glGetnUniformivKHR_p: APcv = ap_None();
    /// Tries to load [`glGetnUniformivKHR`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    #[cfg(any(feature = "GL_KHR_robustness"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_KHR_robustness"))))]
    pub unsafe fn glGetnUniformivKHR_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glGetnUniformivKHR\0",
            &glGetnUniformivKHR_p,
        )
    }
    /// Checks if the pointer for [`glGetnUniformivKHR`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    #[cfg(any(feature = "GL_KHR_robustness"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_KHR_robustness"))))]
    pub fn glGetnUniformivKHR_is_loaded() -> bool {
        !glGetnUniformivKHR_p.load(RELAX).is_null()
    }

    /// [glGetnUniformuiv](http://docs.gl/es3/glGetnUniform)(program, location, bufSize, params)
    /// `program` class: program
    /// `params` len: bufSize / 4
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn glGetnUniformuiv(
        program: GLuint,
        location: GLint,
        bufSize: GLsizei,
        params: *mut GLuint,
    ) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glGetnUniformuiv({:?}, {:?}, {:?}, {:p});",
                program,
                location,
                bufSize,
                params
            );
        }
        let out = call_atomic_ptr_4arg(
            "glGetnUniformuiv",
            &glGetnUniformuiv_p,
            program,
            location,
            bufSize,
            params,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glGetnUniformuiv");
        }
        out
    }
    static glGetnUniformuiv_p: APcv = ap_None();
    /// Tries to load [`glGetnUniformuiv`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    pub unsafe fn glGetnUniformuiv_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(get_proc_address, b"glGetnUniformuiv\0", &glGetnUniformuiv_p)
    }
    /// Checks if the pointer for [`glGetnUniformuiv`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    pub fn glGetnUniformuiv_is_loaded() -> bool {
        !glGetnUniformuiv_p.load(RELAX).is_null()
    }

    /// [glGetnUniformuivKHR](http://docs.gl/es3/glGetnUniformuivKHR)(program, location, bufSize, params)
    /// `program` class: program
    /// `params` len: bufSize / 4
    /// alias of: [`glGetnUniformuiv`]
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    #[cfg(any(feature = "GL_KHR_robustness"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_KHR_robustness"))))]
    pub unsafe fn glGetnUniformuivKHR(
        program: GLuint,
        location: GLint,
        bufSize: GLsizei,
        params: *mut GLuint,
    ) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glGetnUniformuivKHR({:?}, {:?}, {:?}, {:p});",
                program,
                location,
                bufSize,
                params
            );
        }
        let out = call_atomic_ptr_4arg(
            "glGetnUniformuivKHR",
            &glGetnUniformuivKHR_p,
            program,
            location,
            bufSize,
            params,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glGetnUniformuivKHR");
        }
        out
    }
    #[cfg(any(feature = "GL_KHR_robustness"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_KHR_robustness"))))]
    static glGetnUniformuivKHR_p: APcv = ap_None();
    /// Tries to load [`glGetnUniformuivKHR`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    #[cfg(any(feature = "GL_KHR_robustness"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_KHR_robustness"))))]
    pub unsafe fn glGetnUniformuivKHR_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glGetnUniformuivKHR\0",
            &glGetnUniformuivKHR_p,
        )
    }
    /// Checks if the pointer for [`glGetnUniformuivKHR`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    #[cfg(any(feature = "GL_KHR_robustness"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_KHR_robustness"))))]
    pub fn glGetnUniformuivKHR_is_loaded() -> bool {
        !glGetnUniformuivKHR_p.load(RELAX).is_null()
    }

    /// [glHint](http://docs.gl/es3/glHint)(target, mode)
    /// `target` group: HintTarget
    /// `mode` group: HintMode
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn glHint(target: GLenum, mode: GLenum) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!("calling glHint({:#X}, {:#X});", target, mode);
        }
        let out = call_atomic_ptr_2arg("glHint", &glHint_p, target, mode);
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glHint");
        }
        out
    }
    static glHint_p: APcv = ap_None();
    /// Tries to load [`glHint`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    pub unsafe fn glHint_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(get_proc_address, b"glHint\0", &glHint_p)
    }
    /// Checks if the pointer for [`glHint`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    pub fn glHint_is_loaded() -> bool {
        !glHint_p.load(RELAX).is_null()
    }

    /// [glImportMemoryFdEXT](http://docs.gl/es3/glImportMemoryFdEXT)(memory, size, handleType, fd)
    /// `handleType` group: ExternalHandleType
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    #[cfg(any(feature = "GL_EXT_memory_object_fd"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_memory_object_fd"))))]
    pub unsafe fn glImportMemoryFdEXT(
        memory: GLuint,
        size: GLuint64,
        handleType: GLenum,
        fd: GLint,
    ) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glImportMemoryFdEXT({:?}, {:?}, {:#X}, {:?});",
                memory,
                size,
                handleType,
                fd
            );
        }
        let out = call_atomic_ptr_4arg(
            "glImportMemoryFdEXT",
            &glImportMemoryFdEXT_p,
            memory,
            size,
            handleType,
            fd,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glImportMemoryFdEXT");
        }
        out
    }
    #[cfg(any(feature = "GL_EXT_memory_object_fd"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_memory_object_fd"))))]
    static glImportMemoryFdEXT_p: APcv = ap_None();
    /// Tries to load [`glImportMemoryFdEXT`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    #[cfg(any(feature = "GL_EXT_memory_object_fd"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_memory_object_fd"))))]
    pub unsafe fn glImportMemoryFdEXT_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glImportMemoryFdEXT\0",
            &glImportMemoryFdEXT_p,
        )
    }
    /// Checks if the pointer for [`glImportMemoryFdEXT`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    #[cfg(any(feature = "GL_EXT_memory_object_fd"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_memory_object_fd"))))]
    pub fn glImportMemoryFdEXT_is_loaded() -> bool {
        !glImportMemoryFdEXT_p.load(RELAX).is_null()
    }

    /// [glImportMemoryWin32HandleEXT](http://docs.gl/es3/glImportMemoryWin32HandleEXT)(memory, size, handleType, handle)
    /// `handleType` group: ExternalHandleType
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    #[cfg(any(feature = "GL_EXT_memory_object_win32"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_memory_object_win32"))))]
    pub unsafe fn glImportMemoryWin32HandleEXT(
        memory: GLuint,
        size: GLuint64,
        handleType: GLenum,
        handle: *mut c_void,
    ) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glImportMemoryWin32HandleEXT({:?}, {:?}, {:#X}, {:p});",
                memory,
                size,
                handleType,
                handle
            );
        }
        let out = call_atomic_ptr_4arg(
            "glImportMemoryWin32HandleEXT",
            &glImportMemoryWin32HandleEXT_p,
            memory,
            size,
            handleType,
            handle,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glImportMemoryWin32HandleEXT");
        }
        out
    }
    #[cfg(any(feature = "GL_EXT_memory_object_win32"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_memory_object_win32"))))]
    static glImportMemoryWin32HandleEXT_p: APcv = ap_None();
    /// Tries to load [`glImportMemoryWin32HandleEXT`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    #[cfg(any(feature = "GL_EXT_memory_object_win32"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_memory_object_win32"))))]
    pub unsafe fn glImportMemoryWin32HandleEXT_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glImportMemoryWin32HandleEXT\0",
            &glImportMemoryWin32HandleEXT_p,
        )
    }
    /// Checks if the pointer for [`glImportMemoryWin32HandleEXT`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    #[cfg(any(feature = "GL_EXT_memory_object_win32"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_memory_object_win32"))))]
    pub fn glImportMemoryWin32HandleEXT_is_loaded() -> bool {
        !glImportMemoryWin32HandleEXT_p.load(RELAX).is_null()
    }

    /// [glImportMemoryWin32NameEXT](http://docs.gl/es3/glImportMemoryWin32NameEXT)(memory, size, handleType, name)
    /// `handleType` group: ExternalHandleType
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    #[cfg(any(feature = "GL_EXT_memory_object_win32"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_memory_object_win32"))))]
    pub unsafe fn glImportMemoryWin32NameEXT(
        memory: GLuint,
        size: GLuint64,
        handleType: GLenum,
        name: *const c_void,
    ) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glImportMemoryWin32NameEXT({:?}, {:?}, {:#X}, {:p});",
                memory,
                size,
                handleType,
                name
            );
        }
        let out = call_atomic_ptr_4arg(
            "glImportMemoryWin32NameEXT",
            &glImportMemoryWin32NameEXT_p,
            memory,
            size,
            handleType,
            name,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glImportMemoryWin32NameEXT");
        }
        out
    }
    #[cfg(any(feature = "GL_EXT_memory_object_win32"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_memory_object_win32"))))]
    static glImportMemoryWin32NameEXT_p: APcv = ap_None();
    /// Tries to load [`glImportMemoryWin32NameEXT`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    #[cfg(any(feature = "GL_EXT_memory_object_win32"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_memory_object_win32"))))]
    pub unsafe fn glImportMemoryWin32NameEXT_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glImportMemoryWin32NameEXT\0",
            &glImportMemoryWin32NameEXT_p,
        )
    }
    /// Checks if the pointer for [`glImportMemoryWin32NameEXT`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    #[cfg(any(feature = "GL_EXT_memory_object_win32"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_memory_object_win32"))))]
    pub fn glImportMemoryWin32NameEXT_is_loaded() -> bool {
        !glImportMemoryWin32NameEXT_p.load(RELAX).is_null()
    }

    /// [glImportSemaphoreFdEXT](http://docs.gl/es3/glImportSemaphoreFdEXT)(semaphore, handleType, fd)
    /// `handleType` group: ExternalHandleType
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    #[cfg(any(feature = "GL_EXT_semaphore_fd"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_semaphore_fd"))))]
    pub unsafe fn glImportSemaphoreFdEXT(semaphore: GLuint, handleType: GLenum, fd: GLint) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glImportSemaphoreFdEXT({:?}, {:#X}, {:?});",
                semaphore,
                handleType,
                fd
            );
        }
        let out = call_atomic_ptr_3arg(
            "glImportSemaphoreFdEXT",
            &glImportSemaphoreFdEXT_p,
            semaphore,
            handleType,
            fd,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glImportSemaphoreFdEXT");
        }
        out
    }
    #[cfg(any(feature = "GL_EXT_semaphore_fd"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_semaphore_fd"))))]
    static glImportSemaphoreFdEXT_p: APcv = ap_None();
    /// Tries to load [`glImportSemaphoreFdEXT`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    #[cfg(any(feature = "GL_EXT_semaphore_fd"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_semaphore_fd"))))]
    pub unsafe fn glImportSemaphoreFdEXT_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glImportSemaphoreFdEXT\0",
            &glImportSemaphoreFdEXT_p,
        )
    }
    /// Checks if the pointer for [`glImportSemaphoreFdEXT`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    #[cfg(any(feature = "GL_EXT_semaphore_fd"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_semaphore_fd"))))]
    pub fn glImportSemaphoreFdEXT_is_loaded() -> bool {
        !glImportSemaphoreFdEXT_p.load(RELAX).is_null()
    }

    /// [glImportSemaphoreWin32HandleEXT](http://docs.gl/es3/glImportSemaphoreWin32HandleEXT)(semaphore, handleType, handle)
    /// `handleType` group: ExternalHandleType
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    #[cfg(any(feature = "GL_EXT_semaphore_win32"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_semaphore_win32"))))]
    pub unsafe fn glImportSemaphoreWin32HandleEXT(
        semaphore: GLuint,
        handleType: GLenum,
        handle: *mut c_void,
    ) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glImportSemaphoreWin32HandleEXT({:?}, {:#X}, {:p});",
                semaphore,
                handleType,
                handle
            );
        }
        let out = call_atomic_ptr_3arg(
            "glImportSemaphoreWin32HandleEXT",
            &glImportSemaphoreWin32HandleEXT_p,
            semaphore,
            handleType,
            handle,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glImportSemaphoreWin32HandleEXT");
        }
        out
    }
    #[cfg(any(feature = "GL_EXT_semaphore_win32"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_semaphore_win32"))))]
    static glImportSemaphoreWin32HandleEXT_p: APcv = ap_None();
    /// Tries to load [`glImportSemaphoreWin32HandleEXT`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    #[cfg(any(feature = "GL_EXT_semaphore_win32"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_semaphore_win32"))))]
    pub unsafe fn glImportSemaphoreWin32HandleEXT_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glImportSemaphoreWin32HandleEXT\0",
            &glImportSemaphoreWin32HandleEXT_p,
        )
    }
    /// Checks if the pointer for [`glImportSemaphoreWin32HandleEXT`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    #[cfg(any(feature = "GL_EXT_semaphore_win32"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_semaphore_win32"))))]
    pub fn glImportSemaphoreWin32HandleEXT_is_loaded() -> bool {
        !glImportSemaphoreWin32HandleEXT_p.load(RELAX).is_null()
    }

    /// [glImportSemaphoreWin32NameEXT](http://docs.gl/es3/glImportSemaphoreWin32NameEXT)(semaphore, handleType, name)
    /// `handleType` group: ExternalHandleType
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    #[cfg(any(feature = "GL_EXT_semaphore_win32"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_semaphore_win32"))))]
    pub unsafe fn glImportSemaphoreWin32NameEXT(
        semaphore: GLuint,
        handleType: GLenum,
        name: *const c_void,
    ) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glImportSemaphoreWin32NameEXT({:?}, {:#X}, {:p});",
                semaphore,
                handleType,
                name
            );
        }
        let out = call_atomic_ptr_3arg(
            "glImportSemaphoreWin32NameEXT",
            &glImportSemaphoreWin32NameEXT_p,
            semaphore,
            handleType,
            name,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glImportSemaphoreWin32NameEXT");
        }
        out
    }
    #[cfg(any(feature = "GL_EXT_semaphore_win32"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_semaphore_win32"))))]
    static glImportSemaphoreWin32NameEXT_p: APcv = ap_None();
    /// Tries to load [`glImportSemaphoreWin32NameEXT`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    #[cfg(any(feature = "GL_EXT_semaphore_win32"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_semaphore_win32"))))]
    pub unsafe fn glImportSemaphoreWin32NameEXT_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glImportSemaphoreWin32NameEXT\0",
            &glImportSemaphoreWin32NameEXT_p,
        )
    }
    /// Checks if the pointer for [`glImportSemaphoreWin32NameEXT`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    #[cfg(any(feature = "GL_EXT_semaphore_win32"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_semaphore_win32"))))]
    pub fn glImportSemaphoreWin32NameEXT_is_loaded() -> bool {
        !glImportSemaphoreWin32NameEXT_p.load(RELAX).is_null()
    }

    /// [glInsertEventMarkerEXT](http://docs.gl/es3/glInsertEventMarkerEXT)(length, marker)
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    #[cfg(any(feature = "GL_EXT_debug_marker"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_debug_marker"))))]
    pub unsafe fn glInsertEventMarkerEXT(length: GLsizei, marker: *const GLchar) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glInsertEventMarkerEXT({:?}, {:p});",
                length,
                marker
            );
        }
        let out = call_atomic_ptr_2arg(
            "glInsertEventMarkerEXT",
            &glInsertEventMarkerEXT_p,
            length,
            marker,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glInsertEventMarkerEXT");
        }
        out
    }
    #[cfg(any(feature = "GL_EXT_debug_marker"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_debug_marker"))))]
    static glInsertEventMarkerEXT_p: APcv = ap_None();
    /// Tries to load [`glInsertEventMarkerEXT`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    #[cfg(any(feature = "GL_EXT_debug_marker"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_debug_marker"))))]
    pub unsafe fn glInsertEventMarkerEXT_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glInsertEventMarkerEXT\0",
            &glInsertEventMarkerEXT_p,
        )
    }
    /// Checks if the pointer for [`glInsertEventMarkerEXT`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    #[cfg(any(feature = "GL_EXT_debug_marker"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_debug_marker"))))]
    pub fn glInsertEventMarkerEXT_is_loaded() -> bool {
        !glInsertEventMarkerEXT_p.load(RELAX).is_null()
    }

    /// [glInterpolatePathsNV](http://docs.gl/es3/glInterpolatePathsNV)(resultPath, pathA, pathB, weight)
    /// `resultPath` group: Path
    /// `pathA` group: Path
    /// `pathB` group: Path
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    #[cfg(any(feature = "GL_NV_path_rendering"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_path_rendering"))))]
    pub unsafe fn glInterpolatePathsNV(
        resultPath: GLuint,
        pathA: GLuint,
        pathB: GLuint,
        weight: GLfloat,
    ) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glInterpolatePathsNV({:?}, {:?}, {:?}, {:?});",
                resultPath,
                pathA,
                pathB,
                weight
            );
        }
        let out = call_atomic_ptr_4arg(
            "glInterpolatePathsNV",
            &glInterpolatePathsNV_p,
            resultPath,
            pathA,
            pathB,
            weight,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glInterpolatePathsNV");
        }
        out
    }
    #[cfg(any(feature = "GL_NV_path_rendering"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_path_rendering"))))]
    static glInterpolatePathsNV_p: APcv = ap_None();
    /// Tries to load [`glInterpolatePathsNV`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    #[cfg(any(feature = "GL_NV_path_rendering"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_path_rendering"))))]
    pub unsafe fn glInterpolatePathsNV_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glInterpolatePathsNV\0",
            &glInterpolatePathsNV_p,
        )
    }
    /// Checks if the pointer for [`glInterpolatePathsNV`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    #[cfg(any(feature = "GL_NV_path_rendering"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_path_rendering"))))]
    pub fn glInterpolatePathsNV_is_loaded() -> bool {
        !glInterpolatePathsNV_p.load(RELAX).is_null()
    }

    /// [glInvalidateFramebuffer](http://docs.gl/es3/glInvalidateFramebuffer)(target, numAttachments, attachments)
    /// `target` group: FramebufferTarget
    /// `attachments` group: InvalidateFramebufferAttachment
    /// `attachments` len: numAttachments
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn glInvalidateFramebuffer(
        target: GLenum,
        numAttachments: GLsizei,
        attachments: *const GLenum,
    ) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glInvalidateFramebuffer({:#X}, {:?}, {:p});",
                target,
                numAttachments,
                attachments
            );
        }
        let out = call_atomic_ptr_3arg(
            "glInvalidateFramebuffer",
            &glInvalidateFramebuffer_p,
            target,
            numAttachments,
            attachments,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glInvalidateFramebuffer");
        }
        out
    }
    static glInvalidateFramebuffer_p: APcv = ap_None();
    /// Tries to load [`glInvalidateFramebuffer`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    pub unsafe fn glInvalidateFramebuffer_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glInvalidateFramebuffer\0",
            &glInvalidateFramebuffer_p,
        )
    }
    /// Checks if the pointer for [`glInvalidateFramebuffer`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    pub fn glInvalidateFramebuffer_is_loaded() -> bool {
        !glInvalidateFramebuffer_p.load(RELAX).is_null()
    }

    /// [glInvalidateSubFramebuffer](http://docs.gl/es3/glInvalidateSubFramebuffer)(target, numAttachments, attachments, x, y, width, height)
    /// `target` group: FramebufferTarget
    /// `attachments` group: InvalidateFramebufferAttachment
    /// `attachments` len: numAttachments
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn glInvalidateSubFramebuffer(
        target: GLenum,
        numAttachments: GLsizei,
        attachments: *const GLenum,
        x: GLint,
        y: GLint,
        width: GLsizei,
        height: GLsizei,
    ) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glInvalidateSubFramebuffer({:#X}, {:?}, {:p}, {:?}, {:?}, {:?}, {:?});",
                target,
                numAttachments,
                attachments,
                x,
                y,
                width,
                height
            );
        }
        let out = call_atomic_ptr_7arg(
            "glInvalidateSubFramebuffer",
            &glInvalidateSubFramebuffer_p,
            target,
            numAttachments,
            attachments,
            x,
            y,
            width,
            height,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glInvalidateSubFramebuffer");
        }
        out
    }
    static glInvalidateSubFramebuffer_p: APcv = ap_None();
    /// Tries to load [`glInvalidateSubFramebuffer`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    pub unsafe fn glInvalidateSubFramebuffer_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glInvalidateSubFramebuffer\0",
            &glInvalidateSubFramebuffer_p,
        )
    }
    /// Checks if the pointer for [`glInvalidateSubFramebuffer`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    pub fn glInvalidateSubFramebuffer_is_loaded() -> bool {
        !glInvalidateSubFramebuffer_p.load(RELAX).is_null()
    }

    /// [glIsBuffer](http://docs.gl/es3/glIsBuffer)(buffer)
    /// `buffer` class: buffer
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn glIsBuffer(buffer: GLuint) -> GLboolean {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!("calling glIsBuffer({:?});", buffer);
        }
        let out = call_atomic_ptr_1arg("glIsBuffer", &glIsBuffer_p, buffer);
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glIsBuffer");
        }
        out
    }
    static glIsBuffer_p: APcv = ap_None();
    /// Tries to load [`glIsBuffer`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    pub unsafe fn glIsBuffer_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(get_proc_address, b"glIsBuffer\0", &glIsBuffer_p)
    }
    /// Checks if the pointer for [`glIsBuffer`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    pub fn glIsBuffer_is_loaded() -> bool {
        !glIsBuffer_p.load(RELAX).is_null()
    }

    /// [glIsEnabled](http://docs.gl/es3/glIsEnabled)(cap)
    /// `cap` group: EnableCap
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn glIsEnabled(cap: GLenum) -> GLboolean {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!("calling glIsEnabled({:#X});", cap);
        }
        let out = call_atomic_ptr_1arg("glIsEnabled", &glIsEnabled_p, cap);
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glIsEnabled");
        }
        out
    }
    static glIsEnabled_p: APcv = ap_None();
    /// Tries to load [`glIsEnabled`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    pub unsafe fn glIsEnabled_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(get_proc_address, b"glIsEnabled\0", &glIsEnabled_p)
    }
    /// Checks if the pointer for [`glIsEnabled`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    pub fn glIsEnabled_is_loaded() -> bool {
        !glIsEnabled_p.load(RELAX).is_null()
    }

    /// [glIsEnabledi](http://docs.gl/es3/glIsEnabled)(target, index)
    /// `target` group: EnableCap
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn glIsEnabledi(target: GLenum, index: GLuint) -> GLboolean {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!("calling glIsEnabledi({:#X}, {:?});", target, index);
        }
        let out = call_atomic_ptr_2arg("glIsEnabledi", &glIsEnabledi_p, target, index);
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glIsEnabledi");
        }
        out
    }
    static glIsEnabledi_p: APcv = ap_None();
    /// Tries to load [`glIsEnabledi`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    pub unsafe fn glIsEnabledi_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(get_proc_address, b"glIsEnabledi\0", &glIsEnabledi_p)
    }
    /// Checks if the pointer for [`glIsEnabledi`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    pub fn glIsEnabledi_is_loaded() -> bool {
        !glIsEnabledi_p.load(RELAX).is_null()
    }

    /// [glIsEnablediEXT](http://docs.gl/es3/glIsEnablediEXT)(target, index)
    /// `target` group: EnableCap
    /// alias of: [`glIsEnabledi`]
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    #[cfg(any(feature = "GL_EXT_draw_buffers_indexed"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_draw_buffers_indexed"))))]
    pub unsafe fn glIsEnablediEXT(target: GLenum, index: GLuint) -> GLboolean {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!("calling glIsEnablediEXT({:#X}, {:?});", target, index);
        }
        let out = call_atomic_ptr_2arg("glIsEnablediEXT", &glIsEnablediEXT_p, target, index);
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glIsEnablediEXT");
        }
        out
    }
    #[cfg(any(feature = "GL_EXT_draw_buffers_indexed"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_draw_buffers_indexed"))))]
    static glIsEnablediEXT_p: APcv = ap_None();
    /// Tries to load [`glIsEnablediEXT`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    #[cfg(any(feature = "GL_EXT_draw_buffers_indexed"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_draw_buffers_indexed"))))]
    pub unsafe fn glIsEnablediEXT_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(get_proc_address, b"glIsEnablediEXT\0", &glIsEnablediEXT_p)
    }
    /// Checks if the pointer for [`glIsEnablediEXT`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    #[cfg(any(feature = "GL_EXT_draw_buffers_indexed"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_draw_buffers_indexed"))))]
    pub fn glIsEnablediEXT_is_loaded() -> bool {
        !glIsEnablediEXT_p.load(RELAX).is_null()
    }

    /// [glIsEnablediNV](http://docs.gl/es3/glIsEnablediNV)(target, index)
    /// `target` group: EnableCap
    /// alias of: [`glIsEnabledi`]
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    #[cfg(any(feature = "GL_NV_viewport_array"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_viewport_array"))))]
    pub unsafe fn glIsEnablediNV(target: GLenum, index: GLuint) -> GLboolean {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!("calling glIsEnablediNV({:#X}, {:?});", target, index);
        }
        let out = call_atomic_ptr_2arg("glIsEnablediNV", &glIsEnablediNV_p, target, index);
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glIsEnablediNV");
        }
        out
    }
    #[cfg(any(feature = "GL_NV_viewport_array"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_viewport_array"))))]
    static glIsEnablediNV_p: APcv = ap_None();
    /// Tries to load [`glIsEnablediNV`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    #[cfg(any(feature = "GL_NV_viewport_array"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_viewport_array"))))]
    pub unsafe fn glIsEnablediNV_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(get_proc_address, b"glIsEnablediNV\0", &glIsEnablediNV_p)
    }
    /// Checks if the pointer for [`glIsEnablediNV`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    #[cfg(any(feature = "GL_NV_viewport_array"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_viewport_array"))))]
    pub fn glIsEnablediNV_is_loaded() -> bool {
        !glIsEnablediNV_p.load(RELAX).is_null()
    }

    /// [glIsEnablediOES](http://docs.gl/es3/glIsEnablediOES)(target, index)
    /// `target` group: EnableCap
    /// alias of: [`glIsEnabledi`]
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    #[cfg(any(
        feature = "GL_OES_draw_buffers_indexed",
        feature = "GL_OES_viewport_array"
    ))]
    #[cfg_attr(
        docs_rs,
        doc(cfg(any(
            feature = "GL_OES_draw_buffers_indexed",
            feature = "GL_OES_viewport_array"
        )))
    )]
    pub unsafe fn glIsEnablediOES(target: GLenum, index: GLuint) -> GLboolean {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!("calling glIsEnablediOES({:#X}, {:?});", target, index);
        }
        let out = call_atomic_ptr_2arg("glIsEnablediOES", &glIsEnablediOES_p, target, index);
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glIsEnablediOES");
        }
        out
    }
    #[cfg(any(
        feature = "GL_OES_draw_buffers_indexed",
        feature = "GL_OES_viewport_array"
    ))]
    #[cfg_attr(
        docs_rs,
        doc(cfg(any(
            feature = "GL_OES_draw_buffers_indexed",
            feature = "GL_OES_viewport_array"
        )))
    )]
    static glIsEnablediOES_p: APcv = ap_None();
    /// Tries to load [`glIsEnablediOES`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    #[cfg(any(
        feature = "GL_OES_draw_buffers_indexed",
        feature = "GL_OES_viewport_array"
    ))]
    #[cfg_attr(
        docs_rs,
        doc(cfg(any(
            feature = "GL_OES_draw_buffers_indexed",
            feature = "GL_OES_viewport_array"
        )))
    )]
    pub unsafe fn glIsEnablediOES_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(get_proc_address, b"glIsEnablediOES\0", &glIsEnablediOES_p)
    }
    /// Checks if the pointer for [`glIsEnablediOES`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    #[cfg(any(
        feature = "GL_OES_draw_buffers_indexed",
        feature = "GL_OES_viewport_array"
    ))]
    #[cfg_attr(
        docs_rs,
        doc(cfg(any(
            feature = "GL_OES_draw_buffers_indexed",
            feature = "GL_OES_viewport_array"
        )))
    )]
    pub fn glIsEnablediOES_is_loaded() -> bool {
        !glIsEnablediOES_p.load(RELAX).is_null()
    }

    /// [glIsFenceNV](http://docs.gl/es3/glIsFenceNV)(fence)
    /// `fence` group: FenceNV
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    #[cfg(any(feature = "GL_NV_fence"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_fence"))))]
    pub unsafe fn glIsFenceNV(fence: GLuint) -> GLboolean {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!("calling glIsFenceNV({:?});", fence);
        }
        let out = call_atomic_ptr_1arg("glIsFenceNV", &glIsFenceNV_p, fence);
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glIsFenceNV");
        }
        out
    }
    #[cfg(any(feature = "GL_NV_fence"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_fence"))))]
    static glIsFenceNV_p: APcv = ap_None();
    /// Tries to load [`glIsFenceNV`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    #[cfg(any(feature = "GL_NV_fence"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_fence"))))]
    pub unsafe fn glIsFenceNV_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(get_proc_address, b"glIsFenceNV\0", &glIsFenceNV_p)
    }
    /// Checks if the pointer for [`glIsFenceNV`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    #[cfg(any(feature = "GL_NV_fence"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_fence"))))]
    pub fn glIsFenceNV_is_loaded() -> bool {
        !glIsFenceNV_p.load(RELAX).is_null()
    }

    /// [glIsFramebuffer](http://docs.gl/es3/glIsFramebuffer)(framebuffer)
    /// `framebuffer` class: framebuffer
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn glIsFramebuffer(framebuffer: GLuint) -> GLboolean {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!("calling glIsFramebuffer({:?});", framebuffer);
        }
        let out = call_atomic_ptr_1arg("glIsFramebuffer", &glIsFramebuffer_p, framebuffer);
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glIsFramebuffer");
        }
        out
    }
    static glIsFramebuffer_p: APcv = ap_None();
    /// Tries to load [`glIsFramebuffer`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    pub unsafe fn glIsFramebuffer_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(get_proc_address, b"glIsFramebuffer\0", &glIsFramebuffer_p)
    }
    /// Checks if the pointer for [`glIsFramebuffer`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    pub fn glIsFramebuffer_is_loaded() -> bool {
        !glIsFramebuffer_p.load(RELAX).is_null()
    }

    /// [glIsImageHandleResidentNV](http://docs.gl/es3/glIsImageHandleResidentNV)(handle)
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    #[cfg(any(feature = "GL_NV_bindless_texture"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_bindless_texture"))))]
    pub unsafe fn glIsImageHandleResidentNV(handle: GLuint64) -> GLboolean {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!("calling glIsImageHandleResidentNV({:?});", handle);
        }
        let out = call_atomic_ptr_1arg(
            "glIsImageHandleResidentNV",
            &glIsImageHandleResidentNV_p,
            handle,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glIsImageHandleResidentNV");
        }
        out
    }
    #[cfg(any(feature = "GL_NV_bindless_texture"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_bindless_texture"))))]
    static glIsImageHandleResidentNV_p: APcv = ap_None();
    /// Tries to load [`glIsImageHandleResidentNV`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    #[cfg(any(feature = "GL_NV_bindless_texture"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_bindless_texture"))))]
    pub unsafe fn glIsImageHandleResidentNV_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glIsImageHandleResidentNV\0",
            &glIsImageHandleResidentNV_p,
        )
    }
    /// Checks if the pointer for [`glIsImageHandleResidentNV`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    #[cfg(any(feature = "GL_NV_bindless_texture"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_bindless_texture"))))]
    pub fn glIsImageHandleResidentNV_is_loaded() -> bool {
        !glIsImageHandleResidentNV_p.load(RELAX).is_null()
    }

    /// [glIsMemoryObjectEXT](http://docs.gl/es3/glIsMemoryObjectEXT)(memoryObject)
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    #[cfg(any(feature = "GL_EXT_memory_object"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_memory_object"))))]
    pub unsafe fn glIsMemoryObjectEXT(memoryObject: GLuint) -> GLboolean {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!("calling glIsMemoryObjectEXT({:?});", memoryObject);
        }
        let out = call_atomic_ptr_1arg("glIsMemoryObjectEXT", &glIsMemoryObjectEXT_p, memoryObject);
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glIsMemoryObjectEXT");
        }
        out
    }
    #[cfg(any(feature = "GL_EXT_memory_object"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_memory_object"))))]
    static glIsMemoryObjectEXT_p: APcv = ap_None();
    /// Tries to load [`glIsMemoryObjectEXT`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    #[cfg(any(feature = "GL_EXT_memory_object"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_memory_object"))))]
    pub unsafe fn glIsMemoryObjectEXT_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glIsMemoryObjectEXT\0",
            &glIsMemoryObjectEXT_p,
        )
    }
    /// Checks if the pointer for [`glIsMemoryObjectEXT`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    #[cfg(any(feature = "GL_EXT_memory_object"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_memory_object"))))]
    pub fn glIsMemoryObjectEXT_is_loaded() -> bool {
        !glIsMemoryObjectEXT_p.load(RELAX).is_null()
    }

    /// [glIsPathNV](http://docs.gl/es3/glIsPathNV)(path)
    /// `path` group: Path
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    #[cfg(any(feature = "GL_NV_path_rendering"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_path_rendering"))))]
    pub unsafe fn glIsPathNV(path: GLuint) -> GLboolean {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!("calling glIsPathNV({:?});", path);
        }
        let out = call_atomic_ptr_1arg("glIsPathNV", &glIsPathNV_p, path);
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glIsPathNV");
        }
        out
    }
    #[cfg(any(feature = "GL_NV_path_rendering"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_path_rendering"))))]
    static glIsPathNV_p: APcv = ap_None();
    /// Tries to load [`glIsPathNV`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    #[cfg(any(feature = "GL_NV_path_rendering"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_path_rendering"))))]
    pub unsafe fn glIsPathNV_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(get_proc_address, b"glIsPathNV\0", &glIsPathNV_p)
    }
    /// Checks if the pointer for [`glIsPathNV`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    #[cfg(any(feature = "GL_NV_path_rendering"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_path_rendering"))))]
    pub fn glIsPathNV_is_loaded() -> bool {
        !glIsPathNV_p.load(RELAX).is_null()
    }

    /// [glIsPointInFillPathNV](http://docs.gl/es3/glIsPointInFillPathNV)(path, mask, x, y)
    /// `path` group: Path
    /// `mask` group: MaskedStencilValue
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    #[cfg(any(feature = "GL_NV_path_rendering"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_path_rendering"))))]
    pub unsafe fn glIsPointInFillPathNV(
        path: GLuint,
        mask: GLuint,
        x: GLfloat,
        y: GLfloat,
    ) -> GLboolean {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glIsPointInFillPathNV({:?}, {:?}, {:?}, {:?});",
                path,
                mask,
                x,
                y
            );
        }
        let out = call_atomic_ptr_4arg(
            "glIsPointInFillPathNV",
            &glIsPointInFillPathNV_p,
            path,
            mask,
            x,
            y,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glIsPointInFillPathNV");
        }
        out
    }
    #[cfg(any(feature = "GL_NV_path_rendering"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_path_rendering"))))]
    static glIsPointInFillPathNV_p: APcv = ap_None();
    /// Tries to load [`glIsPointInFillPathNV`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    #[cfg(any(feature = "GL_NV_path_rendering"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_path_rendering"))))]
    pub unsafe fn glIsPointInFillPathNV_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glIsPointInFillPathNV\0",
            &glIsPointInFillPathNV_p,
        )
    }
    /// Checks if the pointer for [`glIsPointInFillPathNV`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    #[cfg(any(feature = "GL_NV_path_rendering"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_path_rendering"))))]
    pub fn glIsPointInFillPathNV_is_loaded() -> bool {
        !glIsPointInFillPathNV_p.load(RELAX).is_null()
    }

    /// [glIsPointInStrokePathNV](http://docs.gl/es3/glIsPointInStrokePathNV)(path, x, y)
    /// `path` group: Path
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    #[cfg(any(feature = "GL_NV_path_rendering"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_path_rendering"))))]
    pub unsafe fn glIsPointInStrokePathNV(path: GLuint, x: GLfloat, y: GLfloat) -> GLboolean {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glIsPointInStrokePathNV({:?}, {:?}, {:?});",
                path,
                x,
                y
            );
        }
        let out = call_atomic_ptr_3arg(
            "glIsPointInStrokePathNV",
            &glIsPointInStrokePathNV_p,
            path,
            x,
            y,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glIsPointInStrokePathNV");
        }
        out
    }
    #[cfg(any(feature = "GL_NV_path_rendering"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_path_rendering"))))]
    static glIsPointInStrokePathNV_p: APcv = ap_None();
    /// Tries to load [`glIsPointInStrokePathNV`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    #[cfg(any(feature = "GL_NV_path_rendering"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_path_rendering"))))]
    pub unsafe fn glIsPointInStrokePathNV_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glIsPointInStrokePathNV\0",
            &glIsPointInStrokePathNV_p,
        )
    }
    /// Checks if the pointer for [`glIsPointInStrokePathNV`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    #[cfg(any(feature = "GL_NV_path_rendering"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_path_rendering"))))]
    pub fn glIsPointInStrokePathNV_is_loaded() -> bool {
        !glIsPointInStrokePathNV_p.load(RELAX).is_null()
    }

    /// [glIsProgram](http://docs.gl/es3/glIsProgram)(program)
    /// `program` class: program
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn glIsProgram(program: GLuint) -> GLboolean {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!("calling glIsProgram({:?});", program);
        }
        let out = call_atomic_ptr_1arg("glIsProgram", &glIsProgram_p, program);
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glIsProgram");
        }
        out
    }
    static glIsProgram_p: APcv = ap_None();
    /// Tries to load [`glIsProgram`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    pub unsafe fn glIsProgram_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(get_proc_address, b"glIsProgram\0", &glIsProgram_p)
    }
    /// Checks if the pointer for [`glIsProgram`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    pub fn glIsProgram_is_loaded() -> bool {
        !glIsProgram_p.load(RELAX).is_null()
    }

    /// [glIsProgramPipeline](http://docs.gl/es3/glIsProgramPipeline)(pipeline)
    /// `pipeline` class: program pipeline
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn glIsProgramPipeline(pipeline: GLuint) -> GLboolean {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!("calling glIsProgramPipeline({:?});", pipeline);
        }
        let out = call_atomic_ptr_1arg("glIsProgramPipeline", &glIsProgramPipeline_p, pipeline);
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glIsProgramPipeline");
        }
        out
    }
    static glIsProgramPipeline_p: APcv = ap_None();
    /// Tries to load [`glIsProgramPipeline`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    pub unsafe fn glIsProgramPipeline_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glIsProgramPipeline\0",
            &glIsProgramPipeline_p,
        )
    }
    /// Checks if the pointer for [`glIsProgramPipeline`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    pub fn glIsProgramPipeline_is_loaded() -> bool {
        !glIsProgramPipeline_p.load(RELAX).is_null()
    }

    /// [glIsProgramPipelineEXT](http://docs.gl/es3/glIsProgramPipelineEXT)(pipeline)
    /// `pipeline` class: program pipeline
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    #[cfg(any(feature = "GL_EXT_separate_shader_objects"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_separate_shader_objects"))))]
    pub unsafe fn glIsProgramPipelineEXT(pipeline: GLuint) -> GLboolean {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!("calling glIsProgramPipelineEXT({:?});", pipeline);
        }
        let out = call_atomic_ptr_1arg(
            "glIsProgramPipelineEXT",
            &glIsProgramPipelineEXT_p,
            pipeline,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glIsProgramPipelineEXT");
        }
        out
    }
    #[cfg(any(feature = "GL_EXT_separate_shader_objects"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_separate_shader_objects"))))]
    static glIsProgramPipelineEXT_p: APcv = ap_None();
    /// Tries to load [`glIsProgramPipelineEXT`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    #[cfg(any(feature = "GL_EXT_separate_shader_objects"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_separate_shader_objects"))))]
    pub unsafe fn glIsProgramPipelineEXT_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glIsProgramPipelineEXT\0",
            &glIsProgramPipelineEXT_p,
        )
    }
    /// Checks if the pointer for [`glIsProgramPipelineEXT`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    #[cfg(any(feature = "GL_EXT_separate_shader_objects"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_separate_shader_objects"))))]
    pub fn glIsProgramPipelineEXT_is_loaded() -> bool {
        !glIsProgramPipelineEXT_p.load(RELAX).is_null()
    }

    /// [glIsQuery](http://docs.gl/es3/glIsQuery)(id)
    /// `id` class: query
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn glIsQuery(id: GLuint) -> GLboolean {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!("calling glIsQuery({:?});", id);
        }
        let out = call_atomic_ptr_1arg("glIsQuery", &glIsQuery_p, id);
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glIsQuery");
        }
        out
    }
    static glIsQuery_p: APcv = ap_None();
    /// Tries to load [`glIsQuery`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    pub unsafe fn glIsQuery_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(get_proc_address, b"glIsQuery\0", &glIsQuery_p)
    }
    /// Checks if the pointer for [`glIsQuery`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    pub fn glIsQuery_is_loaded() -> bool {
        !glIsQuery_p.load(RELAX).is_null()
    }

    /// [glIsQueryEXT](http://docs.gl/es3/glIsQueryEXT)(id)
    /// `id` class: query
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    #[cfg(any(
        feature = "GL_EXT_disjoint_timer_query",
        feature = "GL_EXT_occlusion_query_boolean"
    ))]
    #[cfg_attr(
        docs_rs,
        doc(cfg(any(
            feature = "GL_EXT_disjoint_timer_query",
            feature = "GL_EXT_occlusion_query_boolean"
        )))
    )]
    pub unsafe fn glIsQueryEXT(id: GLuint) -> GLboolean {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!("calling glIsQueryEXT({:?});", id);
        }
        let out = call_atomic_ptr_1arg("glIsQueryEXT", &glIsQueryEXT_p, id);
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glIsQueryEXT");
        }
        out
    }
    #[cfg(any(
        feature = "GL_EXT_disjoint_timer_query",
        feature = "GL_EXT_occlusion_query_boolean"
    ))]
    #[cfg_attr(
        docs_rs,
        doc(cfg(any(
            feature = "GL_EXT_disjoint_timer_query",
            feature = "GL_EXT_occlusion_query_boolean"
        )))
    )]
    static glIsQueryEXT_p: APcv = ap_None();
    /// Tries to load [`glIsQueryEXT`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    #[cfg(any(
        feature = "GL_EXT_disjoint_timer_query",
        feature = "GL_EXT_occlusion_query_boolean"
    ))]
    #[cfg_attr(
        docs_rs,
        doc(cfg(any(
            feature = "GL_EXT_disjoint_timer_query",
            feature = "GL_EXT_occlusion_query_boolean"
        )))
    )]
    pub unsafe fn glIsQueryEXT_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(get_proc_address, b"glIsQueryEXT\0", &glIsQueryEXT_p)
    }
    /// Checks if the pointer for [`glIsQueryEXT`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    #[cfg(any(
        feature = "GL_EXT_disjoint_timer_query",
        feature = "GL_EXT_occlusion_query_boolean"
    ))]
    #[cfg_attr(
        docs_rs,
        doc(cfg(any(
            feature = "GL_EXT_disjoint_timer_query",
            feature = "GL_EXT_occlusion_query_boolean"
        )))
    )]
    pub fn glIsQueryEXT_is_loaded() -> bool {
        !glIsQueryEXT_p.load(RELAX).is_null()
    }

    /// [glIsRenderbuffer](http://docs.gl/es3/glIsRenderbuffer)(renderbuffer)
    /// `renderbuffer` class: renderbuffer
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn glIsRenderbuffer(renderbuffer: GLuint) -> GLboolean {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!("calling glIsRenderbuffer({:?});", renderbuffer);
        }
        let out = call_atomic_ptr_1arg("glIsRenderbuffer", &glIsRenderbuffer_p, renderbuffer);
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glIsRenderbuffer");
        }
        out
    }
    static glIsRenderbuffer_p: APcv = ap_None();
    /// Tries to load [`glIsRenderbuffer`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    pub unsafe fn glIsRenderbuffer_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(get_proc_address, b"glIsRenderbuffer\0", &glIsRenderbuffer_p)
    }
    /// Checks if the pointer for [`glIsRenderbuffer`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    pub fn glIsRenderbuffer_is_loaded() -> bool {
        !glIsRenderbuffer_p.load(RELAX).is_null()
    }

    /// [glIsSampler](http://docs.gl/es3/glIsSampler)(sampler)
    /// `sampler` class: sampler
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn glIsSampler(sampler: GLuint) -> GLboolean {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!("calling glIsSampler({:?});", sampler);
        }
        let out = call_atomic_ptr_1arg("glIsSampler", &glIsSampler_p, sampler);
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glIsSampler");
        }
        out
    }
    static glIsSampler_p: APcv = ap_None();
    /// Tries to load [`glIsSampler`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    pub unsafe fn glIsSampler_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(get_proc_address, b"glIsSampler\0", &glIsSampler_p)
    }
    /// Checks if the pointer for [`glIsSampler`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    pub fn glIsSampler_is_loaded() -> bool {
        !glIsSampler_p.load(RELAX).is_null()
    }

    /// [glIsSemaphoreEXT](http://docs.gl/es3/glIsSemaphoreEXT)(semaphore)
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    #[cfg(any(feature = "GL_EXT_semaphore"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_semaphore"))))]
    pub unsafe fn glIsSemaphoreEXT(semaphore: GLuint) -> GLboolean {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!("calling glIsSemaphoreEXT({:?});", semaphore);
        }
        let out = call_atomic_ptr_1arg("glIsSemaphoreEXT", &glIsSemaphoreEXT_p, semaphore);
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glIsSemaphoreEXT");
        }
        out
    }
    #[cfg(any(feature = "GL_EXT_semaphore"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_semaphore"))))]
    static glIsSemaphoreEXT_p: APcv = ap_None();
    /// Tries to load [`glIsSemaphoreEXT`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    #[cfg(any(feature = "GL_EXT_semaphore"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_semaphore"))))]
    pub unsafe fn glIsSemaphoreEXT_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(get_proc_address, b"glIsSemaphoreEXT\0", &glIsSemaphoreEXT_p)
    }
    /// Checks if the pointer for [`glIsSemaphoreEXT`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    #[cfg(any(feature = "GL_EXT_semaphore"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_semaphore"))))]
    pub fn glIsSemaphoreEXT_is_loaded() -> bool {
        !glIsSemaphoreEXT_p.load(RELAX).is_null()
    }

    /// [glIsShader](http://docs.gl/es3/glIsShader)(shader)
    /// `shader` class: shader
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn glIsShader(shader: GLuint) -> GLboolean {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!("calling glIsShader({:?});", shader);
        }
        let out = call_atomic_ptr_1arg("glIsShader", &glIsShader_p, shader);
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glIsShader");
        }
        out
    }
    static glIsShader_p: APcv = ap_None();
    /// Tries to load [`glIsShader`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    pub unsafe fn glIsShader_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(get_proc_address, b"glIsShader\0", &glIsShader_p)
    }
    /// Checks if the pointer for [`glIsShader`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    pub fn glIsShader_is_loaded() -> bool {
        !glIsShader_p.load(RELAX).is_null()
    }

    /// [glIsSync](http://docs.gl/es3/glIsSync)(sync)
    /// `sync` group: sync
    /// `sync` class: sync
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn glIsSync(sync: GLsync) -> GLboolean {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!("calling glIsSync({:p});", sync);
        }
        let out = call_atomic_ptr_1arg("glIsSync", &glIsSync_p, sync);
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glIsSync");
        }
        out
    }
    static glIsSync_p: APcv = ap_None();
    /// Tries to load [`glIsSync`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    pub unsafe fn glIsSync_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(get_proc_address, b"glIsSync\0", &glIsSync_p)
    }
    /// Checks if the pointer for [`glIsSync`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    pub fn glIsSync_is_loaded() -> bool {
        !glIsSync_p.load(RELAX).is_null()
    }

    /// [glIsSyncAPPLE](http://docs.gl/es3/glIsSyncAPPLE)(sync)
    /// `sync` class: sync
    /// alias of: [`glIsSync`]
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    #[cfg(any(feature = "GL_APPLE_sync"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_APPLE_sync"))))]
    pub unsafe fn glIsSyncAPPLE(sync: GLsync) -> GLboolean {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!("calling glIsSyncAPPLE({:p});", sync);
        }
        let out = call_atomic_ptr_1arg("glIsSyncAPPLE", &glIsSyncAPPLE_p, sync);
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glIsSyncAPPLE");
        }
        out
    }
    #[cfg(any(feature = "GL_APPLE_sync"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_APPLE_sync"))))]
    static glIsSyncAPPLE_p: APcv = ap_None();
    /// Tries to load [`glIsSyncAPPLE`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    #[cfg(any(feature = "GL_APPLE_sync"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_APPLE_sync"))))]
    pub unsafe fn glIsSyncAPPLE_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(get_proc_address, b"glIsSyncAPPLE\0", &glIsSyncAPPLE_p)
    }
    /// Checks if the pointer for [`glIsSyncAPPLE`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    #[cfg(any(feature = "GL_APPLE_sync"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_APPLE_sync"))))]
    pub fn glIsSyncAPPLE_is_loaded() -> bool {
        !glIsSyncAPPLE_p.load(RELAX).is_null()
    }

    /// [glIsTexture](http://docs.gl/es3/glIsTexture)(texture)
    /// `texture` group: Texture
    /// `texture` class: texture
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn glIsTexture(texture: GLuint) -> GLboolean {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!("calling glIsTexture({:?});", texture);
        }
        let out = call_atomic_ptr_1arg("glIsTexture", &glIsTexture_p, texture);
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glIsTexture");
        }
        out
    }
    static glIsTexture_p: APcv = ap_None();
    /// Tries to load [`glIsTexture`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    pub unsafe fn glIsTexture_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(get_proc_address, b"glIsTexture\0", &glIsTexture_p)
    }
    /// Checks if the pointer for [`glIsTexture`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    pub fn glIsTexture_is_loaded() -> bool {
        !glIsTexture_p.load(RELAX).is_null()
    }

    /// [glIsTextureHandleResidentNV](http://docs.gl/es3/glIsTextureHandleResidentNV)(handle)
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    #[cfg(any(feature = "GL_NV_bindless_texture"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_bindless_texture"))))]
    pub unsafe fn glIsTextureHandleResidentNV(handle: GLuint64) -> GLboolean {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!("calling glIsTextureHandleResidentNV({:?});", handle);
        }
        let out = call_atomic_ptr_1arg(
            "glIsTextureHandleResidentNV",
            &glIsTextureHandleResidentNV_p,
            handle,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glIsTextureHandleResidentNV");
        }
        out
    }
    #[cfg(any(feature = "GL_NV_bindless_texture"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_bindless_texture"))))]
    static glIsTextureHandleResidentNV_p: APcv = ap_None();
    /// Tries to load [`glIsTextureHandleResidentNV`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    #[cfg(any(feature = "GL_NV_bindless_texture"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_bindless_texture"))))]
    pub unsafe fn glIsTextureHandleResidentNV_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glIsTextureHandleResidentNV\0",
            &glIsTextureHandleResidentNV_p,
        )
    }
    /// Checks if the pointer for [`glIsTextureHandleResidentNV`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    #[cfg(any(feature = "GL_NV_bindless_texture"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_bindless_texture"))))]
    pub fn glIsTextureHandleResidentNV_is_loaded() -> bool {
        !glIsTextureHandleResidentNV_p.load(RELAX).is_null()
    }

    /// [glIsTransformFeedback](http://docs.gl/es3/glIsTransformFeedback)(id)
    /// `id` class: transform feedback
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn glIsTransformFeedback(id: GLuint) -> GLboolean {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!("calling glIsTransformFeedback({:?});", id);
        }
        let out = call_atomic_ptr_1arg("glIsTransformFeedback", &glIsTransformFeedback_p, id);
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glIsTransformFeedback");
        }
        out
    }
    static glIsTransformFeedback_p: APcv = ap_None();
    /// Tries to load [`glIsTransformFeedback`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    pub unsafe fn glIsTransformFeedback_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glIsTransformFeedback\0",
            &glIsTransformFeedback_p,
        )
    }
    /// Checks if the pointer for [`glIsTransformFeedback`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    pub fn glIsTransformFeedback_is_loaded() -> bool {
        !glIsTransformFeedback_p.load(RELAX).is_null()
    }

    /// [glIsVertexArray](http://docs.gl/es3/glIsVertexArray)(array)
    /// `array` class: vertex array
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn glIsVertexArray(array: GLuint) -> GLboolean {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!("calling glIsVertexArray({:?});", array);
        }
        let out = call_atomic_ptr_1arg("glIsVertexArray", &glIsVertexArray_p, array);
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glIsVertexArray");
        }
        out
    }
    static glIsVertexArray_p: APcv = ap_None();
    /// Tries to load [`glIsVertexArray`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    pub unsafe fn glIsVertexArray_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(get_proc_address, b"glIsVertexArray\0", &glIsVertexArray_p)
    }
    /// Checks if the pointer for [`glIsVertexArray`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    pub fn glIsVertexArray_is_loaded() -> bool {
        !glIsVertexArray_p.load(RELAX).is_null()
    }

    /// [glIsVertexArrayOES](http://docs.gl/es3/glIsVertexArrayOES)(array)
    /// `array` class: vertex array
    /// alias of: [`glIsVertexArray`]
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    #[cfg(any(feature = "GL_OES_vertex_array_object"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_OES_vertex_array_object"))))]
    pub unsafe fn glIsVertexArrayOES(array: GLuint) -> GLboolean {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!("calling glIsVertexArrayOES({:?});", array);
        }
        let out = call_atomic_ptr_1arg("glIsVertexArrayOES", &glIsVertexArrayOES_p, array);
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glIsVertexArrayOES");
        }
        out
    }
    #[cfg(any(feature = "GL_OES_vertex_array_object"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_OES_vertex_array_object"))))]
    static glIsVertexArrayOES_p: APcv = ap_None();
    /// Tries to load [`glIsVertexArrayOES`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    #[cfg(any(feature = "GL_OES_vertex_array_object"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_OES_vertex_array_object"))))]
    pub unsafe fn glIsVertexArrayOES_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glIsVertexArrayOES\0",
            &glIsVertexArrayOES_p,
        )
    }
    /// Checks if the pointer for [`glIsVertexArrayOES`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    #[cfg(any(feature = "GL_OES_vertex_array_object"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_OES_vertex_array_object"))))]
    pub fn glIsVertexArrayOES_is_loaded() -> bool {
        !glIsVertexArrayOES_p.load(RELAX).is_null()
    }

    /// [glLabelObjectEXT](http://docs.gl/es3/glLabelObjectEXT)(type_, object, length, label)
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    #[cfg(any(feature = "GL_EXT_debug_label"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_debug_label"))))]
    pub unsafe fn glLabelObjectEXT(
        type_: GLenum,
        object: GLuint,
        length: GLsizei,
        label: *const GLchar,
    ) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glLabelObjectEXT({:#X}, {:?}, {:?}, {:p});",
                type_,
                object,
                length,
                label
            );
        }
        let out = call_atomic_ptr_4arg(
            "glLabelObjectEXT",
            &glLabelObjectEXT_p,
            type_,
            object,
            length,
            label,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glLabelObjectEXT");
        }
        out
    }
    #[cfg(any(feature = "GL_EXT_debug_label"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_debug_label"))))]
    static glLabelObjectEXT_p: APcv = ap_None();
    /// Tries to load [`glLabelObjectEXT`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    #[cfg(any(feature = "GL_EXT_debug_label"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_debug_label"))))]
    pub unsafe fn glLabelObjectEXT_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(get_proc_address, b"glLabelObjectEXT\0", &glLabelObjectEXT_p)
    }
    /// Checks if the pointer for [`glLabelObjectEXT`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    #[cfg(any(feature = "GL_EXT_debug_label"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_debug_label"))))]
    pub fn glLabelObjectEXT_is_loaded() -> bool {
        !glLabelObjectEXT_p.load(RELAX).is_null()
    }

    /// [glLineWidth](http://docs.gl/es3/glLineWidth)(width)
    /// `width` group: CheckedFloat32
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn glLineWidth(width: GLfloat) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!("calling glLineWidth({:?});", width);
        }
        let out = call_atomic_ptr_1arg("glLineWidth", &glLineWidth_p, width);
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glLineWidth");
        }
        out
    }
    static glLineWidth_p: APcv = ap_None();
    /// Tries to load [`glLineWidth`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    pub unsafe fn glLineWidth_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(get_proc_address, b"glLineWidth\0", &glLineWidth_p)
    }
    /// Checks if the pointer for [`glLineWidth`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    pub fn glLineWidth_is_loaded() -> bool {
        !glLineWidth_p.load(RELAX).is_null()
    }

    /// [glLinkProgram](http://docs.gl/es3/glLinkProgram)(program)
    /// `program` class: program
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn glLinkProgram(program: GLuint) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!("calling glLinkProgram({:?});", program);
        }
        let out = call_atomic_ptr_1arg("glLinkProgram", &glLinkProgram_p, program);
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glLinkProgram");
        }
        out
    }
    static glLinkProgram_p: APcv = ap_None();
    /// Tries to load [`glLinkProgram`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    pub unsafe fn glLinkProgram_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(get_proc_address, b"glLinkProgram\0", &glLinkProgram_p)
    }
    /// Checks if the pointer for [`glLinkProgram`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    pub fn glLinkProgram_is_loaded() -> bool {
        !glLinkProgram_p.load(RELAX).is_null()
    }

    /// [glMakeImageHandleNonResidentNV](http://docs.gl/es3/glMakeImageHandleNonResidentNV)(handle)
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    #[cfg(any(feature = "GL_NV_bindless_texture"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_bindless_texture"))))]
    pub unsafe fn glMakeImageHandleNonResidentNV(handle: GLuint64) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!("calling glMakeImageHandleNonResidentNV({:?});", handle);
        }
        let out = call_atomic_ptr_1arg(
            "glMakeImageHandleNonResidentNV",
            &glMakeImageHandleNonResidentNV_p,
            handle,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glMakeImageHandleNonResidentNV");
        }
        out
    }
    #[cfg(any(feature = "GL_NV_bindless_texture"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_bindless_texture"))))]
    static glMakeImageHandleNonResidentNV_p: APcv = ap_None();
    /// Tries to load [`glMakeImageHandleNonResidentNV`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    #[cfg(any(feature = "GL_NV_bindless_texture"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_bindless_texture"))))]
    pub unsafe fn glMakeImageHandleNonResidentNV_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glMakeImageHandleNonResidentNV\0",
            &glMakeImageHandleNonResidentNV_p,
        )
    }
    /// Checks if the pointer for [`glMakeImageHandleNonResidentNV`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    #[cfg(any(feature = "GL_NV_bindless_texture"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_bindless_texture"))))]
    pub fn glMakeImageHandleNonResidentNV_is_loaded() -> bool {
        !glMakeImageHandleNonResidentNV_p.load(RELAX).is_null()
    }

    /// [glMakeImageHandleResidentNV](http://docs.gl/es3/glMakeImageHandleResidentNV)(handle, access)
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    #[cfg(any(feature = "GL_NV_bindless_texture"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_bindless_texture"))))]
    pub unsafe fn glMakeImageHandleResidentNV(handle: GLuint64, access: GLenum) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glMakeImageHandleResidentNV({:?}, {:#X});",
                handle,
                access
            );
        }
        let out = call_atomic_ptr_2arg(
            "glMakeImageHandleResidentNV",
            &glMakeImageHandleResidentNV_p,
            handle,
            access,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glMakeImageHandleResidentNV");
        }
        out
    }
    #[cfg(any(feature = "GL_NV_bindless_texture"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_bindless_texture"))))]
    static glMakeImageHandleResidentNV_p: APcv = ap_None();
    /// Tries to load [`glMakeImageHandleResidentNV`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    #[cfg(any(feature = "GL_NV_bindless_texture"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_bindless_texture"))))]
    pub unsafe fn glMakeImageHandleResidentNV_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glMakeImageHandleResidentNV\0",
            &glMakeImageHandleResidentNV_p,
        )
    }
    /// Checks if the pointer for [`glMakeImageHandleResidentNV`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    #[cfg(any(feature = "GL_NV_bindless_texture"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_bindless_texture"))))]
    pub fn glMakeImageHandleResidentNV_is_loaded() -> bool {
        !glMakeImageHandleResidentNV_p.load(RELAX).is_null()
    }

    /// [glMakeTextureHandleNonResidentNV](http://docs.gl/es3/glMakeTextureHandleNonResidentNV)(handle)
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    #[cfg(any(feature = "GL_NV_bindless_texture"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_bindless_texture"))))]
    pub unsafe fn glMakeTextureHandleNonResidentNV(handle: GLuint64) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!("calling glMakeTextureHandleNonResidentNV({:?});", handle);
        }
        let out = call_atomic_ptr_1arg(
            "glMakeTextureHandleNonResidentNV",
            &glMakeTextureHandleNonResidentNV_p,
            handle,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glMakeTextureHandleNonResidentNV");
        }
        out
    }
    #[cfg(any(feature = "GL_NV_bindless_texture"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_bindless_texture"))))]
    static glMakeTextureHandleNonResidentNV_p: APcv = ap_None();
    /// Tries to load [`glMakeTextureHandleNonResidentNV`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    #[cfg(any(feature = "GL_NV_bindless_texture"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_bindless_texture"))))]
    pub unsafe fn glMakeTextureHandleNonResidentNV_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glMakeTextureHandleNonResidentNV\0",
            &glMakeTextureHandleNonResidentNV_p,
        )
    }
    /// Checks if the pointer for [`glMakeTextureHandleNonResidentNV`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    #[cfg(any(feature = "GL_NV_bindless_texture"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_bindless_texture"))))]
    pub fn glMakeTextureHandleNonResidentNV_is_loaded() -> bool {
        !glMakeTextureHandleNonResidentNV_p.load(RELAX).is_null()
    }

    /// [glMakeTextureHandleResidentNV](http://docs.gl/es3/glMakeTextureHandleResidentNV)(handle)
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    #[cfg(any(feature = "GL_NV_bindless_texture"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_bindless_texture"))))]
    pub unsafe fn glMakeTextureHandleResidentNV(handle: GLuint64) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!("calling glMakeTextureHandleResidentNV({:?});", handle);
        }
        let out = call_atomic_ptr_1arg(
            "glMakeTextureHandleResidentNV",
            &glMakeTextureHandleResidentNV_p,
            handle,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glMakeTextureHandleResidentNV");
        }
        out
    }
    #[cfg(any(feature = "GL_NV_bindless_texture"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_bindless_texture"))))]
    static glMakeTextureHandleResidentNV_p: APcv = ap_None();
    /// Tries to load [`glMakeTextureHandleResidentNV`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    #[cfg(any(feature = "GL_NV_bindless_texture"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_bindless_texture"))))]
    pub unsafe fn glMakeTextureHandleResidentNV_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glMakeTextureHandleResidentNV\0",
            &glMakeTextureHandleResidentNV_p,
        )
    }
    /// Checks if the pointer for [`glMakeTextureHandleResidentNV`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    #[cfg(any(feature = "GL_NV_bindless_texture"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_bindless_texture"))))]
    pub fn glMakeTextureHandleResidentNV_is_loaded() -> bool {
        !glMakeTextureHandleResidentNV_p.load(RELAX).is_null()
    }

    /// [glMapBufferOES](http://docs.gl/es3/glMapBufferOES)(target, access)
    /// `target` group: BufferTargetARB
    /// `access` group: BufferAccessARB
    /// alias of: [`glMapBuffer`]
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    #[cfg(any(feature = "GL_OES_mapbuffer"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_OES_mapbuffer"))))]
    pub unsafe fn glMapBufferOES(target: GLenum, access: GLenum) -> *mut c_void {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!("calling glMapBufferOES({:#X}, {:#X});", target, access);
        }
        let out = call_atomic_ptr_2arg("glMapBufferOES", &glMapBufferOES_p, target, access);
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glMapBufferOES");
        }
        out
    }
    #[cfg(any(feature = "GL_OES_mapbuffer"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_OES_mapbuffer"))))]
    static glMapBufferOES_p: APcv = ap_None();
    /// Tries to load [`glMapBufferOES`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    #[cfg(any(feature = "GL_OES_mapbuffer"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_OES_mapbuffer"))))]
    pub unsafe fn glMapBufferOES_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(get_proc_address, b"glMapBufferOES\0", &glMapBufferOES_p)
    }
    /// Checks if the pointer for [`glMapBufferOES`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    #[cfg(any(feature = "GL_OES_mapbuffer"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_OES_mapbuffer"))))]
    pub fn glMapBufferOES_is_loaded() -> bool {
        !glMapBufferOES_p.load(RELAX).is_null()
    }

    /// [glMapBufferRange](http://docs.gl/es3/glMapBufferRange)(target, offset, length, access)
    /// `target` group: BufferTargetARB
    /// `offset` group: BufferOffset
    /// `length` group: BufferSize
    /// `access` group: MapBufferAccessMask
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn glMapBufferRange(
        target: GLenum,
        offset: GLintptr,
        length: GLsizeiptr,
        access: GLbitfield,
    ) -> *mut c_void {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glMapBufferRange({:#X}, {:?}, {:?}, {:?});",
                target,
                offset,
                length,
                access
            );
        }
        let out = call_atomic_ptr_4arg(
            "glMapBufferRange",
            &glMapBufferRange_p,
            target,
            offset,
            length,
            access,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glMapBufferRange");
        }
        out
    }
    static glMapBufferRange_p: APcv = ap_None();
    /// Tries to load [`glMapBufferRange`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    pub unsafe fn glMapBufferRange_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(get_proc_address, b"glMapBufferRange\0", &glMapBufferRange_p)
    }
    /// Checks if the pointer for [`glMapBufferRange`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    pub fn glMapBufferRange_is_loaded() -> bool {
        !glMapBufferRange_p.load(RELAX).is_null()
    }

    /// [glMapBufferRangeEXT](http://docs.gl/es3/glMapBufferRangeEXT)(target, offset, length, access)
    /// `target` group: BufferTargetARB
    /// `access` group: MapBufferAccessMask
    /// alias of: [`glMapBufferRange`]
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    #[cfg(any(feature = "GL_EXT_map_buffer_range"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_map_buffer_range"))))]
    pub unsafe fn glMapBufferRangeEXT(
        target: GLenum,
        offset: GLintptr,
        length: GLsizeiptr,
        access: GLbitfield,
    ) -> *mut c_void {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glMapBufferRangeEXT({:#X}, {:?}, {:?}, {:?});",
                target,
                offset,
                length,
                access
            );
        }
        let out = call_atomic_ptr_4arg(
            "glMapBufferRangeEXT",
            &glMapBufferRangeEXT_p,
            target,
            offset,
            length,
            access,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glMapBufferRangeEXT");
        }
        out
    }
    #[cfg(any(feature = "GL_EXT_map_buffer_range"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_map_buffer_range"))))]
    static glMapBufferRangeEXT_p: APcv = ap_None();
    /// Tries to load [`glMapBufferRangeEXT`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    #[cfg(any(feature = "GL_EXT_map_buffer_range"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_map_buffer_range"))))]
    pub unsafe fn glMapBufferRangeEXT_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glMapBufferRangeEXT\0",
            &glMapBufferRangeEXT_p,
        )
    }
    /// Checks if the pointer for [`glMapBufferRangeEXT`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    #[cfg(any(feature = "GL_EXT_map_buffer_range"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_map_buffer_range"))))]
    pub fn glMapBufferRangeEXT_is_loaded() -> bool {
        !glMapBufferRangeEXT_p.load(RELAX).is_null()
    }

    /// [glMatrixFrustumEXT](http://docs.gl/es3/glMatrixFrustumEXT)(mode, left, right, bottom, top, zNear, zFar)
    /// `mode` group: MatrixMode
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    #[cfg(any(feature = "GL_NV_path_rendering"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_path_rendering"))))]
    pub unsafe fn glMatrixFrustumEXT(
        mode: GLenum,
        left: GLdouble,
        right: GLdouble,
        bottom: GLdouble,
        top: GLdouble,
        zNear: GLdouble,
        zFar: GLdouble,
    ) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glMatrixFrustumEXT({:#X}, {:?}, {:?}, {:?}, {:?}, {:?}, {:?});",
                mode,
                left,
                right,
                bottom,
                top,
                zNear,
                zFar
            );
        }
        let out = call_atomic_ptr_7arg(
            "glMatrixFrustumEXT",
            &glMatrixFrustumEXT_p,
            mode,
            left,
            right,
            bottom,
            top,
            zNear,
            zFar,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glMatrixFrustumEXT");
        }
        out
    }
    #[cfg(any(feature = "GL_NV_path_rendering"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_path_rendering"))))]
    static glMatrixFrustumEXT_p: APcv = ap_None();
    /// Tries to load [`glMatrixFrustumEXT`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    #[cfg(any(feature = "GL_NV_path_rendering"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_path_rendering"))))]
    pub unsafe fn glMatrixFrustumEXT_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glMatrixFrustumEXT\0",
            &glMatrixFrustumEXT_p,
        )
    }
    /// Checks if the pointer for [`glMatrixFrustumEXT`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    #[cfg(any(feature = "GL_NV_path_rendering"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_path_rendering"))))]
    pub fn glMatrixFrustumEXT_is_loaded() -> bool {
        !glMatrixFrustumEXT_p.load(RELAX).is_null()
    }

    /// [glMatrixLoad3x2fNV](http://docs.gl/es3/glMatrixLoad3x2fNV)(matrixMode, m)
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    #[cfg(any(feature = "GL_NV_path_rendering"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_path_rendering"))))]
    pub unsafe fn glMatrixLoad3x2fNV(matrixMode: GLenum, m: *const GLfloat) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!("calling glMatrixLoad3x2fNV({:#X}, {:p});", matrixMode, m);
        }
        let out = call_atomic_ptr_2arg("glMatrixLoad3x2fNV", &glMatrixLoad3x2fNV_p, matrixMode, m);
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glMatrixLoad3x2fNV");
        }
        out
    }
    #[cfg(any(feature = "GL_NV_path_rendering"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_path_rendering"))))]
    static glMatrixLoad3x2fNV_p: APcv = ap_None();
    /// Tries to load [`glMatrixLoad3x2fNV`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    #[cfg(any(feature = "GL_NV_path_rendering"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_path_rendering"))))]
    pub unsafe fn glMatrixLoad3x2fNV_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glMatrixLoad3x2fNV\0",
            &glMatrixLoad3x2fNV_p,
        )
    }
    /// Checks if the pointer for [`glMatrixLoad3x2fNV`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    #[cfg(any(feature = "GL_NV_path_rendering"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_path_rendering"))))]
    pub fn glMatrixLoad3x2fNV_is_loaded() -> bool {
        !glMatrixLoad3x2fNV_p.load(RELAX).is_null()
    }

    /// [glMatrixLoad3x3fNV](http://docs.gl/es3/glMatrixLoad3x3fNV)(matrixMode, m)
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    #[cfg(any(feature = "GL_NV_path_rendering"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_path_rendering"))))]
    pub unsafe fn glMatrixLoad3x3fNV(matrixMode: GLenum, m: *const GLfloat) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!("calling glMatrixLoad3x3fNV({:#X}, {:p});", matrixMode, m);
        }
        let out = call_atomic_ptr_2arg("glMatrixLoad3x3fNV", &glMatrixLoad3x3fNV_p, matrixMode, m);
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glMatrixLoad3x3fNV");
        }
        out
    }
    #[cfg(any(feature = "GL_NV_path_rendering"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_path_rendering"))))]
    static glMatrixLoad3x3fNV_p: APcv = ap_None();
    /// Tries to load [`glMatrixLoad3x3fNV`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    #[cfg(any(feature = "GL_NV_path_rendering"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_path_rendering"))))]
    pub unsafe fn glMatrixLoad3x3fNV_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glMatrixLoad3x3fNV\0",
            &glMatrixLoad3x3fNV_p,
        )
    }
    /// Checks if the pointer for [`glMatrixLoad3x3fNV`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    #[cfg(any(feature = "GL_NV_path_rendering"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_path_rendering"))))]
    pub fn glMatrixLoad3x3fNV_is_loaded() -> bool {
        !glMatrixLoad3x3fNV_p.load(RELAX).is_null()
    }

    /// [glMatrixLoadIdentityEXT](http://docs.gl/es3/glMatrixLoadIdentityEXT)(mode)
    /// `mode` group: MatrixMode
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    #[cfg(any(feature = "GL_NV_path_rendering"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_path_rendering"))))]
    pub unsafe fn glMatrixLoadIdentityEXT(mode: GLenum) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!("calling glMatrixLoadIdentityEXT({:#X});", mode);
        }
        let out = call_atomic_ptr_1arg("glMatrixLoadIdentityEXT", &glMatrixLoadIdentityEXT_p, mode);
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glMatrixLoadIdentityEXT");
        }
        out
    }
    #[cfg(any(feature = "GL_NV_path_rendering"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_path_rendering"))))]
    static glMatrixLoadIdentityEXT_p: APcv = ap_None();
    /// Tries to load [`glMatrixLoadIdentityEXT`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    #[cfg(any(feature = "GL_NV_path_rendering"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_path_rendering"))))]
    pub unsafe fn glMatrixLoadIdentityEXT_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glMatrixLoadIdentityEXT\0",
            &glMatrixLoadIdentityEXT_p,
        )
    }
    /// Checks if the pointer for [`glMatrixLoadIdentityEXT`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    #[cfg(any(feature = "GL_NV_path_rendering"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_path_rendering"))))]
    pub fn glMatrixLoadIdentityEXT_is_loaded() -> bool {
        !glMatrixLoadIdentityEXT_p.load(RELAX).is_null()
    }

    /// [glMatrixLoadTranspose3x3fNV](http://docs.gl/es3/glMatrixLoadTranspose3x3fNV)(matrixMode, m)
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    #[cfg(any(feature = "GL_NV_path_rendering"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_path_rendering"))))]
    pub unsafe fn glMatrixLoadTranspose3x3fNV(matrixMode: GLenum, m: *const GLfloat) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glMatrixLoadTranspose3x3fNV({:#X}, {:p});",
                matrixMode,
                m
            );
        }
        let out = call_atomic_ptr_2arg(
            "glMatrixLoadTranspose3x3fNV",
            &glMatrixLoadTranspose3x3fNV_p,
            matrixMode,
            m,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glMatrixLoadTranspose3x3fNV");
        }
        out
    }
    #[cfg(any(feature = "GL_NV_path_rendering"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_path_rendering"))))]
    static glMatrixLoadTranspose3x3fNV_p: APcv = ap_None();
    /// Tries to load [`glMatrixLoadTranspose3x3fNV`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    #[cfg(any(feature = "GL_NV_path_rendering"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_path_rendering"))))]
    pub unsafe fn glMatrixLoadTranspose3x3fNV_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glMatrixLoadTranspose3x3fNV\0",
            &glMatrixLoadTranspose3x3fNV_p,
        )
    }
    /// Checks if the pointer for [`glMatrixLoadTranspose3x3fNV`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    #[cfg(any(feature = "GL_NV_path_rendering"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_path_rendering"))))]
    pub fn glMatrixLoadTranspose3x3fNV_is_loaded() -> bool {
        !glMatrixLoadTranspose3x3fNV_p.load(RELAX).is_null()
    }

    /// [glMatrixLoadTransposedEXT](http://docs.gl/es3/glMatrixLoadTransposedEXT)(mode, m)
    /// `mode` group: MatrixMode
    /// `m` len: 16
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    #[cfg(any(feature = "GL_NV_path_rendering"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_path_rendering"))))]
    pub unsafe fn glMatrixLoadTransposedEXT(mode: GLenum, m: *const GLdouble) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!("calling glMatrixLoadTransposedEXT({:#X}, {:p});", mode, m);
        }
        let out = call_atomic_ptr_2arg(
            "glMatrixLoadTransposedEXT",
            &glMatrixLoadTransposedEXT_p,
            mode,
            m,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glMatrixLoadTransposedEXT");
        }
        out
    }
    #[cfg(any(feature = "GL_NV_path_rendering"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_path_rendering"))))]
    static glMatrixLoadTransposedEXT_p: APcv = ap_None();
    /// Tries to load [`glMatrixLoadTransposedEXT`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    #[cfg(any(feature = "GL_NV_path_rendering"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_path_rendering"))))]
    pub unsafe fn glMatrixLoadTransposedEXT_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glMatrixLoadTransposedEXT\0",
            &glMatrixLoadTransposedEXT_p,
        )
    }
    /// Checks if the pointer for [`glMatrixLoadTransposedEXT`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    #[cfg(any(feature = "GL_NV_path_rendering"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_path_rendering"))))]
    pub fn glMatrixLoadTransposedEXT_is_loaded() -> bool {
        !glMatrixLoadTransposedEXT_p.load(RELAX).is_null()
    }

    /// [glMatrixLoadTransposefEXT](http://docs.gl/es3/glMatrixLoadTransposefEXT)(mode, m)
    /// `mode` group: MatrixMode
    /// `m` len: 16
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    #[cfg(any(feature = "GL_NV_path_rendering"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_path_rendering"))))]
    pub unsafe fn glMatrixLoadTransposefEXT(mode: GLenum, m: *const GLfloat) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!("calling glMatrixLoadTransposefEXT({:#X}, {:p});", mode, m);
        }
        let out = call_atomic_ptr_2arg(
            "glMatrixLoadTransposefEXT",
            &glMatrixLoadTransposefEXT_p,
            mode,
            m,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glMatrixLoadTransposefEXT");
        }
        out
    }
    #[cfg(any(feature = "GL_NV_path_rendering"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_path_rendering"))))]
    static glMatrixLoadTransposefEXT_p: APcv = ap_None();
    /// Tries to load [`glMatrixLoadTransposefEXT`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    #[cfg(any(feature = "GL_NV_path_rendering"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_path_rendering"))))]
    pub unsafe fn glMatrixLoadTransposefEXT_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glMatrixLoadTransposefEXT\0",
            &glMatrixLoadTransposefEXT_p,
        )
    }
    /// Checks if the pointer for [`glMatrixLoadTransposefEXT`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    #[cfg(any(feature = "GL_NV_path_rendering"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_path_rendering"))))]
    pub fn glMatrixLoadTransposefEXT_is_loaded() -> bool {
        !glMatrixLoadTransposefEXT_p.load(RELAX).is_null()
    }

    /// [glMatrixLoaddEXT](http://docs.gl/es3/glMatrixLoaddEXT)(mode, m)
    /// `mode` group: MatrixMode
    /// `m` len: 16
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    #[cfg(any(feature = "GL_NV_path_rendering"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_path_rendering"))))]
    pub unsafe fn glMatrixLoaddEXT(mode: GLenum, m: *const GLdouble) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!("calling glMatrixLoaddEXT({:#X}, {:p});", mode, m);
        }
        let out = call_atomic_ptr_2arg("glMatrixLoaddEXT", &glMatrixLoaddEXT_p, mode, m);
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glMatrixLoaddEXT");
        }
        out
    }
    #[cfg(any(feature = "GL_NV_path_rendering"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_path_rendering"))))]
    static glMatrixLoaddEXT_p: APcv = ap_None();
    /// Tries to load [`glMatrixLoaddEXT`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    #[cfg(any(feature = "GL_NV_path_rendering"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_path_rendering"))))]
    pub unsafe fn glMatrixLoaddEXT_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(get_proc_address, b"glMatrixLoaddEXT\0", &glMatrixLoaddEXT_p)
    }
    /// Checks if the pointer for [`glMatrixLoaddEXT`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    #[cfg(any(feature = "GL_NV_path_rendering"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_path_rendering"))))]
    pub fn glMatrixLoaddEXT_is_loaded() -> bool {
        !glMatrixLoaddEXT_p.load(RELAX).is_null()
    }

    /// [glMatrixLoadfEXT](http://docs.gl/es3/glMatrixLoadfEXT)(mode, m)
    /// `mode` group: MatrixMode
    /// `m` len: 16
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    #[cfg(any(feature = "GL_NV_path_rendering"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_path_rendering"))))]
    pub unsafe fn glMatrixLoadfEXT(mode: GLenum, m: *const GLfloat) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!("calling glMatrixLoadfEXT({:#X}, {:p});", mode, m);
        }
        let out = call_atomic_ptr_2arg("glMatrixLoadfEXT", &glMatrixLoadfEXT_p, mode, m);
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glMatrixLoadfEXT");
        }
        out
    }
    #[cfg(any(feature = "GL_NV_path_rendering"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_path_rendering"))))]
    static glMatrixLoadfEXT_p: APcv = ap_None();
    /// Tries to load [`glMatrixLoadfEXT`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    #[cfg(any(feature = "GL_NV_path_rendering"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_path_rendering"))))]
    pub unsafe fn glMatrixLoadfEXT_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(get_proc_address, b"glMatrixLoadfEXT\0", &glMatrixLoadfEXT_p)
    }
    /// Checks if the pointer for [`glMatrixLoadfEXT`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    #[cfg(any(feature = "GL_NV_path_rendering"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_path_rendering"))))]
    pub fn glMatrixLoadfEXT_is_loaded() -> bool {
        !glMatrixLoadfEXT_p.load(RELAX).is_null()
    }

    /// [glMatrixMult3x2fNV](http://docs.gl/es3/glMatrixMult3x2fNV)(matrixMode, m)
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    #[cfg(any(feature = "GL_NV_path_rendering"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_path_rendering"))))]
    pub unsafe fn glMatrixMult3x2fNV(matrixMode: GLenum, m: *const GLfloat) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!("calling glMatrixMult3x2fNV({:#X}, {:p});", matrixMode, m);
        }
        let out = call_atomic_ptr_2arg("glMatrixMult3x2fNV", &glMatrixMult3x2fNV_p, matrixMode, m);
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glMatrixMult3x2fNV");
        }
        out
    }
    #[cfg(any(feature = "GL_NV_path_rendering"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_path_rendering"))))]
    static glMatrixMult3x2fNV_p: APcv = ap_None();
    /// Tries to load [`glMatrixMult3x2fNV`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    #[cfg(any(feature = "GL_NV_path_rendering"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_path_rendering"))))]
    pub unsafe fn glMatrixMult3x2fNV_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glMatrixMult3x2fNV\0",
            &glMatrixMult3x2fNV_p,
        )
    }
    /// Checks if the pointer for [`glMatrixMult3x2fNV`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    #[cfg(any(feature = "GL_NV_path_rendering"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_path_rendering"))))]
    pub fn glMatrixMult3x2fNV_is_loaded() -> bool {
        !glMatrixMult3x2fNV_p.load(RELAX).is_null()
    }

    /// [glMatrixMult3x3fNV](http://docs.gl/es3/glMatrixMult3x3fNV)(matrixMode, m)
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    #[cfg(any(feature = "GL_NV_path_rendering"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_path_rendering"))))]
    pub unsafe fn glMatrixMult3x3fNV(matrixMode: GLenum, m: *const GLfloat) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!("calling glMatrixMult3x3fNV({:#X}, {:p});", matrixMode, m);
        }
        let out = call_atomic_ptr_2arg("glMatrixMult3x3fNV", &glMatrixMult3x3fNV_p, matrixMode, m);
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glMatrixMult3x3fNV");
        }
        out
    }
    #[cfg(any(feature = "GL_NV_path_rendering"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_path_rendering"))))]
    static glMatrixMult3x3fNV_p: APcv = ap_None();
    /// Tries to load [`glMatrixMult3x3fNV`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    #[cfg(any(feature = "GL_NV_path_rendering"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_path_rendering"))))]
    pub unsafe fn glMatrixMult3x3fNV_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glMatrixMult3x3fNV\0",
            &glMatrixMult3x3fNV_p,
        )
    }
    /// Checks if the pointer for [`glMatrixMult3x3fNV`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    #[cfg(any(feature = "GL_NV_path_rendering"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_path_rendering"))))]
    pub fn glMatrixMult3x3fNV_is_loaded() -> bool {
        !glMatrixMult3x3fNV_p.load(RELAX).is_null()
    }

    /// [glMatrixMultTranspose3x3fNV](http://docs.gl/es3/glMatrixMultTranspose3x3fNV)(matrixMode, m)
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    #[cfg(any(feature = "GL_NV_path_rendering"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_path_rendering"))))]
    pub unsafe fn glMatrixMultTranspose3x3fNV(matrixMode: GLenum, m: *const GLfloat) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glMatrixMultTranspose3x3fNV({:#X}, {:p});",
                matrixMode,
                m
            );
        }
        let out = call_atomic_ptr_2arg(
            "glMatrixMultTranspose3x3fNV",
            &glMatrixMultTranspose3x3fNV_p,
            matrixMode,
            m,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glMatrixMultTranspose3x3fNV");
        }
        out
    }
    #[cfg(any(feature = "GL_NV_path_rendering"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_path_rendering"))))]
    static glMatrixMultTranspose3x3fNV_p: APcv = ap_None();
    /// Tries to load [`glMatrixMultTranspose3x3fNV`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    #[cfg(any(feature = "GL_NV_path_rendering"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_path_rendering"))))]
    pub unsafe fn glMatrixMultTranspose3x3fNV_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glMatrixMultTranspose3x3fNV\0",
            &glMatrixMultTranspose3x3fNV_p,
        )
    }
    /// Checks if the pointer for [`glMatrixMultTranspose3x3fNV`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    #[cfg(any(feature = "GL_NV_path_rendering"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_path_rendering"))))]
    pub fn glMatrixMultTranspose3x3fNV_is_loaded() -> bool {
        !glMatrixMultTranspose3x3fNV_p.load(RELAX).is_null()
    }

    /// [glMatrixMultTransposedEXT](http://docs.gl/es3/glMatrixMultTransposedEXT)(mode, m)
    /// `mode` group: MatrixMode
    /// `m` len: 16
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    #[cfg(any(feature = "GL_NV_path_rendering"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_path_rendering"))))]
    pub unsafe fn glMatrixMultTransposedEXT(mode: GLenum, m: *const GLdouble) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!("calling glMatrixMultTransposedEXT({:#X}, {:p});", mode, m);
        }
        let out = call_atomic_ptr_2arg(
            "glMatrixMultTransposedEXT",
            &glMatrixMultTransposedEXT_p,
            mode,
            m,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glMatrixMultTransposedEXT");
        }
        out
    }
    #[cfg(any(feature = "GL_NV_path_rendering"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_path_rendering"))))]
    static glMatrixMultTransposedEXT_p: APcv = ap_None();
    /// Tries to load [`glMatrixMultTransposedEXT`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    #[cfg(any(feature = "GL_NV_path_rendering"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_path_rendering"))))]
    pub unsafe fn glMatrixMultTransposedEXT_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glMatrixMultTransposedEXT\0",
            &glMatrixMultTransposedEXT_p,
        )
    }
    /// Checks if the pointer for [`glMatrixMultTransposedEXT`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    #[cfg(any(feature = "GL_NV_path_rendering"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_path_rendering"))))]
    pub fn glMatrixMultTransposedEXT_is_loaded() -> bool {
        !glMatrixMultTransposedEXT_p.load(RELAX).is_null()
    }

    /// [glMatrixMultTransposefEXT](http://docs.gl/es3/glMatrixMultTransposefEXT)(mode, m)
    /// `mode` group: MatrixMode
    /// `m` len: 16
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    #[cfg(any(feature = "GL_NV_path_rendering"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_path_rendering"))))]
    pub unsafe fn glMatrixMultTransposefEXT(mode: GLenum, m: *const GLfloat) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!("calling glMatrixMultTransposefEXT({:#X}, {:p});", mode, m);
        }
        let out = call_atomic_ptr_2arg(
            "glMatrixMultTransposefEXT",
            &glMatrixMultTransposefEXT_p,
            mode,
            m,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glMatrixMultTransposefEXT");
        }
        out
    }
    #[cfg(any(feature = "GL_NV_path_rendering"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_path_rendering"))))]
    static glMatrixMultTransposefEXT_p: APcv = ap_None();
    /// Tries to load [`glMatrixMultTransposefEXT`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    #[cfg(any(feature = "GL_NV_path_rendering"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_path_rendering"))))]
    pub unsafe fn glMatrixMultTransposefEXT_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glMatrixMultTransposefEXT\0",
            &glMatrixMultTransposefEXT_p,
        )
    }
    /// Checks if the pointer for [`glMatrixMultTransposefEXT`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    #[cfg(any(feature = "GL_NV_path_rendering"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_path_rendering"))))]
    pub fn glMatrixMultTransposefEXT_is_loaded() -> bool {
        !glMatrixMultTransposefEXT_p.load(RELAX).is_null()
    }

    /// [glMatrixMultdEXT](http://docs.gl/es3/glMatrixMultdEXT)(mode, m)
    /// `mode` group: MatrixMode
    /// `m` len: 16
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    #[cfg(any(feature = "GL_NV_path_rendering"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_path_rendering"))))]
    pub unsafe fn glMatrixMultdEXT(mode: GLenum, m: *const GLdouble) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!("calling glMatrixMultdEXT({:#X}, {:p});", mode, m);
        }
        let out = call_atomic_ptr_2arg("glMatrixMultdEXT", &glMatrixMultdEXT_p, mode, m);
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glMatrixMultdEXT");
        }
        out
    }
    #[cfg(any(feature = "GL_NV_path_rendering"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_path_rendering"))))]
    static glMatrixMultdEXT_p: APcv = ap_None();
    /// Tries to load [`glMatrixMultdEXT`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    #[cfg(any(feature = "GL_NV_path_rendering"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_path_rendering"))))]
    pub unsafe fn glMatrixMultdEXT_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(get_proc_address, b"glMatrixMultdEXT\0", &glMatrixMultdEXT_p)
    }
    /// Checks if the pointer for [`glMatrixMultdEXT`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    #[cfg(any(feature = "GL_NV_path_rendering"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_path_rendering"))))]
    pub fn glMatrixMultdEXT_is_loaded() -> bool {
        !glMatrixMultdEXT_p.load(RELAX).is_null()
    }

    /// [glMatrixMultfEXT](http://docs.gl/es3/glMatrixMultfEXT)(mode, m)
    /// `mode` group: MatrixMode
    /// `m` len: 16
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    #[cfg(any(feature = "GL_NV_path_rendering"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_path_rendering"))))]
    pub unsafe fn glMatrixMultfEXT(mode: GLenum, m: *const GLfloat) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!("calling glMatrixMultfEXT({:#X}, {:p});", mode, m);
        }
        let out = call_atomic_ptr_2arg("glMatrixMultfEXT", &glMatrixMultfEXT_p, mode, m);
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glMatrixMultfEXT");
        }
        out
    }
    #[cfg(any(feature = "GL_NV_path_rendering"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_path_rendering"))))]
    static glMatrixMultfEXT_p: APcv = ap_None();
    /// Tries to load [`glMatrixMultfEXT`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    #[cfg(any(feature = "GL_NV_path_rendering"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_path_rendering"))))]
    pub unsafe fn glMatrixMultfEXT_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(get_proc_address, b"glMatrixMultfEXT\0", &glMatrixMultfEXT_p)
    }
    /// Checks if the pointer for [`glMatrixMultfEXT`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    #[cfg(any(feature = "GL_NV_path_rendering"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_path_rendering"))))]
    pub fn glMatrixMultfEXT_is_loaded() -> bool {
        !glMatrixMultfEXT_p.load(RELAX).is_null()
    }

    /// [glMatrixOrthoEXT](http://docs.gl/es3/glMatrixOrthoEXT)(mode, left, right, bottom, top, zNear, zFar)
    /// `mode` group: MatrixMode
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    #[cfg(any(feature = "GL_NV_path_rendering"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_path_rendering"))))]
    pub unsafe fn glMatrixOrthoEXT(
        mode: GLenum,
        left: GLdouble,
        right: GLdouble,
        bottom: GLdouble,
        top: GLdouble,
        zNear: GLdouble,
        zFar: GLdouble,
    ) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glMatrixOrthoEXT({:#X}, {:?}, {:?}, {:?}, {:?}, {:?}, {:?});",
                mode,
                left,
                right,
                bottom,
                top,
                zNear,
                zFar
            );
        }
        let out = call_atomic_ptr_7arg(
            "glMatrixOrthoEXT",
            &glMatrixOrthoEXT_p,
            mode,
            left,
            right,
            bottom,
            top,
            zNear,
            zFar,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glMatrixOrthoEXT");
        }
        out
    }
    #[cfg(any(feature = "GL_NV_path_rendering"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_path_rendering"))))]
    static glMatrixOrthoEXT_p: APcv = ap_None();
    /// Tries to load [`glMatrixOrthoEXT`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    #[cfg(any(feature = "GL_NV_path_rendering"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_path_rendering"))))]
    pub unsafe fn glMatrixOrthoEXT_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(get_proc_address, b"glMatrixOrthoEXT\0", &glMatrixOrthoEXT_p)
    }
    /// Checks if the pointer for [`glMatrixOrthoEXT`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    #[cfg(any(feature = "GL_NV_path_rendering"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_path_rendering"))))]
    pub fn glMatrixOrthoEXT_is_loaded() -> bool {
        !glMatrixOrthoEXT_p.load(RELAX).is_null()
    }

    /// [glMatrixPopEXT](http://docs.gl/es3/glMatrixPopEXT)(mode)
    /// `mode` group: MatrixMode
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    #[cfg(any(feature = "GL_NV_path_rendering"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_path_rendering"))))]
    pub unsafe fn glMatrixPopEXT(mode: GLenum) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!("calling glMatrixPopEXT({:#X});", mode);
        }
        let out = call_atomic_ptr_1arg("glMatrixPopEXT", &glMatrixPopEXT_p, mode);
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glMatrixPopEXT");
        }
        out
    }
    #[cfg(any(feature = "GL_NV_path_rendering"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_path_rendering"))))]
    static glMatrixPopEXT_p: APcv = ap_None();
    /// Tries to load [`glMatrixPopEXT`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    #[cfg(any(feature = "GL_NV_path_rendering"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_path_rendering"))))]
    pub unsafe fn glMatrixPopEXT_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(get_proc_address, b"glMatrixPopEXT\0", &glMatrixPopEXT_p)
    }
    /// Checks if the pointer for [`glMatrixPopEXT`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    #[cfg(any(feature = "GL_NV_path_rendering"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_path_rendering"))))]
    pub fn glMatrixPopEXT_is_loaded() -> bool {
        !glMatrixPopEXT_p.load(RELAX).is_null()
    }

    /// [glMatrixPushEXT](http://docs.gl/es3/glMatrixPushEXT)(mode)
    /// `mode` group: MatrixMode
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    #[cfg(any(feature = "GL_NV_path_rendering"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_path_rendering"))))]
    pub unsafe fn glMatrixPushEXT(mode: GLenum) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!("calling glMatrixPushEXT({:#X});", mode);
        }
        let out = call_atomic_ptr_1arg("glMatrixPushEXT", &glMatrixPushEXT_p, mode);
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glMatrixPushEXT");
        }
        out
    }
    #[cfg(any(feature = "GL_NV_path_rendering"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_path_rendering"))))]
    static glMatrixPushEXT_p: APcv = ap_None();
    /// Tries to load [`glMatrixPushEXT`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    #[cfg(any(feature = "GL_NV_path_rendering"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_path_rendering"))))]
    pub unsafe fn glMatrixPushEXT_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(get_proc_address, b"glMatrixPushEXT\0", &glMatrixPushEXT_p)
    }
    /// Checks if the pointer for [`glMatrixPushEXT`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    #[cfg(any(feature = "GL_NV_path_rendering"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_path_rendering"))))]
    pub fn glMatrixPushEXT_is_loaded() -> bool {
        !glMatrixPushEXT_p.load(RELAX).is_null()
    }

    /// [glMatrixRotatedEXT](http://docs.gl/es3/glMatrixRotatedEXT)(mode, angle, x, y, z)
    /// `mode` group: MatrixMode
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    #[cfg(any(feature = "GL_NV_path_rendering"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_path_rendering"))))]
    pub unsafe fn glMatrixRotatedEXT(
        mode: GLenum,
        angle: GLdouble,
        x: GLdouble,
        y: GLdouble,
        z: GLdouble,
    ) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glMatrixRotatedEXT({:#X}, {:?}, {:?}, {:?}, {:?});",
                mode,
                angle,
                x,
                y,
                z
            );
        }
        let out = call_atomic_ptr_5arg(
            "glMatrixRotatedEXT",
            &glMatrixRotatedEXT_p,
            mode,
            angle,
            x,
            y,
            z,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glMatrixRotatedEXT");
        }
        out
    }
    #[cfg(any(feature = "GL_NV_path_rendering"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_path_rendering"))))]
    static glMatrixRotatedEXT_p: APcv = ap_None();
    /// Tries to load [`glMatrixRotatedEXT`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    #[cfg(any(feature = "GL_NV_path_rendering"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_path_rendering"))))]
    pub unsafe fn glMatrixRotatedEXT_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glMatrixRotatedEXT\0",
            &glMatrixRotatedEXT_p,
        )
    }
    /// Checks if the pointer for [`glMatrixRotatedEXT`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    #[cfg(any(feature = "GL_NV_path_rendering"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_path_rendering"))))]
    pub fn glMatrixRotatedEXT_is_loaded() -> bool {
        !glMatrixRotatedEXT_p.load(RELAX).is_null()
    }

    /// [glMatrixRotatefEXT](http://docs.gl/es3/glMatrixRotatefEXT)(mode, angle, x, y, z)
    /// `mode` group: MatrixMode
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    #[cfg(any(feature = "GL_NV_path_rendering"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_path_rendering"))))]
    pub unsafe fn glMatrixRotatefEXT(
        mode: GLenum,
        angle: GLfloat,
        x: GLfloat,
        y: GLfloat,
        z: GLfloat,
    ) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glMatrixRotatefEXT({:#X}, {:?}, {:?}, {:?}, {:?});",
                mode,
                angle,
                x,
                y,
                z
            );
        }
        let out = call_atomic_ptr_5arg(
            "glMatrixRotatefEXT",
            &glMatrixRotatefEXT_p,
            mode,
            angle,
            x,
            y,
            z,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glMatrixRotatefEXT");
        }
        out
    }
    #[cfg(any(feature = "GL_NV_path_rendering"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_path_rendering"))))]
    static glMatrixRotatefEXT_p: APcv = ap_None();
    /// Tries to load [`glMatrixRotatefEXT`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    #[cfg(any(feature = "GL_NV_path_rendering"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_path_rendering"))))]
    pub unsafe fn glMatrixRotatefEXT_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glMatrixRotatefEXT\0",
            &glMatrixRotatefEXT_p,
        )
    }
    /// Checks if the pointer for [`glMatrixRotatefEXT`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    #[cfg(any(feature = "GL_NV_path_rendering"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_path_rendering"))))]
    pub fn glMatrixRotatefEXT_is_loaded() -> bool {
        !glMatrixRotatefEXT_p.load(RELAX).is_null()
    }

    /// [glMatrixScaledEXT](http://docs.gl/es3/glMatrixScaledEXT)(mode, x, y, z)
    /// `mode` group: MatrixMode
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    #[cfg(any(feature = "GL_NV_path_rendering"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_path_rendering"))))]
    pub unsafe fn glMatrixScaledEXT(mode: GLenum, x: GLdouble, y: GLdouble, z: GLdouble) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glMatrixScaledEXT({:#X}, {:?}, {:?}, {:?});",
                mode,
                x,
                y,
                z
            );
        }
        let out = call_atomic_ptr_4arg("glMatrixScaledEXT", &glMatrixScaledEXT_p, mode, x, y, z);
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glMatrixScaledEXT");
        }
        out
    }
    #[cfg(any(feature = "GL_NV_path_rendering"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_path_rendering"))))]
    static glMatrixScaledEXT_p: APcv = ap_None();
    /// Tries to load [`glMatrixScaledEXT`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    #[cfg(any(feature = "GL_NV_path_rendering"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_path_rendering"))))]
    pub unsafe fn glMatrixScaledEXT_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glMatrixScaledEXT\0",
            &glMatrixScaledEXT_p,
        )
    }
    /// Checks if the pointer for [`glMatrixScaledEXT`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    #[cfg(any(feature = "GL_NV_path_rendering"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_path_rendering"))))]
    pub fn glMatrixScaledEXT_is_loaded() -> bool {
        !glMatrixScaledEXT_p.load(RELAX).is_null()
    }

    /// [glMatrixScalefEXT](http://docs.gl/es3/glMatrixScalefEXT)(mode, x, y, z)
    /// `mode` group: MatrixMode
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    #[cfg(any(feature = "GL_NV_path_rendering"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_path_rendering"))))]
    pub unsafe fn glMatrixScalefEXT(mode: GLenum, x: GLfloat, y: GLfloat, z: GLfloat) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glMatrixScalefEXT({:#X}, {:?}, {:?}, {:?});",
                mode,
                x,
                y,
                z
            );
        }
        let out = call_atomic_ptr_4arg("glMatrixScalefEXT", &glMatrixScalefEXT_p, mode, x, y, z);
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glMatrixScalefEXT");
        }
        out
    }
    #[cfg(any(feature = "GL_NV_path_rendering"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_path_rendering"))))]
    static glMatrixScalefEXT_p: APcv = ap_None();
    /// Tries to load [`glMatrixScalefEXT`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    #[cfg(any(feature = "GL_NV_path_rendering"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_path_rendering"))))]
    pub unsafe fn glMatrixScalefEXT_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glMatrixScalefEXT\0",
            &glMatrixScalefEXT_p,
        )
    }
    /// Checks if the pointer for [`glMatrixScalefEXT`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    #[cfg(any(feature = "GL_NV_path_rendering"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_path_rendering"))))]
    pub fn glMatrixScalefEXT_is_loaded() -> bool {
        !glMatrixScalefEXT_p.load(RELAX).is_null()
    }

    /// [glMatrixTranslatedEXT](http://docs.gl/es3/glMatrixTranslatedEXT)(mode, x, y, z)
    /// `mode` group: MatrixMode
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    #[cfg(any(feature = "GL_NV_path_rendering"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_path_rendering"))))]
    pub unsafe fn glMatrixTranslatedEXT(mode: GLenum, x: GLdouble, y: GLdouble, z: GLdouble) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glMatrixTranslatedEXT({:#X}, {:?}, {:?}, {:?});",
                mode,
                x,
                y,
                z
            );
        }
        let out = call_atomic_ptr_4arg(
            "glMatrixTranslatedEXT",
            &glMatrixTranslatedEXT_p,
            mode,
            x,
            y,
            z,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glMatrixTranslatedEXT");
        }
        out
    }
    #[cfg(any(feature = "GL_NV_path_rendering"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_path_rendering"))))]
    static glMatrixTranslatedEXT_p: APcv = ap_None();
    /// Tries to load [`glMatrixTranslatedEXT`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    #[cfg(any(feature = "GL_NV_path_rendering"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_path_rendering"))))]
    pub unsafe fn glMatrixTranslatedEXT_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glMatrixTranslatedEXT\0",
            &glMatrixTranslatedEXT_p,
        )
    }
    /// Checks if the pointer for [`glMatrixTranslatedEXT`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    #[cfg(any(feature = "GL_NV_path_rendering"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_path_rendering"))))]
    pub fn glMatrixTranslatedEXT_is_loaded() -> bool {
        !glMatrixTranslatedEXT_p.load(RELAX).is_null()
    }

    /// [glMatrixTranslatefEXT](http://docs.gl/es3/glMatrixTranslatefEXT)(mode, x, y, z)
    /// `mode` group: MatrixMode
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    #[cfg(any(feature = "GL_NV_path_rendering"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_path_rendering"))))]
    pub unsafe fn glMatrixTranslatefEXT(mode: GLenum, x: GLfloat, y: GLfloat, z: GLfloat) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glMatrixTranslatefEXT({:#X}, {:?}, {:?}, {:?});",
                mode,
                x,
                y,
                z
            );
        }
        let out = call_atomic_ptr_4arg(
            "glMatrixTranslatefEXT",
            &glMatrixTranslatefEXT_p,
            mode,
            x,
            y,
            z,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glMatrixTranslatefEXT");
        }
        out
    }
    #[cfg(any(feature = "GL_NV_path_rendering"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_path_rendering"))))]
    static glMatrixTranslatefEXT_p: APcv = ap_None();
    /// Tries to load [`glMatrixTranslatefEXT`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    #[cfg(any(feature = "GL_NV_path_rendering"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_path_rendering"))))]
    pub unsafe fn glMatrixTranslatefEXT_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glMatrixTranslatefEXT\0",
            &glMatrixTranslatefEXT_p,
        )
    }
    /// Checks if the pointer for [`glMatrixTranslatefEXT`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    #[cfg(any(feature = "GL_NV_path_rendering"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_path_rendering"))))]
    pub fn glMatrixTranslatefEXT_is_loaded() -> bool {
        !glMatrixTranslatefEXT_p.load(RELAX).is_null()
    }

    /// [glMaxShaderCompilerThreadsKHR](http://docs.gl/es3/glMaxShaderCompilerThreadsKHR)(count)
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    #[cfg(any(feature = "GL_KHR_parallel_shader_compile"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_KHR_parallel_shader_compile"))))]
    pub unsafe fn glMaxShaderCompilerThreadsKHR(count: GLuint) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!("calling glMaxShaderCompilerThreadsKHR({:?});", count);
        }
        let out = call_atomic_ptr_1arg(
            "glMaxShaderCompilerThreadsKHR",
            &glMaxShaderCompilerThreadsKHR_p,
            count,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glMaxShaderCompilerThreadsKHR");
        }
        out
    }
    #[cfg(any(feature = "GL_KHR_parallel_shader_compile"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_KHR_parallel_shader_compile"))))]
    static glMaxShaderCompilerThreadsKHR_p: APcv = ap_None();
    /// Tries to load [`glMaxShaderCompilerThreadsKHR`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    #[cfg(any(feature = "GL_KHR_parallel_shader_compile"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_KHR_parallel_shader_compile"))))]
    pub unsafe fn glMaxShaderCompilerThreadsKHR_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glMaxShaderCompilerThreadsKHR\0",
            &glMaxShaderCompilerThreadsKHR_p,
        )
    }
    /// Checks if the pointer for [`glMaxShaderCompilerThreadsKHR`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    #[cfg(any(feature = "GL_KHR_parallel_shader_compile"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_KHR_parallel_shader_compile"))))]
    pub fn glMaxShaderCompilerThreadsKHR_is_loaded() -> bool {
        !glMaxShaderCompilerThreadsKHR_p.load(RELAX).is_null()
    }

    /// [glMemoryBarrier](http://docs.gl/es3/glMemoryBarrier)(barriers)
    /// `barriers` group: MemoryBarrierMask
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn glMemoryBarrier(barriers: GLbitfield) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!("calling glMemoryBarrier({:?});", barriers);
        }
        let out = call_atomic_ptr_1arg("glMemoryBarrier", &glMemoryBarrier_p, barriers);
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glMemoryBarrier");
        }
        out
    }
    static glMemoryBarrier_p: APcv = ap_None();
    /// Tries to load [`glMemoryBarrier`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    pub unsafe fn glMemoryBarrier_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(get_proc_address, b"glMemoryBarrier\0", &glMemoryBarrier_p)
    }
    /// Checks if the pointer for [`glMemoryBarrier`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    pub fn glMemoryBarrier_is_loaded() -> bool {
        !glMemoryBarrier_p.load(RELAX).is_null()
    }

    /// [glMemoryBarrierByRegion](http://docs.gl/es3/glMemoryBarrierByRegion)(barriers)
    /// `barriers` group: MemoryBarrierMask
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn glMemoryBarrierByRegion(barriers: GLbitfield) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!("calling glMemoryBarrierByRegion({:?});", barriers);
        }
        let out = call_atomic_ptr_1arg(
            "glMemoryBarrierByRegion",
            &glMemoryBarrierByRegion_p,
            barriers,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glMemoryBarrierByRegion");
        }
        out
    }
    static glMemoryBarrierByRegion_p: APcv = ap_None();
    /// Tries to load [`glMemoryBarrierByRegion`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    pub unsafe fn glMemoryBarrierByRegion_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glMemoryBarrierByRegion\0",
            &glMemoryBarrierByRegion_p,
        )
    }
    /// Checks if the pointer for [`glMemoryBarrierByRegion`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    pub fn glMemoryBarrierByRegion_is_loaded() -> bool {
        !glMemoryBarrierByRegion_p.load(RELAX).is_null()
    }

    /// [glMemoryObjectParameterivEXT](http://docs.gl/es3/glMemoryObjectParameterivEXT)(memoryObject, pname, params)
    /// `pname` group: MemoryObjectParameterName
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    #[cfg(any(feature = "GL_EXT_memory_object"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_memory_object"))))]
    pub unsafe fn glMemoryObjectParameterivEXT(
        memoryObject: GLuint,
        pname: GLenum,
        params: *const GLint,
    ) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glMemoryObjectParameterivEXT({:?}, {:#X}, {:p});",
                memoryObject,
                pname,
                params
            );
        }
        let out = call_atomic_ptr_3arg(
            "glMemoryObjectParameterivEXT",
            &glMemoryObjectParameterivEXT_p,
            memoryObject,
            pname,
            params,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glMemoryObjectParameterivEXT");
        }
        out
    }
    #[cfg(any(feature = "GL_EXT_memory_object"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_memory_object"))))]
    static glMemoryObjectParameterivEXT_p: APcv = ap_None();
    /// Tries to load [`glMemoryObjectParameterivEXT`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    #[cfg(any(feature = "GL_EXT_memory_object"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_memory_object"))))]
    pub unsafe fn glMemoryObjectParameterivEXT_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glMemoryObjectParameterivEXT\0",
            &glMemoryObjectParameterivEXT_p,
        )
    }
    /// Checks if the pointer for [`glMemoryObjectParameterivEXT`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    #[cfg(any(feature = "GL_EXT_memory_object"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_memory_object"))))]
    pub fn glMemoryObjectParameterivEXT_is_loaded() -> bool {
        !glMemoryObjectParameterivEXT_p.load(RELAX).is_null()
    }

    /// [glMinSampleShading](http://docs.gl/es3/glMinSampleShading)(value)
    /// `value` group: ColorF
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn glMinSampleShading(value: GLfloat) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!("calling glMinSampleShading({:?});", value);
        }
        let out = call_atomic_ptr_1arg("glMinSampleShading", &glMinSampleShading_p, value);
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glMinSampleShading");
        }
        out
    }
    static glMinSampleShading_p: APcv = ap_None();
    /// Tries to load [`glMinSampleShading`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    pub unsafe fn glMinSampleShading_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glMinSampleShading\0",
            &glMinSampleShading_p,
        )
    }
    /// Checks if the pointer for [`glMinSampleShading`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    pub fn glMinSampleShading_is_loaded() -> bool {
        !glMinSampleShading_p.load(RELAX).is_null()
    }

    /// [glMinSampleShadingOES](http://docs.gl/es3/glMinSampleShadingOES)(value)
    /// `value` group: ColorF
    /// alias of: [`glMinSampleShading`]
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    #[cfg(any(feature = "GL_OES_sample_shading"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_OES_sample_shading"))))]
    pub unsafe fn glMinSampleShadingOES(value: GLfloat) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!("calling glMinSampleShadingOES({:?});", value);
        }
        let out = call_atomic_ptr_1arg("glMinSampleShadingOES", &glMinSampleShadingOES_p, value);
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glMinSampleShadingOES");
        }
        out
    }
    #[cfg(any(feature = "GL_OES_sample_shading"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_OES_sample_shading"))))]
    static glMinSampleShadingOES_p: APcv = ap_None();
    /// Tries to load [`glMinSampleShadingOES`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    #[cfg(any(feature = "GL_OES_sample_shading"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_OES_sample_shading"))))]
    pub unsafe fn glMinSampleShadingOES_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glMinSampleShadingOES\0",
            &glMinSampleShadingOES_p,
        )
    }
    /// Checks if the pointer for [`glMinSampleShadingOES`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    #[cfg(any(feature = "GL_OES_sample_shading"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_OES_sample_shading"))))]
    pub fn glMinSampleShadingOES_is_loaded() -> bool {
        !glMinSampleShadingOES_p.load(RELAX).is_null()
    }

    /// [glMultiDrawArraysEXT](http://docs.gl/es3/glMultiDrawArraysEXT)(mode, first, count, primcount)
    /// `mode` group: PrimitiveType
    /// `first` len: COMPSIZE(primcount)
    /// `count` len: COMPSIZE(primcount)
    /// alias of: [`glMultiDrawArrays`]
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    #[cfg(any(feature = "GL_EXT_multi_draw_arrays"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_multi_draw_arrays"))))]
    pub unsafe fn glMultiDrawArraysEXT(
        mode: GLenum,
        first: *const GLint,
        count: *const GLsizei,
        primcount: GLsizei,
    ) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glMultiDrawArraysEXT({:#X}, {:p}, {:p}, {:?});",
                mode,
                first,
                count,
                primcount
            );
        }
        let out = call_atomic_ptr_4arg(
            "glMultiDrawArraysEXT",
            &glMultiDrawArraysEXT_p,
            mode,
            first,
            count,
            primcount,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glMultiDrawArraysEXT");
        }
        out
    }
    #[cfg(any(feature = "GL_EXT_multi_draw_arrays"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_multi_draw_arrays"))))]
    static glMultiDrawArraysEXT_p: APcv = ap_None();
    /// Tries to load [`glMultiDrawArraysEXT`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    #[cfg(any(feature = "GL_EXT_multi_draw_arrays"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_multi_draw_arrays"))))]
    pub unsafe fn glMultiDrawArraysEXT_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glMultiDrawArraysEXT\0",
            &glMultiDrawArraysEXT_p,
        )
    }
    /// Checks if the pointer for [`glMultiDrawArraysEXT`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    #[cfg(any(feature = "GL_EXT_multi_draw_arrays"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_multi_draw_arrays"))))]
    pub fn glMultiDrawArraysEXT_is_loaded() -> bool {
        !glMultiDrawArraysEXT_p.load(RELAX).is_null()
    }

    /// [glMultiDrawArraysIndirectEXT](http://docs.gl/es3/glMultiDrawArraysIndirectEXT)(mode, indirect, drawcount, stride)
    /// `mode` group: PrimitiveType
    /// `indirect` len: COMPSIZE(drawcount,stride)
    /// alias of: [`glMultiDrawArraysIndirect`]
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    #[cfg(any(feature = "GL_EXT_multi_draw_indirect"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_multi_draw_indirect"))))]
    pub unsafe fn glMultiDrawArraysIndirectEXT(
        mode: GLenum,
        indirect: *const c_void,
        drawcount: GLsizei,
        stride: GLsizei,
    ) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glMultiDrawArraysIndirectEXT({:#X}, {:p}, {:?}, {:?});",
                mode,
                indirect,
                drawcount,
                stride
            );
        }
        let out = call_atomic_ptr_4arg(
            "glMultiDrawArraysIndirectEXT",
            &glMultiDrawArraysIndirectEXT_p,
            mode,
            indirect,
            drawcount,
            stride,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glMultiDrawArraysIndirectEXT");
        }
        out
    }
    #[cfg(any(feature = "GL_EXT_multi_draw_indirect"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_multi_draw_indirect"))))]
    static glMultiDrawArraysIndirectEXT_p: APcv = ap_None();
    /// Tries to load [`glMultiDrawArraysIndirectEXT`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    #[cfg(any(feature = "GL_EXT_multi_draw_indirect"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_multi_draw_indirect"))))]
    pub unsafe fn glMultiDrawArraysIndirectEXT_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glMultiDrawArraysIndirectEXT\0",
            &glMultiDrawArraysIndirectEXT_p,
        )
    }
    /// Checks if the pointer for [`glMultiDrawArraysIndirectEXT`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    #[cfg(any(feature = "GL_EXT_multi_draw_indirect"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_multi_draw_indirect"))))]
    pub fn glMultiDrawArraysIndirectEXT_is_loaded() -> bool {
        !glMultiDrawArraysIndirectEXT_p.load(RELAX).is_null()
    }

    /// [glMultiDrawElementsBaseVertexEXT](http://docs.gl/es3/glMultiDrawElementsBaseVertexEXT)(mode, count, type_, indices, drawcount, basevertex)
    /// `mode` group: PrimitiveType
    /// `count` len: COMPSIZE(drawcount)
    /// `type_` group: DrawElementsType
    /// `indices` len: COMPSIZE(drawcount)
    /// `basevertex` len: COMPSIZE(drawcount)
    /// alias of: [`glMultiDrawElementsBaseVertex`]
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    #[cfg(any(
        feature = "GL_EXT_draw_elements_base_vertex",
        feature = "GL_OES_draw_elements_base_vertex"
    ))]
    #[cfg_attr(
        docs_rs,
        doc(cfg(any(
            feature = "GL_EXT_draw_elements_base_vertex",
            feature = "GL_OES_draw_elements_base_vertex"
        )))
    )]
    pub unsafe fn glMultiDrawElementsBaseVertexEXT(
        mode: GLenum,
        count: *const GLsizei,
        type_: GLenum,
        indices: *const *const c_void,
        drawcount: GLsizei,
        basevertex: *const GLint,
    ) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glMultiDrawElementsBaseVertexEXT({:#X}, {:p}, {:#X}, {:p}, {:?}, {:p});",
                mode,
                count,
                type_,
                indices,
                drawcount,
                basevertex
            );
        }
        let out = call_atomic_ptr_6arg(
            "glMultiDrawElementsBaseVertexEXT",
            &glMultiDrawElementsBaseVertexEXT_p,
            mode,
            count,
            type_,
            indices,
            drawcount,
            basevertex,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glMultiDrawElementsBaseVertexEXT");
        }
        out
    }
    #[cfg(any(
        feature = "GL_EXT_draw_elements_base_vertex",
        feature = "GL_OES_draw_elements_base_vertex"
    ))]
    #[cfg_attr(
        docs_rs,
        doc(cfg(any(
            feature = "GL_EXT_draw_elements_base_vertex",
            feature = "GL_OES_draw_elements_base_vertex"
        )))
    )]
    static glMultiDrawElementsBaseVertexEXT_p: APcv = ap_None();
    /// Tries to load [`glMultiDrawElementsBaseVertexEXT`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    #[cfg(any(
        feature = "GL_EXT_draw_elements_base_vertex",
        feature = "GL_OES_draw_elements_base_vertex"
    ))]
    #[cfg_attr(
        docs_rs,
        doc(cfg(any(
            feature = "GL_EXT_draw_elements_base_vertex",
            feature = "GL_OES_draw_elements_base_vertex"
        )))
    )]
    pub unsafe fn glMultiDrawElementsBaseVertexEXT_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glMultiDrawElementsBaseVertexEXT\0",
            &glMultiDrawElementsBaseVertexEXT_p,
        )
    }
    /// Checks if the pointer for [`glMultiDrawElementsBaseVertexEXT`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    #[cfg(any(
        feature = "GL_EXT_draw_elements_base_vertex",
        feature = "GL_OES_draw_elements_base_vertex"
    ))]
    #[cfg_attr(
        docs_rs,
        doc(cfg(any(
            feature = "GL_EXT_draw_elements_base_vertex",
            feature = "GL_OES_draw_elements_base_vertex"
        )))
    )]
    pub fn glMultiDrawElementsBaseVertexEXT_is_loaded() -> bool {
        !glMultiDrawElementsBaseVertexEXT_p.load(RELAX).is_null()
    }

    /// [glMultiDrawElementsEXT](http://docs.gl/es3/glMultiDrawElementsEXT)(mode, count, type_, indices, primcount)
    /// `mode` group: PrimitiveType
    /// `count` len: COMPSIZE(primcount)
    /// `type_` group: DrawElementsType
    /// `indices` len: COMPSIZE(primcount)
    /// alias of: [`glMultiDrawElements`]
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    #[cfg(any(feature = "GL_EXT_multi_draw_arrays"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_multi_draw_arrays"))))]
    pub unsafe fn glMultiDrawElementsEXT(
        mode: GLenum,
        count: *const GLsizei,
        type_: GLenum,
        indices: *const *const c_void,
        primcount: GLsizei,
    ) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glMultiDrawElementsEXT({:#X}, {:p}, {:#X}, {:p}, {:?});",
                mode,
                count,
                type_,
                indices,
                primcount
            );
        }
        let out = call_atomic_ptr_5arg(
            "glMultiDrawElementsEXT",
            &glMultiDrawElementsEXT_p,
            mode,
            count,
            type_,
            indices,
            primcount,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glMultiDrawElementsEXT");
        }
        out
    }
    #[cfg(any(feature = "GL_EXT_multi_draw_arrays"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_multi_draw_arrays"))))]
    static glMultiDrawElementsEXT_p: APcv = ap_None();
    /// Tries to load [`glMultiDrawElementsEXT`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    #[cfg(any(feature = "GL_EXT_multi_draw_arrays"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_multi_draw_arrays"))))]
    pub unsafe fn glMultiDrawElementsEXT_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glMultiDrawElementsEXT\0",
            &glMultiDrawElementsEXT_p,
        )
    }
    /// Checks if the pointer for [`glMultiDrawElementsEXT`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    #[cfg(any(feature = "GL_EXT_multi_draw_arrays"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_multi_draw_arrays"))))]
    pub fn glMultiDrawElementsEXT_is_loaded() -> bool {
        !glMultiDrawElementsEXT_p.load(RELAX).is_null()
    }

    /// [glMultiDrawElementsIndirectEXT](http://docs.gl/es3/glMultiDrawElementsIndirectEXT)(mode, type_, indirect, drawcount, stride)
    /// `mode` group: PrimitiveType
    /// `type_` group: DrawElementsType
    /// `indirect` len: COMPSIZE(drawcount,stride)
    /// alias of: [`glMultiDrawElementsIndirect`]
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    #[cfg(any(feature = "GL_EXT_multi_draw_indirect"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_multi_draw_indirect"))))]
    pub unsafe fn glMultiDrawElementsIndirectEXT(
        mode: GLenum,
        type_: GLenum,
        indirect: *const c_void,
        drawcount: GLsizei,
        stride: GLsizei,
    ) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glMultiDrawElementsIndirectEXT({:#X}, {:#X}, {:p}, {:?}, {:?});",
                mode,
                type_,
                indirect,
                drawcount,
                stride
            );
        }
        let out = call_atomic_ptr_5arg(
            "glMultiDrawElementsIndirectEXT",
            &glMultiDrawElementsIndirectEXT_p,
            mode,
            type_,
            indirect,
            drawcount,
            stride,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glMultiDrawElementsIndirectEXT");
        }
        out
    }
    #[cfg(any(feature = "GL_EXT_multi_draw_indirect"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_multi_draw_indirect"))))]
    static glMultiDrawElementsIndirectEXT_p: APcv = ap_None();
    /// Tries to load [`glMultiDrawElementsIndirectEXT`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    #[cfg(any(feature = "GL_EXT_multi_draw_indirect"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_multi_draw_indirect"))))]
    pub unsafe fn glMultiDrawElementsIndirectEXT_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glMultiDrawElementsIndirectEXT\0",
            &glMultiDrawElementsIndirectEXT_p,
        )
    }
    /// Checks if the pointer for [`glMultiDrawElementsIndirectEXT`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    #[cfg(any(feature = "GL_EXT_multi_draw_indirect"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_multi_draw_indirect"))))]
    pub fn glMultiDrawElementsIndirectEXT_is_loaded() -> bool {
        !glMultiDrawElementsIndirectEXT_p.load(RELAX).is_null()
    }

    /// [glMultiDrawMeshTasksIndirectCountNV](http://docs.gl/es3/glMultiDrawMeshTasksIndirectCountNV)(indirect, drawcount, maxdrawcount, stride)
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    #[cfg(any(feature = "GL_NV_mesh_shader"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_mesh_shader"))))]
    pub unsafe fn glMultiDrawMeshTasksIndirectCountNV(
        indirect: GLintptr,
        drawcount: GLintptr,
        maxdrawcount: GLsizei,
        stride: GLsizei,
    ) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glMultiDrawMeshTasksIndirectCountNV({:?}, {:?}, {:?}, {:?});",
                indirect,
                drawcount,
                maxdrawcount,
                stride
            );
        }
        let out = call_atomic_ptr_4arg(
            "glMultiDrawMeshTasksIndirectCountNV",
            &glMultiDrawMeshTasksIndirectCountNV_p,
            indirect,
            drawcount,
            maxdrawcount,
            stride,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glMultiDrawMeshTasksIndirectCountNV");
        }
        out
    }
    #[cfg(any(feature = "GL_NV_mesh_shader"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_mesh_shader"))))]
    static glMultiDrawMeshTasksIndirectCountNV_p: APcv = ap_None();
    /// Tries to load [`glMultiDrawMeshTasksIndirectCountNV`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    #[cfg(any(feature = "GL_NV_mesh_shader"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_mesh_shader"))))]
    pub unsafe fn glMultiDrawMeshTasksIndirectCountNV_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glMultiDrawMeshTasksIndirectCountNV\0",
            &glMultiDrawMeshTasksIndirectCountNV_p,
        )
    }
    /// Checks if the pointer for [`glMultiDrawMeshTasksIndirectCountNV`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    #[cfg(any(feature = "GL_NV_mesh_shader"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_mesh_shader"))))]
    pub fn glMultiDrawMeshTasksIndirectCountNV_is_loaded() -> bool {
        !glMultiDrawMeshTasksIndirectCountNV_p.load(RELAX).is_null()
    }

    /// [glMultiDrawMeshTasksIndirectNV](http://docs.gl/es3/glMultiDrawMeshTasksIndirectNV)(indirect, drawcount, stride)
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    #[cfg(any(feature = "GL_NV_mesh_shader"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_mesh_shader"))))]
    pub unsafe fn glMultiDrawMeshTasksIndirectNV(
        indirect: GLintptr,
        drawcount: GLsizei,
        stride: GLsizei,
    ) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glMultiDrawMeshTasksIndirectNV({:?}, {:?}, {:?});",
                indirect,
                drawcount,
                stride
            );
        }
        let out = call_atomic_ptr_3arg(
            "glMultiDrawMeshTasksIndirectNV",
            &glMultiDrawMeshTasksIndirectNV_p,
            indirect,
            drawcount,
            stride,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glMultiDrawMeshTasksIndirectNV");
        }
        out
    }
    #[cfg(any(feature = "GL_NV_mesh_shader"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_mesh_shader"))))]
    static glMultiDrawMeshTasksIndirectNV_p: APcv = ap_None();
    /// Tries to load [`glMultiDrawMeshTasksIndirectNV`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    #[cfg(any(feature = "GL_NV_mesh_shader"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_mesh_shader"))))]
    pub unsafe fn glMultiDrawMeshTasksIndirectNV_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glMultiDrawMeshTasksIndirectNV\0",
            &glMultiDrawMeshTasksIndirectNV_p,
        )
    }
    /// Checks if the pointer for [`glMultiDrawMeshTasksIndirectNV`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    #[cfg(any(feature = "GL_NV_mesh_shader"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_mesh_shader"))))]
    pub fn glMultiDrawMeshTasksIndirectNV_is_loaded() -> bool {
        !glMultiDrawMeshTasksIndirectNV_p.load(RELAX).is_null()
    }

    /// [glNamedBufferAttachMemoryNV](http://docs.gl/es3/glNamedBufferAttachMemoryNV)(buffer, memory, offset)
    /// `buffer` class: buffer
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    #[cfg(any(feature = "GL_NV_memory_attachment"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_memory_attachment"))))]
    pub unsafe fn glNamedBufferAttachMemoryNV(buffer: GLuint, memory: GLuint, offset: GLuint64) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glNamedBufferAttachMemoryNV({:?}, {:?}, {:?});",
                buffer,
                memory,
                offset
            );
        }
        let out = call_atomic_ptr_3arg(
            "glNamedBufferAttachMemoryNV",
            &glNamedBufferAttachMemoryNV_p,
            buffer,
            memory,
            offset,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glNamedBufferAttachMemoryNV");
        }
        out
    }
    #[cfg(any(feature = "GL_NV_memory_attachment"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_memory_attachment"))))]
    static glNamedBufferAttachMemoryNV_p: APcv = ap_None();
    /// Tries to load [`glNamedBufferAttachMemoryNV`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    #[cfg(any(feature = "GL_NV_memory_attachment"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_memory_attachment"))))]
    pub unsafe fn glNamedBufferAttachMemoryNV_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glNamedBufferAttachMemoryNV\0",
            &glNamedBufferAttachMemoryNV_p,
        )
    }
    /// Checks if the pointer for [`glNamedBufferAttachMemoryNV`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    #[cfg(any(feature = "GL_NV_memory_attachment"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_memory_attachment"))))]
    pub fn glNamedBufferAttachMemoryNV_is_loaded() -> bool {
        !glNamedBufferAttachMemoryNV_p.load(RELAX).is_null()
    }

    /// [glNamedBufferPageCommitmentMemNV](http://docs.gl/es3/glNamedBufferPageCommitmentMemNV)(buffer, offset, size, memory, memOffset, commit)
    /// `buffer` class: buffer
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    #[cfg(any(feature = "GL_NV_memory_object_sparse"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_memory_object_sparse"))))]
    pub unsafe fn glNamedBufferPageCommitmentMemNV(
        buffer: GLuint,
        offset: GLintptr,
        size: GLsizeiptr,
        memory: GLuint,
        memOffset: GLuint64,
        commit: GLboolean,
    ) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glNamedBufferPageCommitmentMemNV({:?}, {:?}, {:?}, {:?}, {:?}, {:?});",
                buffer,
                offset,
                size,
                memory,
                memOffset,
                commit
            );
        }
        let out = call_atomic_ptr_6arg(
            "glNamedBufferPageCommitmentMemNV",
            &glNamedBufferPageCommitmentMemNV_p,
            buffer,
            offset,
            size,
            memory,
            memOffset,
            commit,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glNamedBufferPageCommitmentMemNV");
        }
        out
    }
    #[cfg(any(feature = "GL_NV_memory_object_sparse"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_memory_object_sparse"))))]
    static glNamedBufferPageCommitmentMemNV_p: APcv = ap_None();
    /// Tries to load [`glNamedBufferPageCommitmentMemNV`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    #[cfg(any(feature = "GL_NV_memory_object_sparse"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_memory_object_sparse"))))]
    pub unsafe fn glNamedBufferPageCommitmentMemNV_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glNamedBufferPageCommitmentMemNV\0",
            &glNamedBufferPageCommitmentMemNV_p,
        )
    }
    /// Checks if the pointer for [`glNamedBufferPageCommitmentMemNV`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    #[cfg(any(feature = "GL_NV_memory_object_sparse"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_memory_object_sparse"))))]
    pub fn glNamedBufferPageCommitmentMemNV_is_loaded() -> bool {
        !glNamedBufferPageCommitmentMemNV_p.load(RELAX).is_null()
    }

    /// [glNamedBufferStorageExternalEXT](http://docs.gl/es3/glNamedBufferStorageExternalEXT)(buffer, offset, size, clientBuffer, flags)
    /// `buffer` class: buffer
    /// `flags` group: BufferStorageMask
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    #[cfg(any(feature = "GL_EXT_external_buffer"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_external_buffer"))))]
    pub unsafe fn glNamedBufferStorageExternalEXT(
        buffer: GLuint,
        offset: GLintptr,
        size: GLsizeiptr,
        clientBuffer: GLeglClientBufferEXT,
        flags: GLbitfield,
    ) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glNamedBufferStorageExternalEXT({:?}, {:?}, {:?}, {:?}, {:?});",
                buffer,
                offset,
                size,
                clientBuffer,
                flags
            );
        }
        let out = call_atomic_ptr_5arg(
            "glNamedBufferStorageExternalEXT",
            &glNamedBufferStorageExternalEXT_p,
            buffer,
            offset,
            size,
            clientBuffer,
            flags,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glNamedBufferStorageExternalEXT");
        }
        out
    }
    #[cfg(any(feature = "GL_EXT_external_buffer"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_external_buffer"))))]
    static glNamedBufferStorageExternalEXT_p: APcv = ap_None();
    /// Tries to load [`glNamedBufferStorageExternalEXT`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    #[cfg(any(feature = "GL_EXT_external_buffer"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_external_buffer"))))]
    pub unsafe fn glNamedBufferStorageExternalEXT_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glNamedBufferStorageExternalEXT\0",
            &glNamedBufferStorageExternalEXT_p,
        )
    }
    /// Checks if the pointer for [`glNamedBufferStorageExternalEXT`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    #[cfg(any(feature = "GL_EXT_external_buffer"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_external_buffer"))))]
    pub fn glNamedBufferStorageExternalEXT_is_loaded() -> bool {
        !glNamedBufferStorageExternalEXT_p.load(RELAX).is_null()
    }

    /// [glNamedBufferStorageMemEXT](http://docs.gl/es3/glNamedBufferStorageMemEXT)(buffer, size, memory, offset)
    /// `buffer` class: buffer
    /// `size` group: BufferSize
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    #[cfg(any(feature = "GL_EXT_memory_object"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_memory_object"))))]
    pub unsafe fn glNamedBufferStorageMemEXT(
        buffer: GLuint,
        size: GLsizeiptr,
        memory: GLuint,
        offset: GLuint64,
    ) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glNamedBufferStorageMemEXT({:?}, {:?}, {:?}, {:?});",
                buffer,
                size,
                memory,
                offset
            );
        }
        let out = call_atomic_ptr_4arg(
            "glNamedBufferStorageMemEXT",
            &glNamedBufferStorageMemEXT_p,
            buffer,
            size,
            memory,
            offset,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glNamedBufferStorageMemEXT");
        }
        out
    }
    #[cfg(any(feature = "GL_EXT_memory_object"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_memory_object"))))]
    static glNamedBufferStorageMemEXT_p: APcv = ap_None();
    /// Tries to load [`glNamedBufferStorageMemEXT`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    #[cfg(any(feature = "GL_EXT_memory_object"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_memory_object"))))]
    pub unsafe fn glNamedBufferStorageMemEXT_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glNamedBufferStorageMemEXT\0",
            &glNamedBufferStorageMemEXT_p,
        )
    }
    /// Checks if the pointer for [`glNamedBufferStorageMemEXT`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    #[cfg(any(feature = "GL_EXT_memory_object"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_memory_object"))))]
    pub fn glNamedBufferStorageMemEXT_is_loaded() -> bool {
        !glNamedBufferStorageMemEXT_p.load(RELAX).is_null()
    }

    /// [glNamedFramebufferSampleLocationsfvNV](http://docs.gl/es3/glNamedFramebufferSampleLocationsfvNV)(framebuffer, start, count, v)
    /// `framebuffer` class: framebuffer
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    #[cfg(any(feature = "GL_NV_sample_locations"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_sample_locations"))))]
    pub unsafe fn glNamedFramebufferSampleLocationsfvNV(
        framebuffer: GLuint,
        start: GLuint,
        count: GLsizei,
        v: *const GLfloat,
    ) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glNamedFramebufferSampleLocationsfvNV({:?}, {:?}, {:?}, {:p});",
                framebuffer,
                start,
                count,
                v
            );
        }
        let out = call_atomic_ptr_4arg(
            "glNamedFramebufferSampleLocationsfvNV",
            &glNamedFramebufferSampleLocationsfvNV_p,
            framebuffer,
            start,
            count,
            v,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glNamedFramebufferSampleLocationsfvNV");
        }
        out
    }
    #[cfg(any(feature = "GL_NV_sample_locations"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_sample_locations"))))]
    static glNamedFramebufferSampleLocationsfvNV_p: APcv = ap_None();
    /// Tries to load [`glNamedFramebufferSampleLocationsfvNV`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    #[cfg(any(feature = "GL_NV_sample_locations"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_sample_locations"))))]
    pub unsafe fn glNamedFramebufferSampleLocationsfvNV_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glNamedFramebufferSampleLocationsfvNV\0",
            &glNamedFramebufferSampleLocationsfvNV_p,
        )
    }
    /// Checks if the pointer for [`glNamedFramebufferSampleLocationsfvNV`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    #[cfg(any(feature = "GL_NV_sample_locations"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_sample_locations"))))]
    pub fn glNamedFramebufferSampleLocationsfvNV_is_loaded() -> bool {
        !glNamedFramebufferSampleLocationsfvNV_p
            .load(RELAX)
            .is_null()
    }

    /// [glNamedRenderbufferStorageMultisampleAdvancedAMD](http://docs.gl/es3/glNamedRenderbufferStorageMultisampleAdvancedAMD)(renderbuffer, samples, storageSamples, internalformat, width, height)
    /// `renderbuffer` group: Renderbuffer
    /// `renderbuffer` class: renderbuffer
    /// `internalformat` group: InternalFormat
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    #[cfg(any(feature = "GL_AMD_framebuffer_multisample_advanced"))]
    #[cfg_attr(
        docs_rs,
        doc(cfg(any(feature = "GL_AMD_framebuffer_multisample_advanced")))
    )]
    pub unsafe fn glNamedRenderbufferStorageMultisampleAdvancedAMD(
        renderbuffer: GLuint,
        samples: GLsizei,
        storageSamples: GLsizei,
        internalformat: GLenum,
        width: GLsizei,
        height: GLsizei,
    ) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glNamedRenderbufferStorageMultisampleAdvancedAMD({:?}, {:?}, {:?}, {:#X}, {:?}, {:?});",
                renderbuffer,
                samples,
                storageSamples,
                internalformat,
                width,
                height
            );
        }
        let out = call_atomic_ptr_6arg(
            "glNamedRenderbufferStorageMultisampleAdvancedAMD",
            &glNamedRenderbufferStorageMultisampleAdvancedAMD_p,
            renderbuffer,
            samples,
            storageSamples,
            internalformat,
            width,
            height,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glNamedRenderbufferStorageMultisampleAdvancedAMD");
        }
        out
    }
    #[cfg(any(feature = "GL_AMD_framebuffer_multisample_advanced"))]
    #[cfg_attr(
        docs_rs,
        doc(cfg(any(feature = "GL_AMD_framebuffer_multisample_advanced")))
    )]
    static glNamedRenderbufferStorageMultisampleAdvancedAMD_p: APcv = ap_None();
    /// Tries to load [`glNamedRenderbufferStorageMultisampleAdvancedAMD`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    #[cfg(any(feature = "GL_AMD_framebuffer_multisample_advanced"))]
    #[cfg_attr(
        docs_rs,
        doc(cfg(any(feature = "GL_AMD_framebuffer_multisample_advanced")))
    )]
    pub unsafe fn glNamedRenderbufferStorageMultisampleAdvancedAMD_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glNamedRenderbufferStorageMultisampleAdvancedAMD\0",
            &glNamedRenderbufferStorageMultisampleAdvancedAMD_p,
        )
    }
    /// Checks if the pointer for [`glNamedRenderbufferStorageMultisampleAdvancedAMD`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    #[cfg(any(feature = "GL_AMD_framebuffer_multisample_advanced"))]
    #[cfg_attr(
        docs_rs,
        doc(cfg(any(feature = "GL_AMD_framebuffer_multisample_advanced")))
    )]
    pub fn glNamedRenderbufferStorageMultisampleAdvancedAMD_is_loaded() -> bool {
        !glNamedRenderbufferStorageMultisampleAdvancedAMD_p
            .load(RELAX)
            .is_null()
    }

    /// [glObjectLabel](http://docs.gl/es3/glObjectLabel)(identifier, name, length, label)
    /// `identifier` group: ObjectIdentifier
    /// `label` len: COMPSIZE(label,length)
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn glObjectLabel(
        identifier: GLenum,
        name: GLuint,
        length: GLsizei,
        label: *const GLchar,
    ) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glObjectLabel({:#X}, {:?}, {:?}, {:p});",
                identifier,
                name,
                length,
                label
            );
        }
        let out = call_atomic_ptr_4arg(
            "glObjectLabel",
            &glObjectLabel_p,
            identifier,
            name,
            length,
            label,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glObjectLabel");
        }
        out
    }
    static glObjectLabel_p: APcv = ap_None();
    /// Tries to load [`glObjectLabel`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    pub unsafe fn glObjectLabel_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(get_proc_address, b"glObjectLabel\0", &glObjectLabel_p)
    }
    /// Checks if the pointer for [`glObjectLabel`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    pub fn glObjectLabel_is_loaded() -> bool {
        !glObjectLabel_p.load(RELAX).is_null()
    }

    /// [glObjectLabelKHR](http://docs.gl/es3/glObjectLabelKHR)(identifier, name, length, label)
    /// `identifier` group: ObjectIdentifier
    /// alias of: [`glObjectLabel`]
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    #[cfg(any(feature = "GL_KHR_debug"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_KHR_debug"))))]
    pub unsafe fn glObjectLabelKHR(
        identifier: GLenum,
        name: GLuint,
        length: GLsizei,
        label: *const GLchar,
    ) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glObjectLabelKHR({:#X}, {:?}, {:?}, {:p});",
                identifier,
                name,
                length,
                label
            );
        }
        let out = call_atomic_ptr_4arg(
            "glObjectLabelKHR",
            &glObjectLabelKHR_p,
            identifier,
            name,
            length,
            label,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glObjectLabelKHR");
        }
        out
    }
    #[cfg(any(feature = "GL_KHR_debug"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_KHR_debug"))))]
    static glObjectLabelKHR_p: APcv = ap_None();
    /// Tries to load [`glObjectLabelKHR`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    #[cfg(any(feature = "GL_KHR_debug"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_KHR_debug"))))]
    pub unsafe fn glObjectLabelKHR_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(get_proc_address, b"glObjectLabelKHR\0", &glObjectLabelKHR_p)
    }
    /// Checks if the pointer for [`glObjectLabelKHR`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    #[cfg(any(feature = "GL_KHR_debug"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_KHR_debug"))))]
    pub fn glObjectLabelKHR_is_loaded() -> bool {
        !glObjectLabelKHR_p.load(RELAX).is_null()
    }

    /// [glObjectPtrLabel](http://docs.gl/es3/glObjectPtrLabel)(ptr, length, label)
    /// `label` len: COMPSIZE(label,length)
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn glObjectPtrLabel(ptr: *const c_void, length: GLsizei, label: *const GLchar) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glObjectPtrLabel({:p}, {:?}, {:p});",
                ptr,
                length,
                label
            );
        }
        let out = call_atomic_ptr_3arg("glObjectPtrLabel", &glObjectPtrLabel_p, ptr, length, label);
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glObjectPtrLabel");
        }
        out
    }
    static glObjectPtrLabel_p: APcv = ap_None();
    /// Tries to load [`glObjectPtrLabel`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    pub unsafe fn glObjectPtrLabel_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(get_proc_address, b"glObjectPtrLabel\0", &glObjectPtrLabel_p)
    }
    /// Checks if the pointer for [`glObjectPtrLabel`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    pub fn glObjectPtrLabel_is_loaded() -> bool {
        !glObjectPtrLabel_p.load(RELAX).is_null()
    }

    /// [glObjectPtrLabelKHR](http://docs.gl/es3/glObjectPtrLabelKHR)(ptr, length, label)
    /// alias of: [`glObjectPtrLabel`]
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    #[cfg(any(feature = "GL_KHR_debug"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_KHR_debug"))))]
    pub unsafe fn glObjectPtrLabelKHR(ptr: *const c_void, length: GLsizei, label: *const GLchar) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glObjectPtrLabelKHR({:p}, {:?}, {:p});",
                ptr,
                length,
                label
            );
        }
        let out = call_atomic_ptr_3arg(
            "glObjectPtrLabelKHR",
            &glObjectPtrLabelKHR_p,
            ptr,
            length,
            label,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glObjectPtrLabelKHR");
        }
        out
    }
    #[cfg(any(feature = "GL_KHR_debug"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_KHR_debug"))))]
    static glObjectPtrLabelKHR_p: APcv = ap_None();
    /// Tries to load [`glObjectPtrLabelKHR`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    #[cfg(any(feature = "GL_KHR_debug"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_KHR_debug"))))]
    pub unsafe fn glObjectPtrLabelKHR_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glObjectPtrLabelKHR\0",
            &glObjectPtrLabelKHR_p,
        )
    }
    /// Checks if the pointer for [`glObjectPtrLabelKHR`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    #[cfg(any(feature = "GL_KHR_debug"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_KHR_debug"))))]
    pub fn glObjectPtrLabelKHR_is_loaded() -> bool {
        !glObjectPtrLabelKHR_p.load(RELAX).is_null()
    }

    /// [glPatchParameteri](http://docs.gl/es3/glPatchParameter)(pname, value)
    /// `pname` group: PatchParameterName
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn glPatchParameteri(pname: GLenum, value: GLint) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!("calling glPatchParameteri({:#X}, {:?});", pname, value);
        }
        let out = call_atomic_ptr_2arg("glPatchParameteri", &glPatchParameteri_p, pname, value);
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glPatchParameteri");
        }
        out
    }
    static glPatchParameteri_p: APcv = ap_None();
    /// Tries to load [`glPatchParameteri`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    pub unsafe fn glPatchParameteri_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glPatchParameteri\0",
            &glPatchParameteri_p,
        )
    }
    /// Checks if the pointer for [`glPatchParameteri`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    pub fn glPatchParameteri_is_loaded() -> bool {
        !glPatchParameteri_p.load(RELAX).is_null()
    }

    /// [glPatchParameteriEXT](http://docs.gl/es3/glPatchParameteriEXT)(pname, value)
    /// `pname` group: PatchParameterName
    /// alias of: [`glPatchParameteri`]
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    #[cfg(any(feature = "GL_EXT_tessellation_shader"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_tessellation_shader"))))]
    pub unsafe fn glPatchParameteriEXT(pname: GLenum, value: GLint) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!("calling glPatchParameteriEXT({:#X}, {:?});", pname, value);
        }
        let out = call_atomic_ptr_2arg(
            "glPatchParameteriEXT",
            &glPatchParameteriEXT_p,
            pname,
            value,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glPatchParameteriEXT");
        }
        out
    }
    #[cfg(any(feature = "GL_EXT_tessellation_shader"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_tessellation_shader"))))]
    static glPatchParameteriEXT_p: APcv = ap_None();
    /// Tries to load [`glPatchParameteriEXT`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    #[cfg(any(feature = "GL_EXT_tessellation_shader"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_tessellation_shader"))))]
    pub unsafe fn glPatchParameteriEXT_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glPatchParameteriEXT\0",
            &glPatchParameteriEXT_p,
        )
    }
    /// Checks if the pointer for [`glPatchParameteriEXT`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    #[cfg(any(feature = "GL_EXT_tessellation_shader"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_tessellation_shader"))))]
    pub fn glPatchParameteriEXT_is_loaded() -> bool {
        !glPatchParameteriEXT_p.load(RELAX).is_null()
    }

    /// [glPatchParameteriOES](http://docs.gl/es3/glPatchParameteriOES)(pname, value)
    /// `pname` group: PatchParameterName
    /// alias of: [`glPatchParameteri`]
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    #[cfg(any(feature = "GL_OES_tessellation_shader"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_OES_tessellation_shader"))))]
    pub unsafe fn glPatchParameteriOES(pname: GLenum, value: GLint) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!("calling glPatchParameteriOES({:#X}, {:?});", pname, value);
        }
        let out = call_atomic_ptr_2arg(
            "glPatchParameteriOES",
            &glPatchParameteriOES_p,
            pname,
            value,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glPatchParameteriOES");
        }
        out
    }
    #[cfg(any(feature = "GL_OES_tessellation_shader"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_OES_tessellation_shader"))))]
    static glPatchParameteriOES_p: APcv = ap_None();
    /// Tries to load [`glPatchParameteriOES`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    #[cfg(any(feature = "GL_OES_tessellation_shader"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_OES_tessellation_shader"))))]
    pub unsafe fn glPatchParameteriOES_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glPatchParameteriOES\0",
            &glPatchParameteriOES_p,
        )
    }
    /// Checks if the pointer for [`glPatchParameteriOES`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    #[cfg(any(feature = "GL_OES_tessellation_shader"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_OES_tessellation_shader"))))]
    pub fn glPatchParameteriOES_is_loaded() -> bool {
        !glPatchParameteriOES_p.load(RELAX).is_null()
    }

    /// [glPathCommandsNV](http://docs.gl/es3/glPathCommandsNV)(path, numCommands, commands, numCoords, coordType, coords)
    /// `path` group: Path
    /// `commands` group: PathCommand
    /// `commands` len: numCommands
    /// `coordType` group: PathCoordType
    /// `coords` len: COMPSIZE(numCoords,coordType)
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    #[cfg(any(feature = "GL_NV_path_rendering"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_path_rendering"))))]
    pub unsafe fn glPathCommandsNV(
        path: GLuint,
        numCommands: GLsizei,
        commands: *const GLubyte,
        numCoords: GLsizei,
        coordType: GLenum,
        coords: *const c_void,
    ) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glPathCommandsNV({:?}, {:?}, {:p}, {:?}, {:#X}, {:p});",
                path,
                numCommands,
                commands,
                numCoords,
                coordType,
                coords
            );
        }
        let out = call_atomic_ptr_6arg(
            "glPathCommandsNV",
            &glPathCommandsNV_p,
            path,
            numCommands,
            commands,
            numCoords,
            coordType,
            coords,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glPathCommandsNV");
        }
        out
    }
    #[cfg(any(feature = "GL_NV_path_rendering"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_path_rendering"))))]
    static glPathCommandsNV_p: APcv = ap_None();
    /// Tries to load [`glPathCommandsNV`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    #[cfg(any(feature = "GL_NV_path_rendering"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_path_rendering"))))]
    pub unsafe fn glPathCommandsNV_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(get_proc_address, b"glPathCommandsNV\0", &glPathCommandsNV_p)
    }
    /// Checks if the pointer for [`glPathCommandsNV`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    #[cfg(any(feature = "GL_NV_path_rendering"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_path_rendering"))))]
    pub fn glPathCommandsNV_is_loaded() -> bool {
        !glPathCommandsNV_p.load(RELAX).is_null()
    }

    /// [glPathCoordsNV](http://docs.gl/es3/glPathCoordsNV)(path, numCoords, coordType, coords)
    /// `path` group: Path
    /// `coordType` group: PathCoordType
    /// `coords` len: COMPSIZE(numCoords,coordType)
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    #[cfg(any(feature = "GL_NV_path_rendering"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_path_rendering"))))]
    pub unsafe fn glPathCoordsNV(
        path: GLuint,
        numCoords: GLsizei,
        coordType: GLenum,
        coords: *const c_void,
    ) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glPathCoordsNV({:?}, {:?}, {:#X}, {:p});",
                path,
                numCoords,
                coordType,
                coords
            );
        }
        let out = call_atomic_ptr_4arg(
            "glPathCoordsNV",
            &glPathCoordsNV_p,
            path,
            numCoords,
            coordType,
            coords,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glPathCoordsNV");
        }
        out
    }
    #[cfg(any(feature = "GL_NV_path_rendering"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_path_rendering"))))]
    static glPathCoordsNV_p: APcv = ap_None();
    /// Tries to load [`glPathCoordsNV`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    #[cfg(any(feature = "GL_NV_path_rendering"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_path_rendering"))))]
    pub unsafe fn glPathCoordsNV_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(get_proc_address, b"glPathCoordsNV\0", &glPathCoordsNV_p)
    }
    /// Checks if the pointer for [`glPathCoordsNV`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    #[cfg(any(feature = "GL_NV_path_rendering"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_path_rendering"))))]
    pub fn glPathCoordsNV_is_loaded() -> bool {
        !glPathCoordsNV_p.load(RELAX).is_null()
    }

    /// [glPathCoverDepthFuncNV](http://docs.gl/es3/glPathCoverDepthFuncNV)(func)
    /// `func` group: DepthFunction
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    #[cfg(any(feature = "GL_NV_path_rendering"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_path_rendering"))))]
    pub unsafe fn glPathCoverDepthFuncNV(func: GLenum) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!("calling glPathCoverDepthFuncNV({:#X});", func);
        }
        let out = call_atomic_ptr_1arg("glPathCoverDepthFuncNV", &glPathCoverDepthFuncNV_p, func);
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glPathCoverDepthFuncNV");
        }
        out
    }
    #[cfg(any(feature = "GL_NV_path_rendering"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_path_rendering"))))]
    static glPathCoverDepthFuncNV_p: APcv = ap_None();
    /// Tries to load [`glPathCoverDepthFuncNV`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    #[cfg(any(feature = "GL_NV_path_rendering"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_path_rendering"))))]
    pub unsafe fn glPathCoverDepthFuncNV_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glPathCoverDepthFuncNV\0",
            &glPathCoverDepthFuncNV_p,
        )
    }
    /// Checks if the pointer for [`glPathCoverDepthFuncNV`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    #[cfg(any(feature = "GL_NV_path_rendering"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_path_rendering"))))]
    pub fn glPathCoverDepthFuncNV_is_loaded() -> bool {
        !glPathCoverDepthFuncNV_p.load(RELAX).is_null()
    }

    /// [glPathDashArrayNV](http://docs.gl/es3/glPathDashArrayNV)(path, dashCount, dashArray)
    /// `path` group: Path
    /// `dashArray` len: dashCount
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    #[cfg(any(feature = "GL_NV_path_rendering"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_path_rendering"))))]
    pub unsafe fn glPathDashArrayNV(path: GLuint, dashCount: GLsizei, dashArray: *const GLfloat) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glPathDashArrayNV({:?}, {:?}, {:p});",
                path,
                dashCount,
                dashArray
            );
        }
        let out = call_atomic_ptr_3arg(
            "glPathDashArrayNV",
            &glPathDashArrayNV_p,
            path,
            dashCount,
            dashArray,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glPathDashArrayNV");
        }
        out
    }
    #[cfg(any(feature = "GL_NV_path_rendering"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_path_rendering"))))]
    static glPathDashArrayNV_p: APcv = ap_None();
    /// Tries to load [`glPathDashArrayNV`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    #[cfg(any(feature = "GL_NV_path_rendering"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_path_rendering"))))]
    pub unsafe fn glPathDashArrayNV_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glPathDashArrayNV\0",
            &glPathDashArrayNV_p,
        )
    }
    /// Checks if the pointer for [`glPathDashArrayNV`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    #[cfg(any(feature = "GL_NV_path_rendering"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_path_rendering"))))]
    pub fn glPathDashArrayNV_is_loaded() -> bool {
        !glPathDashArrayNV_p.load(RELAX).is_null()
    }

    /// [glPathGlyphIndexArrayNV](http://docs.gl/es3/glPathGlyphIndexArrayNV)(firstPathName, fontTarget, fontName, fontStyle, firstGlyphIndex, numGlyphs, pathParameterTemplate, emScale)
    /// `fontStyle` group: PathFontStyle
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    #[cfg(any(feature = "GL_NV_path_rendering"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_path_rendering"))))]
    pub unsafe fn glPathGlyphIndexArrayNV(
        firstPathName: GLuint,
        fontTarget: GLenum,
        fontName: *const c_void,
        fontStyle: GLbitfield,
        firstGlyphIndex: GLuint,
        numGlyphs: GLsizei,
        pathParameterTemplate: GLuint,
        emScale: GLfloat,
    ) -> GLenum {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glPathGlyphIndexArrayNV({:?}, {:#X}, {:p}, {:?}, {:?}, {:?}, {:?}, {:?});",
                firstPathName,
                fontTarget,
                fontName,
                fontStyle,
                firstGlyphIndex,
                numGlyphs,
                pathParameterTemplate,
                emScale
            );
        }
        let out = call_atomic_ptr_8arg(
            "glPathGlyphIndexArrayNV",
            &glPathGlyphIndexArrayNV_p,
            firstPathName,
            fontTarget,
            fontName,
            fontStyle,
            firstGlyphIndex,
            numGlyphs,
            pathParameterTemplate,
            emScale,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glPathGlyphIndexArrayNV");
        }
        out
    }
    #[cfg(any(feature = "GL_NV_path_rendering"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_path_rendering"))))]
    static glPathGlyphIndexArrayNV_p: APcv = ap_None();
    /// Tries to load [`glPathGlyphIndexArrayNV`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    #[cfg(any(feature = "GL_NV_path_rendering"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_path_rendering"))))]
    pub unsafe fn glPathGlyphIndexArrayNV_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glPathGlyphIndexArrayNV\0",
            &glPathGlyphIndexArrayNV_p,
        )
    }
    /// Checks if the pointer for [`glPathGlyphIndexArrayNV`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    #[cfg(any(feature = "GL_NV_path_rendering"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_path_rendering"))))]
    pub fn glPathGlyphIndexArrayNV_is_loaded() -> bool {
        !glPathGlyphIndexArrayNV_p.load(RELAX).is_null()
    }

    /// [glPathGlyphIndexRangeNV](http://docs.gl/es3/glPathGlyphIndexRangeNV)(fontTarget, fontName, fontStyle, pathParameterTemplate, emScale, baseAndCount)
    /// `fontStyle` group: PathFontStyle
    /// `baseAndCount` len: 2
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    #[cfg(any(feature = "GL_NV_path_rendering"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_path_rendering"))))]
    pub unsafe fn glPathGlyphIndexRangeNV(
        fontTarget: GLenum,
        fontName: *const c_void,
        fontStyle: GLbitfield,
        pathParameterTemplate: GLuint,
        emScale: GLfloat,
        baseAndCount: *mut GLuint,
    ) -> GLenum {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glPathGlyphIndexRangeNV({:#X}, {:p}, {:?}, {:?}, {:?}, {:p});",
                fontTarget,
                fontName,
                fontStyle,
                pathParameterTemplate,
                emScale,
                baseAndCount
            );
        }
        let out = call_atomic_ptr_6arg(
            "glPathGlyphIndexRangeNV",
            &glPathGlyphIndexRangeNV_p,
            fontTarget,
            fontName,
            fontStyle,
            pathParameterTemplate,
            emScale,
            baseAndCount,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glPathGlyphIndexRangeNV");
        }
        out
    }
    #[cfg(any(feature = "GL_NV_path_rendering"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_path_rendering"))))]
    static glPathGlyphIndexRangeNV_p: APcv = ap_None();
    /// Tries to load [`glPathGlyphIndexRangeNV`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    #[cfg(any(feature = "GL_NV_path_rendering"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_path_rendering"))))]
    pub unsafe fn glPathGlyphIndexRangeNV_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glPathGlyphIndexRangeNV\0",
            &glPathGlyphIndexRangeNV_p,
        )
    }
    /// Checks if the pointer for [`glPathGlyphIndexRangeNV`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    #[cfg(any(feature = "GL_NV_path_rendering"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_path_rendering"))))]
    pub fn glPathGlyphIndexRangeNV_is_loaded() -> bool {
        !glPathGlyphIndexRangeNV_p.load(RELAX).is_null()
    }

    /// [glPathGlyphRangeNV](http://docs.gl/es3/glPathGlyphRangeNV)(firstPathName, fontTarget, fontName, fontStyle, firstGlyph, numGlyphs, handleMissingGlyphs, pathParameterTemplate, emScale)
    /// `firstPathName` group: Path
    /// `fontTarget` group: PathFontTarget
    /// `fontName` len: COMPSIZE(fontTarget,fontName)
    /// `fontStyle` group: PathFontStyle
    /// `handleMissingGlyphs` group: PathHandleMissingGlyphs
    /// `pathParameterTemplate` group: Path
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    #[cfg(any(feature = "GL_NV_path_rendering"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_path_rendering"))))]
    pub unsafe fn glPathGlyphRangeNV(
        firstPathName: GLuint,
        fontTarget: GLenum,
        fontName: *const c_void,
        fontStyle: GLbitfield,
        firstGlyph: GLuint,
        numGlyphs: GLsizei,
        handleMissingGlyphs: GLenum,
        pathParameterTemplate: GLuint,
        emScale: GLfloat,
    ) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glPathGlyphRangeNV({:?}, {:#X}, {:p}, {:?}, {:?}, {:?}, {:#X}, {:?}, {:?});",
                firstPathName,
                fontTarget,
                fontName,
                fontStyle,
                firstGlyph,
                numGlyphs,
                handleMissingGlyphs,
                pathParameterTemplate,
                emScale
            );
        }
        let out = call_atomic_ptr_9arg(
            "glPathGlyphRangeNV",
            &glPathGlyphRangeNV_p,
            firstPathName,
            fontTarget,
            fontName,
            fontStyle,
            firstGlyph,
            numGlyphs,
            handleMissingGlyphs,
            pathParameterTemplate,
            emScale,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glPathGlyphRangeNV");
        }
        out
    }
    #[cfg(any(feature = "GL_NV_path_rendering"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_path_rendering"))))]
    static glPathGlyphRangeNV_p: APcv = ap_None();
    /// Tries to load [`glPathGlyphRangeNV`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    #[cfg(any(feature = "GL_NV_path_rendering"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_path_rendering"))))]
    pub unsafe fn glPathGlyphRangeNV_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glPathGlyphRangeNV\0",
            &glPathGlyphRangeNV_p,
        )
    }
    /// Checks if the pointer for [`glPathGlyphRangeNV`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    #[cfg(any(feature = "GL_NV_path_rendering"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_path_rendering"))))]
    pub fn glPathGlyphRangeNV_is_loaded() -> bool {
        !glPathGlyphRangeNV_p.load(RELAX).is_null()
    }

    /// [glPathGlyphsNV](http://docs.gl/es3/glPathGlyphsNV)(firstPathName, fontTarget, fontName, fontStyle, numGlyphs, type_, charcodes, handleMissingGlyphs, pathParameterTemplate, emScale)
    /// `firstPathName` group: Path
    /// `fontTarget` group: PathFontTarget
    /// `fontName` len: COMPSIZE(fontTarget,fontName)
    /// `fontStyle` group: PathFontStyle
    /// `type_` group: PathElementType
    /// `charcodes` len: COMPSIZE(numGlyphs,type,charcodes)
    /// `handleMissingGlyphs` group: PathHandleMissingGlyphs
    /// `pathParameterTemplate` group: Path
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    #[cfg(any(feature = "GL_NV_path_rendering"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_path_rendering"))))]
    pub unsafe fn glPathGlyphsNV(
        firstPathName: GLuint,
        fontTarget: GLenum,
        fontName: *const c_void,
        fontStyle: GLbitfield,
        numGlyphs: GLsizei,
        type_: GLenum,
        charcodes: *const c_void,
        handleMissingGlyphs: GLenum,
        pathParameterTemplate: GLuint,
        emScale: GLfloat,
    ) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glPathGlyphsNV({:?}, {:#X}, {:p}, {:?}, {:?}, {:#X}, {:p}, {:#X}, {:?}, {:?});",
                firstPathName,
                fontTarget,
                fontName,
                fontStyle,
                numGlyphs,
                type_,
                charcodes,
                handleMissingGlyphs,
                pathParameterTemplate,
                emScale
            );
        }
        let out = call_atomic_ptr_10arg(
            "glPathGlyphsNV",
            &glPathGlyphsNV_p,
            firstPathName,
            fontTarget,
            fontName,
            fontStyle,
            numGlyphs,
            type_,
            charcodes,
            handleMissingGlyphs,
            pathParameterTemplate,
            emScale,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glPathGlyphsNV");
        }
        out
    }
    #[cfg(any(feature = "GL_NV_path_rendering"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_path_rendering"))))]
    static glPathGlyphsNV_p: APcv = ap_None();
    /// Tries to load [`glPathGlyphsNV`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    #[cfg(any(feature = "GL_NV_path_rendering"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_path_rendering"))))]
    pub unsafe fn glPathGlyphsNV_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(get_proc_address, b"glPathGlyphsNV\0", &glPathGlyphsNV_p)
    }
    /// Checks if the pointer for [`glPathGlyphsNV`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    #[cfg(any(feature = "GL_NV_path_rendering"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_path_rendering"))))]
    pub fn glPathGlyphsNV_is_loaded() -> bool {
        !glPathGlyphsNV_p.load(RELAX).is_null()
    }

    /// [glPathMemoryGlyphIndexArrayNV](http://docs.gl/es3/glPathMemoryGlyphIndexArrayNV)(firstPathName, fontTarget, fontSize, fontData, faceIndex, firstGlyphIndex, numGlyphs, pathParameterTemplate, emScale)
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    #[cfg(any(feature = "GL_NV_path_rendering"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_path_rendering"))))]
    pub unsafe fn glPathMemoryGlyphIndexArrayNV(
        firstPathName: GLuint,
        fontTarget: GLenum,
        fontSize: GLsizeiptr,
        fontData: *const c_void,
        faceIndex: GLsizei,
        firstGlyphIndex: GLuint,
        numGlyphs: GLsizei,
        pathParameterTemplate: GLuint,
        emScale: GLfloat,
    ) -> GLenum {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glPathMemoryGlyphIndexArrayNV({:?}, {:#X}, {:?}, {:p}, {:?}, {:?}, {:?}, {:?}, {:?});",
                firstPathName,
                fontTarget,
                fontSize,
                fontData,
                faceIndex,
                firstGlyphIndex,
                numGlyphs,
                pathParameterTemplate,
                emScale
            );
        }
        let out = call_atomic_ptr_9arg(
            "glPathMemoryGlyphIndexArrayNV",
            &glPathMemoryGlyphIndexArrayNV_p,
            firstPathName,
            fontTarget,
            fontSize,
            fontData,
            faceIndex,
            firstGlyphIndex,
            numGlyphs,
            pathParameterTemplate,
            emScale,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glPathMemoryGlyphIndexArrayNV");
        }
        out
    }
    #[cfg(any(feature = "GL_NV_path_rendering"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_path_rendering"))))]
    static glPathMemoryGlyphIndexArrayNV_p: APcv = ap_None();
    /// Tries to load [`glPathMemoryGlyphIndexArrayNV`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    #[cfg(any(feature = "GL_NV_path_rendering"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_path_rendering"))))]
    pub unsafe fn glPathMemoryGlyphIndexArrayNV_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glPathMemoryGlyphIndexArrayNV\0",
            &glPathMemoryGlyphIndexArrayNV_p,
        )
    }
    /// Checks if the pointer for [`glPathMemoryGlyphIndexArrayNV`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    #[cfg(any(feature = "GL_NV_path_rendering"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_path_rendering"))))]
    pub fn glPathMemoryGlyphIndexArrayNV_is_loaded() -> bool {
        !glPathMemoryGlyphIndexArrayNV_p.load(RELAX).is_null()
    }

    /// [glPathParameterfNV](http://docs.gl/es3/glPathParameterfNV)(path, pname, value)
    /// `path` group: Path
    /// `pname` group: PathParameter
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    #[cfg(any(feature = "GL_NV_path_rendering"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_path_rendering"))))]
    pub unsafe fn glPathParameterfNV(path: GLuint, pname: GLenum, value: GLfloat) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glPathParameterfNV({:?}, {:#X}, {:?});",
                path,
                pname,
                value
            );
        }
        let out = call_atomic_ptr_3arg(
            "glPathParameterfNV",
            &glPathParameterfNV_p,
            path,
            pname,
            value,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glPathParameterfNV");
        }
        out
    }
    #[cfg(any(feature = "GL_NV_path_rendering"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_path_rendering"))))]
    static glPathParameterfNV_p: APcv = ap_None();
    /// Tries to load [`glPathParameterfNV`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    #[cfg(any(feature = "GL_NV_path_rendering"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_path_rendering"))))]
    pub unsafe fn glPathParameterfNV_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glPathParameterfNV\0",
            &glPathParameterfNV_p,
        )
    }
    /// Checks if the pointer for [`glPathParameterfNV`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    #[cfg(any(feature = "GL_NV_path_rendering"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_path_rendering"))))]
    pub fn glPathParameterfNV_is_loaded() -> bool {
        !glPathParameterfNV_p.load(RELAX).is_null()
    }

    /// [glPathParameterfvNV](http://docs.gl/es3/glPathParameterfvNV)(path, pname, value)
    /// `path` group: Path
    /// `pname` group: PathParameter
    /// `value` len: COMPSIZE(pname)
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    #[cfg(any(feature = "GL_NV_path_rendering"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_path_rendering"))))]
    pub unsafe fn glPathParameterfvNV(path: GLuint, pname: GLenum, value: *const GLfloat) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glPathParameterfvNV({:?}, {:#X}, {:p});",
                path,
                pname,
                value
            );
        }
        let out = call_atomic_ptr_3arg(
            "glPathParameterfvNV",
            &glPathParameterfvNV_p,
            path,
            pname,
            value,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glPathParameterfvNV");
        }
        out
    }
    #[cfg(any(feature = "GL_NV_path_rendering"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_path_rendering"))))]
    static glPathParameterfvNV_p: APcv = ap_None();
    /// Tries to load [`glPathParameterfvNV`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    #[cfg(any(feature = "GL_NV_path_rendering"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_path_rendering"))))]
    pub unsafe fn glPathParameterfvNV_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glPathParameterfvNV\0",
            &glPathParameterfvNV_p,
        )
    }
    /// Checks if the pointer for [`glPathParameterfvNV`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    #[cfg(any(feature = "GL_NV_path_rendering"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_path_rendering"))))]
    pub fn glPathParameterfvNV_is_loaded() -> bool {
        !glPathParameterfvNV_p.load(RELAX).is_null()
    }

    /// [glPathParameteriNV](http://docs.gl/es3/glPathParameteriNV)(path, pname, value)
    /// `path` group: Path
    /// `pname` group: PathParameter
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    #[cfg(any(feature = "GL_NV_path_rendering"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_path_rendering"))))]
    pub unsafe fn glPathParameteriNV(path: GLuint, pname: GLenum, value: GLint) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glPathParameteriNV({:?}, {:#X}, {:?});",
                path,
                pname,
                value
            );
        }
        let out = call_atomic_ptr_3arg(
            "glPathParameteriNV",
            &glPathParameteriNV_p,
            path,
            pname,
            value,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glPathParameteriNV");
        }
        out
    }
    #[cfg(any(feature = "GL_NV_path_rendering"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_path_rendering"))))]
    static glPathParameteriNV_p: APcv = ap_None();
    /// Tries to load [`glPathParameteriNV`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    #[cfg(any(feature = "GL_NV_path_rendering"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_path_rendering"))))]
    pub unsafe fn glPathParameteriNV_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glPathParameteriNV\0",
            &glPathParameteriNV_p,
        )
    }
    /// Checks if the pointer for [`glPathParameteriNV`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    #[cfg(any(feature = "GL_NV_path_rendering"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_path_rendering"))))]
    pub fn glPathParameteriNV_is_loaded() -> bool {
        !glPathParameteriNV_p.load(RELAX).is_null()
    }

    /// [glPathParameterivNV](http://docs.gl/es3/glPathParameterivNV)(path, pname, value)
    /// `path` group: Path
    /// `pname` group: PathParameter
    /// `value` len: COMPSIZE(pname)
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    #[cfg(any(feature = "GL_NV_path_rendering"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_path_rendering"))))]
    pub unsafe fn glPathParameterivNV(path: GLuint, pname: GLenum, value: *const GLint) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glPathParameterivNV({:?}, {:#X}, {:p});",
                path,
                pname,
                value
            );
        }
        let out = call_atomic_ptr_3arg(
            "glPathParameterivNV",
            &glPathParameterivNV_p,
            path,
            pname,
            value,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glPathParameterivNV");
        }
        out
    }
    #[cfg(any(feature = "GL_NV_path_rendering"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_path_rendering"))))]
    static glPathParameterivNV_p: APcv = ap_None();
    /// Tries to load [`glPathParameterivNV`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    #[cfg(any(feature = "GL_NV_path_rendering"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_path_rendering"))))]
    pub unsafe fn glPathParameterivNV_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glPathParameterivNV\0",
            &glPathParameterivNV_p,
        )
    }
    /// Checks if the pointer for [`glPathParameterivNV`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    #[cfg(any(feature = "GL_NV_path_rendering"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_path_rendering"))))]
    pub fn glPathParameterivNV_is_loaded() -> bool {
        !glPathParameterivNV_p.load(RELAX).is_null()
    }

    /// [glPathStencilDepthOffsetNV](http://docs.gl/es3/glPathStencilDepthOffsetNV)(factor, units)
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    #[cfg(any(feature = "GL_NV_path_rendering"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_path_rendering"))))]
    pub unsafe fn glPathStencilDepthOffsetNV(factor: GLfloat, units: GLfloat) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glPathStencilDepthOffsetNV({:?}, {:?});",
                factor,
                units
            );
        }
        let out = call_atomic_ptr_2arg(
            "glPathStencilDepthOffsetNV",
            &glPathStencilDepthOffsetNV_p,
            factor,
            units,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glPathStencilDepthOffsetNV");
        }
        out
    }
    #[cfg(any(feature = "GL_NV_path_rendering"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_path_rendering"))))]
    static glPathStencilDepthOffsetNV_p: APcv = ap_None();
    /// Tries to load [`glPathStencilDepthOffsetNV`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    #[cfg(any(feature = "GL_NV_path_rendering"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_path_rendering"))))]
    pub unsafe fn glPathStencilDepthOffsetNV_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glPathStencilDepthOffsetNV\0",
            &glPathStencilDepthOffsetNV_p,
        )
    }
    /// Checks if the pointer for [`glPathStencilDepthOffsetNV`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    #[cfg(any(feature = "GL_NV_path_rendering"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_path_rendering"))))]
    pub fn glPathStencilDepthOffsetNV_is_loaded() -> bool {
        !glPathStencilDepthOffsetNV_p.load(RELAX).is_null()
    }

    /// [glPathStencilFuncNV](http://docs.gl/es3/glPathStencilFuncNV)(func, ref_, mask)
    /// `func` group: StencilFunction
    /// `ref_` group: ClampedStencilValue
    /// `mask` group: MaskedStencilValue
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    #[cfg(any(feature = "GL_NV_path_rendering"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_path_rendering"))))]
    pub unsafe fn glPathStencilFuncNV(func: GLenum, ref_: GLint, mask: GLuint) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glPathStencilFuncNV({:#X}, {:?}, {:?});",
                func,
                ref_,
                mask
            );
        }
        let out = call_atomic_ptr_3arg(
            "glPathStencilFuncNV",
            &glPathStencilFuncNV_p,
            func,
            ref_,
            mask,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glPathStencilFuncNV");
        }
        out
    }
    #[cfg(any(feature = "GL_NV_path_rendering"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_path_rendering"))))]
    static glPathStencilFuncNV_p: APcv = ap_None();
    /// Tries to load [`glPathStencilFuncNV`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    #[cfg(any(feature = "GL_NV_path_rendering"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_path_rendering"))))]
    pub unsafe fn glPathStencilFuncNV_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glPathStencilFuncNV\0",
            &glPathStencilFuncNV_p,
        )
    }
    /// Checks if the pointer for [`glPathStencilFuncNV`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    #[cfg(any(feature = "GL_NV_path_rendering"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_path_rendering"))))]
    pub fn glPathStencilFuncNV_is_loaded() -> bool {
        !glPathStencilFuncNV_p.load(RELAX).is_null()
    }

    /// [glPathStringNV](http://docs.gl/es3/glPathStringNV)(path, format, length, pathString)
    /// `path` group: Path
    /// `format` group: PathStringFormat
    /// `pathString` len: length
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    #[cfg(any(feature = "GL_NV_path_rendering"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_path_rendering"))))]
    pub unsafe fn glPathStringNV(
        path: GLuint,
        format: GLenum,
        length: GLsizei,
        pathString: *const c_void,
    ) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glPathStringNV({:?}, {:#X}, {:?}, {:p});",
                path,
                format,
                length,
                pathString
            );
        }
        let out = call_atomic_ptr_4arg(
            "glPathStringNV",
            &glPathStringNV_p,
            path,
            format,
            length,
            pathString,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glPathStringNV");
        }
        out
    }
    #[cfg(any(feature = "GL_NV_path_rendering"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_path_rendering"))))]
    static glPathStringNV_p: APcv = ap_None();
    /// Tries to load [`glPathStringNV`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    #[cfg(any(feature = "GL_NV_path_rendering"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_path_rendering"))))]
    pub unsafe fn glPathStringNV_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(get_proc_address, b"glPathStringNV\0", &glPathStringNV_p)
    }
    /// Checks if the pointer for [`glPathStringNV`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    #[cfg(any(feature = "GL_NV_path_rendering"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_path_rendering"))))]
    pub fn glPathStringNV_is_loaded() -> bool {
        !glPathStringNV_p.load(RELAX).is_null()
    }

    /// [glPathSubCommandsNV](http://docs.gl/es3/glPathSubCommandsNV)(path, commandStart, commandsToDelete, numCommands, commands, numCoords, coordType, coords)
    /// `path` group: Path
    /// `commands` group: PathCommand
    /// `commands` len: numCommands
    /// `coordType` group: PathCoordType
    /// `coords` len: COMPSIZE(numCoords,coordType)
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    #[cfg(any(feature = "GL_NV_path_rendering"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_path_rendering"))))]
    pub unsafe fn glPathSubCommandsNV(
        path: GLuint,
        commandStart: GLsizei,
        commandsToDelete: GLsizei,
        numCommands: GLsizei,
        commands: *const GLubyte,
        numCoords: GLsizei,
        coordType: GLenum,
        coords: *const c_void,
    ) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glPathSubCommandsNV({:?}, {:?}, {:?}, {:?}, {:p}, {:?}, {:#X}, {:p});",
                path,
                commandStart,
                commandsToDelete,
                numCommands,
                commands,
                numCoords,
                coordType,
                coords
            );
        }
        let out = call_atomic_ptr_8arg(
            "glPathSubCommandsNV",
            &glPathSubCommandsNV_p,
            path,
            commandStart,
            commandsToDelete,
            numCommands,
            commands,
            numCoords,
            coordType,
            coords,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glPathSubCommandsNV");
        }
        out
    }
    #[cfg(any(feature = "GL_NV_path_rendering"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_path_rendering"))))]
    static glPathSubCommandsNV_p: APcv = ap_None();
    /// Tries to load [`glPathSubCommandsNV`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    #[cfg(any(feature = "GL_NV_path_rendering"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_path_rendering"))))]
    pub unsafe fn glPathSubCommandsNV_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glPathSubCommandsNV\0",
            &glPathSubCommandsNV_p,
        )
    }
    /// Checks if the pointer for [`glPathSubCommandsNV`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    #[cfg(any(feature = "GL_NV_path_rendering"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_path_rendering"))))]
    pub fn glPathSubCommandsNV_is_loaded() -> bool {
        !glPathSubCommandsNV_p.load(RELAX).is_null()
    }

    /// [glPathSubCoordsNV](http://docs.gl/es3/glPathSubCoordsNV)(path, coordStart, numCoords, coordType, coords)
    /// `path` group: Path
    /// `coordType` group: PathCoordType
    /// `coords` len: COMPSIZE(numCoords,coordType)
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    #[cfg(any(feature = "GL_NV_path_rendering"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_path_rendering"))))]
    pub unsafe fn glPathSubCoordsNV(
        path: GLuint,
        coordStart: GLsizei,
        numCoords: GLsizei,
        coordType: GLenum,
        coords: *const c_void,
    ) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glPathSubCoordsNV({:?}, {:?}, {:?}, {:#X}, {:p});",
                path,
                coordStart,
                numCoords,
                coordType,
                coords
            );
        }
        let out = call_atomic_ptr_5arg(
            "glPathSubCoordsNV",
            &glPathSubCoordsNV_p,
            path,
            coordStart,
            numCoords,
            coordType,
            coords,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glPathSubCoordsNV");
        }
        out
    }
    #[cfg(any(feature = "GL_NV_path_rendering"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_path_rendering"))))]
    static glPathSubCoordsNV_p: APcv = ap_None();
    /// Tries to load [`glPathSubCoordsNV`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    #[cfg(any(feature = "GL_NV_path_rendering"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_path_rendering"))))]
    pub unsafe fn glPathSubCoordsNV_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glPathSubCoordsNV\0",
            &glPathSubCoordsNV_p,
        )
    }
    /// Checks if the pointer for [`glPathSubCoordsNV`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    #[cfg(any(feature = "GL_NV_path_rendering"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_path_rendering"))))]
    pub fn glPathSubCoordsNV_is_loaded() -> bool {
        !glPathSubCoordsNV_p.load(RELAX).is_null()
    }

    /// [glPauseTransformFeedback](http://docs.gl/es3/glPauseTransformFeedback)()
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn glPauseTransformFeedback() {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!("calling glPauseTransformFeedback();",);
        }
        let out = call_atomic_ptr_0arg("glPauseTransformFeedback", &glPauseTransformFeedback_p);
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glPauseTransformFeedback");
        }
        out
    }
    static glPauseTransformFeedback_p: APcv = ap_None();
    /// Tries to load [`glPauseTransformFeedback`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    pub unsafe fn glPauseTransformFeedback_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glPauseTransformFeedback\0",
            &glPauseTransformFeedback_p,
        )
    }
    /// Checks if the pointer for [`glPauseTransformFeedback`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    pub fn glPauseTransformFeedback_is_loaded() -> bool {
        !glPauseTransformFeedback_p.load(RELAX).is_null()
    }

    /// [glPixelStorei](http://docs.gl/es3/glPixelStore)(pname, param)
    /// `pname` group: PixelStoreParameter
    /// `param` group: CheckedInt32
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn glPixelStorei(pname: GLenum, param: GLint) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!("calling glPixelStorei({:#X}, {:?});", pname, param);
        }
        let out = call_atomic_ptr_2arg("glPixelStorei", &glPixelStorei_p, pname, param);
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glPixelStorei");
        }
        out
    }
    static glPixelStorei_p: APcv = ap_None();
    /// Tries to load [`glPixelStorei`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    pub unsafe fn glPixelStorei_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(get_proc_address, b"glPixelStorei\0", &glPixelStorei_p)
    }
    /// Checks if the pointer for [`glPixelStorei`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    pub fn glPixelStorei_is_loaded() -> bool {
        !glPixelStorei_p.load(RELAX).is_null()
    }

    /// [glPointAlongPathNV](http://docs.gl/es3/glPointAlongPathNV)(path, startSegment, numSegments, distance, x, y, tangentX, tangentY)
    /// `path` group: Path
    /// `x` len: 1
    /// `y` len: 1
    /// `tangentX` len: 1
    /// `tangentY` len: 1
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    #[cfg(any(feature = "GL_NV_path_rendering"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_path_rendering"))))]
    pub unsafe fn glPointAlongPathNV(
        path: GLuint,
        startSegment: GLsizei,
        numSegments: GLsizei,
        distance: GLfloat,
        x: *mut GLfloat,
        y: *mut GLfloat,
        tangentX: *mut GLfloat,
        tangentY: *mut GLfloat,
    ) -> GLboolean {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glPointAlongPathNV({:?}, {:?}, {:?}, {:?}, {:p}, {:p}, {:p}, {:p});",
                path,
                startSegment,
                numSegments,
                distance,
                x,
                y,
                tangentX,
                tangentY
            );
        }
        let out = call_atomic_ptr_8arg(
            "glPointAlongPathNV",
            &glPointAlongPathNV_p,
            path,
            startSegment,
            numSegments,
            distance,
            x,
            y,
            tangentX,
            tangentY,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glPointAlongPathNV");
        }
        out
    }
    #[cfg(any(feature = "GL_NV_path_rendering"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_path_rendering"))))]
    static glPointAlongPathNV_p: APcv = ap_None();
    /// Tries to load [`glPointAlongPathNV`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    #[cfg(any(feature = "GL_NV_path_rendering"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_path_rendering"))))]
    pub unsafe fn glPointAlongPathNV_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glPointAlongPathNV\0",
            &glPointAlongPathNV_p,
        )
    }
    /// Checks if the pointer for [`glPointAlongPathNV`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    #[cfg(any(feature = "GL_NV_path_rendering"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_path_rendering"))))]
    pub fn glPointAlongPathNV_is_loaded() -> bool {
        !glPointAlongPathNV_p.load(RELAX).is_null()
    }

    /// [glPolygonModeNV](http://docs.gl/es3/glPolygonModeNV)(face, mode)
    /// `face` group: MaterialFace
    /// `mode` group: PolygonMode
    /// alias of: [`glPolygonMode`]
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    #[cfg(any(feature = "GL_NV_polygon_mode"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_polygon_mode"))))]
    pub unsafe fn glPolygonModeNV(face: GLenum, mode: GLenum) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!("calling glPolygonModeNV({:#X}, {:#X});", face, mode);
        }
        let out = call_atomic_ptr_2arg("glPolygonModeNV", &glPolygonModeNV_p, face, mode);
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glPolygonModeNV");
        }
        out
    }
    #[cfg(any(feature = "GL_NV_polygon_mode"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_polygon_mode"))))]
    static glPolygonModeNV_p: APcv = ap_None();
    /// Tries to load [`glPolygonModeNV`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    #[cfg(any(feature = "GL_NV_polygon_mode"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_polygon_mode"))))]
    pub unsafe fn glPolygonModeNV_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(get_proc_address, b"glPolygonModeNV\0", &glPolygonModeNV_p)
    }
    /// Checks if the pointer for [`glPolygonModeNV`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    #[cfg(any(feature = "GL_NV_polygon_mode"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_polygon_mode"))))]
    pub fn glPolygonModeNV_is_loaded() -> bool {
        !glPolygonModeNV_p.load(RELAX).is_null()
    }

    /// [glPolygonOffset](http://docs.gl/es3/glPolygonOffset)(factor, units)
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn glPolygonOffset(factor: GLfloat, units: GLfloat) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!("calling glPolygonOffset({:?}, {:?});", factor, units);
        }
        let out = call_atomic_ptr_2arg("glPolygonOffset", &glPolygonOffset_p, factor, units);
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glPolygonOffset");
        }
        out
    }
    static glPolygonOffset_p: APcv = ap_None();
    /// Tries to load [`glPolygonOffset`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    pub unsafe fn glPolygonOffset_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(get_proc_address, b"glPolygonOffset\0", &glPolygonOffset_p)
    }
    /// Checks if the pointer for [`glPolygonOffset`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    pub fn glPolygonOffset_is_loaded() -> bool {
        !glPolygonOffset_p.load(RELAX).is_null()
    }

    /// [glPolygonOffsetClampEXT](http://docs.gl/es3/glPolygonOffsetClampEXT)(factor, units, clamp)
    /// alias of: [`glPolygonOffsetClamp`]
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    #[cfg(any(feature = "GL_EXT_polygon_offset_clamp"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_polygon_offset_clamp"))))]
    pub unsafe fn glPolygonOffsetClampEXT(factor: GLfloat, units: GLfloat, clamp: GLfloat) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glPolygonOffsetClampEXT({:?}, {:?}, {:?});",
                factor,
                units,
                clamp
            );
        }
        let out = call_atomic_ptr_3arg(
            "glPolygonOffsetClampEXT",
            &glPolygonOffsetClampEXT_p,
            factor,
            units,
            clamp,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glPolygonOffsetClampEXT");
        }
        out
    }
    #[cfg(any(feature = "GL_EXT_polygon_offset_clamp"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_polygon_offset_clamp"))))]
    static glPolygonOffsetClampEXT_p: APcv = ap_None();
    /// Tries to load [`glPolygonOffsetClampEXT`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    #[cfg(any(feature = "GL_EXT_polygon_offset_clamp"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_polygon_offset_clamp"))))]
    pub unsafe fn glPolygonOffsetClampEXT_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glPolygonOffsetClampEXT\0",
            &glPolygonOffsetClampEXT_p,
        )
    }
    /// Checks if the pointer for [`glPolygonOffsetClampEXT`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    #[cfg(any(feature = "GL_EXT_polygon_offset_clamp"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_polygon_offset_clamp"))))]
    pub fn glPolygonOffsetClampEXT_is_loaded() -> bool {
        !glPolygonOffsetClampEXT_p.load(RELAX).is_null()
    }

    /// [glPopDebugGroup](http://docs.gl/es3/glPopDebugGroup)()
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn glPopDebugGroup() {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!("calling glPopDebugGroup();",);
        }
        let out = call_atomic_ptr_0arg("glPopDebugGroup", &glPopDebugGroup_p);
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glPopDebugGroup");
        }
        out
    }
    static glPopDebugGroup_p: APcv = ap_None();
    /// Tries to load [`glPopDebugGroup`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    pub unsafe fn glPopDebugGroup_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(get_proc_address, b"glPopDebugGroup\0", &glPopDebugGroup_p)
    }
    /// Checks if the pointer for [`glPopDebugGroup`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    pub fn glPopDebugGroup_is_loaded() -> bool {
        !glPopDebugGroup_p.load(RELAX).is_null()
    }

    /// [glPopDebugGroupKHR](http://docs.gl/es3/glPopDebugGroupKHR)()
    /// alias of: [`glPopDebugGroup`]
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    #[cfg(any(feature = "GL_KHR_debug"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_KHR_debug"))))]
    pub unsafe fn glPopDebugGroupKHR() {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!("calling glPopDebugGroupKHR();",);
        }
        let out = call_atomic_ptr_0arg("glPopDebugGroupKHR", &glPopDebugGroupKHR_p);
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glPopDebugGroupKHR");
        }
        out
    }
    #[cfg(any(feature = "GL_KHR_debug"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_KHR_debug"))))]
    static glPopDebugGroupKHR_p: APcv = ap_None();
    /// Tries to load [`glPopDebugGroupKHR`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    #[cfg(any(feature = "GL_KHR_debug"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_KHR_debug"))))]
    pub unsafe fn glPopDebugGroupKHR_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glPopDebugGroupKHR\0",
            &glPopDebugGroupKHR_p,
        )
    }
    /// Checks if the pointer for [`glPopDebugGroupKHR`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    #[cfg(any(feature = "GL_KHR_debug"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_KHR_debug"))))]
    pub fn glPopDebugGroupKHR_is_loaded() -> bool {
        !glPopDebugGroupKHR_p.load(RELAX).is_null()
    }

    /// [glPopGroupMarkerEXT](http://docs.gl/es3/glPopGroupMarkerEXT)()
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    #[cfg(any(feature = "GL_EXT_debug_marker"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_debug_marker"))))]
    pub unsafe fn glPopGroupMarkerEXT() {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!("calling glPopGroupMarkerEXT();",);
        }
        let out = call_atomic_ptr_0arg("glPopGroupMarkerEXT", &glPopGroupMarkerEXT_p);
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glPopGroupMarkerEXT");
        }
        out
    }
    #[cfg(any(feature = "GL_EXT_debug_marker"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_debug_marker"))))]
    static glPopGroupMarkerEXT_p: APcv = ap_None();
    /// Tries to load [`glPopGroupMarkerEXT`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    #[cfg(any(feature = "GL_EXT_debug_marker"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_debug_marker"))))]
    pub unsafe fn glPopGroupMarkerEXT_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glPopGroupMarkerEXT\0",
            &glPopGroupMarkerEXT_p,
        )
    }
    /// Checks if the pointer for [`glPopGroupMarkerEXT`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    #[cfg(any(feature = "GL_EXT_debug_marker"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_debug_marker"))))]
    pub fn glPopGroupMarkerEXT_is_loaded() -> bool {
        !glPopGroupMarkerEXT_p.load(RELAX).is_null()
    }

    /// [glPrimitiveBoundingBox](http://docs.gl/es3/glPrimitiveBoundingBox)(minX, minY, minZ, minW, maxX, maxY, maxZ, maxW)
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn glPrimitiveBoundingBox(
        minX: GLfloat,
        minY: GLfloat,
        minZ: GLfloat,
        minW: GLfloat,
        maxX: GLfloat,
        maxY: GLfloat,
        maxZ: GLfloat,
        maxW: GLfloat,
    ) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glPrimitiveBoundingBox({:?}, {:?}, {:?}, {:?}, {:?}, {:?}, {:?}, {:?});",
                minX,
                minY,
                minZ,
                minW,
                maxX,
                maxY,
                maxZ,
                maxW
            );
        }
        let out = call_atomic_ptr_8arg(
            "glPrimitiveBoundingBox",
            &glPrimitiveBoundingBox_p,
            minX,
            minY,
            minZ,
            minW,
            maxX,
            maxY,
            maxZ,
            maxW,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glPrimitiveBoundingBox");
        }
        out
    }
    static glPrimitiveBoundingBox_p: APcv = ap_None();
    /// Tries to load [`glPrimitiveBoundingBox`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    pub unsafe fn glPrimitiveBoundingBox_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glPrimitiveBoundingBox\0",
            &glPrimitiveBoundingBox_p,
        )
    }
    /// Checks if the pointer for [`glPrimitiveBoundingBox`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    pub fn glPrimitiveBoundingBox_is_loaded() -> bool {
        !glPrimitiveBoundingBox_p.load(RELAX).is_null()
    }

    /// [glPrimitiveBoundingBoxEXT](http://docs.gl/es3/glPrimitiveBoundingBoxEXT)(minX, minY, minZ, minW, maxX, maxY, maxZ, maxW)
    /// alias of: [`glPrimitiveBoundingBox`]
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    #[cfg(any(feature = "GL_EXT_primitive_bounding_box"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_primitive_bounding_box"))))]
    pub unsafe fn glPrimitiveBoundingBoxEXT(
        minX: GLfloat,
        minY: GLfloat,
        minZ: GLfloat,
        minW: GLfloat,
        maxX: GLfloat,
        maxY: GLfloat,
        maxZ: GLfloat,
        maxW: GLfloat,
    ) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glPrimitiveBoundingBoxEXT({:?}, {:?}, {:?}, {:?}, {:?}, {:?}, {:?}, {:?});",
                minX,
                minY,
                minZ,
                minW,
                maxX,
                maxY,
                maxZ,
                maxW
            );
        }
        let out = call_atomic_ptr_8arg(
            "glPrimitiveBoundingBoxEXT",
            &glPrimitiveBoundingBoxEXT_p,
            minX,
            minY,
            minZ,
            minW,
            maxX,
            maxY,
            maxZ,
            maxW,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glPrimitiveBoundingBoxEXT");
        }
        out
    }
    #[cfg(any(feature = "GL_EXT_primitive_bounding_box"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_primitive_bounding_box"))))]
    static glPrimitiveBoundingBoxEXT_p: APcv = ap_None();
    /// Tries to load [`glPrimitiveBoundingBoxEXT`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    #[cfg(any(feature = "GL_EXT_primitive_bounding_box"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_primitive_bounding_box"))))]
    pub unsafe fn glPrimitiveBoundingBoxEXT_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glPrimitiveBoundingBoxEXT\0",
            &glPrimitiveBoundingBoxEXT_p,
        )
    }
    /// Checks if the pointer for [`glPrimitiveBoundingBoxEXT`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    #[cfg(any(feature = "GL_EXT_primitive_bounding_box"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_primitive_bounding_box"))))]
    pub fn glPrimitiveBoundingBoxEXT_is_loaded() -> bool {
        !glPrimitiveBoundingBoxEXT_p.load(RELAX).is_null()
    }

    /// [glPrimitiveBoundingBoxOES](http://docs.gl/es3/glPrimitiveBoundingBoxOES)(minX, minY, minZ, minW, maxX, maxY, maxZ, maxW)
    /// alias of: [`glPrimitiveBoundingBox`]
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    #[cfg(any(feature = "GL_OES_primitive_bounding_box"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_OES_primitive_bounding_box"))))]
    pub unsafe fn glPrimitiveBoundingBoxOES(
        minX: GLfloat,
        minY: GLfloat,
        minZ: GLfloat,
        minW: GLfloat,
        maxX: GLfloat,
        maxY: GLfloat,
        maxZ: GLfloat,
        maxW: GLfloat,
    ) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glPrimitiveBoundingBoxOES({:?}, {:?}, {:?}, {:?}, {:?}, {:?}, {:?}, {:?});",
                minX,
                minY,
                minZ,
                minW,
                maxX,
                maxY,
                maxZ,
                maxW
            );
        }
        let out = call_atomic_ptr_8arg(
            "glPrimitiveBoundingBoxOES",
            &glPrimitiveBoundingBoxOES_p,
            minX,
            minY,
            minZ,
            minW,
            maxX,
            maxY,
            maxZ,
            maxW,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glPrimitiveBoundingBoxOES");
        }
        out
    }
    #[cfg(any(feature = "GL_OES_primitive_bounding_box"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_OES_primitive_bounding_box"))))]
    static glPrimitiveBoundingBoxOES_p: APcv = ap_None();
    /// Tries to load [`glPrimitiveBoundingBoxOES`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    #[cfg(any(feature = "GL_OES_primitive_bounding_box"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_OES_primitive_bounding_box"))))]
    pub unsafe fn glPrimitiveBoundingBoxOES_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glPrimitiveBoundingBoxOES\0",
            &glPrimitiveBoundingBoxOES_p,
        )
    }
    /// Checks if the pointer for [`glPrimitiveBoundingBoxOES`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    #[cfg(any(feature = "GL_OES_primitive_bounding_box"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_OES_primitive_bounding_box"))))]
    pub fn glPrimitiveBoundingBoxOES_is_loaded() -> bool {
        !glPrimitiveBoundingBoxOES_p.load(RELAX).is_null()
    }

    /// [glProgramBinary](http://docs.gl/es3/glProgramBinary)(program, binaryFormat, binary, length)
    /// `program` class: program
    /// `binary` len: length
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn glProgramBinary(
        program: GLuint,
        binaryFormat: GLenum,
        binary: *const c_void,
        length: GLsizei,
    ) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glProgramBinary({:?}, {:#X}, {:p}, {:?});",
                program,
                binaryFormat,
                binary,
                length
            );
        }
        let out = call_atomic_ptr_4arg(
            "glProgramBinary",
            &glProgramBinary_p,
            program,
            binaryFormat,
            binary,
            length,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glProgramBinary");
        }
        out
    }
    static glProgramBinary_p: APcv = ap_None();
    /// Tries to load [`glProgramBinary`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    pub unsafe fn glProgramBinary_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(get_proc_address, b"glProgramBinary\0", &glProgramBinary_p)
    }
    /// Checks if the pointer for [`glProgramBinary`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    pub fn glProgramBinary_is_loaded() -> bool {
        !glProgramBinary_p.load(RELAX).is_null()
    }

    /// [glProgramBinaryOES](http://docs.gl/es3/glProgramBinaryOES)(program, binaryFormat, binary, length)
    /// `program` class: program
    /// `binary` len: length
    /// alias of: [`glProgramBinary`]
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    #[cfg(any(feature = "GL_OES_get_program_binary"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_OES_get_program_binary"))))]
    pub unsafe fn glProgramBinaryOES(
        program: GLuint,
        binaryFormat: GLenum,
        binary: *const c_void,
        length: GLint,
    ) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glProgramBinaryOES({:?}, {:#X}, {:p}, {:?});",
                program,
                binaryFormat,
                binary,
                length
            );
        }
        let out = call_atomic_ptr_4arg(
            "glProgramBinaryOES",
            &glProgramBinaryOES_p,
            program,
            binaryFormat,
            binary,
            length,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glProgramBinaryOES");
        }
        out
    }
    #[cfg(any(feature = "GL_OES_get_program_binary"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_OES_get_program_binary"))))]
    static glProgramBinaryOES_p: APcv = ap_None();
    /// Tries to load [`glProgramBinaryOES`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    #[cfg(any(feature = "GL_OES_get_program_binary"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_OES_get_program_binary"))))]
    pub unsafe fn glProgramBinaryOES_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glProgramBinaryOES\0",
            &glProgramBinaryOES_p,
        )
    }
    /// Checks if the pointer for [`glProgramBinaryOES`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    #[cfg(any(feature = "GL_OES_get_program_binary"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_OES_get_program_binary"))))]
    pub fn glProgramBinaryOES_is_loaded() -> bool {
        !glProgramBinaryOES_p.load(RELAX).is_null()
    }

    /// [glProgramParameteri](http://docs.gl/es3/glProgramParameteri)(program, pname, value)
    /// `program` class: program
    /// `pname` group: ProgramParameterPName
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn glProgramParameteri(program: GLuint, pname: GLenum, value: GLint) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glProgramParameteri({:?}, {:#X}, {:?});",
                program,
                pname,
                value
            );
        }
        let out = call_atomic_ptr_3arg(
            "glProgramParameteri",
            &glProgramParameteri_p,
            program,
            pname,
            value,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glProgramParameteri");
        }
        out
    }
    static glProgramParameteri_p: APcv = ap_None();
    /// Tries to load [`glProgramParameteri`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    pub unsafe fn glProgramParameteri_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glProgramParameteri\0",
            &glProgramParameteri_p,
        )
    }
    /// Checks if the pointer for [`glProgramParameteri`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    pub fn glProgramParameteri_is_loaded() -> bool {
        !glProgramParameteri_p.load(RELAX).is_null()
    }

    /// [glProgramParameteriEXT](http://docs.gl/es3/glProgramParameteriEXT)(program, pname, value)
    /// `program` class: program
    /// `pname` group: ProgramParameterPName
    /// alias of: [`glProgramParameteri`]
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    #[cfg(any(feature = "GL_EXT_separate_shader_objects"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_separate_shader_objects"))))]
    pub unsafe fn glProgramParameteriEXT(program: GLuint, pname: GLenum, value: GLint) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glProgramParameteriEXT({:?}, {:#X}, {:?});",
                program,
                pname,
                value
            );
        }
        let out = call_atomic_ptr_3arg(
            "glProgramParameteriEXT",
            &glProgramParameteriEXT_p,
            program,
            pname,
            value,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glProgramParameteriEXT");
        }
        out
    }
    #[cfg(any(feature = "GL_EXT_separate_shader_objects"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_separate_shader_objects"))))]
    static glProgramParameteriEXT_p: APcv = ap_None();
    /// Tries to load [`glProgramParameteriEXT`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    #[cfg(any(feature = "GL_EXT_separate_shader_objects"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_separate_shader_objects"))))]
    pub unsafe fn glProgramParameteriEXT_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glProgramParameteriEXT\0",
            &glProgramParameteriEXT_p,
        )
    }
    /// Checks if the pointer for [`glProgramParameteriEXT`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    #[cfg(any(feature = "GL_EXT_separate_shader_objects"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_separate_shader_objects"))))]
    pub fn glProgramParameteriEXT_is_loaded() -> bool {
        !glProgramParameteriEXT_p.load(RELAX).is_null()
    }

    /// [glProgramPathFragmentInputGenNV](http://docs.gl/es3/glProgramPathFragmentInputGenNV)(program, location, genMode, components, coeffs)
    /// `program` class: program
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    #[cfg(any(feature = "GL_NV_path_rendering"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_path_rendering"))))]
    pub unsafe fn glProgramPathFragmentInputGenNV(
        program: GLuint,
        location: GLint,
        genMode: GLenum,
        components: GLint,
        coeffs: *const GLfloat,
    ) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glProgramPathFragmentInputGenNV({:?}, {:?}, {:#X}, {:?}, {:p});",
                program,
                location,
                genMode,
                components,
                coeffs
            );
        }
        let out = call_atomic_ptr_5arg(
            "glProgramPathFragmentInputGenNV",
            &glProgramPathFragmentInputGenNV_p,
            program,
            location,
            genMode,
            components,
            coeffs,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glProgramPathFragmentInputGenNV");
        }
        out
    }
    #[cfg(any(feature = "GL_NV_path_rendering"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_path_rendering"))))]
    static glProgramPathFragmentInputGenNV_p: APcv = ap_None();
    /// Tries to load [`glProgramPathFragmentInputGenNV`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    #[cfg(any(feature = "GL_NV_path_rendering"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_path_rendering"))))]
    pub unsafe fn glProgramPathFragmentInputGenNV_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glProgramPathFragmentInputGenNV\0",
            &glProgramPathFragmentInputGenNV_p,
        )
    }
    /// Checks if the pointer for [`glProgramPathFragmentInputGenNV`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    #[cfg(any(feature = "GL_NV_path_rendering"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_path_rendering"))))]
    pub fn glProgramPathFragmentInputGenNV_is_loaded() -> bool {
        !glProgramPathFragmentInputGenNV_p.load(RELAX).is_null()
    }

    /// [glProgramUniform1f](http://docs.gl/es3/glProgramUniform)(program, location, v0)
    /// `program` class: program
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn glProgramUniform1f(program: GLuint, location: GLint, v0: GLfloat) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glProgramUniform1f({:?}, {:?}, {:?});",
                program,
                location,
                v0
            );
        }
        let out = call_atomic_ptr_3arg(
            "glProgramUniform1f",
            &glProgramUniform1f_p,
            program,
            location,
            v0,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glProgramUniform1f");
        }
        out
    }
    static glProgramUniform1f_p: APcv = ap_None();
    /// Tries to load [`glProgramUniform1f`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    pub unsafe fn glProgramUniform1f_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glProgramUniform1f\0",
            &glProgramUniform1f_p,
        )
    }
    /// Checks if the pointer for [`glProgramUniform1f`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    pub fn glProgramUniform1f_is_loaded() -> bool {
        !glProgramUniform1f_p.load(RELAX).is_null()
    }

    /// [glProgramUniform1fEXT](http://docs.gl/es3/glProgramUniform1fEXT)(program, location, v0)
    /// `program` class: program
    /// alias of: [`glProgramUniform1f`]
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    #[cfg(any(feature = "GL_EXT_separate_shader_objects"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_separate_shader_objects"))))]
    pub unsafe fn glProgramUniform1fEXT(program: GLuint, location: GLint, v0: GLfloat) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glProgramUniform1fEXT({:?}, {:?}, {:?});",
                program,
                location,
                v0
            );
        }
        let out = call_atomic_ptr_3arg(
            "glProgramUniform1fEXT",
            &glProgramUniform1fEXT_p,
            program,
            location,
            v0,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glProgramUniform1fEXT");
        }
        out
    }
    #[cfg(any(feature = "GL_EXT_separate_shader_objects"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_separate_shader_objects"))))]
    static glProgramUniform1fEXT_p: APcv = ap_None();
    /// Tries to load [`glProgramUniform1fEXT`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    #[cfg(any(feature = "GL_EXT_separate_shader_objects"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_separate_shader_objects"))))]
    pub unsafe fn glProgramUniform1fEXT_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glProgramUniform1fEXT\0",
            &glProgramUniform1fEXT_p,
        )
    }
    /// Checks if the pointer for [`glProgramUniform1fEXT`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    #[cfg(any(feature = "GL_EXT_separate_shader_objects"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_separate_shader_objects"))))]
    pub fn glProgramUniform1fEXT_is_loaded() -> bool {
        !glProgramUniform1fEXT_p.load(RELAX).is_null()
    }

    /// [glProgramUniform1fv](http://docs.gl/es3/glProgramUniform)(program, location, count, value)
    /// `program` class: program
    /// `value` len: count
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn glProgramUniform1fv(
        program: GLuint,
        location: GLint,
        count: GLsizei,
        value: *const GLfloat,
    ) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glProgramUniform1fv({:?}, {:?}, {:?}, {:p});",
                program,
                location,
                count,
                value
            );
        }
        let out = call_atomic_ptr_4arg(
            "glProgramUniform1fv",
            &glProgramUniform1fv_p,
            program,
            location,
            count,
            value,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glProgramUniform1fv");
        }
        out
    }
    static glProgramUniform1fv_p: APcv = ap_None();
    /// Tries to load [`glProgramUniform1fv`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    pub unsafe fn glProgramUniform1fv_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glProgramUniform1fv\0",
            &glProgramUniform1fv_p,
        )
    }
    /// Checks if the pointer for [`glProgramUniform1fv`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    pub fn glProgramUniform1fv_is_loaded() -> bool {
        !glProgramUniform1fv_p.load(RELAX).is_null()
    }

    /// [glProgramUniform1fvEXT](http://docs.gl/es3/glProgramUniform1fvEXT)(program, location, count, value)
    /// `program` class: program
    /// `value` len: count
    /// alias of: [`glProgramUniform1fv`]
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    #[cfg(any(feature = "GL_EXT_separate_shader_objects"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_separate_shader_objects"))))]
    pub unsafe fn glProgramUniform1fvEXT(
        program: GLuint,
        location: GLint,
        count: GLsizei,
        value: *const GLfloat,
    ) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glProgramUniform1fvEXT({:?}, {:?}, {:?}, {:p});",
                program,
                location,
                count,
                value
            );
        }
        let out = call_atomic_ptr_4arg(
            "glProgramUniform1fvEXT",
            &glProgramUniform1fvEXT_p,
            program,
            location,
            count,
            value,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glProgramUniform1fvEXT");
        }
        out
    }
    #[cfg(any(feature = "GL_EXT_separate_shader_objects"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_separate_shader_objects"))))]
    static glProgramUniform1fvEXT_p: APcv = ap_None();
    /// Tries to load [`glProgramUniform1fvEXT`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    #[cfg(any(feature = "GL_EXT_separate_shader_objects"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_separate_shader_objects"))))]
    pub unsafe fn glProgramUniform1fvEXT_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glProgramUniform1fvEXT\0",
            &glProgramUniform1fvEXT_p,
        )
    }
    /// Checks if the pointer for [`glProgramUniform1fvEXT`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    #[cfg(any(feature = "GL_EXT_separate_shader_objects"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_separate_shader_objects"))))]
    pub fn glProgramUniform1fvEXT_is_loaded() -> bool {
        !glProgramUniform1fvEXT_p.load(RELAX).is_null()
    }

    /// [glProgramUniform1i](http://docs.gl/es3/glProgramUniform)(program, location, v0)
    /// `program` class: program
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn glProgramUniform1i(program: GLuint, location: GLint, v0: GLint) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glProgramUniform1i({:?}, {:?}, {:?});",
                program,
                location,
                v0
            );
        }
        let out = call_atomic_ptr_3arg(
            "glProgramUniform1i",
            &glProgramUniform1i_p,
            program,
            location,
            v0,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glProgramUniform1i");
        }
        out
    }
    static glProgramUniform1i_p: APcv = ap_None();
    /// Tries to load [`glProgramUniform1i`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    pub unsafe fn glProgramUniform1i_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glProgramUniform1i\0",
            &glProgramUniform1i_p,
        )
    }
    /// Checks if the pointer for [`glProgramUniform1i`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    pub fn glProgramUniform1i_is_loaded() -> bool {
        !glProgramUniform1i_p.load(RELAX).is_null()
    }

    /// [glProgramUniform1i64NV](http://docs.gl/es3/glProgramUniform1i64NV)(program, location, x)
    /// `program` class: program
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    #[cfg(any(feature = "GL_NV_gpu_shader5"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_gpu_shader5"))))]
    pub unsafe fn glProgramUniform1i64NV(program: GLuint, location: GLint, x: GLint64EXT) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glProgramUniform1i64NV({:?}, {:?}, {:?});",
                program,
                location,
                x
            );
        }
        let out = call_atomic_ptr_3arg(
            "glProgramUniform1i64NV",
            &glProgramUniform1i64NV_p,
            program,
            location,
            x,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glProgramUniform1i64NV");
        }
        out
    }
    #[cfg(any(feature = "GL_NV_gpu_shader5"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_gpu_shader5"))))]
    static glProgramUniform1i64NV_p: APcv = ap_None();
    /// Tries to load [`glProgramUniform1i64NV`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    #[cfg(any(feature = "GL_NV_gpu_shader5"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_gpu_shader5"))))]
    pub unsafe fn glProgramUniform1i64NV_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glProgramUniform1i64NV\0",
            &glProgramUniform1i64NV_p,
        )
    }
    /// Checks if the pointer for [`glProgramUniform1i64NV`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    #[cfg(any(feature = "GL_NV_gpu_shader5"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_gpu_shader5"))))]
    pub fn glProgramUniform1i64NV_is_loaded() -> bool {
        !glProgramUniform1i64NV_p.load(RELAX).is_null()
    }

    /// [glProgramUniform1i64vNV](http://docs.gl/es3/glProgramUniform1i64vNV)(program, location, count, value)
    /// `program` class: program
    /// `value` len: count
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    #[cfg(any(feature = "GL_NV_gpu_shader5"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_gpu_shader5"))))]
    pub unsafe fn glProgramUniform1i64vNV(
        program: GLuint,
        location: GLint,
        count: GLsizei,
        value: *const GLint64EXT,
    ) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glProgramUniform1i64vNV({:?}, {:?}, {:?}, {:p});",
                program,
                location,
                count,
                value
            );
        }
        let out = call_atomic_ptr_4arg(
            "glProgramUniform1i64vNV",
            &glProgramUniform1i64vNV_p,
            program,
            location,
            count,
            value,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glProgramUniform1i64vNV");
        }
        out
    }
    #[cfg(any(feature = "GL_NV_gpu_shader5"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_gpu_shader5"))))]
    static glProgramUniform1i64vNV_p: APcv = ap_None();
    /// Tries to load [`glProgramUniform1i64vNV`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    #[cfg(any(feature = "GL_NV_gpu_shader5"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_gpu_shader5"))))]
    pub unsafe fn glProgramUniform1i64vNV_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glProgramUniform1i64vNV\0",
            &glProgramUniform1i64vNV_p,
        )
    }
    /// Checks if the pointer for [`glProgramUniform1i64vNV`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    #[cfg(any(feature = "GL_NV_gpu_shader5"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_gpu_shader5"))))]
    pub fn glProgramUniform1i64vNV_is_loaded() -> bool {
        !glProgramUniform1i64vNV_p.load(RELAX).is_null()
    }

    /// [glProgramUniform1iEXT](http://docs.gl/es3/glProgramUniform1iEXT)(program, location, v0)
    /// `program` class: program
    /// alias of: [`glProgramUniform1i`]
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    #[cfg(any(feature = "GL_EXT_separate_shader_objects"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_separate_shader_objects"))))]
    pub unsafe fn glProgramUniform1iEXT(program: GLuint, location: GLint, v0: GLint) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glProgramUniform1iEXT({:?}, {:?}, {:?});",
                program,
                location,
                v0
            );
        }
        let out = call_atomic_ptr_3arg(
            "glProgramUniform1iEXT",
            &glProgramUniform1iEXT_p,
            program,
            location,
            v0,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glProgramUniform1iEXT");
        }
        out
    }
    #[cfg(any(feature = "GL_EXT_separate_shader_objects"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_separate_shader_objects"))))]
    static glProgramUniform1iEXT_p: APcv = ap_None();
    /// Tries to load [`glProgramUniform1iEXT`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    #[cfg(any(feature = "GL_EXT_separate_shader_objects"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_separate_shader_objects"))))]
    pub unsafe fn glProgramUniform1iEXT_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glProgramUniform1iEXT\0",
            &glProgramUniform1iEXT_p,
        )
    }
    /// Checks if the pointer for [`glProgramUniform1iEXT`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    #[cfg(any(feature = "GL_EXT_separate_shader_objects"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_separate_shader_objects"))))]
    pub fn glProgramUniform1iEXT_is_loaded() -> bool {
        !glProgramUniform1iEXT_p.load(RELAX).is_null()
    }

    /// [glProgramUniform1iv](http://docs.gl/es3/glProgramUniform)(program, location, count, value)
    /// `program` class: program
    /// `value` len: count
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn glProgramUniform1iv(
        program: GLuint,
        location: GLint,
        count: GLsizei,
        value: *const GLint,
    ) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glProgramUniform1iv({:?}, {:?}, {:?}, {:p});",
                program,
                location,
                count,
                value
            );
        }
        let out = call_atomic_ptr_4arg(
            "glProgramUniform1iv",
            &glProgramUniform1iv_p,
            program,
            location,
            count,
            value,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glProgramUniform1iv");
        }
        out
    }
    static glProgramUniform1iv_p: APcv = ap_None();
    /// Tries to load [`glProgramUniform1iv`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    pub unsafe fn glProgramUniform1iv_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glProgramUniform1iv\0",
            &glProgramUniform1iv_p,
        )
    }
    /// Checks if the pointer for [`glProgramUniform1iv`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    pub fn glProgramUniform1iv_is_loaded() -> bool {
        !glProgramUniform1iv_p.load(RELAX).is_null()
    }

    /// [glProgramUniform1ivEXT](http://docs.gl/es3/glProgramUniform1ivEXT)(program, location, count, value)
    /// `program` class: program
    /// `value` len: count
    /// alias of: [`glProgramUniform1iv`]
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    #[cfg(any(feature = "GL_EXT_separate_shader_objects"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_separate_shader_objects"))))]
    pub unsafe fn glProgramUniform1ivEXT(
        program: GLuint,
        location: GLint,
        count: GLsizei,
        value: *const GLint,
    ) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glProgramUniform1ivEXT({:?}, {:?}, {:?}, {:p});",
                program,
                location,
                count,
                value
            );
        }
        let out = call_atomic_ptr_4arg(
            "glProgramUniform1ivEXT",
            &glProgramUniform1ivEXT_p,
            program,
            location,
            count,
            value,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glProgramUniform1ivEXT");
        }
        out
    }
    #[cfg(any(feature = "GL_EXT_separate_shader_objects"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_separate_shader_objects"))))]
    static glProgramUniform1ivEXT_p: APcv = ap_None();
    /// Tries to load [`glProgramUniform1ivEXT`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    #[cfg(any(feature = "GL_EXT_separate_shader_objects"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_separate_shader_objects"))))]
    pub unsafe fn glProgramUniform1ivEXT_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glProgramUniform1ivEXT\0",
            &glProgramUniform1ivEXT_p,
        )
    }
    /// Checks if the pointer for [`glProgramUniform1ivEXT`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    #[cfg(any(feature = "GL_EXT_separate_shader_objects"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_separate_shader_objects"))))]
    pub fn glProgramUniform1ivEXT_is_loaded() -> bool {
        !glProgramUniform1ivEXT_p.load(RELAX).is_null()
    }

    /// [glProgramUniform1ui](http://docs.gl/es3/glProgramUniform)(program, location, v0)
    /// `program` class: program
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn glProgramUniform1ui(program: GLuint, location: GLint, v0: GLuint) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glProgramUniform1ui({:?}, {:?}, {:?});",
                program,
                location,
                v0
            );
        }
        let out = call_atomic_ptr_3arg(
            "glProgramUniform1ui",
            &glProgramUniform1ui_p,
            program,
            location,
            v0,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glProgramUniform1ui");
        }
        out
    }
    static glProgramUniform1ui_p: APcv = ap_None();
    /// Tries to load [`glProgramUniform1ui`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    pub unsafe fn glProgramUniform1ui_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glProgramUniform1ui\0",
            &glProgramUniform1ui_p,
        )
    }
    /// Checks if the pointer for [`glProgramUniform1ui`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    pub fn glProgramUniform1ui_is_loaded() -> bool {
        !glProgramUniform1ui_p.load(RELAX).is_null()
    }

    /// [glProgramUniform1ui64NV](http://docs.gl/es3/glProgramUniform1ui64NV)(program, location, x)
    /// `program` class: program
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    #[cfg(any(feature = "GL_NV_gpu_shader5"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_gpu_shader5"))))]
    pub unsafe fn glProgramUniform1ui64NV(program: GLuint, location: GLint, x: GLuint64EXT) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glProgramUniform1ui64NV({:?}, {:?}, {:?});",
                program,
                location,
                x
            );
        }
        let out = call_atomic_ptr_3arg(
            "glProgramUniform1ui64NV",
            &glProgramUniform1ui64NV_p,
            program,
            location,
            x,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glProgramUniform1ui64NV");
        }
        out
    }
    #[cfg(any(feature = "GL_NV_gpu_shader5"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_gpu_shader5"))))]
    static glProgramUniform1ui64NV_p: APcv = ap_None();
    /// Tries to load [`glProgramUniform1ui64NV`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    #[cfg(any(feature = "GL_NV_gpu_shader5"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_gpu_shader5"))))]
    pub unsafe fn glProgramUniform1ui64NV_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glProgramUniform1ui64NV\0",
            &glProgramUniform1ui64NV_p,
        )
    }
    /// Checks if the pointer for [`glProgramUniform1ui64NV`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    #[cfg(any(feature = "GL_NV_gpu_shader5"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_gpu_shader5"))))]
    pub fn glProgramUniform1ui64NV_is_loaded() -> bool {
        !glProgramUniform1ui64NV_p.load(RELAX).is_null()
    }

    /// [glProgramUniform1ui64vNV](http://docs.gl/es3/glProgramUniform1ui64vNV)(program, location, count, value)
    /// `program` class: program
    /// `value` len: count
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    #[cfg(any(feature = "GL_NV_gpu_shader5"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_gpu_shader5"))))]
    pub unsafe fn glProgramUniform1ui64vNV(
        program: GLuint,
        location: GLint,
        count: GLsizei,
        value: *const GLuint64EXT,
    ) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glProgramUniform1ui64vNV({:?}, {:?}, {:?}, {:p});",
                program,
                location,
                count,
                value
            );
        }
        let out = call_atomic_ptr_4arg(
            "glProgramUniform1ui64vNV",
            &glProgramUniform1ui64vNV_p,
            program,
            location,
            count,
            value,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glProgramUniform1ui64vNV");
        }
        out
    }
    #[cfg(any(feature = "GL_NV_gpu_shader5"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_gpu_shader5"))))]
    static glProgramUniform1ui64vNV_p: APcv = ap_None();
    /// Tries to load [`glProgramUniform1ui64vNV`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    #[cfg(any(feature = "GL_NV_gpu_shader5"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_gpu_shader5"))))]
    pub unsafe fn glProgramUniform1ui64vNV_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glProgramUniform1ui64vNV\0",
            &glProgramUniform1ui64vNV_p,
        )
    }
    /// Checks if the pointer for [`glProgramUniform1ui64vNV`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    #[cfg(any(feature = "GL_NV_gpu_shader5"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_gpu_shader5"))))]
    pub fn glProgramUniform1ui64vNV_is_loaded() -> bool {
        !glProgramUniform1ui64vNV_p.load(RELAX).is_null()
    }

    /// [glProgramUniform1uiEXT](http://docs.gl/es3/glProgramUniform1uiEXT)(program, location, v0)
    /// `program` class: program
    /// alias of: [`glProgramUniform1ui`]
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    #[cfg(any(feature = "GL_EXT_separate_shader_objects"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_separate_shader_objects"))))]
    pub unsafe fn glProgramUniform1uiEXT(program: GLuint, location: GLint, v0: GLuint) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glProgramUniform1uiEXT({:?}, {:?}, {:?});",
                program,
                location,
                v0
            );
        }
        let out = call_atomic_ptr_3arg(
            "glProgramUniform1uiEXT",
            &glProgramUniform1uiEXT_p,
            program,
            location,
            v0,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glProgramUniform1uiEXT");
        }
        out
    }
    #[cfg(any(feature = "GL_EXT_separate_shader_objects"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_separate_shader_objects"))))]
    static glProgramUniform1uiEXT_p: APcv = ap_None();
    /// Tries to load [`glProgramUniform1uiEXT`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    #[cfg(any(feature = "GL_EXT_separate_shader_objects"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_separate_shader_objects"))))]
    pub unsafe fn glProgramUniform1uiEXT_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glProgramUniform1uiEXT\0",
            &glProgramUniform1uiEXT_p,
        )
    }
    /// Checks if the pointer for [`glProgramUniform1uiEXT`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    #[cfg(any(feature = "GL_EXT_separate_shader_objects"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_separate_shader_objects"))))]
    pub fn glProgramUniform1uiEXT_is_loaded() -> bool {
        !glProgramUniform1uiEXT_p.load(RELAX).is_null()
    }

    /// [glProgramUniform1uiv](http://docs.gl/es3/glProgramUniform)(program, location, count, value)
    /// `program` class: program
    /// `value` len: count
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn glProgramUniform1uiv(
        program: GLuint,
        location: GLint,
        count: GLsizei,
        value: *const GLuint,
    ) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glProgramUniform1uiv({:?}, {:?}, {:?}, {:p});",
                program,
                location,
                count,
                value
            );
        }
        let out = call_atomic_ptr_4arg(
            "glProgramUniform1uiv",
            &glProgramUniform1uiv_p,
            program,
            location,
            count,
            value,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glProgramUniform1uiv");
        }
        out
    }
    static glProgramUniform1uiv_p: APcv = ap_None();
    /// Tries to load [`glProgramUniform1uiv`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    pub unsafe fn glProgramUniform1uiv_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glProgramUniform1uiv\0",
            &glProgramUniform1uiv_p,
        )
    }
    /// Checks if the pointer for [`glProgramUniform1uiv`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    pub fn glProgramUniform1uiv_is_loaded() -> bool {
        !glProgramUniform1uiv_p.load(RELAX).is_null()
    }

    /// [glProgramUniform1uivEXT](http://docs.gl/es3/glProgramUniform1uivEXT)(program, location, count, value)
    /// `program` class: program
    /// `value` len: count
    /// alias of: [`glProgramUniform1uiv`]
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    #[cfg(any(feature = "GL_EXT_separate_shader_objects"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_separate_shader_objects"))))]
    pub unsafe fn glProgramUniform1uivEXT(
        program: GLuint,
        location: GLint,
        count: GLsizei,
        value: *const GLuint,
    ) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glProgramUniform1uivEXT({:?}, {:?}, {:?}, {:p});",
                program,
                location,
                count,
                value
            );
        }
        let out = call_atomic_ptr_4arg(
            "glProgramUniform1uivEXT",
            &glProgramUniform1uivEXT_p,
            program,
            location,
            count,
            value,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glProgramUniform1uivEXT");
        }
        out
    }
    #[cfg(any(feature = "GL_EXT_separate_shader_objects"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_separate_shader_objects"))))]
    static glProgramUniform1uivEXT_p: APcv = ap_None();
    /// Tries to load [`glProgramUniform1uivEXT`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    #[cfg(any(feature = "GL_EXT_separate_shader_objects"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_separate_shader_objects"))))]
    pub unsafe fn glProgramUniform1uivEXT_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glProgramUniform1uivEXT\0",
            &glProgramUniform1uivEXT_p,
        )
    }
    /// Checks if the pointer for [`glProgramUniform1uivEXT`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    #[cfg(any(feature = "GL_EXT_separate_shader_objects"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_separate_shader_objects"))))]
    pub fn glProgramUniform1uivEXT_is_loaded() -> bool {
        !glProgramUniform1uivEXT_p.load(RELAX).is_null()
    }

    /// [glProgramUniform2f](http://docs.gl/es3/glProgramUniform)(program, location, v0, v1)
    /// `program` class: program
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn glProgramUniform2f(program: GLuint, location: GLint, v0: GLfloat, v1: GLfloat) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glProgramUniform2f({:?}, {:?}, {:?}, {:?});",
                program,
                location,
                v0,
                v1
            );
        }
        let out = call_atomic_ptr_4arg(
            "glProgramUniform2f",
            &glProgramUniform2f_p,
            program,
            location,
            v0,
            v1,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glProgramUniform2f");
        }
        out
    }
    static glProgramUniform2f_p: APcv = ap_None();
    /// Tries to load [`glProgramUniform2f`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    pub unsafe fn glProgramUniform2f_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glProgramUniform2f\0",
            &glProgramUniform2f_p,
        )
    }
    /// Checks if the pointer for [`glProgramUniform2f`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    pub fn glProgramUniform2f_is_loaded() -> bool {
        !glProgramUniform2f_p.load(RELAX).is_null()
    }

    /// [glProgramUniform2fEXT](http://docs.gl/es3/glProgramUniform2fEXT)(program, location, v0, v1)
    /// `program` class: program
    /// alias of: [`glProgramUniform2f`]
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    #[cfg(any(feature = "GL_EXT_separate_shader_objects"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_separate_shader_objects"))))]
    pub unsafe fn glProgramUniform2fEXT(
        program: GLuint,
        location: GLint,
        v0: GLfloat,
        v1: GLfloat,
    ) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glProgramUniform2fEXT({:?}, {:?}, {:?}, {:?});",
                program,
                location,
                v0,
                v1
            );
        }
        let out = call_atomic_ptr_4arg(
            "glProgramUniform2fEXT",
            &glProgramUniform2fEXT_p,
            program,
            location,
            v0,
            v1,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glProgramUniform2fEXT");
        }
        out
    }
    #[cfg(any(feature = "GL_EXT_separate_shader_objects"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_separate_shader_objects"))))]
    static glProgramUniform2fEXT_p: APcv = ap_None();
    /// Tries to load [`glProgramUniform2fEXT`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    #[cfg(any(feature = "GL_EXT_separate_shader_objects"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_separate_shader_objects"))))]
    pub unsafe fn glProgramUniform2fEXT_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glProgramUniform2fEXT\0",
            &glProgramUniform2fEXT_p,
        )
    }
    /// Checks if the pointer for [`glProgramUniform2fEXT`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    #[cfg(any(feature = "GL_EXT_separate_shader_objects"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_separate_shader_objects"))))]
    pub fn glProgramUniform2fEXT_is_loaded() -> bool {
        !glProgramUniform2fEXT_p.load(RELAX).is_null()
    }

    /// [glProgramUniform2fv](http://docs.gl/es3/glProgramUniform)(program, location, count, value)
    /// `program` class: program
    /// `value` len: count*2
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn glProgramUniform2fv(
        program: GLuint,
        location: GLint,
        count: GLsizei,
        value: *const GLfloat,
    ) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glProgramUniform2fv({:?}, {:?}, {:?}, {:p});",
                program,
                location,
                count,
                value
            );
        }
        let out = call_atomic_ptr_4arg(
            "glProgramUniform2fv",
            &glProgramUniform2fv_p,
            program,
            location,
            count,
            value,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glProgramUniform2fv");
        }
        out
    }
    static glProgramUniform2fv_p: APcv = ap_None();
    /// Tries to load [`glProgramUniform2fv`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    pub unsafe fn glProgramUniform2fv_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glProgramUniform2fv\0",
            &glProgramUniform2fv_p,
        )
    }
    /// Checks if the pointer for [`glProgramUniform2fv`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    pub fn glProgramUniform2fv_is_loaded() -> bool {
        !glProgramUniform2fv_p.load(RELAX).is_null()
    }

    /// [glProgramUniform2fvEXT](http://docs.gl/es3/glProgramUniform2fvEXT)(program, location, count, value)
    /// `program` class: program
    /// `value` len: count*2
    /// alias of: [`glProgramUniform2fv`]
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    #[cfg(any(feature = "GL_EXT_separate_shader_objects"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_separate_shader_objects"))))]
    pub unsafe fn glProgramUniform2fvEXT(
        program: GLuint,
        location: GLint,
        count: GLsizei,
        value: *const GLfloat,
    ) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glProgramUniform2fvEXT({:?}, {:?}, {:?}, {:p});",
                program,
                location,
                count,
                value
            );
        }
        let out = call_atomic_ptr_4arg(
            "glProgramUniform2fvEXT",
            &glProgramUniform2fvEXT_p,
            program,
            location,
            count,
            value,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glProgramUniform2fvEXT");
        }
        out
    }
    #[cfg(any(feature = "GL_EXT_separate_shader_objects"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_separate_shader_objects"))))]
    static glProgramUniform2fvEXT_p: APcv = ap_None();
    /// Tries to load [`glProgramUniform2fvEXT`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    #[cfg(any(feature = "GL_EXT_separate_shader_objects"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_separate_shader_objects"))))]
    pub unsafe fn glProgramUniform2fvEXT_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glProgramUniform2fvEXT\0",
            &glProgramUniform2fvEXT_p,
        )
    }
    /// Checks if the pointer for [`glProgramUniform2fvEXT`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    #[cfg(any(feature = "GL_EXT_separate_shader_objects"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_separate_shader_objects"))))]
    pub fn glProgramUniform2fvEXT_is_loaded() -> bool {
        !glProgramUniform2fvEXT_p.load(RELAX).is_null()
    }

    /// [glProgramUniform2i](http://docs.gl/es3/glProgramUniform)(program, location, v0, v1)
    /// `program` class: program
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn glProgramUniform2i(program: GLuint, location: GLint, v0: GLint, v1: GLint) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glProgramUniform2i({:?}, {:?}, {:?}, {:?});",
                program,
                location,
                v0,
                v1
            );
        }
        let out = call_atomic_ptr_4arg(
            "glProgramUniform2i",
            &glProgramUniform2i_p,
            program,
            location,
            v0,
            v1,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glProgramUniform2i");
        }
        out
    }
    static glProgramUniform2i_p: APcv = ap_None();
    /// Tries to load [`glProgramUniform2i`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    pub unsafe fn glProgramUniform2i_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glProgramUniform2i\0",
            &glProgramUniform2i_p,
        )
    }
    /// Checks if the pointer for [`glProgramUniform2i`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    pub fn glProgramUniform2i_is_loaded() -> bool {
        !glProgramUniform2i_p.load(RELAX).is_null()
    }

    /// [glProgramUniform2i64NV](http://docs.gl/es3/glProgramUniform2i64NV)(program, location, x, y)
    /// `program` class: program
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    #[cfg(any(feature = "GL_NV_gpu_shader5"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_gpu_shader5"))))]
    pub unsafe fn glProgramUniform2i64NV(
        program: GLuint,
        location: GLint,
        x: GLint64EXT,
        y: GLint64EXT,
    ) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glProgramUniform2i64NV({:?}, {:?}, {:?}, {:?});",
                program,
                location,
                x,
                y
            );
        }
        let out = call_atomic_ptr_4arg(
            "glProgramUniform2i64NV",
            &glProgramUniform2i64NV_p,
            program,
            location,
            x,
            y,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glProgramUniform2i64NV");
        }
        out
    }
    #[cfg(any(feature = "GL_NV_gpu_shader5"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_gpu_shader5"))))]
    static glProgramUniform2i64NV_p: APcv = ap_None();
    /// Tries to load [`glProgramUniform2i64NV`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    #[cfg(any(feature = "GL_NV_gpu_shader5"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_gpu_shader5"))))]
    pub unsafe fn glProgramUniform2i64NV_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glProgramUniform2i64NV\0",
            &glProgramUniform2i64NV_p,
        )
    }
    /// Checks if the pointer for [`glProgramUniform2i64NV`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    #[cfg(any(feature = "GL_NV_gpu_shader5"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_gpu_shader5"))))]
    pub fn glProgramUniform2i64NV_is_loaded() -> bool {
        !glProgramUniform2i64NV_p.load(RELAX).is_null()
    }

    /// [glProgramUniform2i64vNV](http://docs.gl/es3/glProgramUniform2i64vNV)(program, location, count, value)
    /// `program` class: program
    /// `value` len: count*2
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    #[cfg(any(feature = "GL_NV_gpu_shader5"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_gpu_shader5"))))]
    pub unsafe fn glProgramUniform2i64vNV(
        program: GLuint,
        location: GLint,
        count: GLsizei,
        value: *const GLint64EXT,
    ) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glProgramUniform2i64vNV({:?}, {:?}, {:?}, {:p});",
                program,
                location,
                count,
                value
            );
        }
        let out = call_atomic_ptr_4arg(
            "glProgramUniform2i64vNV",
            &glProgramUniform2i64vNV_p,
            program,
            location,
            count,
            value,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glProgramUniform2i64vNV");
        }
        out
    }
    #[cfg(any(feature = "GL_NV_gpu_shader5"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_gpu_shader5"))))]
    static glProgramUniform2i64vNV_p: APcv = ap_None();
    /// Tries to load [`glProgramUniform2i64vNV`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    #[cfg(any(feature = "GL_NV_gpu_shader5"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_gpu_shader5"))))]
    pub unsafe fn glProgramUniform2i64vNV_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glProgramUniform2i64vNV\0",
            &glProgramUniform2i64vNV_p,
        )
    }
    /// Checks if the pointer for [`glProgramUniform2i64vNV`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    #[cfg(any(feature = "GL_NV_gpu_shader5"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_gpu_shader5"))))]
    pub fn glProgramUniform2i64vNV_is_loaded() -> bool {
        !glProgramUniform2i64vNV_p.load(RELAX).is_null()
    }

    /// [glProgramUniform2iEXT](http://docs.gl/es3/glProgramUniform2iEXT)(program, location, v0, v1)
    /// `program` class: program
    /// alias of: [`glProgramUniform2i`]
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    #[cfg(any(feature = "GL_EXT_separate_shader_objects"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_separate_shader_objects"))))]
    pub unsafe fn glProgramUniform2iEXT(program: GLuint, location: GLint, v0: GLint, v1: GLint) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glProgramUniform2iEXT({:?}, {:?}, {:?}, {:?});",
                program,
                location,
                v0,
                v1
            );
        }
        let out = call_atomic_ptr_4arg(
            "glProgramUniform2iEXT",
            &glProgramUniform2iEXT_p,
            program,
            location,
            v0,
            v1,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glProgramUniform2iEXT");
        }
        out
    }
    #[cfg(any(feature = "GL_EXT_separate_shader_objects"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_separate_shader_objects"))))]
    static glProgramUniform2iEXT_p: APcv = ap_None();
    /// Tries to load [`glProgramUniform2iEXT`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    #[cfg(any(feature = "GL_EXT_separate_shader_objects"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_separate_shader_objects"))))]
    pub unsafe fn glProgramUniform2iEXT_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glProgramUniform2iEXT\0",
            &glProgramUniform2iEXT_p,
        )
    }
    /// Checks if the pointer for [`glProgramUniform2iEXT`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    #[cfg(any(feature = "GL_EXT_separate_shader_objects"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_separate_shader_objects"))))]
    pub fn glProgramUniform2iEXT_is_loaded() -> bool {
        !glProgramUniform2iEXT_p.load(RELAX).is_null()
    }

    /// [glProgramUniform2iv](http://docs.gl/es3/glProgramUniform)(program, location, count, value)
    /// `program` class: program
    /// `value` len: count*2
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn glProgramUniform2iv(
        program: GLuint,
        location: GLint,
        count: GLsizei,
        value: *const GLint,
    ) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glProgramUniform2iv({:?}, {:?}, {:?}, {:p});",
                program,
                location,
                count,
                value
            );
        }
        let out = call_atomic_ptr_4arg(
            "glProgramUniform2iv",
            &glProgramUniform2iv_p,
            program,
            location,
            count,
            value,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glProgramUniform2iv");
        }
        out
    }
    static glProgramUniform2iv_p: APcv = ap_None();
    /// Tries to load [`glProgramUniform2iv`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    pub unsafe fn glProgramUniform2iv_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glProgramUniform2iv\0",
            &glProgramUniform2iv_p,
        )
    }
    /// Checks if the pointer for [`glProgramUniform2iv`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    pub fn glProgramUniform2iv_is_loaded() -> bool {
        !glProgramUniform2iv_p.load(RELAX).is_null()
    }

    /// [glProgramUniform2ivEXT](http://docs.gl/es3/glProgramUniform2ivEXT)(program, location, count, value)
    /// `program` class: program
    /// `value` len: count*2
    /// alias of: [`glProgramUniform2iv`]
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    #[cfg(any(feature = "GL_EXT_separate_shader_objects"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_separate_shader_objects"))))]
    pub unsafe fn glProgramUniform2ivEXT(
        program: GLuint,
        location: GLint,
        count: GLsizei,
        value: *const GLint,
    ) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glProgramUniform2ivEXT({:?}, {:?}, {:?}, {:p});",
                program,
                location,
                count,
                value
            );
        }
        let out = call_atomic_ptr_4arg(
            "glProgramUniform2ivEXT",
            &glProgramUniform2ivEXT_p,
            program,
            location,
            count,
            value,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glProgramUniform2ivEXT");
        }
        out
    }
    #[cfg(any(feature = "GL_EXT_separate_shader_objects"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_separate_shader_objects"))))]
    static glProgramUniform2ivEXT_p: APcv = ap_None();
    /// Tries to load [`glProgramUniform2ivEXT`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    #[cfg(any(feature = "GL_EXT_separate_shader_objects"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_separate_shader_objects"))))]
    pub unsafe fn glProgramUniform2ivEXT_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glProgramUniform2ivEXT\0",
            &glProgramUniform2ivEXT_p,
        )
    }
    /// Checks if the pointer for [`glProgramUniform2ivEXT`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    #[cfg(any(feature = "GL_EXT_separate_shader_objects"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_separate_shader_objects"))))]
    pub fn glProgramUniform2ivEXT_is_loaded() -> bool {
        !glProgramUniform2ivEXT_p.load(RELAX).is_null()
    }

    /// [glProgramUniform2ui](http://docs.gl/es3/glProgramUniform)(program, location, v0, v1)
    /// `program` class: program
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn glProgramUniform2ui(program: GLuint, location: GLint, v0: GLuint, v1: GLuint) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glProgramUniform2ui({:?}, {:?}, {:?}, {:?});",
                program,
                location,
                v0,
                v1
            );
        }
        let out = call_atomic_ptr_4arg(
            "glProgramUniform2ui",
            &glProgramUniform2ui_p,
            program,
            location,
            v0,
            v1,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glProgramUniform2ui");
        }
        out
    }
    static glProgramUniform2ui_p: APcv = ap_None();
    /// Tries to load [`glProgramUniform2ui`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    pub unsafe fn glProgramUniform2ui_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glProgramUniform2ui\0",
            &glProgramUniform2ui_p,
        )
    }
    /// Checks if the pointer for [`glProgramUniform2ui`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    pub fn glProgramUniform2ui_is_loaded() -> bool {
        !glProgramUniform2ui_p.load(RELAX).is_null()
    }

    /// [glProgramUniform2ui64NV](http://docs.gl/es3/glProgramUniform2ui64NV)(program, location, x, y)
    /// `program` class: program
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    #[cfg(any(feature = "GL_NV_gpu_shader5"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_gpu_shader5"))))]
    pub unsafe fn glProgramUniform2ui64NV(
        program: GLuint,
        location: GLint,
        x: GLuint64EXT,
        y: GLuint64EXT,
    ) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glProgramUniform2ui64NV({:?}, {:?}, {:?}, {:?});",
                program,
                location,
                x,
                y
            );
        }
        let out = call_atomic_ptr_4arg(
            "glProgramUniform2ui64NV",
            &glProgramUniform2ui64NV_p,
            program,
            location,
            x,
            y,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glProgramUniform2ui64NV");
        }
        out
    }
    #[cfg(any(feature = "GL_NV_gpu_shader5"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_gpu_shader5"))))]
    static glProgramUniform2ui64NV_p: APcv = ap_None();
    /// Tries to load [`glProgramUniform2ui64NV`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    #[cfg(any(feature = "GL_NV_gpu_shader5"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_gpu_shader5"))))]
    pub unsafe fn glProgramUniform2ui64NV_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glProgramUniform2ui64NV\0",
            &glProgramUniform2ui64NV_p,
        )
    }
    /// Checks if the pointer for [`glProgramUniform2ui64NV`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    #[cfg(any(feature = "GL_NV_gpu_shader5"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_gpu_shader5"))))]
    pub fn glProgramUniform2ui64NV_is_loaded() -> bool {
        !glProgramUniform2ui64NV_p.load(RELAX).is_null()
    }

    /// [glProgramUniform2ui64vNV](http://docs.gl/es3/glProgramUniform2ui64vNV)(program, location, count, value)
    /// `program` class: program
    /// `value` len: count*2
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    #[cfg(any(feature = "GL_NV_gpu_shader5"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_gpu_shader5"))))]
    pub unsafe fn glProgramUniform2ui64vNV(
        program: GLuint,
        location: GLint,
        count: GLsizei,
        value: *const GLuint64EXT,
    ) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glProgramUniform2ui64vNV({:?}, {:?}, {:?}, {:p});",
                program,
                location,
                count,
                value
            );
        }
        let out = call_atomic_ptr_4arg(
            "glProgramUniform2ui64vNV",
            &glProgramUniform2ui64vNV_p,
            program,
            location,
            count,
            value,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glProgramUniform2ui64vNV");
        }
        out
    }
    #[cfg(any(feature = "GL_NV_gpu_shader5"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_gpu_shader5"))))]
    static glProgramUniform2ui64vNV_p: APcv = ap_None();
    /// Tries to load [`glProgramUniform2ui64vNV`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    #[cfg(any(feature = "GL_NV_gpu_shader5"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_gpu_shader5"))))]
    pub unsafe fn glProgramUniform2ui64vNV_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glProgramUniform2ui64vNV\0",
            &glProgramUniform2ui64vNV_p,
        )
    }
    /// Checks if the pointer for [`glProgramUniform2ui64vNV`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    #[cfg(any(feature = "GL_NV_gpu_shader5"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_gpu_shader5"))))]
    pub fn glProgramUniform2ui64vNV_is_loaded() -> bool {
        !glProgramUniform2ui64vNV_p.load(RELAX).is_null()
    }

    /// [glProgramUniform2uiEXT](http://docs.gl/es3/glProgramUniform2uiEXT)(program, location, v0, v1)
    /// `program` class: program
    /// alias of: [`glProgramUniform2ui`]
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    #[cfg(any(feature = "GL_EXT_separate_shader_objects"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_separate_shader_objects"))))]
    pub unsafe fn glProgramUniform2uiEXT(program: GLuint, location: GLint, v0: GLuint, v1: GLuint) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glProgramUniform2uiEXT({:?}, {:?}, {:?}, {:?});",
                program,
                location,
                v0,
                v1
            );
        }
        let out = call_atomic_ptr_4arg(
            "glProgramUniform2uiEXT",
            &glProgramUniform2uiEXT_p,
            program,
            location,
            v0,
            v1,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glProgramUniform2uiEXT");
        }
        out
    }
    #[cfg(any(feature = "GL_EXT_separate_shader_objects"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_separate_shader_objects"))))]
    static glProgramUniform2uiEXT_p: APcv = ap_None();
    /// Tries to load [`glProgramUniform2uiEXT`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    #[cfg(any(feature = "GL_EXT_separate_shader_objects"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_separate_shader_objects"))))]
    pub unsafe fn glProgramUniform2uiEXT_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glProgramUniform2uiEXT\0",
            &glProgramUniform2uiEXT_p,
        )
    }
    /// Checks if the pointer for [`glProgramUniform2uiEXT`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    #[cfg(any(feature = "GL_EXT_separate_shader_objects"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_separate_shader_objects"))))]
    pub fn glProgramUniform2uiEXT_is_loaded() -> bool {
        !glProgramUniform2uiEXT_p.load(RELAX).is_null()
    }

    /// [glProgramUniform2uiv](http://docs.gl/es3/glProgramUniform)(program, location, count, value)
    /// `program` class: program
    /// `value` len: count*2
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn glProgramUniform2uiv(
        program: GLuint,
        location: GLint,
        count: GLsizei,
        value: *const GLuint,
    ) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glProgramUniform2uiv({:?}, {:?}, {:?}, {:p});",
                program,
                location,
                count,
                value
            );
        }
        let out = call_atomic_ptr_4arg(
            "glProgramUniform2uiv",
            &glProgramUniform2uiv_p,
            program,
            location,
            count,
            value,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glProgramUniform2uiv");
        }
        out
    }
    static glProgramUniform2uiv_p: APcv = ap_None();
    /// Tries to load [`glProgramUniform2uiv`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    pub unsafe fn glProgramUniform2uiv_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glProgramUniform2uiv\0",
            &glProgramUniform2uiv_p,
        )
    }
    /// Checks if the pointer for [`glProgramUniform2uiv`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    pub fn glProgramUniform2uiv_is_loaded() -> bool {
        !glProgramUniform2uiv_p.load(RELAX).is_null()
    }

    /// [glProgramUniform2uivEXT](http://docs.gl/es3/glProgramUniform2uivEXT)(program, location, count, value)
    /// `program` class: program
    /// `value` len: count*2
    /// alias of: [`glProgramUniform2uiv`]
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    #[cfg(any(feature = "GL_EXT_separate_shader_objects"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_separate_shader_objects"))))]
    pub unsafe fn glProgramUniform2uivEXT(
        program: GLuint,
        location: GLint,
        count: GLsizei,
        value: *const GLuint,
    ) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glProgramUniform2uivEXT({:?}, {:?}, {:?}, {:p});",
                program,
                location,
                count,
                value
            );
        }
        let out = call_atomic_ptr_4arg(
            "glProgramUniform2uivEXT",
            &glProgramUniform2uivEXT_p,
            program,
            location,
            count,
            value,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glProgramUniform2uivEXT");
        }
        out
    }
    #[cfg(any(feature = "GL_EXT_separate_shader_objects"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_separate_shader_objects"))))]
    static glProgramUniform2uivEXT_p: APcv = ap_None();
    /// Tries to load [`glProgramUniform2uivEXT`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    #[cfg(any(feature = "GL_EXT_separate_shader_objects"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_separate_shader_objects"))))]
    pub unsafe fn glProgramUniform2uivEXT_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glProgramUniform2uivEXT\0",
            &glProgramUniform2uivEXT_p,
        )
    }
    /// Checks if the pointer for [`glProgramUniform2uivEXT`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    #[cfg(any(feature = "GL_EXT_separate_shader_objects"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_separate_shader_objects"))))]
    pub fn glProgramUniform2uivEXT_is_loaded() -> bool {
        !glProgramUniform2uivEXT_p.load(RELAX).is_null()
    }

    /// [glProgramUniform3f](http://docs.gl/es3/glProgramUniform)(program, location, v0, v1, v2)
    /// `program` class: program
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn glProgramUniform3f(
        program: GLuint,
        location: GLint,
        v0: GLfloat,
        v1: GLfloat,
        v2: GLfloat,
    ) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glProgramUniform3f({:?}, {:?}, {:?}, {:?}, {:?});",
                program,
                location,
                v0,
                v1,
                v2
            );
        }
        let out = call_atomic_ptr_5arg(
            "glProgramUniform3f",
            &glProgramUniform3f_p,
            program,
            location,
            v0,
            v1,
            v2,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glProgramUniform3f");
        }
        out
    }
    static glProgramUniform3f_p: APcv = ap_None();
    /// Tries to load [`glProgramUniform3f`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    pub unsafe fn glProgramUniform3f_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glProgramUniform3f\0",
            &glProgramUniform3f_p,
        )
    }
    /// Checks if the pointer for [`glProgramUniform3f`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    pub fn glProgramUniform3f_is_loaded() -> bool {
        !glProgramUniform3f_p.load(RELAX).is_null()
    }

    /// [glProgramUniform3fEXT](http://docs.gl/es3/glProgramUniform3fEXT)(program, location, v0, v1, v2)
    /// `program` class: program
    /// alias of: [`glProgramUniform3f`]
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    #[cfg(any(feature = "GL_EXT_separate_shader_objects"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_separate_shader_objects"))))]
    pub unsafe fn glProgramUniform3fEXT(
        program: GLuint,
        location: GLint,
        v0: GLfloat,
        v1: GLfloat,
        v2: GLfloat,
    ) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glProgramUniform3fEXT({:?}, {:?}, {:?}, {:?}, {:?});",
                program,
                location,
                v0,
                v1,
                v2
            );
        }
        let out = call_atomic_ptr_5arg(
            "glProgramUniform3fEXT",
            &glProgramUniform3fEXT_p,
            program,
            location,
            v0,
            v1,
            v2,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glProgramUniform3fEXT");
        }
        out
    }
    #[cfg(any(feature = "GL_EXT_separate_shader_objects"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_separate_shader_objects"))))]
    static glProgramUniform3fEXT_p: APcv = ap_None();
    /// Tries to load [`glProgramUniform3fEXT`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    #[cfg(any(feature = "GL_EXT_separate_shader_objects"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_separate_shader_objects"))))]
    pub unsafe fn glProgramUniform3fEXT_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glProgramUniform3fEXT\0",
            &glProgramUniform3fEXT_p,
        )
    }
    /// Checks if the pointer for [`glProgramUniform3fEXT`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    #[cfg(any(feature = "GL_EXT_separate_shader_objects"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_separate_shader_objects"))))]
    pub fn glProgramUniform3fEXT_is_loaded() -> bool {
        !glProgramUniform3fEXT_p.load(RELAX).is_null()
    }

    /// [glProgramUniform3fv](http://docs.gl/es3/glProgramUniform)(program, location, count, value)
    /// `program` class: program
    /// `value` len: count*3
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn glProgramUniform3fv(
        program: GLuint,
        location: GLint,
        count: GLsizei,
        value: *const GLfloat,
    ) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glProgramUniform3fv({:?}, {:?}, {:?}, {:p});",
                program,
                location,
                count,
                value
            );
        }
        let out = call_atomic_ptr_4arg(
            "glProgramUniform3fv",
            &glProgramUniform3fv_p,
            program,
            location,
            count,
            value,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glProgramUniform3fv");
        }
        out
    }
    static glProgramUniform3fv_p: APcv = ap_None();
    /// Tries to load [`glProgramUniform3fv`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    pub unsafe fn glProgramUniform3fv_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glProgramUniform3fv\0",
            &glProgramUniform3fv_p,
        )
    }
    /// Checks if the pointer for [`glProgramUniform3fv`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    pub fn glProgramUniform3fv_is_loaded() -> bool {
        !glProgramUniform3fv_p.load(RELAX).is_null()
    }

    /// [glProgramUniform3fvEXT](http://docs.gl/es3/glProgramUniform3fvEXT)(program, location, count, value)
    /// `program` class: program
    /// `value` len: count*3
    /// alias of: [`glProgramUniform3fv`]
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    #[cfg(any(feature = "GL_EXT_separate_shader_objects"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_separate_shader_objects"))))]
    pub unsafe fn glProgramUniform3fvEXT(
        program: GLuint,
        location: GLint,
        count: GLsizei,
        value: *const GLfloat,
    ) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glProgramUniform3fvEXT({:?}, {:?}, {:?}, {:p});",
                program,
                location,
                count,
                value
            );
        }
        let out = call_atomic_ptr_4arg(
            "glProgramUniform3fvEXT",
            &glProgramUniform3fvEXT_p,
            program,
            location,
            count,
            value,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glProgramUniform3fvEXT");
        }
        out
    }
    #[cfg(any(feature = "GL_EXT_separate_shader_objects"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_separate_shader_objects"))))]
    static glProgramUniform3fvEXT_p: APcv = ap_None();
    /// Tries to load [`glProgramUniform3fvEXT`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    #[cfg(any(feature = "GL_EXT_separate_shader_objects"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_separate_shader_objects"))))]
    pub unsafe fn glProgramUniform3fvEXT_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glProgramUniform3fvEXT\0",
            &glProgramUniform3fvEXT_p,
        )
    }
    /// Checks if the pointer for [`glProgramUniform3fvEXT`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    #[cfg(any(feature = "GL_EXT_separate_shader_objects"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_separate_shader_objects"))))]
    pub fn glProgramUniform3fvEXT_is_loaded() -> bool {
        !glProgramUniform3fvEXT_p.load(RELAX).is_null()
    }

    /// [glProgramUniform3i](http://docs.gl/es3/glProgramUniform)(program, location, v0, v1, v2)
    /// `program` class: program
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn glProgramUniform3i(
        program: GLuint,
        location: GLint,
        v0: GLint,
        v1: GLint,
        v2: GLint,
    ) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glProgramUniform3i({:?}, {:?}, {:?}, {:?}, {:?});",
                program,
                location,
                v0,
                v1,
                v2
            );
        }
        let out = call_atomic_ptr_5arg(
            "glProgramUniform3i",
            &glProgramUniform3i_p,
            program,
            location,
            v0,
            v1,
            v2,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glProgramUniform3i");
        }
        out
    }
    static glProgramUniform3i_p: APcv = ap_None();
    /// Tries to load [`glProgramUniform3i`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    pub unsafe fn glProgramUniform3i_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glProgramUniform3i\0",
            &glProgramUniform3i_p,
        )
    }
    /// Checks if the pointer for [`glProgramUniform3i`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    pub fn glProgramUniform3i_is_loaded() -> bool {
        !glProgramUniform3i_p.load(RELAX).is_null()
    }

    /// [glProgramUniform3i64NV](http://docs.gl/es3/glProgramUniform3i64NV)(program, location, x, y, z)
    /// `program` class: program
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    #[cfg(any(feature = "GL_NV_gpu_shader5"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_gpu_shader5"))))]
    pub unsafe fn glProgramUniform3i64NV(
        program: GLuint,
        location: GLint,
        x: GLint64EXT,
        y: GLint64EXT,
        z: GLint64EXT,
    ) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glProgramUniform3i64NV({:?}, {:?}, {:?}, {:?}, {:?});",
                program,
                location,
                x,
                y,
                z
            );
        }
        let out = call_atomic_ptr_5arg(
            "glProgramUniform3i64NV",
            &glProgramUniform3i64NV_p,
            program,
            location,
            x,
            y,
            z,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glProgramUniform3i64NV");
        }
        out
    }
    #[cfg(any(feature = "GL_NV_gpu_shader5"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_gpu_shader5"))))]
    static glProgramUniform3i64NV_p: APcv = ap_None();
    /// Tries to load [`glProgramUniform3i64NV`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    #[cfg(any(feature = "GL_NV_gpu_shader5"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_gpu_shader5"))))]
    pub unsafe fn glProgramUniform3i64NV_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glProgramUniform3i64NV\0",
            &glProgramUniform3i64NV_p,
        )
    }
    /// Checks if the pointer for [`glProgramUniform3i64NV`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    #[cfg(any(feature = "GL_NV_gpu_shader5"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_gpu_shader5"))))]
    pub fn glProgramUniform3i64NV_is_loaded() -> bool {
        !glProgramUniform3i64NV_p.load(RELAX).is_null()
    }

    /// [glProgramUniform3i64vNV](http://docs.gl/es3/glProgramUniform3i64vNV)(program, location, count, value)
    /// `program` class: program
    /// `value` len: count*3
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    #[cfg(any(feature = "GL_NV_gpu_shader5"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_gpu_shader5"))))]
    pub unsafe fn glProgramUniform3i64vNV(
        program: GLuint,
        location: GLint,
        count: GLsizei,
        value: *const GLint64EXT,
    ) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glProgramUniform3i64vNV({:?}, {:?}, {:?}, {:p});",
                program,
                location,
                count,
                value
            );
        }
        let out = call_atomic_ptr_4arg(
            "glProgramUniform3i64vNV",
            &glProgramUniform3i64vNV_p,
            program,
            location,
            count,
            value,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glProgramUniform3i64vNV");
        }
        out
    }
    #[cfg(any(feature = "GL_NV_gpu_shader5"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_gpu_shader5"))))]
    static glProgramUniform3i64vNV_p: APcv = ap_None();
    /// Tries to load [`glProgramUniform3i64vNV`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    #[cfg(any(feature = "GL_NV_gpu_shader5"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_gpu_shader5"))))]
    pub unsafe fn glProgramUniform3i64vNV_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glProgramUniform3i64vNV\0",
            &glProgramUniform3i64vNV_p,
        )
    }
    /// Checks if the pointer for [`glProgramUniform3i64vNV`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    #[cfg(any(feature = "GL_NV_gpu_shader5"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_gpu_shader5"))))]
    pub fn glProgramUniform3i64vNV_is_loaded() -> bool {
        !glProgramUniform3i64vNV_p.load(RELAX).is_null()
    }

    /// [glProgramUniform3iEXT](http://docs.gl/es3/glProgramUniform3iEXT)(program, location, v0, v1, v2)
    /// `program` class: program
    /// alias of: [`glProgramUniform3i`]
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    #[cfg(any(feature = "GL_EXT_separate_shader_objects"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_separate_shader_objects"))))]
    pub unsafe fn glProgramUniform3iEXT(
        program: GLuint,
        location: GLint,
        v0: GLint,
        v1: GLint,
        v2: GLint,
    ) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glProgramUniform3iEXT({:?}, {:?}, {:?}, {:?}, {:?});",
                program,
                location,
                v0,
                v1,
                v2
            );
        }
        let out = call_atomic_ptr_5arg(
            "glProgramUniform3iEXT",
            &glProgramUniform3iEXT_p,
            program,
            location,
            v0,
            v1,
            v2,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glProgramUniform3iEXT");
        }
        out
    }
    #[cfg(any(feature = "GL_EXT_separate_shader_objects"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_separate_shader_objects"))))]
    static glProgramUniform3iEXT_p: APcv = ap_None();
    /// Tries to load [`glProgramUniform3iEXT`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    #[cfg(any(feature = "GL_EXT_separate_shader_objects"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_separate_shader_objects"))))]
    pub unsafe fn glProgramUniform3iEXT_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glProgramUniform3iEXT\0",
            &glProgramUniform3iEXT_p,
        )
    }
    /// Checks if the pointer for [`glProgramUniform3iEXT`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    #[cfg(any(feature = "GL_EXT_separate_shader_objects"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_separate_shader_objects"))))]
    pub fn glProgramUniform3iEXT_is_loaded() -> bool {
        !glProgramUniform3iEXT_p.load(RELAX).is_null()
    }

    /// [glProgramUniform3iv](http://docs.gl/es3/glProgramUniform)(program, location, count, value)
    /// `program` class: program
    /// `value` len: count*3
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn glProgramUniform3iv(
        program: GLuint,
        location: GLint,
        count: GLsizei,
        value: *const GLint,
    ) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glProgramUniform3iv({:?}, {:?}, {:?}, {:p});",
                program,
                location,
                count,
                value
            );
        }
        let out = call_atomic_ptr_4arg(
            "glProgramUniform3iv",
            &glProgramUniform3iv_p,
            program,
            location,
            count,
            value,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glProgramUniform3iv");
        }
        out
    }
    static glProgramUniform3iv_p: APcv = ap_None();
    /// Tries to load [`glProgramUniform3iv`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    pub unsafe fn glProgramUniform3iv_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glProgramUniform3iv\0",
            &glProgramUniform3iv_p,
        )
    }
    /// Checks if the pointer for [`glProgramUniform3iv`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    pub fn glProgramUniform3iv_is_loaded() -> bool {
        !glProgramUniform3iv_p.load(RELAX).is_null()
    }

    /// [glProgramUniform3ivEXT](http://docs.gl/es3/glProgramUniform3ivEXT)(program, location, count, value)
    /// `program` class: program
    /// `value` len: count*3
    /// alias of: [`glProgramUniform3iv`]
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    #[cfg(any(feature = "GL_EXT_separate_shader_objects"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_separate_shader_objects"))))]
    pub unsafe fn glProgramUniform3ivEXT(
        program: GLuint,
        location: GLint,
        count: GLsizei,
        value: *const GLint,
    ) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glProgramUniform3ivEXT({:?}, {:?}, {:?}, {:p});",
                program,
                location,
                count,
                value
            );
        }
        let out = call_atomic_ptr_4arg(
            "glProgramUniform3ivEXT",
            &glProgramUniform3ivEXT_p,
            program,
            location,
            count,
            value,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glProgramUniform3ivEXT");
        }
        out
    }
    #[cfg(any(feature = "GL_EXT_separate_shader_objects"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_separate_shader_objects"))))]
    static glProgramUniform3ivEXT_p: APcv = ap_None();
    /// Tries to load [`glProgramUniform3ivEXT`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    #[cfg(any(feature = "GL_EXT_separate_shader_objects"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_separate_shader_objects"))))]
    pub unsafe fn glProgramUniform3ivEXT_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glProgramUniform3ivEXT\0",
            &glProgramUniform3ivEXT_p,
        )
    }
    /// Checks if the pointer for [`glProgramUniform3ivEXT`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    #[cfg(any(feature = "GL_EXT_separate_shader_objects"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_separate_shader_objects"))))]
    pub fn glProgramUniform3ivEXT_is_loaded() -> bool {
        !glProgramUniform3ivEXT_p.load(RELAX).is_null()
    }

    /// [glProgramUniform3ui](http://docs.gl/es3/glProgramUniform)(program, location, v0, v1, v2)
    /// `program` class: program
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn glProgramUniform3ui(
        program: GLuint,
        location: GLint,
        v0: GLuint,
        v1: GLuint,
        v2: GLuint,
    ) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glProgramUniform3ui({:?}, {:?}, {:?}, {:?}, {:?});",
                program,
                location,
                v0,
                v1,
                v2
            );
        }
        let out = call_atomic_ptr_5arg(
            "glProgramUniform3ui",
            &glProgramUniform3ui_p,
            program,
            location,
            v0,
            v1,
            v2,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glProgramUniform3ui");
        }
        out
    }
    static glProgramUniform3ui_p: APcv = ap_None();
    /// Tries to load [`glProgramUniform3ui`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    pub unsafe fn glProgramUniform3ui_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glProgramUniform3ui\0",
            &glProgramUniform3ui_p,
        )
    }
    /// Checks if the pointer for [`glProgramUniform3ui`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    pub fn glProgramUniform3ui_is_loaded() -> bool {
        !glProgramUniform3ui_p.load(RELAX).is_null()
    }

    /// [glProgramUniform3ui64NV](http://docs.gl/es3/glProgramUniform3ui64NV)(program, location, x, y, z)
    /// `program` class: program
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    #[cfg(any(feature = "GL_NV_gpu_shader5"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_gpu_shader5"))))]
    pub unsafe fn glProgramUniform3ui64NV(
        program: GLuint,
        location: GLint,
        x: GLuint64EXT,
        y: GLuint64EXT,
        z: GLuint64EXT,
    ) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glProgramUniform3ui64NV({:?}, {:?}, {:?}, {:?}, {:?});",
                program,
                location,
                x,
                y,
                z
            );
        }
        let out = call_atomic_ptr_5arg(
            "glProgramUniform3ui64NV",
            &glProgramUniform3ui64NV_p,
            program,
            location,
            x,
            y,
            z,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glProgramUniform3ui64NV");
        }
        out
    }
    #[cfg(any(feature = "GL_NV_gpu_shader5"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_gpu_shader5"))))]
    static glProgramUniform3ui64NV_p: APcv = ap_None();
    /// Tries to load [`glProgramUniform3ui64NV`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    #[cfg(any(feature = "GL_NV_gpu_shader5"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_gpu_shader5"))))]
    pub unsafe fn glProgramUniform3ui64NV_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glProgramUniform3ui64NV\0",
            &glProgramUniform3ui64NV_p,
        )
    }
    /// Checks if the pointer for [`glProgramUniform3ui64NV`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    #[cfg(any(feature = "GL_NV_gpu_shader5"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_gpu_shader5"))))]
    pub fn glProgramUniform3ui64NV_is_loaded() -> bool {
        !glProgramUniform3ui64NV_p.load(RELAX).is_null()
    }

    /// [glProgramUniform3ui64vNV](http://docs.gl/es3/glProgramUniform3ui64vNV)(program, location, count, value)
    /// `program` class: program
    /// `value` len: count*3
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    #[cfg(any(feature = "GL_NV_gpu_shader5"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_gpu_shader5"))))]
    pub unsafe fn glProgramUniform3ui64vNV(
        program: GLuint,
        location: GLint,
        count: GLsizei,
        value: *const GLuint64EXT,
    ) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glProgramUniform3ui64vNV({:?}, {:?}, {:?}, {:p});",
                program,
                location,
                count,
                value
            );
        }
        let out = call_atomic_ptr_4arg(
            "glProgramUniform3ui64vNV",
            &glProgramUniform3ui64vNV_p,
            program,
            location,
            count,
            value,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glProgramUniform3ui64vNV");
        }
        out
    }
    #[cfg(any(feature = "GL_NV_gpu_shader5"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_gpu_shader5"))))]
    static glProgramUniform3ui64vNV_p: APcv = ap_None();
    /// Tries to load [`glProgramUniform3ui64vNV`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    #[cfg(any(feature = "GL_NV_gpu_shader5"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_gpu_shader5"))))]
    pub unsafe fn glProgramUniform3ui64vNV_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glProgramUniform3ui64vNV\0",
            &glProgramUniform3ui64vNV_p,
        )
    }
    /// Checks if the pointer for [`glProgramUniform3ui64vNV`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    #[cfg(any(feature = "GL_NV_gpu_shader5"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_gpu_shader5"))))]
    pub fn glProgramUniform3ui64vNV_is_loaded() -> bool {
        !glProgramUniform3ui64vNV_p.load(RELAX).is_null()
    }

    /// [glProgramUniform3uiEXT](http://docs.gl/es3/glProgramUniform3uiEXT)(program, location, v0, v1, v2)
    /// `program` class: program
    /// alias of: [`glProgramUniform3ui`]
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    #[cfg(any(feature = "GL_EXT_separate_shader_objects"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_separate_shader_objects"))))]
    pub unsafe fn glProgramUniform3uiEXT(
        program: GLuint,
        location: GLint,
        v0: GLuint,
        v1: GLuint,
        v2: GLuint,
    ) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glProgramUniform3uiEXT({:?}, {:?}, {:?}, {:?}, {:?});",
                program,
                location,
                v0,
                v1,
                v2
            );
        }
        let out = call_atomic_ptr_5arg(
            "glProgramUniform3uiEXT",
            &glProgramUniform3uiEXT_p,
            program,
            location,
            v0,
            v1,
            v2,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glProgramUniform3uiEXT");
        }
        out
    }
    #[cfg(any(feature = "GL_EXT_separate_shader_objects"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_separate_shader_objects"))))]
    static glProgramUniform3uiEXT_p: APcv = ap_None();
    /// Tries to load [`glProgramUniform3uiEXT`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    #[cfg(any(feature = "GL_EXT_separate_shader_objects"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_separate_shader_objects"))))]
    pub unsafe fn glProgramUniform3uiEXT_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glProgramUniform3uiEXT\0",
            &glProgramUniform3uiEXT_p,
        )
    }
    /// Checks if the pointer for [`glProgramUniform3uiEXT`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    #[cfg(any(feature = "GL_EXT_separate_shader_objects"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_separate_shader_objects"))))]
    pub fn glProgramUniform3uiEXT_is_loaded() -> bool {
        !glProgramUniform3uiEXT_p.load(RELAX).is_null()
    }

    /// [glProgramUniform3uiv](http://docs.gl/es3/glProgramUniform)(program, location, count, value)
    /// `program` class: program
    /// `value` len: count*3
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn glProgramUniform3uiv(
        program: GLuint,
        location: GLint,
        count: GLsizei,
        value: *const GLuint,
    ) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glProgramUniform3uiv({:?}, {:?}, {:?}, {:p});",
                program,
                location,
                count,
                value
            );
        }
        let out = call_atomic_ptr_4arg(
            "glProgramUniform3uiv",
            &glProgramUniform3uiv_p,
            program,
            location,
            count,
            value,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glProgramUniform3uiv");
        }
        out
    }
    static glProgramUniform3uiv_p: APcv = ap_None();
    /// Tries to load [`glProgramUniform3uiv`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    pub unsafe fn glProgramUniform3uiv_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glProgramUniform3uiv\0",
            &glProgramUniform3uiv_p,
        )
    }
    /// Checks if the pointer for [`glProgramUniform3uiv`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    pub fn glProgramUniform3uiv_is_loaded() -> bool {
        !glProgramUniform3uiv_p.load(RELAX).is_null()
    }

    /// [glProgramUniform3uivEXT](http://docs.gl/es3/glProgramUniform3uivEXT)(program, location, count, value)
    /// `program` class: program
    /// `value` len: count*3
    /// alias of: [`glProgramUniform3uiv`]
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    #[cfg(any(feature = "GL_EXT_separate_shader_objects"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_separate_shader_objects"))))]
    pub unsafe fn glProgramUniform3uivEXT(
        program: GLuint,
        location: GLint,
        count: GLsizei,
        value: *const GLuint,
    ) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glProgramUniform3uivEXT({:?}, {:?}, {:?}, {:p});",
                program,
                location,
                count,
                value
            );
        }
        let out = call_atomic_ptr_4arg(
            "glProgramUniform3uivEXT",
            &glProgramUniform3uivEXT_p,
            program,
            location,
            count,
            value,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glProgramUniform3uivEXT");
        }
        out
    }
    #[cfg(any(feature = "GL_EXT_separate_shader_objects"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_separate_shader_objects"))))]
    static glProgramUniform3uivEXT_p: APcv = ap_None();
    /// Tries to load [`glProgramUniform3uivEXT`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    #[cfg(any(feature = "GL_EXT_separate_shader_objects"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_separate_shader_objects"))))]
    pub unsafe fn glProgramUniform3uivEXT_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glProgramUniform3uivEXT\0",
            &glProgramUniform3uivEXT_p,
        )
    }
    /// Checks if the pointer for [`glProgramUniform3uivEXT`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    #[cfg(any(feature = "GL_EXT_separate_shader_objects"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_separate_shader_objects"))))]
    pub fn glProgramUniform3uivEXT_is_loaded() -> bool {
        !glProgramUniform3uivEXT_p.load(RELAX).is_null()
    }

    /// [glProgramUniform4f](http://docs.gl/es3/glProgramUniform)(program, location, v0, v1, v2, v3)
    /// `program` class: program
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn glProgramUniform4f(
        program: GLuint,
        location: GLint,
        v0: GLfloat,
        v1: GLfloat,
        v2: GLfloat,
        v3: GLfloat,
    ) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glProgramUniform4f({:?}, {:?}, {:?}, {:?}, {:?}, {:?});",
                program,
                location,
                v0,
                v1,
                v2,
                v3
            );
        }
        let out = call_atomic_ptr_6arg(
            "glProgramUniform4f",
            &glProgramUniform4f_p,
            program,
            location,
            v0,
            v1,
            v2,
            v3,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glProgramUniform4f");
        }
        out
    }
    static glProgramUniform4f_p: APcv = ap_None();
    /// Tries to load [`glProgramUniform4f`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    pub unsafe fn glProgramUniform4f_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glProgramUniform4f\0",
            &glProgramUniform4f_p,
        )
    }
    /// Checks if the pointer for [`glProgramUniform4f`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    pub fn glProgramUniform4f_is_loaded() -> bool {
        !glProgramUniform4f_p.load(RELAX).is_null()
    }

    /// [glProgramUniform4fEXT](http://docs.gl/es3/glProgramUniform4fEXT)(program, location, v0, v1, v2, v3)
    /// `program` class: program
    /// alias of: [`glProgramUniform4f`]
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    #[cfg(any(feature = "GL_EXT_separate_shader_objects"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_separate_shader_objects"))))]
    pub unsafe fn glProgramUniform4fEXT(
        program: GLuint,
        location: GLint,
        v0: GLfloat,
        v1: GLfloat,
        v2: GLfloat,
        v3: GLfloat,
    ) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glProgramUniform4fEXT({:?}, {:?}, {:?}, {:?}, {:?}, {:?});",
                program,
                location,
                v0,
                v1,
                v2,
                v3
            );
        }
        let out = call_atomic_ptr_6arg(
            "glProgramUniform4fEXT",
            &glProgramUniform4fEXT_p,
            program,
            location,
            v0,
            v1,
            v2,
            v3,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glProgramUniform4fEXT");
        }
        out
    }
    #[cfg(any(feature = "GL_EXT_separate_shader_objects"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_separate_shader_objects"))))]
    static glProgramUniform4fEXT_p: APcv = ap_None();
    /// Tries to load [`glProgramUniform4fEXT`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    #[cfg(any(feature = "GL_EXT_separate_shader_objects"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_separate_shader_objects"))))]
    pub unsafe fn glProgramUniform4fEXT_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glProgramUniform4fEXT\0",
            &glProgramUniform4fEXT_p,
        )
    }
    /// Checks if the pointer for [`glProgramUniform4fEXT`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    #[cfg(any(feature = "GL_EXT_separate_shader_objects"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_separate_shader_objects"))))]
    pub fn glProgramUniform4fEXT_is_loaded() -> bool {
        !glProgramUniform4fEXT_p.load(RELAX).is_null()
    }

    /// [glProgramUniform4fv](http://docs.gl/es3/glProgramUniform)(program, location, count, value)
    /// `program` class: program
    /// `value` len: count*4
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn glProgramUniform4fv(
        program: GLuint,
        location: GLint,
        count: GLsizei,
        value: *const GLfloat,
    ) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glProgramUniform4fv({:?}, {:?}, {:?}, {:p});",
                program,
                location,
                count,
                value
            );
        }
        let out = call_atomic_ptr_4arg(
            "glProgramUniform4fv",
            &glProgramUniform4fv_p,
            program,
            location,
            count,
            value,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glProgramUniform4fv");
        }
        out
    }
    static glProgramUniform4fv_p: APcv = ap_None();
    /// Tries to load [`glProgramUniform4fv`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    pub unsafe fn glProgramUniform4fv_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glProgramUniform4fv\0",
            &glProgramUniform4fv_p,
        )
    }
    /// Checks if the pointer for [`glProgramUniform4fv`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    pub fn glProgramUniform4fv_is_loaded() -> bool {
        !glProgramUniform4fv_p.load(RELAX).is_null()
    }

    /// [glProgramUniform4fvEXT](http://docs.gl/es3/glProgramUniform4fvEXT)(program, location, count, value)
    /// `program` class: program
    /// `value` len: count*4
    /// alias of: [`glProgramUniform4fv`]
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    #[cfg(any(feature = "GL_EXT_separate_shader_objects"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_separate_shader_objects"))))]
    pub unsafe fn glProgramUniform4fvEXT(
        program: GLuint,
        location: GLint,
        count: GLsizei,
        value: *const GLfloat,
    ) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glProgramUniform4fvEXT({:?}, {:?}, {:?}, {:p});",
                program,
                location,
                count,
                value
            );
        }
        let out = call_atomic_ptr_4arg(
            "glProgramUniform4fvEXT",
            &glProgramUniform4fvEXT_p,
            program,
            location,
            count,
            value,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glProgramUniform4fvEXT");
        }
        out
    }
    #[cfg(any(feature = "GL_EXT_separate_shader_objects"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_separate_shader_objects"))))]
    static glProgramUniform4fvEXT_p: APcv = ap_None();
    /// Tries to load [`glProgramUniform4fvEXT`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    #[cfg(any(feature = "GL_EXT_separate_shader_objects"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_separate_shader_objects"))))]
    pub unsafe fn glProgramUniform4fvEXT_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glProgramUniform4fvEXT\0",
            &glProgramUniform4fvEXT_p,
        )
    }
    /// Checks if the pointer for [`glProgramUniform4fvEXT`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    #[cfg(any(feature = "GL_EXT_separate_shader_objects"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_separate_shader_objects"))))]
    pub fn glProgramUniform4fvEXT_is_loaded() -> bool {
        !glProgramUniform4fvEXT_p.load(RELAX).is_null()
    }

    /// [glProgramUniform4i](http://docs.gl/es3/glProgramUniform)(program, location, v0, v1, v2, v3)
    /// `program` class: program
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn glProgramUniform4i(
        program: GLuint,
        location: GLint,
        v0: GLint,
        v1: GLint,
        v2: GLint,
        v3: GLint,
    ) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glProgramUniform4i({:?}, {:?}, {:?}, {:?}, {:?}, {:?});",
                program,
                location,
                v0,
                v1,
                v2,
                v3
            );
        }
        let out = call_atomic_ptr_6arg(
            "glProgramUniform4i",
            &glProgramUniform4i_p,
            program,
            location,
            v0,
            v1,
            v2,
            v3,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glProgramUniform4i");
        }
        out
    }
    static glProgramUniform4i_p: APcv = ap_None();
    /// Tries to load [`glProgramUniform4i`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    pub unsafe fn glProgramUniform4i_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glProgramUniform4i\0",
            &glProgramUniform4i_p,
        )
    }
    /// Checks if the pointer for [`glProgramUniform4i`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    pub fn glProgramUniform4i_is_loaded() -> bool {
        !glProgramUniform4i_p.load(RELAX).is_null()
    }

    /// [glProgramUniform4i64NV](http://docs.gl/es3/glProgramUniform4i64NV)(program, location, x, y, z, w)
    /// `program` class: program
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    #[cfg(any(feature = "GL_NV_gpu_shader5"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_gpu_shader5"))))]
    pub unsafe fn glProgramUniform4i64NV(
        program: GLuint,
        location: GLint,
        x: GLint64EXT,
        y: GLint64EXT,
        z: GLint64EXT,
        w: GLint64EXT,
    ) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glProgramUniform4i64NV({:?}, {:?}, {:?}, {:?}, {:?}, {:?});",
                program,
                location,
                x,
                y,
                z,
                w
            );
        }
        let out = call_atomic_ptr_6arg(
            "glProgramUniform4i64NV",
            &glProgramUniform4i64NV_p,
            program,
            location,
            x,
            y,
            z,
            w,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glProgramUniform4i64NV");
        }
        out
    }
    #[cfg(any(feature = "GL_NV_gpu_shader5"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_gpu_shader5"))))]
    static glProgramUniform4i64NV_p: APcv = ap_None();
    /// Tries to load [`glProgramUniform4i64NV`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    #[cfg(any(feature = "GL_NV_gpu_shader5"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_gpu_shader5"))))]
    pub unsafe fn glProgramUniform4i64NV_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glProgramUniform4i64NV\0",
            &glProgramUniform4i64NV_p,
        )
    }
    /// Checks if the pointer for [`glProgramUniform4i64NV`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    #[cfg(any(feature = "GL_NV_gpu_shader5"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_gpu_shader5"))))]
    pub fn glProgramUniform4i64NV_is_loaded() -> bool {
        !glProgramUniform4i64NV_p.load(RELAX).is_null()
    }

    /// [glProgramUniform4i64vNV](http://docs.gl/es3/glProgramUniform4i64vNV)(program, location, count, value)
    /// `program` class: program
    /// `value` len: count*4
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    #[cfg(any(feature = "GL_NV_gpu_shader5"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_gpu_shader5"))))]
    pub unsafe fn glProgramUniform4i64vNV(
        program: GLuint,
        location: GLint,
        count: GLsizei,
        value: *const GLint64EXT,
    ) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glProgramUniform4i64vNV({:?}, {:?}, {:?}, {:p});",
                program,
                location,
                count,
                value
            );
        }
        let out = call_atomic_ptr_4arg(
            "glProgramUniform4i64vNV",
            &glProgramUniform4i64vNV_p,
            program,
            location,
            count,
            value,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glProgramUniform4i64vNV");
        }
        out
    }
    #[cfg(any(feature = "GL_NV_gpu_shader5"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_gpu_shader5"))))]
    static glProgramUniform4i64vNV_p: APcv = ap_None();
    /// Tries to load [`glProgramUniform4i64vNV`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    #[cfg(any(feature = "GL_NV_gpu_shader5"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_gpu_shader5"))))]
    pub unsafe fn glProgramUniform4i64vNV_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glProgramUniform4i64vNV\0",
            &glProgramUniform4i64vNV_p,
        )
    }
    /// Checks if the pointer for [`glProgramUniform4i64vNV`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    #[cfg(any(feature = "GL_NV_gpu_shader5"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_gpu_shader5"))))]
    pub fn glProgramUniform4i64vNV_is_loaded() -> bool {
        !glProgramUniform4i64vNV_p.load(RELAX).is_null()
    }

    /// [glProgramUniform4iEXT](http://docs.gl/es3/glProgramUniform4iEXT)(program, location, v0, v1, v2, v3)
    /// `program` class: program
    /// alias of: [`glProgramUniform4i`]
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    #[cfg(any(feature = "GL_EXT_separate_shader_objects"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_separate_shader_objects"))))]
    pub unsafe fn glProgramUniform4iEXT(
        program: GLuint,
        location: GLint,
        v0: GLint,
        v1: GLint,
        v2: GLint,
        v3: GLint,
    ) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glProgramUniform4iEXT({:?}, {:?}, {:?}, {:?}, {:?}, {:?});",
                program,
                location,
                v0,
                v1,
                v2,
                v3
            );
        }
        let out = call_atomic_ptr_6arg(
            "glProgramUniform4iEXT",
            &glProgramUniform4iEXT_p,
            program,
            location,
            v0,
            v1,
            v2,
            v3,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glProgramUniform4iEXT");
        }
        out
    }
    #[cfg(any(feature = "GL_EXT_separate_shader_objects"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_separate_shader_objects"))))]
    static glProgramUniform4iEXT_p: APcv = ap_None();
    /// Tries to load [`glProgramUniform4iEXT`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    #[cfg(any(feature = "GL_EXT_separate_shader_objects"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_separate_shader_objects"))))]
    pub unsafe fn glProgramUniform4iEXT_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glProgramUniform4iEXT\0",
            &glProgramUniform4iEXT_p,
        )
    }
    /// Checks if the pointer for [`glProgramUniform4iEXT`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    #[cfg(any(feature = "GL_EXT_separate_shader_objects"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_separate_shader_objects"))))]
    pub fn glProgramUniform4iEXT_is_loaded() -> bool {
        !glProgramUniform4iEXT_p.load(RELAX).is_null()
    }

    /// [glProgramUniform4iv](http://docs.gl/es3/glProgramUniform)(program, location, count, value)
    /// `program` class: program
    /// `value` len: count*4
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn glProgramUniform4iv(
        program: GLuint,
        location: GLint,
        count: GLsizei,
        value: *const GLint,
    ) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glProgramUniform4iv({:?}, {:?}, {:?}, {:p});",
                program,
                location,
                count,
                value
            );
        }
        let out = call_atomic_ptr_4arg(
            "glProgramUniform4iv",
            &glProgramUniform4iv_p,
            program,
            location,
            count,
            value,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glProgramUniform4iv");
        }
        out
    }
    static glProgramUniform4iv_p: APcv = ap_None();
    /// Tries to load [`glProgramUniform4iv`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    pub unsafe fn glProgramUniform4iv_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glProgramUniform4iv\0",
            &glProgramUniform4iv_p,
        )
    }
    /// Checks if the pointer for [`glProgramUniform4iv`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    pub fn glProgramUniform4iv_is_loaded() -> bool {
        !glProgramUniform4iv_p.load(RELAX).is_null()
    }

    /// [glProgramUniform4ivEXT](http://docs.gl/es3/glProgramUniform4ivEXT)(program, location, count, value)
    /// `program` class: program
    /// `value` len: count*4
    /// alias of: [`glProgramUniform4iv`]
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    #[cfg(any(feature = "GL_EXT_separate_shader_objects"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_separate_shader_objects"))))]
    pub unsafe fn glProgramUniform4ivEXT(
        program: GLuint,
        location: GLint,
        count: GLsizei,
        value: *const GLint,
    ) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glProgramUniform4ivEXT({:?}, {:?}, {:?}, {:p});",
                program,
                location,
                count,
                value
            );
        }
        let out = call_atomic_ptr_4arg(
            "glProgramUniform4ivEXT",
            &glProgramUniform4ivEXT_p,
            program,
            location,
            count,
            value,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glProgramUniform4ivEXT");
        }
        out
    }
    #[cfg(any(feature = "GL_EXT_separate_shader_objects"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_separate_shader_objects"))))]
    static glProgramUniform4ivEXT_p: APcv = ap_None();
    /// Tries to load [`glProgramUniform4ivEXT`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    #[cfg(any(feature = "GL_EXT_separate_shader_objects"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_separate_shader_objects"))))]
    pub unsafe fn glProgramUniform4ivEXT_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glProgramUniform4ivEXT\0",
            &glProgramUniform4ivEXT_p,
        )
    }
    /// Checks if the pointer for [`glProgramUniform4ivEXT`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    #[cfg(any(feature = "GL_EXT_separate_shader_objects"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_separate_shader_objects"))))]
    pub fn glProgramUniform4ivEXT_is_loaded() -> bool {
        !glProgramUniform4ivEXT_p.load(RELAX).is_null()
    }

    /// [glProgramUniform4ui](http://docs.gl/es3/glProgramUniform)(program, location, v0, v1, v2, v3)
    /// `program` class: program
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn glProgramUniform4ui(
        program: GLuint,
        location: GLint,
        v0: GLuint,
        v1: GLuint,
        v2: GLuint,
        v3: GLuint,
    ) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glProgramUniform4ui({:?}, {:?}, {:?}, {:?}, {:?}, {:?});",
                program,
                location,
                v0,
                v1,
                v2,
                v3
            );
        }
        let out = call_atomic_ptr_6arg(
            "glProgramUniform4ui",
            &glProgramUniform4ui_p,
            program,
            location,
            v0,
            v1,
            v2,
            v3,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glProgramUniform4ui");
        }
        out
    }
    static glProgramUniform4ui_p: APcv = ap_None();
    /// Tries to load [`glProgramUniform4ui`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    pub unsafe fn glProgramUniform4ui_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glProgramUniform4ui\0",
            &glProgramUniform4ui_p,
        )
    }
    /// Checks if the pointer for [`glProgramUniform4ui`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    pub fn glProgramUniform4ui_is_loaded() -> bool {
        !glProgramUniform4ui_p.load(RELAX).is_null()
    }

    /// [glProgramUniform4ui64NV](http://docs.gl/es3/glProgramUniform4ui64NV)(program, location, x, y, z, w)
    /// `program` class: program
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    #[cfg(any(feature = "GL_NV_gpu_shader5"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_gpu_shader5"))))]
    pub unsafe fn glProgramUniform4ui64NV(
        program: GLuint,
        location: GLint,
        x: GLuint64EXT,
        y: GLuint64EXT,
        z: GLuint64EXT,
        w: GLuint64EXT,
    ) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glProgramUniform4ui64NV({:?}, {:?}, {:?}, {:?}, {:?}, {:?});",
                program,
                location,
                x,
                y,
                z,
                w
            );
        }
        let out = call_atomic_ptr_6arg(
            "glProgramUniform4ui64NV",
            &glProgramUniform4ui64NV_p,
            program,
            location,
            x,
            y,
            z,
            w,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glProgramUniform4ui64NV");
        }
        out
    }
    #[cfg(any(feature = "GL_NV_gpu_shader5"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_gpu_shader5"))))]
    static glProgramUniform4ui64NV_p: APcv = ap_None();
    /// Tries to load [`glProgramUniform4ui64NV`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    #[cfg(any(feature = "GL_NV_gpu_shader5"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_gpu_shader5"))))]
    pub unsafe fn glProgramUniform4ui64NV_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glProgramUniform4ui64NV\0",
            &glProgramUniform4ui64NV_p,
        )
    }
    /// Checks if the pointer for [`glProgramUniform4ui64NV`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    #[cfg(any(feature = "GL_NV_gpu_shader5"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_gpu_shader5"))))]
    pub fn glProgramUniform4ui64NV_is_loaded() -> bool {
        !glProgramUniform4ui64NV_p.load(RELAX).is_null()
    }

    /// [glProgramUniform4ui64vNV](http://docs.gl/es3/glProgramUniform4ui64vNV)(program, location, count, value)
    /// `program` class: program
    /// `value` len: count*4
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    #[cfg(any(feature = "GL_NV_gpu_shader5"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_gpu_shader5"))))]
    pub unsafe fn glProgramUniform4ui64vNV(
        program: GLuint,
        location: GLint,
        count: GLsizei,
        value: *const GLuint64EXT,
    ) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glProgramUniform4ui64vNV({:?}, {:?}, {:?}, {:p});",
                program,
                location,
                count,
                value
            );
        }
        let out = call_atomic_ptr_4arg(
            "glProgramUniform4ui64vNV",
            &glProgramUniform4ui64vNV_p,
            program,
            location,
            count,
            value,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glProgramUniform4ui64vNV");
        }
        out
    }
    #[cfg(any(feature = "GL_NV_gpu_shader5"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_gpu_shader5"))))]
    static glProgramUniform4ui64vNV_p: APcv = ap_None();
    /// Tries to load [`glProgramUniform4ui64vNV`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    #[cfg(any(feature = "GL_NV_gpu_shader5"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_gpu_shader5"))))]
    pub unsafe fn glProgramUniform4ui64vNV_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glProgramUniform4ui64vNV\0",
            &glProgramUniform4ui64vNV_p,
        )
    }
    /// Checks if the pointer for [`glProgramUniform4ui64vNV`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    #[cfg(any(feature = "GL_NV_gpu_shader5"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_gpu_shader5"))))]
    pub fn glProgramUniform4ui64vNV_is_loaded() -> bool {
        !glProgramUniform4ui64vNV_p.load(RELAX).is_null()
    }

    /// [glProgramUniform4uiEXT](http://docs.gl/es3/glProgramUniform4uiEXT)(program, location, v0, v1, v2, v3)
    /// `program` class: program
    /// alias of: [`glProgramUniform4ui`]
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    #[cfg(any(feature = "GL_EXT_separate_shader_objects"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_separate_shader_objects"))))]
    pub unsafe fn glProgramUniform4uiEXT(
        program: GLuint,
        location: GLint,
        v0: GLuint,
        v1: GLuint,
        v2: GLuint,
        v3: GLuint,
    ) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glProgramUniform4uiEXT({:?}, {:?}, {:?}, {:?}, {:?}, {:?});",
                program,
                location,
                v0,
                v1,
                v2,
                v3
            );
        }
        let out = call_atomic_ptr_6arg(
            "glProgramUniform4uiEXT",
            &glProgramUniform4uiEXT_p,
            program,
            location,
            v0,
            v1,
            v2,
            v3,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glProgramUniform4uiEXT");
        }
        out
    }
    #[cfg(any(feature = "GL_EXT_separate_shader_objects"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_separate_shader_objects"))))]
    static glProgramUniform4uiEXT_p: APcv = ap_None();
    /// Tries to load [`glProgramUniform4uiEXT`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    #[cfg(any(feature = "GL_EXT_separate_shader_objects"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_separate_shader_objects"))))]
    pub unsafe fn glProgramUniform4uiEXT_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glProgramUniform4uiEXT\0",
            &glProgramUniform4uiEXT_p,
        )
    }
    /// Checks if the pointer for [`glProgramUniform4uiEXT`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    #[cfg(any(feature = "GL_EXT_separate_shader_objects"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_separate_shader_objects"))))]
    pub fn glProgramUniform4uiEXT_is_loaded() -> bool {
        !glProgramUniform4uiEXT_p.load(RELAX).is_null()
    }

    /// [glProgramUniform4uiv](http://docs.gl/es3/glProgramUniform)(program, location, count, value)
    /// `program` class: program
    /// `value` len: count*4
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn glProgramUniform4uiv(
        program: GLuint,
        location: GLint,
        count: GLsizei,
        value: *const GLuint,
    ) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glProgramUniform4uiv({:?}, {:?}, {:?}, {:p});",
                program,
                location,
                count,
                value
            );
        }
        let out = call_atomic_ptr_4arg(
            "glProgramUniform4uiv",
            &glProgramUniform4uiv_p,
            program,
            location,
            count,
            value,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glProgramUniform4uiv");
        }
        out
    }
    static glProgramUniform4uiv_p: APcv = ap_None();
    /// Tries to load [`glProgramUniform4uiv`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    pub unsafe fn glProgramUniform4uiv_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glProgramUniform4uiv\0",
            &glProgramUniform4uiv_p,
        )
    }
    /// Checks if the pointer for [`glProgramUniform4uiv`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    pub fn glProgramUniform4uiv_is_loaded() -> bool {
        !glProgramUniform4uiv_p.load(RELAX).is_null()
    }

    /// [glProgramUniform4uivEXT](http://docs.gl/es3/glProgramUniform4uivEXT)(program, location, count, value)
    /// `program` class: program
    /// `value` len: count*4
    /// alias of: [`glProgramUniform4uiv`]
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    #[cfg(any(feature = "GL_EXT_separate_shader_objects"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_separate_shader_objects"))))]
    pub unsafe fn glProgramUniform4uivEXT(
        program: GLuint,
        location: GLint,
        count: GLsizei,
        value: *const GLuint,
    ) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glProgramUniform4uivEXT({:?}, {:?}, {:?}, {:p});",
                program,
                location,
                count,
                value
            );
        }
        let out = call_atomic_ptr_4arg(
            "glProgramUniform4uivEXT",
            &glProgramUniform4uivEXT_p,
            program,
            location,
            count,
            value,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glProgramUniform4uivEXT");
        }
        out
    }
    #[cfg(any(feature = "GL_EXT_separate_shader_objects"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_separate_shader_objects"))))]
    static glProgramUniform4uivEXT_p: APcv = ap_None();
    /// Tries to load [`glProgramUniform4uivEXT`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    #[cfg(any(feature = "GL_EXT_separate_shader_objects"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_separate_shader_objects"))))]
    pub unsafe fn glProgramUniform4uivEXT_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glProgramUniform4uivEXT\0",
            &glProgramUniform4uivEXT_p,
        )
    }
    /// Checks if the pointer for [`glProgramUniform4uivEXT`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    #[cfg(any(feature = "GL_EXT_separate_shader_objects"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_separate_shader_objects"))))]
    pub fn glProgramUniform4uivEXT_is_loaded() -> bool {
        !glProgramUniform4uivEXT_p.load(RELAX).is_null()
    }

    /// [glProgramUniformHandleui64IMG](http://docs.gl/es3/glProgramUniformHandleui64IMG)(program, location, value)
    /// `program` class: program
    /// alias of: [`glProgramUniformHandleui64ARB`]
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    #[cfg(any(feature = "GL_IMG_bindless_texture"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_IMG_bindless_texture"))))]
    pub unsafe fn glProgramUniformHandleui64IMG(program: GLuint, location: GLint, value: GLuint64) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glProgramUniformHandleui64IMG({:?}, {:?}, {:?});",
                program,
                location,
                value
            );
        }
        let out = call_atomic_ptr_3arg(
            "glProgramUniformHandleui64IMG",
            &glProgramUniformHandleui64IMG_p,
            program,
            location,
            value,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glProgramUniformHandleui64IMG");
        }
        out
    }
    #[cfg(any(feature = "GL_IMG_bindless_texture"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_IMG_bindless_texture"))))]
    static glProgramUniformHandleui64IMG_p: APcv = ap_None();
    /// Tries to load [`glProgramUniformHandleui64IMG`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    #[cfg(any(feature = "GL_IMG_bindless_texture"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_IMG_bindless_texture"))))]
    pub unsafe fn glProgramUniformHandleui64IMG_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glProgramUniformHandleui64IMG\0",
            &glProgramUniformHandleui64IMG_p,
        )
    }
    /// Checks if the pointer for [`glProgramUniformHandleui64IMG`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    #[cfg(any(feature = "GL_IMG_bindless_texture"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_IMG_bindless_texture"))))]
    pub fn glProgramUniformHandleui64IMG_is_loaded() -> bool {
        !glProgramUniformHandleui64IMG_p.load(RELAX).is_null()
    }

    /// [glProgramUniformHandleui64NV](http://docs.gl/es3/glProgramUniformHandleui64NV)(program, location, value)
    /// `program` class: program
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    #[cfg(any(feature = "GL_NV_bindless_texture"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_bindless_texture"))))]
    pub unsafe fn glProgramUniformHandleui64NV(program: GLuint, location: GLint, value: GLuint64) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glProgramUniformHandleui64NV({:?}, {:?}, {:?});",
                program,
                location,
                value
            );
        }
        let out = call_atomic_ptr_3arg(
            "glProgramUniformHandleui64NV",
            &glProgramUniformHandleui64NV_p,
            program,
            location,
            value,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glProgramUniformHandleui64NV");
        }
        out
    }
    #[cfg(any(feature = "GL_NV_bindless_texture"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_bindless_texture"))))]
    static glProgramUniformHandleui64NV_p: APcv = ap_None();
    /// Tries to load [`glProgramUniformHandleui64NV`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    #[cfg(any(feature = "GL_NV_bindless_texture"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_bindless_texture"))))]
    pub unsafe fn glProgramUniformHandleui64NV_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glProgramUniformHandleui64NV\0",
            &glProgramUniformHandleui64NV_p,
        )
    }
    /// Checks if the pointer for [`glProgramUniformHandleui64NV`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    #[cfg(any(feature = "GL_NV_bindless_texture"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_bindless_texture"))))]
    pub fn glProgramUniformHandleui64NV_is_loaded() -> bool {
        !glProgramUniformHandleui64NV_p.load(RELAX).is_null()
    }

    /// [glProgramUniformHandleui64vIMG](http://docs.gl/es3/glProgramUniformHandleui64vIMG)(program, location, count, values)
    /// `program` class: program
    /// `values` len: count
    /// alias of: [`glProgramUniformHandleui64vARB`]
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    #[cfg(any(feature = "GL_IMG_bindless_texture"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_IMG_bindless_texture"))))]
    pub unsafe fn glProgramUniformHandleui64vIMG(
        program: GLuint,
        location: GLint,
        count: GLsizei,
        values: *const GLuint64,
    ) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glProgramUniformHandleui64vIMG({:?}, {:?}, {:?}, {:p});",
                program,
                location,
                count,
                values
            );
        }
        let out = call_atomic_ptr_4arg(
            "glProgramUniformHandleui64vIMG",
            &glProgramUniformHandleui64vIMG_p,
            program,
            location,
            count,
            values,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glProgramUniformHandleui64vIMG");
        }
        out
    }
    #[cfg(any(feature = "GL_IMG_bindless_texture"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_IMG_bindless_texture"))))]
    static glProgramUniformHandleui64vIMG_p: APcv = ap_None();
    /// Tries to load [`glProgramUniformHandleui64vIMG`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    #[cfg(any(feature = "GL_IMG_bindless_texture"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_IMG_bindless_texture"))))]
    pub unsafe fn glProgramUniformHandleui64vIMG_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glProgramUniformHandleui64vIMG\0",
            &glProgramUniformHandleui64vIMG_p,
        )
    }
    /// Checks if the pointer for [`glProgramUniformHandleui64vIMG`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    #[cfg(any(feature = "GL_IMG_bindless_texture"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_IMG_bindless_texture"))))]
    pub fn glProgramUniformHandleui64vIMG_is_loaded() -> bool {
        !glProgramUniformHandleui64vIMG_p.load(RELAX).is_null()
    }

    /// [glProgramUniformHandleui64vNV](http://docs.gl/es3/glProgramUniformHandleui64vNV)(program, location, count, values)
    /// `program` class: program
    /// `values` len: count
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    #[cfg(any(feature = "GL_NV_bindless_texture"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_bindless_texture"))))]
    pub unsafe fn glProgramUniformHandleui64vNV(
        program: GLuint,
        location: GLint,
        count: GLsizei,
        values: *const GLuint64,
    ) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glProgramUniformHandleui64vNV({:?}, {:?}, {:?}, {:p});",
                program,
                location,
                count,
                values
            );
        }
        let out = call_atomic_ptr_4arg(
            "glProgramUniformHandleui64vNV",
            &glProgramUniformHandleui64vNV_p,
            program,
            location,
            count,
            values,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glProgramUniformHandleui64vNV");
        }
        out
    }
    #[cfg(any(feature = "GL_NV_bindless_texture"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_bindless_texture"))))]
    static glProgramUniformHandleui64vNV_p: APcv = ap_None();
    /// Tries to load [`glProgramUniformHandleui64vNV`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    #[cfg(any(feature = "GL_NV_bindless_texture"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_bindless_texture"))))]
    pub unsafe fn glProgramUniformHandleui64vNV_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glProgramUniformHandleui64vNV\0",
            &glProgramUniformHandleui64vNV_p,
        )
    }
    /// Checks if the pointer for [`glProgramUniformHandleui64vNV`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    #[cfg(any(feature = "GL_NV_bindless_texture"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_bindless_texture"))))]
    pub fn glProgramUniformHandleui64vNV_is_loaded() -> bool {
        !glProgramUniformHandleui64vNV_p.load(RELAX).is_null()
    }

    /// [glProgramUniformMatrix2fv](http://docs.gl/es3/glProgramUniform)(program, location, count, transpose, value)
    /// `program` class: program
    /// `value` len: count*4
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn glProgramUniformMatrix2fv(
        program: GLuint,
        location: GLint,
        count: GLsizei,
        transpose: GLboolean,
        value: *const GLfloat,
    ) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glProgramUniformMatrix2fv({:?}, {:?}, {:?}, {:?}, {:p});",
                program,
                location,
                count,
                transpose,
                value
            );
        }
        let out = call_atomic_ptr_5arg(
            "glProgramUniformMatrix2fv",
            &glProgramUniformMatrix2fv_p,
            program,
            location,
            count,
            transpose,
            value,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glProgramUniformMatrix2fv");
        }
        out
    }
    static glProgramUniformMatrix2fv_p: APcv = ap_None();
    /// Tries to load [`glProgramUniformMatrix2fv`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    pub unsafe fn glProgramUniformMatrix2fv_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glProgramUniformMatrix2fv\0",
            &glProgramUniformMatrix2fv_p,
        )
    }
    /// Checks if the pointer for [`glProgramUniformMatrix2fv`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    pub fn glProgramUniformMatrix2fv_is_loaded() -> bool {
        !glProgramUniformMatrix2fv_p.load(RELAX).is_null()
    }

    /// [glProgramUniformMatrix2fvEXT](http://docs.gl/es3/glProgramUniformMatrix2fvEXT)(program, location, count, transpose, value)
    /// `program` class: program
    /// `value` len: count*4
    /// alias of: [`glProgramUniformMatrix2fv`]
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    #[cfg(any(feature = "GL_EXT_separate_shader_objects"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_separate_shader_objects"))))]
    pub unsafe fn glProgramUniformMatrix2fvEXT(
        program: GLuint,
        location: GLint,
        count: GLsizei,
        transpose: GLboolean,
        value: *const GLfloat,
    ) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glProgramUniformMatrix2fvEXT({:?}, {:?}, {:?}, {:?}, {:p});",
                program,
                location,
                count,
                transpose,
                value
            );
        }
        let out = call_atomic_ptr_5arg(
            "glProgramUniformMatrix2fvEXT",
            &glProgramUniformMatrix2fvEXT_p,
            program,
            location,
            count,
            transpose,
            value,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glProgramUniformMatrix2fvEXT");
        }
        out
    }
    #[cfg(any(feature = "GL_EXT_separate_shader_objects"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_separate_shader_objects"))))]
    static glProgramUniformMatrix2fvEXT_p: APcv = ap_None();
    /// Tries to load [`glProgramUniformMatrix2fvEXT`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    #[cfg(any(feature = "GL_EXT_separate_shader_objects"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_separate_shader_objects"))))]
    pub unsafe fn glProgramUniformMatrix2fvEXT_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glProgramUniformMatrix2fvEXT\0",
            &glProgramUniformMatrix2fvEXT_p,
        )
    }
    /// Checks if the pointer for [`glProgramUniformMatrix2fvEXT`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    #[cfg(any(feature = "GL_EXT_separate_shader_objects"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_separate_shader_objects"))))]
    pub fn glProgramUniformMatrix2fvEXT_is_loaded() -> bool {
        !glProgramUniformMatrix2fvEXT_p.load(RELAX).is_null()
    }

    /// [glProgramUniformMatrix2x3fv](http://docs.gl/es3/glProgramUniform)(program, location, count, transpose, value)
    /// `program` class: program
    /// `value` len: count*6
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn glProgramUniformMatrix2x3fv(
        program: GLuint,
        location: GLint,
        count: GLsizei,
        transpose: GLboolean,
        value: *const GLfloat,
    ) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glProgramUniformMatrix2x3fv({:?}, {:?}, {:?}, {:?}, {:p});",
                program,
                location,
                count,
                transpose,
                value
            );
        }
        let out = call_atomic_ptr_5arg(
            "glProgramUniformMatrix2x3fv",
            &glProgramUniformMatrix2x3fv_p,
            program,
            location,
            count,
            transpose,
            value,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glProgramUniformMatrix2x3fv");
        }
        out
    }
    static glProgramUniformMatrix2x3fv_p: APcv = ap_None();
    /// Tries to load [`glProgramUniformMatrix2x3fv`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    pub unsafe fn glProgramUniformMatrix2x3fv_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glProgramUniformMatrix2x3fv\0",
            &glProgramUniformMatrix2x3fv_p,
        )
    }
    /// Checks if the pointer for [`glProgramUniformMatrix2x3fv`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    pub fn glProgramUniformMatrix2x3fv_is_loaded() -> bool {
        !glProgramUniformMatrix2x3fv_p.load(RELAX).is_null()
    }

    /// [glProgramUniformMatrix2x3fvEXT](http://docs.gl/es3/glProgramUniformMatrix2x3fvEXT)(program, location, count, transpose, value)
    /// `program` class: program
    /// `value` len: count*6
    /// alias of: [`glProgramUniformMatrix2x3fv`]
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    #[cfg(any(feature = "GL_EXT_separate_shader_objects"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_separate_shader_objects"))))]
    pub unsafe fn glProgramUniformMatrix2x3fvEXT(
        program: GLuint,
        location: GLint,
        count: GLsizei,
        transpose: GLboolean,
        value: *const GLfloat,
    ) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glProgramUniformMatrix2x3fvEXT({:?}, {:?}, {:?}, {:?}, {:p});",
                program,
                location,
                count,
                transpose,
                value
            );
        }
        let out = call_atomic_ptr_5arg(
            "glProgramUniformMatrix2x3fvEXT",
            &glProgramUniformMatrix2x3fvEXT_p,
            program,
            location,
            count,
            transpose,
            value,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glProgramUniformMatrix2x3fvEXT");
        }
        out
    }
    #[cfg(any(feature = "GL_EXT_separate_shader_objects"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_separate_shader_objects"))))]
    static glProgramUniformMatrix2x3fvEXT_p: APcv = ap_None();
    /// Tries to load [`glProgramUniformMatrix2x3fvEXT`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    #[cfg(any(feature = "GL_EXT_separate_shader_objects"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_separate_shader_objects"))))]
    pub unsafe fn glProgramUniformMatrix2x3fvEXT_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glProgramUniformMatrix2x3fvEXT\0",
            &glProgramUniformMatrix2x3fvEXT_p,
        )
    }
    /// Checks if the pointer for [`glProgramUniformMatrix2x3fvEXT`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    #[cfg(any(feature = "GL_EXT_separate_shader_objects"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_separate_shader_objects"))))]
    pub fn glProgramUniformMatrix2x3fvEXT_is_loaded() -> bool {
        !glProgramUniformMatrix2x3fvEXT_p.load(RELAX).is_null()
    }

    /// [glProgramUniformMatrix2x4fv](http://docs.gl/es3/glProgramUniform)(program, location, count, transpose, value)
    /// `program` class: program
    /// `value` len: count*8
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn glProgramUniformMatrix2x4fv(
        program: GLuint,
        location: GLint,
        count: GLsizei,
        transpose: GLboolean,
        value: *const GLfloat,
    ) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glProgramUniformMatrix2x4fv({:?}, {:?}, {:?}, {:?}, {:p});",
                program,
                location,
                count,
                transpose,
                value
            );
        }
        let out = call_atomic_ptr_5arg(
            "glProgramUniformMatrix2x4fv",
            &glProgramUniformMatrix2x4fv_p,
            program,
            location,
            count,
            transpose,
            value,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glProgramUniformMatrix2x4fv");
        }
        out
    }
    static glProgramUniformMatrix2x4fv_p: APcv = ap_None();
    /// Tries to load [`glProgramUniformMatrix2x4fv`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    pub unsafe fn glProgramUniformMatrix2x4fv_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glProgramUniformMatrix2x4fv\0",
            &glProgramUniformMatrix2x4fv_p,
        )
    }
    /// Checks if the pointer for [`glProgramUniformMatrix2x4fv`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    pub fn glProgramUniformMatrix2x4fv_is_loaded() -> bool {
        !glProgramUniformMatrix2x4fv_p.load(RELAX).is_null()
    }

    /// [glProgramUniformMatrix2x4fvEXT](http://docs.gl/es3/glProgramUniformMatrix2x4fvEXT)(program, location, count, transpose, value)
    /// `program` class: program
    /// `value` len: count*8
    /// alias of: [`glProgramUniformMatrix2x4fv`]
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    #[cfg(any(feature = "GL_EXT_separate_shader_objects"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_separate_shader_objects"))))]
    pub unsafe fn glProgramUniformMatrix2x4fvEXT(
        program: GLuint,
        location: GLint,
        count: GLsizei,
        transpose: GLboolean,
        value: *const GLfloat,
    ) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glProgramUniformMatrix2x4fvEXT({:?}, {:?}, {:?}, {:?}, {:p});",
                program,
                location,
                count,
                transpose,
                value
            );
        }
        let out = call_atomic_ptr_5arg(
            "glProgramUniformMatrix2x4fvEXT",
            &glProgramUniformMatrix2x4fvEXT_p,
            program,
            location,
            count,
            transpose,
            value,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glProgramUniformMatrix2x4fvEXT");
        }
        out
    }
    #[cfg(any(feature = "GL_EXT_separate_shader_objects"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_separate_shader_objects"))))]
    static glProgramUniformMatrix2x4fvEXT_p: APcv = ap_None();
    /// Tries to load [`glProgramUniformMatrix2x4fvEXT`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    #[cfg(any(feature = "GL_EXT_separate_shader_objects"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_separate_shader_objects"))))]
    pub unsafe fn glProgramUniformMatrix2x4fvEXT_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glProgramUniformMatrix2x4fvEXT\0",
            &glProgramUniformMatrix2x4fvEXT_p,
        )
    }
    /// Checks if the pointer for [`glProgramUniformMatrix2x4fvEXT`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    #[cfg(any(feature = "GL_EXT_separate_shader_objects"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_separate_shader_objects"))))]
    pub fn glProgramUniformMatrix2x4fvEXT_is_loaded() -> bool {
        !glProgramUniformMatrix2x4fvEXT_p.load(RELAX).is_null()
    }

    /// [glProgramUniformMatrix3fv](http://docs.gl/es3/glProgramUniform)(program, location, count, transpose, value)
    /// `program` class: program
    /// `value` len: count*9
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn glProgramUniformMatrix3fv(
        program: GLuint,
        location: GLint,
        count: GLsizei,
        transpose: GLboolean,
        value: *const GLfloat,
    ) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glProgramUniformMatrix3fv({:?}, {:?}, {:?}, {:?}, {:p});",
                program,
                location,
                count,
                transpose,
                value
            );
        }
        let out = call_atomic_ptr_5arg(
            "glProgramUniformMatrix3fv",
            &glProgramUniformMatrix3fv_p,
            program,
            location,
            count,
            transpose,
            value,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glProgramUniformMatrix3fv");
        }
        out
    }
    static glProgramUniformMatrix3fv_p: APcv = ap_None();
    /// Tries to load [`glProgramUniformMatrix3fv`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    pub unsafe fn glProgramUniformMatrix3fv_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glProgramUniformMatrix3fv\0",
            &glProgramUniformMatrix3fv_p,
        )
    }
    /// Checks if the pointer for [`glProgramUniformMatrix3fv`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    pub fn glProgramUniformMatrix3fv_is_loaded() -> bool {
        !glProgramUniformMatrix3fv_p.load(RELAX).is_null()
    }

    /// [glProgramUniformMatrix3fvEXT](http://docs.gl/es3/glProgramUniformMatrix3fvEXT)(program, location, count, transpose, value)
    /// `program` class: program
    /// `value` len: count*9
    /// alias of: [`glProgramUniformMatrix3fv`]
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    #[cfg(any(feature = "GL_EXT_separate_shader_objects"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_separate_shader_objects"))))]
    pub unsafe fn glProgramUniformMatrix3fvEXT(
        program: GLuint,
        location: GLint,
        count: GLsizei,
        transpose: GLboolean,
        value: *const GLfloat,
    ) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glProgramUniformMatrix3fvEXT({:?}, {:?}, {:?}, {:?}, {:p});",
                program,
                location,
                count,
                transpose,
                value
            );
        }
        let out = call_atomic_ptr_5arg(
            "glProgramUniformMatrix3fvEXT",
            &glProgramUniformMatrix3fvEXT_p,
            program,
            location,
            count,
            transpose,
            value,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glProgramUniformMatrix3fvEXT");
        }
        out
    }
    #[cfg(any(feature = "GL_EXT_separate_shader_objects"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_separate_shader_objects"))))]
    static glProgramUniformMatrix3fvEXT_p: APcv = ap_None();
    /// Tries to load [`glProgramUniformMatrix3fvEXT`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    #[cfg(any(feature = "GL_EXT_separate_shader_objects"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_separate_shader_objects"))))]
    pub unsafe fn glProgramUniformMatrix3fvEXT_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glProgramUniformMatrix3fvEXT\0",
            &glProgramUniformMatrix3fvEXT_p,
        )
    }
    /// Checks if the pointer for [`glProgramUniformMatrix3fvEXT`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    #[cfg(any(feature = "GL_EXT_separate_shader_objects"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_separate_shader_objects"))))]
    pub fn glProgramUniformMatrix3fvEXT_is_loaded() -> bool {
        !glProgramUniformMatrix3fvEXT_p.load(RELAX).is_null()
    }

    /// [glProgramUniformMatrix3x2fv](http://docs.gl/es3/glProgramUniform)(program, location, count, transpose, value)
    /// `program` class: program
    /// `value` len: count*6
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn glProgramUniformMatrix3x2fv(
        program: GLuint,
        location: GLint,
        count: GLsizei,
        transpose: GLboolean,
        value: *const GLfloat,
    ) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glProgramUniformMatrix3x2fv({:?}, {:?}, {:?}, {:?}, {:p});",
                program,
                location,
                count,
                transpose,
                value
            );
        }
        let out = call_atomic_ptr_5arg(
            "glProgramUniformMatrix3x2fv",
            &glProgramUniformMatrix3x2fv_p,
            program,
            location,
            count,
            transpose,
            value,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glProgramUniformMatrix3x2fv");
        }
        out
    }
    static glProgramUniformMatrix3x2fv_p: APcv = ap_None();
    /// Tries to load [`glProgramUniformMatrix3x2fv`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    pub unsafe fn glProgramUniformMatrix3x2fv_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glProgramUniformMatrix3x2fv\0",
            &glProgramUniformMatrix3x2fv_p,
        )
    }
    /// Checks if the pointer for [`glProgramUniformMatrix3x2fv`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    pub fn glProgramUniformMatrix3x2fv_is_loaded() -> bool {
        !glProgramUniformMatrix3x2fv_p.load(RELAX).is_null()
    }

    /// [glProgramUniformMatrix3x2fvEXT](http://docs.gl/es3/glProgramUniformMatrix3x2fvEXT)(program, location, count, transpose, value)
    /// `program` class: program
    /// `value` len: count*6
    /// alias of: [`glProgramUniformMatrix3x2fv`]
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    #[cfg(any(feature = "GL_EXT_separate_shader_objects"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_separate_shader_objects"))))]
    pub unsafe fn glProgramUniformMatrix3x2fvEXT(
        program: GLuint,
        location: GLint,
        count: GLsizei,
        transpose: GLboolean,
        value: *const GLfloat,
    ) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glProgramUniformMatrix3x2fvEXT({:?}, {:?}, {:?}, {:?}, {:p});",
                program,
                location,
                count,
                transpose,
                value
            );
        }
        let out = call_atomic_ptr_5arg(
            "glProgramUniformMatrix3x2fvEXT",
            &glProgramUniformMatrix3x2fvEXT_p,
            program,
            location,
            count,
            transpose,
            value,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glProgramUniformMatrix3x2fvEXT");
        }
        out
    }
    #[cfg(any(feature = "GL_EXT_separate_shader_objects"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_separate_shader_objects"))))]
    static glProgramUniformMatrix3x2fvEXT_p: APcv = ap_None();
    /// Tries to load [`glProgramUniformMatrix3x2fvEXT`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    #[cfg(any(feature = "GL_EXT_separate_shader_objects"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_separate_shader_objects"))))]
    pub unsafe fn glProgramUniformMatrix3x2fvEXT_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glProgramUniformMatrix3x2fvEXT\0",
            &glProgramUniformMatrix3x2fvEXT_p,
        )
    }
    /// Checks if the pointer for [`glProgramUniformMatrix3x2fvEXT`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    #[cfg(any(feature = "GL_EXT_separate_shader_objects"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_separate_shader_objects"))))]
    pub fn glProgramUniformMatrix3x2fvEXT_is_loaded() -> bool {
        !glProgramUniformMatrix3x2fvEXT_p.load(RELAX).is_null()
    }

    /// [glProgramUniformMatrix3x4fv](http://docs.gl/es3/glProgramUniform)(program, location, count, transpose, value)
    /// `program` class: program
    /// `value` len: count*12
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn glProgramUniformMatrix3x4fv(
        program: GLuint,
        location: GLint,
        count: GLsizei,
        transpose: GLboolean,
        value: *const GLfloat,
    ) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glProgramUniformMatrix3x4fv({:?}, {:?}, {:?}, {:?}, {:p});",
                program,
                location,
                count,
                transpose,
                value
            );
        }
        let out = call_atomic_ptr_5arg(
            "glProgramUniformMatrix3x4fv",
            &glProgramUniformMatrix3x4fv_p,
            program,
            location,
            count,
            transpose,
            value,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glProgramUniformMatrix3x4fv");
        }
        out
    }
    static glProgramUniformMatrix3x4fv_p: APcv = ap_None();
    /// Tries to load [`glProgramUniformMatrix3x4fv`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    pub unsafe fn glProgramUniformMatrix3x4fv_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glProgramUniformMatrix3x4fv\0",
            &glProgramUniformMatrix3x4fv_p,
        )
    }
    /// Checks if the pointer for [`glProgramUniformMatrix3x4fv`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    pub fn glProgramUniformMatrix3x4fv_is_loaded() -> bool {
        !glProgramUniformMatrix3x4fv_p.load(RELAX).is_null()
    }

    /// [glProgramUniformMatrix3x4fvEXT](http://docs.gl/es3/glProgramUniformMatrix3x4fvEXT)(program, location, count, transpose, value)
    /// `program` class: program
    /// `value` len: count*12
    /// alias of: [`glProgramUniformMatrix3x4fv`]
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    #[cfg(any(feature = "GL_EXT_separate_shader_objects"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_separate_shader_objects"))))]
    pub unsafe fn glProgramUniformMatrix3x4fvEXT(
        program: GLuint,
        location: GLint,
        count: GLsizei,
        transpose: GLboolean,
        value: *const GLfloat,
    ) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glProgramUniformMatrix3x4fvEXT({:?}, {:?}, {:?}, {:?}, {:p});",
                program,
                location,
                count,
                transpose,
                value
            );
        }
        let out = call_atomic_ptr_5arg(
            "glProgramUniformMatrix3x4fvEXT",
            &glProgramUniformMatrix3x4fvEXT_p,
            program,
            location,
            count,
            transpose,
            value,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glProgramUniformMatrix3x4fvEXT");
        }
        out
    }
    #[cfg(any(feature = "GL_EXT_separate_shader_objects"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_separate_shader_objects"))))]
    static glProgramUniformMatrix3x4fvEXT_p: APcv = ap_None();
    /// Tries to load [`glProgramUniformMatrix3x4fvEXT`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    #[cfg(any(feature = "GL_EXT_separate_shader_objects"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_separate_shader_objects"))))]
    pub unsafe fn glProgramUniformMatrix3x4fvEXT_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glProgramUniformMatrix3x4fvEXT\0",
            &glProgramUniformMatrix3x4fvEXT_p,
        )
    }
    /// Checks if the pointer for [`glProgramUniformMatrix3x4fvEXT`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    #[cfg(any(feature = "GL_EXT_separate_shader_objects"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_separate_shader_objects"))))]
    pub fn glProgramUniformMatrix3x4fvEXT_is_loaded() -> bool {
        !glProgramUniformMatrix3x4fvEXT_p.load(RELAX).is_null()
    }

    /// [glProgramUniformMatrix4fv](http://docs.gl/es3/glProgramUniform)(program, location, count, transpose, value)
    /// `program` class: program
    /// `value` len: count*16
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn glProgramUniformMatrix4fv(
        program: GLuint,
        location: GLint,
        count: GLsizei,
        transpose: GLboolean,
        value: *const GLfloat,
    ) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glProgramUniformMatrix4fv({:?}, {:?}, {:?}, {:?}, {:p});",
                program,
                location,
                count,
                transpose,
                value
            );
        }
        let out = call_atomic_ptr_5arg(
            "glProgramUniformMatrix4fv",
            &glProgramUniformMatrix4fv_p,
            program,
            location,
            count,
            transpose,
            value,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glProgramUniformMatrix4fv");
        }
        out
    }
    static glProgramUniformMatrix4fv_p: APcv = ap_None();
    /// Tries to load [`glProgramUniformMatrix4fv`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    pub unsafe fn glProgramUniformMatrix4fv_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glProgramUniformMatrix4fv\0",
            &glProgramUniformMatrix4fv_p,
        )
    }
    /// Checks if the pointer for [`glProgramUniformMatrix4fv`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    pub fn glProgramUniformMatrix4fv_is_loaded() -> bool {
        !glProgramUniformMatrix4fv_p.load(RELAX).is_null()
    }

    /// [glProgramUniformMatrix4fvEXT](http://docs.gl/es3/glProgramUniformMatrix4fvEXT)(program, location, count, transpose, value)
    /// `program` class: program
    /// `value` len: count*16
    /// alias of: [`glProgramUniformMatrix4fv`]
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    #[cfg(any(feature = "GL_EXT_separate_shader_objects"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_separate_shader_objects"))))]
    pub unsafe fn glProgramUniformMatrix4fvEXT(
        program: GLuint,
        location: GLint,
        count: GLsizei,
        transpose: GLboolean,
        value: *const GLfloat,
    ) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glProgramUniformMatrix4fvEXT({:?}, {:?}, {:?}, {:?}, {:p});",
                program,
                location,
                count,
                transpose,
                value
            );
        }
        let out = call_atomic_ptr_5arg(
            "glProgramUniformMatrix4fvEXT",
            &glProgramUniformMatrix4fvEXT_p,
            program,
            location,
            count,
            transpose,
            value,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glProgramUniformMatrix4fvEXT");
        }
        out
    }
    #[cfg(any(feature = "GL_EXT_separate_shader_objects"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_separate_shader_objects"))))]
    static glProgramUniformMatrix4fvEXT_p: APcv = ap_None();
    /// Tries to load [`glProgramUniformMatrix4fvEXT`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    #[cfg(any(feature = "GL_EXT_separate_shader_objects"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_separate_shader_objects"))))]
    pub unsafe fn glProgramUniformMatrix4fvEXT_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glProgramUniformMatrix4fvEXT\0",
            &glProgramUniformMatrix4fvEXT_p,
        )
    }
    /// Checks if the pointer for [`glProgramUniformMatrix4fvEXT`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    #[cfg(any(feature = "GL_EXT_separate_shader_objects"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_separate_shader_objects"))))]
    pub fn glProgramUniformMatrix4fvEXT_is_loaded() -> bool {
        !glProgramUniformMatrix4fvEXT_p.load(RELAX).is_null()
    }

    /// [glProgramUniformMatrix4x2fv](http://docs.gl/es3/glProgramUniform)(program, location, count, transpose, value)
    /// `program` class: program
    /// `value` len: count*8
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn glProgramUniformMatrix4x2fv(
        program: GLuint,
        location: GLint,
        count: GLsizei,
        transpose: GLboolean,
        value: *const GLfloat,
    ) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glProgramUniformMatrix4x2fv({:?}, {:?}, {:?}, {:?}, {:p});",
                program,
                location,
                count,
                transpose,
                value
            );
        }
        let out = call_atomic_ptr_5arg(
            "glProgramUniformMatrix4x2fv",
            &glProgramUniformMatrix4x2fv_p,
            program,
            location,
            count,
            transpose,
            value,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glProgramUniformMatrix4x2fv");
        }
        out
    }
    static glProgramUniformMatrix4x2fv_p: APcv = ap_None();
    /// Tries to load [`glProgramUniformMatrix4x2fv`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    pub unsafe fn glProgramUniformMatrix4x2fv_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glProgramUniformMatrix4x2fv\0",
            &glProgramUniformMatrix4x2fv_p,
        )
    }
    /// Checks if the pointer for [`glProgramUniformMatrix4x2fv`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    pub fn glProgramUniformMatrix4x2fv_is_loaded() -> bool {
        !glProgramUniformMatrix4x2fv_p.load(RELAX).is_null()
    }

    /// [glProgramUniformMatrix4x2fvEXT](http://docs.gl/es3/glProgramUniformMatrix4x2fvEXT)(program, location, count, transpose, value)
    /// `program` class: program
    /// `value` len: count*8
    /// alias of: [`glProgramUniformMatrix4x2fv`]
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    #[cfg(any(feature = "GL_EXT_separate_shader_objects"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_separate_shader_objects"))))]
    pub unsafe fn glProgramUniformMatrix4x2fvEXT(
        program: GLuint,
        location: GLint,
        count: GLsizei,
        transpose: GLboolean,
        value: *const GLfloat,
    ) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glProgramUniformMatrix4x2fvEXT({:?}, {:?}, {:?}, {:?}, {:p});",
                program,
                location,
                count,
                transpose,
                value
            );
        }
        let out = call_atomic_ptr_5arg(
            "glProgramUniformMatrix4x2fvEXT",
            &glProgramUniformMatrix4x2fvEXT_p,
            program,
            location,
            count,
            transpose,
            value,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glProgramUniformMatrix4x2fvEXT");
        }
        out
    }
    #[cfg(any(feature = "GL_EXT_separate_shader_objects"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_separate_shader_objects"))))]
    static glProgramUniformMatrix4x2fvEXT_p: APcv = ap_None();
    /// Tries to load [`glProgramUniformMatrix4x2fvEXT`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    #[cfg(any(feature = "GL_EXT_separate_shader_objects"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_separate_shader_objects"))))]
    pub unsafe fn glProgramUniformMatrix4x2fvEXT_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glProgramUniformMatrix4x2fvEXT\0",
            &glProgramUniformMatrix4x2fvEXT_p,
        )
    }
    /// Checks if the pointer for [`glProgramUniformMatrix4x2fvEXT`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    #[cfg(any(feature = "GL_EXT_separate_shader_objects"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_separate_shader_objects"))))]
    pub fn glProgramUniformMatrix4x2fvEXT_is_loaded() -> bool {
        !glProgramUniformMatrix4x2fvEXT_p.load(RELAX).is_null()
    }

    /// [glProgramUniformMatrix4x3fv](http://docs.gl/es3/glProgramUniform)(program, location, count, transpose, value)
    /// `program` class: program
    /// `value` len: count*12
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn glProgramUniformMatrix4x3fv(
        program: GLuint,
        location: GLint,
        count: GLsizei,
        transpose: GLboolean,
        value: *const GLfloat,
    ) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glProgramUniformMatrix4x3fv({:?}, {:?}, {:?}, {:?}, {:p});",
                program,
                location,
                count,
                transpose,
                value
            );
        }
        let out = call_atomic_ptr_5arg(
            "glProgramUniformMatrix4x3fv",
            &glProgramUniformMatrix4x3fv_p,
            program,
            location,
            count,
            transpose,
            value,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glProgramUniformMatrix4x3fv");
        }
        out
    }
    static glProgramUniformMatrix4x3fv_p: APcv = ap_None();
    /// Tries to load [`glProgramUniformMatrix4x3fv`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    pub unsafe fn glProgramUniformMatrix4x3fv_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glProgramUniformMatrix4x3fv\0",
            &glProgramUniformMatrix4x3fv_p,
        )
    }
    /// Checks if the pointer for [`glProgramUniformMatrix4x3fv`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    pub fn glProgramUniformMatrix4x3fv_is_loaded() -> bool {
        !glProgramUniformMatrix4x3fv_p.load(RELAX).is_null()
    }

    /// [glProgramUniformMatrix4x3fvEXT](http://docs.gl/es3/glProgramUniformMatrix4x3fvEXT)(program, location, count, transpose, value)
    /// `program` class: program
    /// `value` len: count*12
    /// alias of: [`glProgramUniformMatrix4x3fv`]
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    #[cfg(any(feature = "GL_EXT_separate_shader_objects"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_separate_shader_objects"))))]
    pub unsafe fn glProgramUniformMatrix4x3fvEXT(
        program: GLuint,
        location: GLint,
        count: GLsizei,
        transpose: GLboolean,
        value: *const GLfloat,
    ) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glProgramUniformMatrix4x3fvEXT({:?}, {:?}, {:?}, {:?}, {:p});",
                program,
                location,
                count,
                transpose,
                value
            );
        }
        let out = call_atomic_ptr_5arg(
            "glProgramUniformMatrix4x3fvEXT",
            &glProgramUniformMatrix4x3fvEXT_p,
            program,
            location,
            count,
            transpose,
            value,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glProgramUniformMatrix4x3fvEXT");
        }
        out
    }
    #[cfg(any(feature = "GL_EXT_separate_shader_objects"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_separate_shader_objects"))))]
    static glProgramUniformMatrix4x3fvEXT_p: APcv = ap_None();
    /// Tries to load [`glProgramUniformMatrix4x3fvEXT`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    #[cfg(any(feature = "GL_EXT_separate_shader_objects"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_separate_shader_objects"))))]
    pub unsafe fn glProgramUniformMatrix4x3fvEXT_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glProgramUniformMatrix4x3fvEXT\0",
            &glProgramUniformMatrix4x3fvEXT_p,
        )
    }
    /// Checks if the pointer for [`glProgramUniformMatrix4x3fvEXT`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    #[cfg(any(feature = "GL_EXT_separate_shader_objects"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_separate_shader_objects"))))]
    pub fn glProgramUniformMatrix4x3fvEXT_is_loaded() -> bool {
        !glProgramUniformMatrix4x3fvEXT_p.load(RELAX).is_null()
    }

    /// [glPushDebugGroup](http://docs.gl/es3/glPushDebugGroup)(source, id, length, message)
    /// `source` group: DebugSource
    /// `message` len: COMPSIZE(message,length)
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn glPushDebugGroup(
        source: GLenum,
        id: GLuint,
        length: GLsizei,
        message: *const GLchar,
    ) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glPushDebugGroup({:#X}, {:?}, {:?}, {:p});",
                source,
                id,
                length,
                message
            );
        }
        let out = call_atomic_ptr_4arg(
            "glPushDebugGroup",
            &glPushDebugGroup_p,
            source,
            id,
            length,
            message,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glPushDebugGroup");
        }
        out
    }
    static glPushDebugGroup_p: APcv = ap_None();
    /// Tries to load [`glPushDebugGroup`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    pub unsafe fn glPushDebugGroup_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(get_proc_address, b"glPushDebugGroup\0", &glPushDebugGroup_p)
    }
    /// Checks if the pointer for [`glPushDebugGroup`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    pub fn glPushDebugGroup_is_loaded() -> bool {
        !glPushDebugGroup_p.load(RELAX).is_null()
    }

    /// [glPushDebugGroupKHR](http://docs.gl/es3/glPushDebugGroupKHR)(source, id, length, message)
    /// `source` group: DebugSource
    /// alias of: [`glPushDebugGroup`]
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    #[cfg(any(feature = "GL_KHR_debug"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_KHR_debug"))))]
    pub unsafe fn glPushDebugGroupKHR(
        source: GLenum,
        id: GLuint,
        length: GLsizei,
        message: *const GLchar,
    ) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glPushDebugGroupKHR({:#X}, {:?}, {:?}, {:p});",
                source,
                id,
                length,
                message
            );
        }
        let out = call_atomic_ptr_4arg(
            "glPushDebugGroupKHR",
            &glPushDebugGroupKHR_p,
            source,
            id,
            length,
            message,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glPushDebugGroupKHR");
        }
        out
    }
    #[cfg(any(feature = "GL_KHR_debug"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_KHR_debug"))))]
    static glPushDebugGroupKHR_p: APcv = ap_None();
    /// Tries to load [`glPushDebugGroupKHR`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    #[cfg(any(feature = "GL_KHR_debug"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_KHR_debug"))))]
    pub unsafe fn glPushDebugGroupKHR_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glPushDebugGroupKHR\0",
            &glPushDebugGroupKHR_p,
        )
    }
    /// Checks if the pointer for [`glPushDebugGroupKHR`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    #[cfg(any(feature = "GL_KHR_debug"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_KHR_debug"))))]
    pub fn glPushDebugGroupKHR_is_loaded() -> bool {
        !glPushDebugGroupKHR_p.load(RELAX).is_null()
    }

    /// [glPushGroupMarkerEXT](http://docs.gl/es3/glPushGroupMarkerEXT)(length, marker)
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    #[cfg(any(feature = "GL_EXT_debug_marker"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_debug_marker"))))]
    pub unsafe fn glPushGroupMarkerEXT(length: GLsizei, marker: *const GLchar) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!("calling glPushGroupMarkerEXT({:?}, {:p});", length, marker);
        }
        let out = call_atomic_ptr_2arg(
            "glPushGroupMarkerEXT",
            &glPushGroupMarkerEXT_p,
            length,
            marker,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glPushGroupMarkerEXT");
        }
        out
    }
    #[cfg(any(feature = "GL_EXT_debug_marker"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_debug_marker"))))]
    static glPushGroupMarkerEXT_p: APcv = ap_None();
    /// Tries to load [`glPushGroupMarkerEXT`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    #[cfg(any(feature = "GL_EXT_debug_marker"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_debug_marker"))))]
    pub unsafe fn glPushGroupMarkerEXT_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glPushGroupMarkerEXT\0",
            &glPushGroupMarkerEXT_p,
        )
    }
    /// Checks if the pointer for [`glPushGroupMarkerEXT`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    #[cfg(any(feature = "GL_EXT_debug_marker"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_debug_marker"))))]
    pub fn glPushGroupMarkerEXT_is_loaded() -> bool {
        !glPushGroupMarkerEXT_p.load(RELAX).is_null()
    }

    /// [glQueryCounterEXT](http://docs.gl/es3/glQueryCounterEXT)(id, target)
    /// `id` class: query
    /// `target` group: QueryCounterTarget
    /// alias of: [`glQueryCounter`]
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    #[cfg(any(feature = "GL_EXT_disjoint_timer_query"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_disjoint_timer_query"))))]
    pub unsafe fn glQueryCounterEXT(id: GLuint, target: GLenum) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!("calling glQueryCounterEXT({:?}, {:#X});", id, target);
        }
        let out = call_atomic_ptr_2arg("glQueryCounterEXT", &glQueryCounterEXT_p, id, target);
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glQueryCounterEXT");
        }
        out
    }
    #[cfg(any(feature = "GL_EXT_disjoint_timer_query"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_disjoint_timer_query"))))]
    static glQueryCounterEXT_p: APcv = ap_None();
    /// Tries to load [`glQueryCounterEXT`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    #[cfg(any(feature = "GL_EXT_disjoint_timer_query"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_disjoint_timer_query"))))]
    pub unsafe fn glQueryCounterEXT_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glQueryCounterEXT\0",
            &glQueryCounterEXT_p,
        )
    }
    /// Checks if the pointer for [`glQueryCounterEXT`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    #[cfg(any(feature = "GL_EXT_disjoint_timer_query"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_disjoint_timer_query"))))]
    pub fn glQueryCounterEXT_is_loaded() -> bool {
        !glQueryCounterEXT_p.load(RELAX).is_null()
    }

    /// [glRasterSamplesEXT](http://docs.gl/es3/glRasterSamplesEXT)(samples, fixedsamplelocations)
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    #[cfg(any(
        feature = "GL_EXT_raster_multisample",
        feature = "GL_NV_framebuffer_mixed_samples"
    ))]
    #[cfg_attr(
        docs_rs,
        doc(cfg(any(
            feature = "GL_EXT_raster_multisample",
            feature = "GL_NV_framebuffer_mixed_samples"
        )))
    )]
    pub unsafe fn glRasterSamplesEXT(samples: GLuint, fixedsamplelocations: GLboolean) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glRasterSamplesEXT({:?}, {:?});",
                samples,
                fixedsamplelocations
            );
        }
        let out = call_atomic_ptr_2arg(
            "glRasterSamplesEXT",
            &glRasterSamplesEXT_p,
            samples,
            fixedsamplelocations,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glRasterSamplesEXT");
        }
        out
    }
    #[cfg(any(
        feature = "GL_EXT_raster_multisample",
        feature = "GL_NV_framebuffer_mixed_samples"
    ))]
    #[cfg_attr(
        docs_rs,
        doc(cfg(any(
            feature = "GL_EXT_raster_multisample",
            feature = "GL_NV_framebuffer_mixed_samples"
        )))
    )]
    static glRasterSamplesEXT_p: APcv = ap_None();
    /// Tries to load [`glRasterSamplesEXT`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    #[cfg(any(
        feature = "GL_EXT_raster_multisample",
        feature = "GL_NV_framebuffer_mixed_samples"
    ))]
    #[cfg_attr(
        docs_rs,
        doc(cfg(any(
            feature = "GL_EXT_raster_multisample",
            feature = "GL_NV_framebuffer_mixed_samples"
        )))
    )]
    pub unsafe fn glRasterSamplesEXT_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glRasterSamplesEXT\0",
            &glRasterSamplesEXT_p,
        )
    }
    /// Checks if the pointer for [`glRasterSamplesEXT`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    #[cfg(any(
        feature = "GL_EXT_raster_multisample",
        feature = "GL_NV_framebuffer_mixed_samples"
    ))]
    #[cfg_attr(
        docs_rs,
        doc(cfg(any(
            feature = "GL_EXT_raster_multisample",
            feature = "GL_NV_framebuffer_mixed_samples"
        )))
    )]
    pub fn glRasterSamplesEXT_is_loaded() -> bool {
        !glRasterSamplesEXT_p.load(RELAX).is_null()
    }

    /// [glReadBuffer](http://docs.gl/es3/glReadBuffer)(src)
    /// `src` group: ReadBufferMode
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn glReadBuffer(src: GLenum) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!("calling glReadBuffer({:#X});", src);
        }
        let out = call_atomic_ptr_1arg("glReadBuffer", &glReadBuffer_p, src);
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glReadBuffer");
        }
        out
    }
    static glReadBuffer_p: APcv = ap_None();
    /// Tries to load [`glReadBuffer`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    pub unsafe fn glReadBuffer_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(get_proc_address, b"glReadBuffer\0", &glReadBuffer_p)
    }
    /// Checks if the pointer for [`glReadBuffer`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    pub fn glReadBuffer_is_loaded() -> bool {
        !glReadBuffer_p.load(RELAX).is_null()
    }

    /// [glReadBufferIndexedEXT](http://docs.gl/es3/glReadBufferIndexedEXT)(src, index)
    /// `src` group: ReadBufferMode
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    #[cfg(any(feature = "GL_EXT_multiview_draw_buffers"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_multiview_draw_buffers"))))]
    pub unsafe fn glReadBufferIndexedEXT(src: GLenum, index: GLint) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!("calling glReadBufferIndexedEXT({:#X}, {:?});", src, index);
        }
        let out = call_atomic_ptr_2arg(
            "glReadBufferIndexedEXT",
            &glReadBufferIndexedEXT_p,
            src,
            index,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glReadBufferIndexedEXT");
        }
        out
    }
    #[cfg(any(feature = "GL_EXT_multiview_draw_buffers"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_multiview_draw_buffers"))))]
    static glReadBufferIndexedEXT_p: APcv = ap_None();
    /// Tries to load [`glReadBufferIndexedEXT`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    #[cfg(any(feature = "GL_EXT_multiview_draw_buffers"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_multiview_draw_buffers"))))]
    pub unsafe fn glReadBufferIndexedEXT_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glReadBufferIndexedEXT\0",
            &glReadBufferIndexedEXT_p,
        )
    }
    /// Checks if the pointer for [`glReadBufferIndexedEXT`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    #[cfg(any(feature = "GL_EXT_multiview_draw_buffers"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_multiview_draw_buffers"))))]
    pub fn glReadBufferIndexedEXT_is_loaded() -> bool {
        !glReadBufferIndexedEXT_p.load(RELAX).is_null()
    }

    /// [glReadBufferNV](http://docs.gl/es3/glReadBufferNV)(mode)
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    #[cfg(any(feature = "GL_NV_read_buffer"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_read_buffer"))))]
    pub unsafe fn glReadBufferNV(mode: GLenum) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!("calling glReadBufferNV({:#X});", mode);
        }
        let out = call_atomic_ptr_1arg("glReadBufferNV", &glReadBufferNV_p, mode);
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glReadBufferNV");
        }
        out
    }
    #[cfg(any(feature = "GL_NV_read_buffer"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_read_buffer"))))]
    static glReadBufferNV_p: APcv = ap_None();
    /// Tries to load [`glReadBufferNV`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    #[cfg(any(feature = "GL_NV_read_buffer"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_read_buffer"))))]
    pub unsafe fn glReadBufferNV_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(get_proc_address, b"glReadBufferNV\0", &glReadBufferNV_p)
    }
    /// Checks if the pointer for [`glReadBufferNV`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    #[cfg(any(feature = "GL_NV_read_buffer"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_read_buffer"))))]
    pub fn glReadBufferNV_is_loaded() -> bool {
        !glReadBufferNV_p.load(RELAX).is_null()
    }

    /// [glReadPixels](http://docs.gl/es3/glReadPixels)(x, y, width, height, format, type_, pixels)
    /// `x` group: WinCoord
    /// `y` group: WinCoord
    /// `format` group: PixelFormat
    /// `type_` group: PixelType
    /// `pixels` len: COMPSIZE(format,type,width,height)
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn glReadPixels(
        x: GLint,
        y: GLint,
        width: GLsizei,
        height: GLsizei,
        format: GLenum,
        type_: GLenum,
        pixels: *mut c_void,
    ) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glReadPixels({:?}, {:?}, {:?}, {:?}, {:#X}, {:#X}, {:p});",
                x,
                y,
                width,
                height,
                format,
                type_,
                pixels
            );
        }
        let out = call_atomic_ptr_7arg(
            "glReadPixels",
            &glReadPixels_p,
            x,
            y,
            width,
            height,
            format,
            type_,
            pixels,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glReadPixels");
        }
        out
    }
    static glReadPixels_p: APcv = ap_None();
    /// Tries to load [`glReadPixels`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    pub unsafe fn glReadPixels_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(get_proc_address, b"glReadPixels\0", &glReadPixels_p)
    }
    /// Checks if the pointer for [`glReadPixels`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    pub fn glReadPixels_is_loaded() -> bool {
        !glReadPixels_p.load(RELAX).is_null()
    }

    /// [glReadnPixels](http://docs.gl/es3/glReadnPixels)(x, y, width, height, format, type_, bufSize, data)
    /// `format` group: PixelFormat
    /// `type_` group: PixelType
    /// `data` len: bufSize
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn glReadnPixels(
        x: GLint,
        y: GLint,
        width: GLsizei,
        height: GLsizei,
        format: GLenum,
        type_: GLenum,
        bufSize: GLsizei,
        data: *mut c_void,
    ) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glReadnPixels({:?}, {:?}, {:?}, {:?}, {:#X}, {:#X}, {:?}, {:p});",
                x,
                y,
                width,
                height,
                format,
                type_,
                bufSize,
                data
            );
        }
        let out = call_atomic_ptr_8arg(
            "glReadnPixels",
            &glReadnPixels_p,
            x,
            y,
            width,
            height,
            format,
            type_,
            bufSize,
            data,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glReadnPixels");
        }
        out
    }
    static glReadnPixels_p: APcv = ap_None();
    /// Tries to load [`glReadnPixels`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    pub unsafe fn glReadnPixels_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(get_proc_address, b"glReadnPixels\0", &glReadnPixels_p)
    }
    /// Checks if the pointer for [`glReadnPixels`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    pub fn glReadnPixels_is_loaded() -> bool {
        !glReadnPixels_p.load(RELAX).is_null()
    }

    /// [glReadnPixelsEXT](http://docs.gl/es3/glReadnPixelsEXT)(x, y, width, height, format, type_, bufSize, data)
    /// `format` group: PixelFormat
    /// `type_` group: PixelType
    /// `data` len: bufSize
    /// alias of: [`glReadnPixels`]
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    #[cfg(any(feature = "GL_EXT_robustness"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_robustness"))))]
    pub unsafe fn glReadnPixelsEXT(
        x: GLint,
        y: GLint,
        width: GLsizei,
        height: GLsizei,
        format: GLenum,
        type_: GLenum,
        bufSize: GLsizei,
        data: *mut c_void,
    ) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glReadnPixelsEXT({:?}, {:?}, {:?}, {:?}, {:#X}, {:#X}, {:?}, {:p});",
                x,
                y,
                width,
                height,
                format,
                type_,
                bufSize,
                data
            );
        }
        let out = call_atomic_ptr_8arg(
            "glReadnPixelsEXT",
            &glReadnPixelsEXT_p,
            x,
            y,
            width,
            height,
            format,
            type_,
            bufSize,
            data,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glReadnPixelsEXT");
        }
        out
    }
    #[cfg(any(feature = "GL_EXT_robustness"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_robustness"))))]
    static glReadnPixelsEXT_p: APcv = ap_None();
    /// Tries to load [`glReadnPixelsEXT`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    #[cfg(any(feature = "GL_EXT_robustness"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_robustness"))))]
    pub unsafe fn glReadnPixelsEXT_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(get_proc_address, b"glReadnPixelsEXT\0", &glReadnPixelsEXT_p)
    }
    /// Checks if the pointer for [`glReadnPixelsEXT`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    #[cfg(any(feature = "GL_EXT_robustness"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_robustness"))))]
    pub fn glReadnPixelsEXT_is_loaded() -> bool {
        !glReadnPixelsEXT_p.load(RELAX).is_null()
    }

    /// [glReadnPixelsKHR](http://docs.gl/es3/glReadnPixelsKHR)(x, y, width, height, format, type_, bufSize, data)
    /// `x` group: WinCoord
    /// `y` group: WinCoord
    /// `format` group: PixelFormat
    /// `type_` group: PixelType
    /// `data` len: bufSize
    /// alias of: [`glReadnPixels`]
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    #[cfg(any(feature = "GL_KHR_robustness"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_KHR_robustness"))))]
    pub unsafe fn glReadnPixelsKHR(
        x: GLint,
        y: GLint,
        width: GLsizei,
        height: GLsizei,
        format: GLenum,
        type_: GLenum,
        bufSize: GLsizei,
        data: *mut c_void,
    ) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glReadnPixelsKHR({:?}, {:?}, {:?}, {:?}, {:#X}, {:#X}, {:?}, {:p});",
                x,
                y,
                width,
                height,
                format,
                type_,
                bufSize,
                data
            );
        }
        let out = call_atomic_ptr_8arg(
            "glReadnPixelsKHR",
            &glReadnPixelsKHR_p,
            x,
            y,
            width,
            height,
            format,
            type_,
            bufSize,
            data,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glReadnPixelsKHR");
        }
        out
    }
    #[cfg(any(feature = "GL_KHR_robustness"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_KHR_robustness"))))]
    static glReadnPixelsKHR_p: APcv = ap_None();
    /// Tries to load [`glReadnPixelsKHR`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    #[cfg(any(feature = "GL_KHR_robustness"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_KHR_robustness"))))]
    pub unsafe fn glReadnPixelsKHR_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(get_proc_address, b"glReadnPixelsKHR\0", &glReadnPixelsKHR_p)
    }
    /// Checks if the pointer for [`glReadnPixelsKHR`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    #[cfg(any(feature = "GL_KHR_robustness"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_KHR_robustness"))))]
    pub fn glReadnPixelsKHR_is_loaded() -> bool {
        !glReadnPixelsKHR_p.load(RELAX).is_null()
    }

    /// [glReleaseKeyedMutexWin32EXT](http://docs.gl/es3/glReleaseKeyedMutexWin32EXT)(memory, key)
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    #[cfg(any(feature = "GL_EXT_win32_keyed_mutex"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_win32_keyed_mutex"))))]
    pub unsafe fn glReleaseKeyedMutexWin32EXT(memory: GLuint, key: GLuint64) -> GLboolean {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glReleaseKeyedMutexWin32EXT({:?}, {:?});",
                memory,
                key
            );
        }
        let out = call_atomic_ptr_2arg(
            "glReleaseKeyedMutexWin32EXT",
            &glReleaseKeyedMutexWin32EXT_p,
            memory,
            key,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glReleaseKeyedMutexWin32EXT");
        }
        out
    }
    #[cfg(any(feature = "GL_EXT_win32_keyed_mutex"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_win32_keyed_mutex"))))]
    static glReleaseKeyedMutexWin32EXT_p: APcv = ap_None();
    /// Tries to load [`glReleaseKeyedMutexWin32EXT`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    #[cfg(any(feature = "GL_EXT_win32_keyed_mutex"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_win32_keyed_mutex"))))]
    pub unsafe fn glReleaseKeyedMutexWin32EXT_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glReleaseKeyedMutexWin32EXT\0",
            &glReleaseKeyedMutexWin32EXT_p,
        )
    }
    /// Checks if the pointer for [`glReleaseKeyedMutexWin32EXT`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    #[cfg(any(feature = "GL_EXT_win32_keyed_mutex"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_win32_keyed_mutex"))))]
    pub fn glReleaseKeyedMutexWin32EXT_is_loaded() -> bool {
        !glReleaseKeyedMutexWin32EXT_p.load(RELAX).is_null()
    }

    /// [glReleaseShaderCompiler](http://docs.gl/es3/glReleaseShaderCompiler)()
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn glReleaseShaderCompiler() {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!("calling glReleaseShaderCompiler();",);
        }
        let out = call_atomic_ptr_0arg("glReleaseShaderCompiler", &glReleaseShaderCompiler_p);
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glReleaseShaderCompiler");
        }
        out
    }
    static glReleaseShaderCompiler_p: APcv = ap_None();
    /// Tries to load [`glReleaseShaderCompiler`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    pub unsafe fn glReleaseShaderCompiler_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glReleaseShaderCompiler\0",
            &glReleaseShaderCompiler_p,
        )
    }
    /// Checks if the pointer for [`glReleaseShaderCompiler`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    pub fn glReleaseShaderCompiler_is_loaded() -> bool {
        !glReleaseShaderCompiler_p.load(RELAX).is_null()
    }

    /// [glRenderbufferStorage](http://docs.gl/es3/glRenderbufferStorage)(target, internalformat, width, height)
    /// `target` group: RenderbufferTarget
    /// `internalformat` group: InternalFormat
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn glRenderbufferStorage(
        target: GLenum,
        internalformat: GLenum,
        width: GLsizei,
        height: GLsizei,
    ) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glRenderbufferStorage({:#X}, {:#X}, {:?}, {:?});",
                target,
                internalformat,
                width,
                height
            );
        }
        let out = call_atomic_ptr_4arg(
            "glRenderbufferStorage",
            &glRenderbufferStorage_p,
            target,
            internalformat,
            width,
            height,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glRenderbufferStorage");
        }
        out
    }
    static glRenderbufferStorage_p: APcv = ap_None();
    /// Tries to load [`glRenderbufferStorage`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    pub unsafe fn glRenderbufferStorage_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glRenderbufferStorage\0",
            &glRenderbufferStorage_p,
        )
    }
    /// Checks if the pointer for [`glRenderbufferStorage`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    pub fn glRenderbufferStorage_is_loaded() -> bool {
        !glRenderbufferStorage_p.load(RELAX).is_null()
    }

    /// [glRenderbufferStorageMultisample](http://docs.gl/es3/glRenderbufferStorageMultisample)(target, samples, internalformat, width, height)
    /// `target` group: RenderbufferTarget
    /// `internalformat` group: InternalFormat
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn glRenderbufferStorageMultisample(
        target: GLenum,
        samples: GLsizei,
        internalformat: GLenum,
        width: GLsizei,
        height: GLsizei,
    ) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glRenderbufferStorageMultisample({:#X}, {:?}, {:#X}, {:?}, {:?});",
                target,
                samples,
                internalformat,
                width,
                height
            );
        }
        let out = call_atomic_ptr_5arg(
            "glRenderbufferStorageMultisample",
            &glRenderbufferStorageMultisample_p,
            target,
            samples,
            internalformat,
            width,
            height,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glRenderbufferStorageMultisample");
        }
        out
    }
    static glRenderbufferStorageMultisample_p: APcv = ap_None();
    /// Tries to load [`glRenderbufferStorageMultisample`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    pub unsafe fn glRenderbufferStorageMultisample_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glRenderbufferStorageMultisample\0",
            &glRenderbufferStorageMultisample_p,
        )
    }
    /// Checks if the pointer for [`glRenderbufferStorageMultisample`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    pub fn glRenderbufferStorageMultisample_is_loaded() -> bool {
        !glRenderbufferStorageMultisample_p.load(RELAX).is_null()
    }

    /// [glRenderbufferStorageMultisampleANGLE](http://docs.gl/es3/glRenderbufferStorageMultisampleANGLE)(target, samples, internalformat, width, height)
    /// `target` group: RenderbufferTarget
    /// `internalformat` group: InternalFormat
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    #[cfg(any(feature = "GL_ANGLE_framebuffer_multisample"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_ANGLE_framebuffer_multisample"))))]
    pub unsafe fn glRenderbufferStorageMultisampleANGLE(
        target: GLenum,
        samples: GLsizei,
        internalformat: GLenum,
        width: GLsizei,
        height: GLsizei,
    ) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glRenderbufferStorageMultisampleANGLE({:#X}, {:?}, {:#X}, {:?}, {:?});",
                target,
                samples,
                internalformat,
                width,
                height
            );
        }
        let out = call_atomic_ptr_5arg(
            "glRenderbufferStorageMultisampleANGLE",
            &glRenderbufferStorageMultisampleANGLE_p,
            target,
            samples,
            internalformat,
            width,
            height,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glRenderbufferStorageMultisampleANGLE");
        }
        out
    }
    #[cfg(any(feature = "GL_ANGLE_framebuffer_multisample"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_ANGLE_framebuffer_multisample"))))]
    static glRenderbufferStorageMultisampleANGLE_p: APcv = ap_None();
    /// Tries to load [`glRenderbufferStorageMultisampleANGLE`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    #[cfg(any(feature = "GL_ANGLE_framebuffer_multisample"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_ANGLE_framebuffer_multisample"))))]
    pub unsafe fn glRenderbufferStorageMultisampleANGLE_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glRenderbufferStorageMultisampleANGLE\0",
            &glRenderbufferStorageMultisampleANGLE_p,
        )
    }
    /// Checks if the pointer for [`glRenderbufferStorageMultisampleANGLE`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    #[cfg(any(feature = "GL_ANGLE_framebuffer_multisample"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_ANGLE_framebuffer_multisample"))))]
    pub fn glRenderbufferStorageMultisampleANGLE_is_loaded() -> bool {
        !glRenderbufferStorageMultisampleANGLE_p
            .load(RELAX)
            .is_null()
    }

    /// [glRenderbufferStorageMultisampleAPPLE](http://docs.gl/es3/glRenderbufferStorageMultisampleAPPLE)(target, samples, internalformat, width, height)
    /// `target` group: RenderbufferTarget
    /// `internalformat` group: InternalFormat
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    #[cfg(any(feature = "GL_APPLE_framebuffer_multisample"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_APPLE_framebuffer_multisample"))))]
    pub unsafe fn glRenderbufferStorageMultisampleAPPLE(
        target: GLenum,
        samples: GLsizei,
        internalformat: GLenum,
        width: GLsizei,
        height: GLsizei,
    ) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glRenderbufferStorageMultisampleAPPLE({:#X}, {:?}, {:#X}, {:?}, {:?});",
                target,
                samples,
                internalformat,
                width,
                height
            );
        }
        let out = call_atomic_ptr_5arg(
            "glRenderbufferStorageMultisampleAPPLE",
            &glRenderbufferStorageMultisampleAPPLE_p,
            target,
            samples,
            internalformat,
            width,
            height,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glRenderbufferStorageMultisampleAPPLE");
        }
        out
    }
    #[cfg(any(feature = "GL_APPLE_framebuffer_multisample"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_APPLE_framebuffer_multisample"))))]
    static glRenderbufferStorageMultisampleAPPLE_p: APcv = ap_None();
    /// Tries to load [`glRenderbufferStorageMultisampleAPPLE`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    #[cfg(any(feature = "GL_APPLE_framebuffer_multisample"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_APPLE_framebuffer_multisample"))))]
    pub unsafe fn glRenderbufferStorageMultisampleAPPLE_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glRenderbufferStorageMultisampleAPPLE\0",
            &glRenderbufferStorageMultisampleAPPLE_p,
        )
    }
    /// Checks if the pointer for [`glRenderbufferStorageMultisampleAPPLE`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    #[cfg(any(feature = "GL_APPLE_framebuffer_multisample"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_APPLE_framebuffer_multisample"))))]
    pub fn glRenderbufferStorageMultisampleAPPLE_is_loaded() -> bool {
        !glRenderbufferStorageMultisampleAPPLE_p
            .load(RELAX)
            .is_null()
    }

    /// [glRenderbufferStorageMultisampleAdvancedAMD](http://docs.gl/es3/glRenderbufferStorageMultisampleAdvancedAMD)(target, samples, storageSamples, internalformat, width, height)
    /// `target` group: RenderbufferTarget
    /// `internalformat` group: InternalFormat
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    #[cfg(any(feature = "GL_AMD_framebuffer_multisample_advanced"))]
    #[cfg_attr(
        docs_rs,
        doc(cfg(any(feature = "GL_AMD_framebuffer_multisample_advanced")))
    )]
    pub unsafe fn glRenderbufferStorageMultisampleAdvancedAMD(
        target: GLenum,
        samples: GLsizei,
        storageSamples: GLsizei,
        internalformat: GLenum,
        width: GLsizei,
        height: GLsizei,
    ) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glRenderbufferStorageMultisampleAdvancedAMD({:#X}, {:?}, {:?}, {:#X}, {:?}, {:?});",
                target,
                samples,
                storageSamples,
                internalformat,
                width,
                height
            );
        }
        let out = call_atomic_ptr_6arg(
            "glRenderbufferStorageMultisampleAdvancedAMD",
            &glRenderbufferStorageMultisampleAdvancedAMD_p,
            target,
            samples,
            storageSamples,
            internalformat,
            width,
            height,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glRenderbufferStorageMultisampleAdvancedAMD");
        }
        out
    }
    #[cfg(any(feature = "GL_AMD_framebuffer_multisample_advanced"))]
    #[cfg_attr(
        docs_rs,
        doc(cfg(any(feature = "GL_AMD_framebuffer_multisample_advanced")))
    )]
    static glRenderbufferStorageMultisampleAdvancedAMD_p: APcv = ap_None();
    /// Tries to load [`glRenderbufferStorageMultisampleAdvancedAMD`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    #[cfg(any(feature = "GL_AMD_framebuffer_multisample_advanced"))]
    #[cfg_attr(
        docs_rs,
        doc(cfg(any(feature = "GL_AMD_framebuffer_multisample_advanced")))
    )]
    pub unsafe fn glRenderbufferStorageMultisampleAdvancedAMD_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glRenderbufferStorageMultisampleAdvancedAMD\0",
            &glRenderbufferStorageMultisampleAdvancedAMD_p,
        )
    }
    /// Checks if the pointer for [`glRenderbufferStorageMultisampleAdvancedAMD`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    #[cfg(any(feature = "GL_AMD_framebuffer_multisample_advanced"))]
    #[cfg_attr(
        docs_rs,
        doc(cfg(any(feature = "GL_AMD_framebuffer_multisample_advanced")))
    )]
    pub fn glRenderbufferStorageMultisampleAdvancedAMD_is_loaded() -> bool {
        !glRenderbufferStorageMultisampleAdvancedAMD_p
            .load(RELAX)
            .is_null()
    }

    /// [glRenderbufferStorageMultisampleEXT](http://docs.gl/es3/glRenderbufferStorageMultisampleEXT)(target, samples, internalformat, width, height)
    /// `target` group: RenderbufferTarget
    /// `internalformat` group: InternalFormat
    /// alias of: [`glRenderbufferStorageMultisample`]
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    #[cfg(any(feature = "GL_EXT_multisampled_render_to_texture"))]
    #[cfg_attr(
        docs_rs,
        doc(cfg(any(feature = "GL_EXT_multisampled_render_to_texture")))
    )]
    pub unsafe fn glRenderbufferStorageMultisampleEXT(
        target: GLenum,
        samples: GLsizei,
        internalformat: GLenum,
        width: GLsizei,
        height: GLsizei,
    ) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glRenderbufferStorageMultisampleEXT({:#X}, {:?}, {:#X}, {:?}, {:?});",
                target,
                samples,
                internalformat,
                width,
                height
            );
        }
        let out = call_atomic_ptr_5arg(
            "glRenderbufferStorageMultisampleEXT",
            &glRenderbufferStorageMultisampleEXT_p,
            target,
            samples,
            internalformat,
            width,
            height,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glRenderbufferStorageMultisampleEXT");
        }
        out
    }
    #[cfg(any(feature = "GL_EXT_multisampled_render_to_texture"))]
    #[cfg_attr(
        docs_rs,
        doc(cfg(any(feature = "GL_EXT_multisampled_render_to_texture")))
    )]
    static glRenderbufferStorageMultisampleEXT_p: APcv = ap_None();
    /// Tries to load [`glRenderbufferStorageMultisampleEXT`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    #[cfg(any(feature = "GL_EXT_multisampled_render_to_texture"))]
    #[cfg_attr(
        docs_rs,
        doc(cfg(any(feature = "GL_EXT_multisampled_render_to_texture")))
    )]
    pub unsafe fn glRenderbufferStorageMultisampleEXT_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glRenderbufferStorageMultisampleEXT\0",
            &glRenderbufferStorageMultisampleEXT_p,
        )
    }
    /// Checks if the pointer for [`glRenderbufferStorageMultisampleEXT`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    #[cfg(any(feature = "GL_EXT_multisampled_render_to_texture"))]
    #[cfg_attr(
        docs_rs,
        doc(cfg(any(feature = "GL_EXT_multisampled_render_to_texture")))
    )]
    pub fn glRenderbufferStorageMultisampleEXT_is_loaded() -> bool {
        !glRenderbufferStorageMultisampleEXT_p.load(RELAX).is_null()
    }

    /// [glRenderbufferStorageMultisampleIMG](http://docs.gl/es3/glRenderbufferStorageMultisampleIMG)(target, samples, internalformat, width, height)
    /// `target` group: RenderbufferTarget
    /// `internalformat` group: InternalFormat
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    #[cfg(any(feature = "GL_IMG_multisampled_render_to_texture"))]
    #[cfg_attr(
        docs_rs,
        doc(cfg(any(feature = "GL_IMG_multisampled_render_to_texture")))
    )]
    pub unsafe fn glRenderbufferStorageMultisampleIMG(
        target: GLenum,
        samples: GLsizei,
        internalformat: GLenum,
        width: GLsizei,
        height: GLsizei,
    ) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glRenderbufferStorageMultisampleIMG({:#X}, {:?}, {:#X}, {:?}, {:?});",
                target,
                samples,
                internalformat,
                width,
                height
            );
        }
        let out = call_atomic_ptr_5arg(
            "glRenderbufferStorageMultisampleIMG",
            &glRenderbufferStorageMultisampleIMG_p,
            target,
            samples,
            internalformat,
            width,
            height,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glRenderbufferStorageMultisampleIMG");
        }
        out
    }
    #[cfg(any(feature = "GL_IMG_multisampled_render_to_texture"))]
    #[cfg_attr(
        docs_rs,
        doc(cfg(any(feature = "GL_IMG_multisampled_render_to_texture")))
    )]
    static glRenderbufferStorageMultisampleIMG_p: APcv = ap_None();
    /// Tries to load [`glRenderbufferStorageMultisampleIMG`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    #[cfg(any(feature = "GL_IMG_multisampled_render_to_texture"))]
    #[cfg_attr(
        docs_rs,
        doc(cfg(any(feature = "GL_IMG_multisampled_render_to_texture")))
    )]
    pub unsafe fn glRenderbufferStorageMultisampleIMG_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glRenderbufferStorageMultisampleIMG\0",
            &glRenderbufferStorageMultisampleIMG_p,
        )
    }
    /// Checks if the pointer for [`glRenderbufferStorageMultisampleIMG`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    #[cfg(any(feature = "GL_IMG_multisampled_render_to_texture"))]
    #[cfg_attr(
        docs_rs,
        doc(cfg(any(feature = "GL_IMG_multisampled_render_to_texture")))
    )]
    pub fn glRenderbufferStorageMultisampleIMG_is_loaded() -> bool {
        !glRenderbufferStorageMultisampleIMG_p.load(RELAX).is_null()
    }

    /// [glRenderbufferStorageMultisampleNV](http://docs.gl/es3/glRenderbufferStorageMultisampleNV)(target, samples, internalformat, width, height)
    /// `target` group: RenderbufferTarget
    /// `internalformat` group: InternalFormat
    /// alias of: [`glRenderbufferStorageMultisample`]
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    #[cfg(any(feature = "GL_NV_framebuffer_multisample"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_framebuffer_multisample"))))]
    pub unsafe fn glRenderbufferStorageMultisampleNV(
        target: GLenum,
        samples: GLsizei,
        internalformat: GLenum,
        width: GLsizei,
        height: GLsizei,
    ) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glRenderbufferStorageMultisampleNV({:#X}, {:?}, {:#X}, {:?}, {:?});",
                target,
                samples,
                internalformat,
                width,
                height
            );
        }
        let out = call_atomic_ptr_5arg(
            "glRenderbufferStorageMultisampleNV",
            &glRenderbufferStorageMultisampleNV_p,
            target,
            samples,
            internalformat,
            width,
            height,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glRenderbufferStorageMultisampleNV");
        }
        out
    }
    #[cfg(any(feature = "GL_NV_framebuffer_multisample"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_framebuffer_multisample"))))]
    static glRenderbufferStorageMultisampleNV_p: APcv = ap_None();
    /// Tries to load [`glRenderbufferStorageMultisampleNV`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    #[cfg(any(feature = "GL_NV_framebuffer_multisample"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_framebuffer_multisample"))))]
    pub unsafe fn glRenderbufferStorageMultisampleNV_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glRenderbufferStorageMultisampleNV\0",
            &glRenderbufferStorageMultisampleNV_p,
        )
    }
    /// Checks if the pointer for [`glRenderbufferStorageMultisampleNV`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    #[cfg(any(feature = "GL_NV_framebuffer_multisample"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_framebuffer_multisample"))))]
    pub fn glRenderbufferStorageMultisampleNV_is_loaded() -> bool {
        !glRenderbufferStorageMultisampleNV_p.load(RELAX).is_null()
    }

    /// [glResetMemoryObjectParameterNV](http://docs.gl/es3/glResetMemoryObjectParameterNV)(memory, pname)
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    #[cfg(any(feature = "GL_NV_memory_attachment"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_memory_attachment"))))]
    pub unsafe fn glResetMemoryObjectParameterNV(memory: GLuint, pname: GLenum) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glResetMemoryObjectParameterNV({:?}, {:#X});",
                memory,
                pname
            );
        }
        let out = call_atomic_ptr_2arg(
            "glResetMemoryObjectParameterNV",
            &glResetMemoryObjectParameterNV_p,
            memory,
            pname,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glResetMemoryObjectParameterNV");
        }
        out
    }
    #[cfg(any(feature = "GL_NV_memory_attachment"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_memory_attachment"))))]
    static glResetMemoryObjectParameterNV_p: APcv = ap_None();
    /// Tries to load [`glResetMemoryObjectParameterNV`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    #[cfg(any(feature = "GL_NV_memory_attachment"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_memory_attachment"))))]
    pub unsafe fn glResetMemoryObjectParameterNV_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glResetMemoryObjectParameterNV\0",
            &glResetMemoryObjectParameterNV_p,
        )
    }
    /// Checks if the pointer for [`glResetMemoryObjectParameterNV`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    #[cfg(any(feature = "GL_NV_memory_attachment"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_memory_attachment"))))]
    pub fn glResetMemoryObjectParameterNV_is_loaded() -> bool {
        !glResetMemoryObjectParameterNV_p.load(RELAX).is_null()
    }

    /// [glResolveDepthValuesNV](http://docs.gl/es3/glResolveDepthValuesNV)()
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    #[cfg(any(feature = "GL_NV_sample_locations"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_sample_locations"))))]
    pub unsafe fn glResolveDepthValuesNV() {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!("calling glResolveDepthValuesNV();",);
        }
        let out = call_atomic_ptr_0arg("glResolveDepthValuesNV", &glResolveDepthValuesNV_p);
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glResolveDepthValuesNV");
        }
        out
    }
    #[cfg(any(feature = "GL_NV_sample_locations"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_sample_locations"))))]
    static glResolveDepthValuesNV_p: APcv = ap_None();
    /// Tries to load [`glResolveDepthValuesNV`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    #[cfg(any(feature = "GL_NV_sample_locations"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_sample_locations"))))]
    pub unsafe fn glResolveDepthValuesNV_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glResolveDepthValuesNV\0",
            &glResolveDepthValuesNV_p,
        )
    }
    /// Checks if the pointer for [`glResolveDepthValuesNV`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    #[cfg(any(feature = "GL_NV_sample_locations"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_sample_locations"))))]
    pub fn glResolveDepthValuesNV_is_loaded() -> bool {
        !glResolveDepthValuesNV_p.load(RELAX).is_null()
    }

    /// [glResolveMultisampleFramebufferAPPLE](http://docs.gl/es3/glResolveMultisampleFramebufferAPPLE)()
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    #[cfg(any(feature = "GL_APPLE_framebuffer_multisample"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_APPLE_framebuffer_multisample"))))]
    pub unsafe fn glResolveMultisampleFramebufferAPPLE() {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!("calling glResolveMultisampleFramebufferAPPLE();",);
        }
        let out = call_atomic_ptr_0arg(
            "glResolveMultisampleFramebufferAPPLE",
            &glResolveMultisampleFramebufferAPPLE_p,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glResolveMultisampleFramebufferAPPLE");
        }
        out
    }
    #[cfg(any(feature = "GL_APPLE_framebuffer_multisample"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_APPLE_framebuffer_multisample"))))]
    static glResolveMultisampleFramebufferAPPLE_p: APcv = ap_None();
    /// Tries to load [`glResolveMultisampleFramebufferAPPLE`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    #[cfg(any(feature = "GL_APPLE_framebuffer_multisample"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_APPLE_framebuffer_multisample"))))]
    pub unsafe fn glResolveMultisampleFramebufferAPPLE_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glResolveMultisampleFramebufferAPPLE\0",
            &glResolveMultisampleFramebufferAPPLE_p,
        )
    }
    /// Checks if the pointer for [`glResolveMultisampleFramebufferAPPLE`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    #[cfg(any(feature = "GL_APPLE_framebuffer_multisample"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_APPLE_framebuffer_multisample"))))]
    pub fn glResolveMultisampleFramebufferAPPLE_is_loaded() -> bool {
        !glResolveMultisampleFramebufferAPPLE_p.load(RELAX).is_null()
    }

    /// [glResumeTransformFeedback](http://docs.gl/es3/glResumeTransformFeedback)()
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn glResumeTransformFeedback() {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!("calling glResumeTransformFeedback();",);
        }
        let out = call_atomic_ptr_0arg("glResumeTransformFeedback", &glResumeTransformFeedback_p);
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glResumeTransformFeedback");
        }
        out
    }
    static glResumeTransformFeedback_p: APcv = ap_None();
    /// Tries to load [`glResumeTransformFeedback`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    pub unsafe fn glResumeTransformFeedback_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glResumeTransformFeedback\0",
            &glResumeTransformFeedback_p,
        )
    }
    /// Checks if the pointer for [`glResumeTransformFeedback`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    pub fn glResumeTransformFeedback_is_loaded() -> bool {
        !glResumeTransformFeedback_p.load(RELAX).is_null()
    }

    /// [glSampleCoverage](http://docs.gl/es3/glSampleCoverage)(value, invert)
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn glSampleCoverage(value: GLfloat, invert: GLboolean) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!("calling glSampleCoverage({:?}, {:?});", value, invert);
        }
        let out = call_atomic_ptr_2arg("glSampleCoverage", &glSampleCoverage_p, value, invert);
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glSampleCoverage");
        }
        out
    }
    static glSampleCoverage_p: APcv = ap_None();
    /// Tries to load [`glSampleCoverage`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    pub unsafe fn glSampleCoverage_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(get_proc_address, b"glSampleCoverage\0", &glSampleCoverage_p)
    }
    /// Checks if the pointer for [`glSampleCoverage`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    pub fn glSampleCoverage_is_loaded() -> bool {
        !glSampleCoverage_p.load(RELAX).is_null()
    }

    /// [glSampleMaski](http://docs.gl/es3/glSampleMask)(maskNumber, mask)
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn glSampleMaski(maskNumber: GLuint, mask: GLbitfield) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!("calling glSampleMaski({:?}, {:?});", maskNumber, mask);
        }
        let out = call_atomic_ptr_2arg("glSampleMaski", &glSampleMaski_p, maskNumber, mask);
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glSampleMaski");
        }
        out
    }
    static glSampleMaski_p: APcv = ap_None();
    /// Tries to load [`glSampleMaski`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    pub unsafe fn glSampleMaski_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(get_proc_address, b"glSampleMaski\0", &glSampleMaski_p)
    }
    /// Checks if the pointer for [`glSampleMaski`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    pub fn glSampleMaski_is_loaded() -> bool {
        !glSampleMaski_p.load(RELAX).is_null()
    }

    /// [glSamplerParameterIiv](http://docs.gl/es3/glSamplerParameter)(sampler, pname, param)
    /// `sampler` class: sampler
    /// `pname` group: SamplerParameterI
    /// `param` len: COMPSIZE(pname)
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn glSamplerParameterIiv(sampler: GLuint, pname: GLenum, param: *const GLint) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glSamplerParameterIiv({:?}, {:#X}, {:p});",
                sampler,
                pname,
                param
            );
        }
        let out = call_atomic_ptr_3arg(
            "glSamplerParameterIiv",
            &glSamplerParameterIiv_p,
            sampler,
            pname,
            param,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glSamplerParameterIiv");
        }
        out
    }
    static glSamplerParameterIiv_p: APcv = ap_None();
    /// Tries to load [`glSamplerParameterIiv`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    pub unsafe fn glSamplerParameterIiv_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glSamplerParameterIiv\0",
            &glSamplerParameterIiv_p,
        )
    }
    /// Checks if the pointer for [`glSamplerParameterIiv`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    pub fn glSamplerParameterIiv_is_loaded() -> bool {
        !glSamplerParameterIiv_p.load(RELAX).is_null()
    }

    /// [glSamplerParameterIivEXT](http://docs.gl/es3/glSamplerParameterIivEXT)(sampler, pname, param)
    /// `sampler` class: sampler
    /// `pname` group: SamplerParameterI
    /// `param` len: COMPSIZE(pname)
    /// alias of: [`glSamplerParameterIiv`]
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    #[cfg(any(feature = "GL_EXT_texture_border_clamp"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_texture_border_clamp"))))]
    pub unsafe fn glSamplerParameterIivEXT(sampler: GLuint, pname: GLenum, param: *const GLint) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glSamplerParameterIivEXT({:?}, {:#X}, {:p});",
                sampler,
                pname,
                param
            );
        }
        let out = call_atomic_ptr_3arg(
            "glSamplerParameterIivEXT",
            &glSamplerParameterIivEXT_p,
            sampler,
            pname,
            param,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glSamplerParameterIivEXT");
        }
        out
    }
    #[cfg(any(feature = "GL_EXT_texture_border_clamp"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_texture_border_clamp"))))]
    static glSamplerParameterIivEXT_p: APcv = ap_None();
    /// Tries to load [`glSamplerParameterIivEXT`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    #[cfg(any(feature = "GL_EXT_texture_border_clamp"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_texture_border_clamp"))))]
    pub unsafe fn glSamplerParameterIivEXT_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glSamplerParameterIivEXT\0",
            &glSamplerParameterIivEXT_p,
        )
    }
    /// Checks if the pointer for [`glSamplerParameterIivEXT`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    #[cfg(any(feature = "GL_EXT_texture_border_clamp"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_texture_border_clamp"))))]
    pub fn glSamplerParameterIivEXT_is_loaded() -> bool {
        !glSamplerParameterIivEXT_p.load(RELAX).is_null()
    }

    /// [glSamplerParameterIivOES](http://docs.gl/es3/glSamplerParameterIivOES)(sampler, pname, param)
    /// `sampler` class: sampler
    /// `pname` group: SamplerParameterI
    /// `param` len: COMPSIZE(pname)
    /// alias of: [`glSamplerParameterIiv`]
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    #[cfg(any(feature = "GL_OES_texture_border_clamp"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_OES_texture_border_clamp"))))]
    pub unsafe fn glSamplerParameterIivOES(sampler: GLuint, pname: GLenum, param: *const GLint) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glSamplerParameterIivOES({:?}, {:#X}, {:p});",
                sampler,
                pname,
                param
            );
        }
        let out = call_atomic_ptr_3arg(
            "glSamplerParameterIivOES",
            &glSamplerParameterIivOES_p,
            sampler,
            pname,
            param,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glSamplerParameterIivOES");
        }
        out
    }
    #[cfg(any(feature = "GL_OES_texture_border_clamp"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_OES_texture_border_clamp"))))]
    static glSamplerParameterIivOES_p: APcv = ap_None();
    /// Tries to load [`glSamplerParameterIivOES`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    #[cfg(any(feature = "GL_OES_texture_border_clamp"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_OES_texture_border_clamp"))))]
    pub unsafe fn glSamplerParameterIivOES_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glSamplerParameterIivOES\0",
            &glSamplerParameterIivOES_p,
        )
    }
    /// Checks if the pointer for [`glSamplerParameterIivOES`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    #[cfg(any(feature = "GL_OES_texture_border_clamp"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_OES_texture_border_clamp"))))]
    pub fn glSamplerParameterIivOES_is_loaded() -> bool {
        !glSamplerParameterIivOES_p.load(RELAX).is_null()
    }

    /// [glSamplerParameterIuiv](http://docs.gl/es3/glSamplerParameter)(sampler, pname, param)
    /// `sampler` class: sampler
    /// `pname` group: SamplerParameterI
    /// `param` len: COMPSIZE(pname)
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn glSamplerParameterIuiv(sampler: GLuint, pname: GLenum, param: *const GLuint) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glSamplerParameterIuiv({:?}, {:#X}, {:p});",
                sampler,
                pname,
                param
            );
        }
        let out = call_atomic_ptr_3arg(
            "glSamplerParameterIuiv",
            &glSamplerParameterIuiv_p,
            sampler,
            pname,
            param,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glSamplerParameterIuiv");
        }
        out
    }
    static glSamplerParameterIuiv_p: APcv = ap_None();
    /// Tries to load [`glSamplerParameterIuiv`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    pub unsafe fn glSamplerParameterIuiv_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glSamplerParameterIuiv\0",
            &glSamplerParameterIuiv_p,
        )
    }
    /// Checks if the pointer for [`glSamplerParameterIuiv`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    pub fn glSamplerParameterIuiv_is_loaded() -> bool {
        !glSamplerParameterIuiv_p.load(RELAX).is_null()
    }

    /// [glSamplerParameterIuivEXT](http://docs.gl/es3/glSamplerParameterIuivEXT)(sampler, pname, param)
    /// `sampler` class: sampler
    /// `pname` group: SamplerParameterI
    /// `param` len: COMPSIZE(pname)
    /// alias of: [`glSamplerParameterIuiv`]
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    #[cfg(any(feature = "GL_EXT_texture_border_clamp"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_texture_border_clamp"))))]
    pub unsafe fn glSamplerParameterIuivEXT(sampler: GLuint, pname: GLenum, param: *const GLuint) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glSamplerParameterIuivEXT({:?}, {:#X}, {:p});",
                sampler,
                pname,
                param
            );
        }
        let out = call_atomic_ptr_3arg(
            "glSamplerParameterIuivEXT",
            &glSamplerParameterIuivEXT_p,
            sampler,
            pname,
            param,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glSamplerParameterIuivEXT");
        }
        out
    }
    #[cfg(any(feature = "GL_EXT_texture_border_clamp"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_texture_border_clamp"))))]
    static glSamplerParameterIuivEXT_p: APcv = ap_None();
    /// Tries to load [`glSamplerParameterIuivEXT`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    #[cfg(any(feature = "GL_EXT_texture_border_clamp"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_texture_border_clamp"))))]
    pub unsafe fn glSamplerParameterIuivEXT_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glSamplerParameterIuivEXT\0",
            &glSamplerParameterIuivEXT_p,
        )
    }
    /// Checks if the pointer for [`glSamplerParameterIuivEXT`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    #[cfg(any(feature = "GL_EXT_texture_border_clamp"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_texture_border_clamp"))))]
    pub fn glSamplerParameterIuivEXT_is_loaded() -> bool {
        !glSamplerParameterIuivEXT_p.load(RELAX).is_null()
    }

    /// [glSamplerParameterIuivOES](http://docs.gl/es3/glSamplerParameterIuivOES)(sampler, pname, param)
    /// `sampler` class: sampler
    /// `pname` group: SamplerParameterI
    /// `param` len: COMPSIZE(pname)
    /// alias of: [`glSamplerParameterIuiv`]
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    #[cfg(any(feature = "GL_OES_texture_border_clamp"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_OES_texture_border_clamp"))))]
    pub unsafe fn glSamplerParameterIuivOES(sampler: GLuint, pname: GLenum, param: *const GLuint) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glSamplerParameterIuivOES({:?}, {:#X}, {:p});",
                sampler,
                pname,
                param
            );
        }
        let out = call_atomic_ptr_3arg(
            "glSamplerParameterIuivOES",
            &glSamplerParameterIuivOES_p,
            sampler,
            pname,
            param,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glSamplerParameterIuivOES");
        }
        out
    }
    #[cfg(any(feature = "GL_OES_texture_border_clamp"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_OES_texture_border_clamp"))))]
    static glSamplerParameterIuivOES_p: APcv = ap_None();
    /// Tries to load [`glSamplerParameterIuivOES`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    #[cfg(any(feature = "GL_OES_texture_border_clamp"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_OES_texture_border_clamp"))))]
    pub unsafe fn glSamplerParameterIuivOES_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glSamplerParameterIuivOES\0",
            &glSamplerParameterIuivOES_p,
        )
    }
    /// Checks if the pointer for [`glSamplerParameterIuivOES`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    #[cfg(any(feature = "GL_OES_texture_border_clamp"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_OES_texture_border_clamp"))))]
    pub fn glSamplerParameterIuivOES_is_loaded() -> bool {
        !glSamplerParameterIuivOES_p.load(RELAX).is_null()
    }

    /// [glSamplerParameterf](http://docs.gl/es3/glSamplerParameter)(sampler, pname, param)
    /// `sampler` class: sampler
    /// `pname` group: SamplerParameterF
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn glSamplerParameterf(sampler: GLuint, pname: GLenum, param: GLfloat) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glSamplerParameterf({:?}, {:#X}, {:?});",
                sampler,
                pname,
                param
            );
        }
        let out = call_atomic_ptr_3arg(
            "glSamplerParameterf",
            &glSamplerParameterf_p,
            sampler,
            pname,
            param,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glSamplerParameterf");
        }
        out
    }
    static glSamplerParameterf_p: APcv = ap_None();
    /// Tries to load [`glSamplerParameterf`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    pub unsafe fn glSamplerParameterf_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glSamplerParameterf\0",
            &glSamplerParameterf_p,
        )
    }
    /// Checks if the pointer for [`glSamplerParameterf`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    pub fn glSamplerParameterf_is_loaded() -> bool {
        !glSamplerParameterf_p.load(RELAX).is_null()
    }

    /// [glSamplerParameterfv](http://docs.gl/es3/glSamplerParameter)(sampler, pname, param)
    /// `sampler` class: sampler
    /// `pname` group: SamplerParameterF
    /// `param` len: COMPSIZE(pname)
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn glSamplerParameterfv(sampler: GLuint, pname: GLenum, param: *const GLfloat) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glSamplerParameterfv({:?}, {:#X}, {:p});",
                sampler,
                pname,
                param
            );
        }
        let out = call_atomic_ptr_3arg(
            "glSamplerParameterfv",
            &glSamplerParameterfv_p,
            sampler,
            pname,
            param,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glSamplerParameterfv");
        }
        out
    }
    static glSamplerParameterfv_p: APcv = ap_None();
    /// Tries to load [`glSamplerParameterfv`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    pub unsafe fn glSamplerParameterfv_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glSamplerParameterfv\0",
            &glSamplerParameterfv_p,
        )
    }
    /// Checks if the pointer for [`glSamplerParameterfv`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    pub fn glSamplerParameterfv_is_loaded() -> bool {
        !glSamplerParameterfv_p.load(RELAX).is_null()
    }

    /// [glSamplerParameteri](http://docs.gl/es3/glSamplerParameter)(sampler, pname, param)
    /// `sampler` class: sampler
    /// `pname` group: SamplerParameterI
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn glSamplerParameteri(sampler: GLuint, pname: GLenum, param: GLint) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glSamplerParameteri({:?}, {:#X}, {:?});",
                sampler,
                pname,
                param
            );
        }
        let out = call_atomic_ptr_3arg(
            "glSamplerParameteri",
            &glSamplerParameteri_p,
            sampler,
            pname,
            param,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glSamplerParameteri");
        }
        out
    }
    static glSamplerParameteri_p: APcv = ap_None();
    /// Tries to load [`glSamplerParameteri`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    pub unsafe fn glSamplerParameteri_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glSamplerParameteri\0",
            &glSamplerParameteri_p,
        )
    }
    /// Checks if the pointer for [`glSamplerParameteri`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    pub fn glSamplerParameteri_is_loaded() -> bool {
        !glSamplerParameteri_p.load(RELAX).is_null()
    }

    /// [glSamplerParameteriv](http://docs.gl/es3/glSamplerParameter)(sampler, pname, param)
    /// `sampler` class: sampler
    /// `pname` group: SamplerParameterI
    /// `param` len: COMPSIZE(pname)
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn glSamplerParameteriv(sampler: GLuint, pname: GLenum, param: *const GLint) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glSamplerParameteriv({:?}, {:#X}, {:p});",
                sampler,
                pname,
                param
            );
        }
        let out = call_atomic_ptr_3arg(
            "glSamplerParameteriv",
            &glSamplerParameteriv_p,
            sampler,
            pname,
            param,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glSamplerParameteriv");
        }
        out
    }
    static glSamplerParameteriv_p: APcv = ap_None();
    /// Tries to load [`glSamplerParameteriv`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    pub unsafe fn glSamplerParameteriv_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glSamplerParameteriv\0",
            &glSamplerParameteriv_p,
        )
    }
    /// Checks if the pointer for [`glSamplerParameteriv`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    pub fn glSamplerParameteriv_is_loaded() -> bool {
        !glSamplerParameteriv_p.load(RELAX).is_null()
    }

    /// [glScissor](http://docs.gl/es3/glScissor)(x, y, width, height)
    /// `x` group: WinCoord
    /// `y` group: WinCoord
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn glScissor(x: GLint, y: GLint, width: GLsizei, height: GLsizei) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glScissor({:?}, {:?}, {:?}, {:?});",
                x,
                y,
                width,
                height
            );
        }
        let out = call_atomic_ptr_4arg("glScissor", &glScissor_p, x, y, width, height);
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glScissor");
        }
        out
    }
    static glScissor_p: APcv = ap_None();
    /// Tries to load [`glScissor`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    pub unsafe fn glScissor_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(get_proc_address, b"glScissor\0", &glScissor_p)
    }
    /// Checks if the pointer for [`glScissor`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    pub fn glScissor_is_loaded() -> bool {
        !glScissor_p.load(RELAX).is_null()
    }

    /// [glScissorArrayvNV](http://docs.gl/es3/glScissorArrayvNV)(first, count, v)
    /// `v` len: COMPSIZE(count)
    /// alias of: [`glScissorArrayv`]
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    #[cfg(any(feature = "GL_NV_viewport_array"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_viewport_array"))))]
    pub unsafe fn glScissorArrayvNV(first: GLuint, count: GLsizei, v: *const GLint) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glScissorArrayvNV({:?}, {:?}, {:p});",
                first,
                count,
                v
            );
        }
        let out = call_atomic_ptr_3arg("glScissorArrayvNV", &glScissorArrayvNV_p, first, count, v);
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glScissorArrayvNV");
        }
        out
    }
    #[cfg(any(feature = "GL_NV_viewport_array"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_viewport_array"))))]
    static glScissorArrayvNV_p: APcv = ap_None();
    /// Tries to load [`glScissorArrayvNV`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    #[cfg(any(feature = "GL_NV_viewport_array"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_viewport_array"))))]
    pub unsafe fn glScissorArrayvNV_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glScissorArrayvNV\0",
            &glScissorArrayvNV_p,
        )
    }
    /// Checks if the pointer for [`glScissorArrayvNV`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    #[cfg(any(feature = "GL_NV_viewport_array"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_viewport_array"))))]
    pub fn glScissorArrayvNV_is_loaded() -> bool {
        !glScissorArrayvNV_p.load(RELAX).is_null()
    }

    /// [glScissorArrayvOES](http://docs.gl/es3/glScissorArrayvOES)(first, count, v)
    /// `v` len: COMPSIZE(count)
    /// alias of: [`glScissorArrayv`]
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    #[cfg(any(feature = "GL_OES_viewport_array"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_OES_viewport_array"))))]
    pub unsafe fn glScissorArrayvOES(first: GLuint, count: GLsizei, v: *const GLint) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glScissorArrayvOES({:?}, {:?}, {:p});",
                first,
                count,
                v
            );
        }
        let out =
            call_atomic_ptr_3arg("glScissorArrayvOES", &glScissorArrayvOES_p, first, count, v);
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glScissorArrayvOES");
        }
        out
    }
    #[cfg(any(feature = "GL_OES_viewport_array"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_OES_viewport_array"))))]
    static glScissorArrayvOES_p: APcv = ap_None();
    /// Tries to load [`glScissorArrayvOES`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    #[cfg(any(feature = "GL_OES_viewport_array"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_OES_viewport_array"))))]
    pub unsafe fn glScissorArrayvOES_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glScissorArrayvOES\0",
            &glScissorArrayvOES_p,
        )
    }
    /// Checks if the pointer for [`glScissorArrayvOES`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    #[cfg(any(feature = "GL_OES_viewport_array"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_OES_viewport_array"))))]
    pub fn glScissorArrayvOES_is_loaded() -> bool {
        !glScissorArrayvOES_p.load(RELAX).is_null()
    }

    /// [glScissorExclusiveArrayvNV](http://docs.gl/es3/glScissorExclusiveArrayvNV)(first, count, v)
    /// `v` len: COMPSIZE(count)
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    #[cfg(any(feature = "GL_NV_scissor_exclusive"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_scissor_exclusive"))))]
    pub unsafe fn glScissorExclusiveArrayvNV(first: GLuint, count: GLsizei, v: *const GLint) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glScissorExclusiveArrayvNV({:?}, {:?}, {:p});",
                first,
                count,
                v
            );
        }
        let out = call_atomic_ptr_3arg(
            "glScissorExclusiveArrayvNV",
            &glScissorExclusiveArrayvNV_p,
            first,
            count,
            v,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glScissorExclusiveArrayvNV");
        }
        out
    }
    #[cfg(any(feature = "GL_NV_scissor_exclusive"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_scissor_exclusive"))))]
    static glScissorExclusiveArrayvNV_p: APcv = ap_None();
    /// Tries to load [`glScissorExclusiveArrayvNV`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    #[cfg(any(feature = "GL_NV_scissor_exclusive"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_scissor_exclusive"))))]
    pub unsafe fn glScissorExclusiveArrayvNV_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glScissorExclusiveArrayvNV\0",
            &glScissorExclusiveArrayvNV_p,
        )
    }
    /// Checks if the pointer for [`glScissorExclusiveArrayvNV`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    #[cfg(any(feature = "GL_NV_scissor_exclusive"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_scissor_exclusive"))))]
    pub fn glScissorExclusiveArrayvNV_is_loaded() -> bool {
        !glScissorExclusiveArrayvNV_p.load(RELAX).is_null()
    }

    /// [glScissorExclusiveNV](http://docs.gl/es3/glScissorExclusiveNV)(x, y, width, height)
    /// `x` group: WinCoord
    /// `y` group: WinCoord
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    #[cfg(any(feature = "GL_NV_scissor_exclusive"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_scissor_exclusive"))))]
    pub unsafe fn glScissorExclusiveNV(x: GLint, y: GLint, width: GLsizei, height: GLsizei) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glScissorExclusiveNV({:?}, {:?}, {:?}, {:?});",
                x,
                y,
                width,
                height
            );
        }
        let out = call_atomic_ptr_4arg(
            "glScissorExclusiveNV",
            &glScissorExclusiveNV_p,
            x,
            y,
            width,
            height,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glScissorExclusiveNV");
        }
        out
    }
    #[cfg(any(feature = "GL_NV_scissor_exclusive"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_scissor_exclusive"))))]
    static glScissorExclusiveNV_p: APcv = ap_None();
    /// Tries to load [`glScissorExclusiveNV`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    #[cfg(any(feature = "GL_NV_scissor_exclusive"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_scissor_exclusive"))))]
    pub unsafe fn glScissorExclusiveNV_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glScissorExclusiveNV\0",
            &glScissorExclusiveNV_p,
        )
    }
    /// Checks if the pointer for [`glScissorExclusiveNV`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    #[cfg(any(feature = "GL_NV_scissor_exclusive"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_scissor_exclusive"))))]
    pub fn glScissorExclusiveNV_is_loaded() -> bool {
        !glScissorExclusiveNV_p.load(RELAX).is_null()
    }

    /// [glScissorIndexedNV](http://docs.gl/es3/glScissorIndexedNV)(index, left, bottom, width, height)
    /// alias of: [`glScissorIndexed`]
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    #[cfg(any(feature = "GL_NV_viewport_array"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_viewport_array"))))]
    pub unsafe fn glScissorIndexedNV(
        index: GLuint,
        left: GLint,
        bottom: GLint,
        width: GLsizei,
        height: GLsizei,
    ) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glScissorIndexedNV({:?}, {:?}, {:?}, {:?}, {:?});",
                index,
                left,
                bottom,
                width,
                height
            );
        }
        let out = call_atomic_ptr_5arg(
            "glScissorIndexedNV",
            &glScissorIndexedNV_p,
            index,
            left,
            bottom,
            width,
            height,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glScissorIndexedNV");
        }
        out
    }
    #[cfg(any(feature = "GL_NV_viewport_array"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_viewport_array"))))]
    static glScissorIndexedNV_p: APcv = ap_None();
    /// Tries to load [`glScissorIndexedNV`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    #[cfg(any(feature = "GL_NV_viewport_array"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_viewport_array"))))]
    pub unsafe fn glScissorIndexedNV_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glScissorIndexedNV\0",
            &glScissorIndexedNV_p,
        )
    }
    /// Checks if the pointer for [`glScissorIndexedNV`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    #[cfg(any(feature = "GL_NV_viewport_array"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_viewport_array"))))]
    pub fn glScissorIndexedNV_is_loaded() -> bool {
        !glScissorIndexedNV_p.load(RELAX).is_null()
    }

    /// [glScissorIndexedOES](http://docs.gl/es3/glScissorIndexedOES)(index, left, bottom, width, height)
    /// alias of: [`glScissorIndexed`]
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    #[cfg(any(feature = "GL_OES_viewport_array"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_OES_viewport_array"))))]
    pub unsafe fn glScissorIndexedOES(
        index: GLuint,
        left: GLint,
        bottom: GLint,
        width: GLsizei,
        height: GLsizei,
    ) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glScissorIndexedOES({:?}, {:?}, {:?}, {:?}, {:?});",
                index,
                left,
                bottom,
                width,
                height
            );
        }
        let out = call_atomic_ptr_5arg(
            "glScissorIndexedOES",
            &glScissorIndexedOES_p,
            index,
            left,
            bottom,
            width,
            height,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glScissorIndexedOES");
        }
        out
    }
    #[cfg(any(feature = "GL_OES_viewport_array"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_OES_viewport_array"))))]
    static glScissorIndexedOES_p: APcv = ap_None();
    /// Tries to load [`glScissorIndexedOES`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    #[cfg(any(feature = "GL_OES_viewport_array"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_OES_viewport_array"))))]
    pub unsafe fn glScissorIndexedOES_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glScissorIndexedOES\0",
            &glScissorIndexedOES_p,
        )
    }
    /// Checks if the pointer for [`glScissorIndexedOES`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    #[cfg(any(feature = "GL_OES_viewport_array"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_OES_viewport_array"))))]
    pub fn glScissorIndexedOES_is_loaded() -> bool {
        !glScissorIndexedOES_p.load(RELAX).is_null()
    }

    /// [glScissorIndexedvNV](http://docs.gl/es3/glScissorIndexedvNV)(index, v)
    /// `v` len: 4
    /// alias of: [`glScissorIndexedv`]
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    #[cfg(any(feature = "GL_NV_viewport_array"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_viewport_array"))))]
    pub unsafe fn glScissorIndexedvNV(index: GLuint, v: *const GLint) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!("calling glScissorIndexedvNV({:?}, {:p});", index, v);
        }
        let out = call_atomic_ptr_2arg("glScissorIndexedvNV", &glScissorIndexedvNV_p, index, v);
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glScissorIndexedvNV");
        }
        out
    }
    #[cfg(any(feature = "GL_NV_viewport_array"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_viewport_array"))))]
    static glScissorIndexedvNV_p: APcv = ap_None();
    /// Tries to load [`glScissorIndexedvNV`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    #[cfg(any(feature = "GL_NV_viewport_array"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_viewport_array"))))]
    pub unsafe fn glScissorIndexedvNV_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glScissorIndexedvNV\0",
            &glScissorIndexedvNV_p,
        )
    }
    /// Checks if the pointer for [`glScissorIndexedvNV`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    #[cfg(any(feature = "GL_NV_viewport_array"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_viewport_array"))))]
    pub fn glScissorIndexedvNV_is_loaded() -> bool {
        !glScissorIndexedvNV_p.load(RELAX).is_null()
    }

    /// [glScissorIndexedvOES](http://docs.gl/es3/glScissorIndexedvOES)(index, v)
    /// `v` len: 4
    /// alias of: [`glScissorIndexedv`]
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    #[cfg(any(feature = "GL_OES_viewport_array"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_OES_viewport_array"))))]
    pub unsafe fn glScissorIndexedvOES(index: GLuint, v: *const GLint) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!("calling glScissorIndexedvOES({:?}, {:p});", index, v);
        }
        let out = call_atomic_ptr_2arg("glScissorIndexedvOES", &glScissorIndexedvOES_p, index, v);
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glScissorIndexedvOES");
        }
        out
    }
    #[cfg(any(feature = "GL_OES_viewport_array"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_OES_viewport_array"))))]
    static glScissorIndexedvOES_p: APcv = ap_None();
    /// Tries to load [`glScissorIndexedvOES`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    #[cfg(any(feature = "GL_OES_viewport_array"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_OES_viewport_array"))))]
    pub unsafe fn glScissorIndexedvOES_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glScissorIndexedvOES\0",
            &glScissorIndexedvOES_p,
        )
    }
    /// Checks if the pointer for [`glScissorIndexedvOES`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    #[cfg(any(feature = "GL_OES_viewport_array"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_OES_viewport_array"))))]
    pub fn glScissorIndexedvOES_is_loaded() -> bool {
        !glScissorIndexedvOES_p.load(RELAX).is_null()
    }

    /// [glSelectPerfMonitorCountersAMD](http://docs.gl/es3/glSelectPerfMonitorCountersAMD)(monitor, enable, group, numCounters, counterList)
    /// `counterList` len: numCounters
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    #[cfg(any(feature = "GL_AMD_performance_monitor"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_AMD_performance_monitor"))))]
    pub unsafe fn glSelectPerfMonitorCountersAMD(
        monitor: GLuint,
        enable: GLboolean,
        group: GLuint,
        numCounters: GLint,
        counterList: *mut GLuint,
    ) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glSelectPerfMonitorCountersAMD({:?}, {:?}, {:?}, {:?}, {:p});",
                monitor,
                enable,
                group,
                numCounters,
                counterList
            );
        }
        let out = call_atomic_ptr_5arg(
            "glSelectPerfMonitorCountersAMD",
            &glSelectPerfMonitorCountersAMD_p,
            monitor,
            enable,
            group,
            numCounters,
            counterList,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glSelectPerfMonitorCountersAMD");
        }
        out
    }
    #[cfg(any(feature = "GL_AMD_performance_monitor"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_AMD_performance_monitor"))))]
    static glSelectPerfMonitorCountersAMD_p: APcv = ap_None();
    /// Tries to load [`glSelectPerfMonitorCountersAMD`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    #[cfg(any(feature = "GL_AMD_performance_monitor"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_AMD_performance_monitor"))))]
    pub unsafe fn glSelectPerfMonitorCountersAMD_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glSelectPerfMonitorCountersAMD\0",
            &glSelectPerfMonitorCountersAMD_p,
        )
    }
    /// Checks if the pointer for [`glSelectPerfMonitorCountersAMD`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    #[cfg(any(feature = "GL_AMD_performance_monitor"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_AMD_performance_monitor"))))]
    pub fn glSelectPerfMonitorCountersAMD_is_loaded() -> bool {
        !glSelectPerfMonitorCountersAMD_p.load(RELAX).is_null()
    }

    /// [glSemaphoreParameterivNV](http://docs.gl/es3/glSemaphoreParameterivNV)(semaphore, pname, params)
    /// `pname` group: SemaphoreParameterName
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    #[cfg(any(feature = "GL_NV_timeline_semaphore"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_timeline_semaphore"))))]
    pub unsafe fn glSemaphoreParameterivNV(semaphore: GLuint, pname: GLenum, params: *const GLint) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glSemaphoreParameterivNV({:?}, {:#X}, {:p});",
                semaphore,
                pname,
                params
            );
        }
        let out = call_atomic_ptr_3arg(
            "glSemaphoreParameterivNV",
            &glSemaphoreParameterivNV_p,
            semaphore,
            pname,
            params,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glSemaphoreParameterivNV");
        }
        out
    }
    #[cfg(any(feature = "GL_NV_timeline_semaphore"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_timeline_semaphore"))))]
    static glSemaphoreParameterivNV_p: APcv = ap_None();
    /// Tries to load [`glSemaphoreParameterivNV`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    #[cfg(any(feature = "GL_NV_timeline_semaphore"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_timeline_semaphore"))))]
    pub unsafe fn glSemaphoreParameterivNV_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glSemaphoreParameterivNV\0",
            &glSemaphoreParameterivNV_p,
        )
    }
    /// Checks if the pointer for [`glSemaphoreParameterivNV`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    #[cfg(any(feature = "GL_NV_timeline_semaphore"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_timeline_semaphore"))))]
    pub fn glSemaphoreParameterivNV_is_loaded() -> bool {
        !glSemaphoreParameterivNV_p.load(RELAX).is_null()
    }

    /// [glSemaphoreParameterui64vEXT](http://docs.gl/es3/glSemaphoreParameterui64vEXT)(semaphore, pname, params)
    /// `pname` group: SemaphoreParameterName
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    #[cfg(any(feature = "GL_EXT_semaphore"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_semaphore"))))]
    pub unsafe fn glSemaphoreParameterui64vEXT(
        semaphore: GLuint,
        pname: GLenum,
        params: *const GLuint64,
    ) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glSemaphoreParameterui64vEXT({:?}, {:#X}, {:p});",
                semaphore,
                pname,
                params
            );
        }
        let out = call_atomic_ptr_3arg(
            "glSemaphoreParameterui64vEXT",
            &glSemaphoreParameterui64vEXT_p,
            semaphore,
            pname,
            params,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glSemaphoreParameterui64vEXT");
        }
        out
    }
    #[cfg(any(feature = "GL_EXT_semaphore"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_semaphore"))))]
    static glSemaphoreParameterui64vEXT_p: APcv = ap_None();
    /// Tries to load [`glSemaphoreParameterui64vEXT`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    #[cfg(any(feature = "GL_EXT_semaphore"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_semaphore"))))]
    pub unsafe fn glSemaphoreParameterui64vEXT_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glSemaphoreParameterui64vEXT\0",
            &glSemaphoreParameterui64vEXT_p,
        )
    }
    /// Checks if the pointer for [`glSemaphoreParameterui64vEXT`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    #[cfg(any(feature = "GL_EXT_semaphore"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_semaphore"))))]
    pub fn glSemaphoreParameterui64vEXT_is_loaded() -> bool {
        !glSemaphoreParameterui64vEXT_p.load(RELAX).is_null()
    }

    /// [glSetFenceNV](http://docs.gl/es3/glSetFenceNV)(fence, condition)
    /// `fence` group: FenceNV
    /// `condition` group: FenceConditionNV
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    #[cfg(any(feature = "GL_NV_fence"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_fence"))))]
    pub unsafe fn glSetFenceNV(fence: GLuint, condition: GLenum) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!("calling glSetFenceNV({:?}, {:#X});", fence, condition);
        }
        let out = call_atomic_ptr_2arg("glSetFenceNV", &glSetFenceNV_p, fence, condition);
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glSetFenceNV");
        }
        out
    }
    #[cfg(any(feature = "GL_NV_fence"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_fence"))))]
    static glSetFenceNV_p: APcv = ap_None();
    /// Tries to load [`glSetFenceNV`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    #[cfg(any(feature = "GL_NV_fence"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_fence"))))]
    pub unsafe fn glSetFenceNV_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(get_proc_address, b"glSetFenceNV\0", &glSetFenceNV_p)
    }
    /// Checks if the pointer for [`glSetFenceNV`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    #[cfg(any(feature = "GL_NV_fence"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_fence"))))]
    pub fn glSetFenceNV_is_loaded() -> bool {
        !glSetFenceNV_p.load(RELAX).is_null()
    }

    /// [glShaderBinary](http://docs.gl/es3/glShaderBinary)(count, shaders, binaryFormat, binary, length)
    /// `shaders` len: count
    /// `shaders` class: shader
    /// `binaryFormat` group: ShaderBinaryFormat
    /// `binary` len: length
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn glShaderBinary(
        count: GLsizei,
        shaders: *const GLuint,
        binaryFormat: GLenum,
        binary: *const c_void,
        length: GLsizei,
    ) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glShaderBinary({:?}, {:p}, {:#X}, {:p}, {:?});",
                count,
                shaders,
                binaryFormat,
                binary,
                length
            );
        }
        let out = call_atomic_ptr_5arg(
            "glShaderBinary",
            &glShaderBinary_p,
            count,
            shaders,
            binaryFormat,
            binary,
            length,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glShaderBinary");
        }
        out
    }
    static glShaderBinary_p: APcv = ap_None();
    /// Tries to load [`glShaderBinary`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    pub unsafe fn glShaderBinary_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(get_proc_address, b"glShaderBinary\0", &glShaderBinary_p)
    }
    /// Checks if the pointer for [`glShaderBinary`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    pub fn glShaderBinary_is_loaded() -> bool {
        !glShaderBinary_p.load(RELAX).is_null()
    }

    /// [glShaderSource](http://docs.gl/es3/glShaderSource)(shader, count, string, length)
    /// `shader` class: shader
    /// `string` len: count
    /// `length` len: count
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn glShaderSource(
        shader: GLuint,
        count: GLsizei,
        string: *const *const GLchar,
        length: *const GLint,
    ) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glShaderSource({:?}, {:?}, {:p}, {:p});",
                shader,
                count,
                string,
                length
            );
        }
        let out = call_atomic_ptr_4arg(
            "glShaderSource",
            &glShaderSource_p,
            shader,
            count,
            string,
            length,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glShaderSource");
        }
        out
    }
    static glShaderSource_p: APcv = ap_None();
    /// Tries to load [`glShaderSource`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    pub unsafe fn glShaderSource_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(get_proc_address, b"glShaderSource\0", &glShaderSource_p)
    }
    /// Checks if the pointer for [`glShaderSource`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    pub fn glShaderSource_is_loaded() -> bool {
        !glShaderSource_p.load(RELAX).is_null()
    }

    /// [glShadingRateImageBarrierNV](http://docs.gl/es3/glShadingRateImageBarrierNV)(synchronize)
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    #[cfg(any(feature = "GL_NV_shading_rate_image"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_shading_rate_image"))))]
    pub unsafe fn glShadingRateImageBarrierNV(synchronize: GLboolean) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!("calling glShadingRateImageBarrierNV({:?});", synchronize);
        }
        let out = call_atomic_ptr_1arg(
            "glShadingRateImageBarrierNV",
            &glShadingRateImageBarrierNV_p,
            synchronize,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glShadingRateImageBarrierNV");
        }
        out
    }
    #[cfg(any(feature = "GL_NV_shading_rate_image"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_shading_rate_image"))))]
    static glShadingRateImageBarrierNV_p: APcv = ap_None();
    /// Tries to load [`glShadingRateImageBarrierNV`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    #[cfg(any(feature = "GL_NV_shading_rate_image"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_shading_rate_image"))))]
    pub unsafe fn glShadingRateImageBarrierNV_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glShadingRateImageBarrierNV\0",
            &glShadingRateImageBarrierNV_p,
        )
    }
    /// Checks if the pointer for [`glShadingRateImageBarrierNV`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    #[cfg(any(feature = "GL_NV_shading_rate_image"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_shading_rate_image"))))]
    pub fn glShadingRateImageBarrierNV_is_loaded() -> bool {
        !glShadingRateImageBarrierNV_p.load(RELAX).is_null()
    }

    /// [glShadingRateImagePaletteNV](http://docs.gl/es3/glShadingRateImagePaletteNV)(viewport, first, count, rates)
    /// `rates` len: count
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    #[cfg(any(feature = "GL_NV_shading_rate_image"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_shading_rate_image"))))]
    pub unsafe fn glShadingRateImagePaletteNV(
        viewport: GLuint,
        first: GLuint,
        count: GLsizei,
        rates: *const GLenum,
    ) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glShadingRateImagePaletteNV({:?}, {:?}, {:?}, {:p});",
                viewport,
                first,
                count,
                rates
            );
        }
        let out = call_atomic_ptr_4arg(
            "glShadingRateImagePaletteNV",
            &glShadingRateImagePaletteNV_p,
            viewport,
            first,
            count,
            rates,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glShadingRateImagePaletteNV");
        }
        out
    }
    #[cfg(any(feature = "GL_NV_shading_rate_image"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_shading_rate_image"))))]
    static glShadingRateImagePaletteNV_p: APcv = ap_None();
    /// Tries to load [`glShadingRateImagePaletteNV`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    #[cfg(any(feature = "GL_NV_shading_rate_image"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_shading_rate_image"))))]
    pub unsafe fn glShadingRateImagePaletteNV_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glShadingRateImagePaletteNV\0",
            &glShadingRateImagePaletteNV_p,
        )
    }
    /// Checks if the pointer for [`glShadingRateImagePaletteNV`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    #[cfg(any(feature = "GL_NV_shading_rate_image"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_shading_rate_image"))))]
    pub fn glShadingRateImagePaletteNV_is_loaded() -> bool {
        !glShadingRateImagePaletteNV_p.load(RELAX).is_null()
    }

    /// [glShadingRateQCOM](http://docs.gl/es3/glShadingRateQCOM)(rate)
    /// `rate` group: ShadingRateQCOM
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    #[cfg(any(feature = "GL_QCOM_shading_rate"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_QCOM_shading_rate"))))]
    pub unsafe fn glShadingRateQCOM(rate: GLenum) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!("calling glShadingRateQCOM({:#X});", rate);
        }
        let out = call_atomic_ptr_1arg("glShadingRateQCOM", &glShadingRateQCOM_p, rate);
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glShadingRateQCOM");
        }
        out
    }
    #[cfg(any(feature = "GL_QCOM_shading_rate"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_QCOM_shading_rate"))))]
    static glShadingRateQCOM_p: APcv = ap_None();
    /// Tries to load [`glShadingRateQCOM`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    #[cfg(any(feature = "GL_QCOM_shading_rate"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_QCOM_shading_rate"))))]
    pub unsafe fn glShadingRateQCOM_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glShadingRateQCOM\0",
            &glShadingRateQCOM_p,
        )
    }
    /// Checks if the pointer for [`glShadingRateQCOM`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    #[cfg(any(feature = "GL_QCOM_shading_rate"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_QCOM_shading_rate"))))]
    pub fn glShadingRateQCOM_is_loaded() -> bool {
        !glShadingRateQCOM_p.load(RELAX).is_null()
    }

    /// [glShadingRateSampleOrderCustomNV](http://docs.gl/es3/glShadingRateSampleOrderCustomNV)(rate, samples, locations)
    /// `locations` len: COMPSIZE(rate,samples)
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    #[cfg(any(feature = "GL_NV_shading_rate_image"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_shading_rate_image"))))]
    pub unsafe fn glShadingRateSampleOrderCustomNV(
        rate: GLenum,
        samples: GLuint,
        locations: *const GLint,
    ) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glShadingRateSampleOrderCustomNV({:#X}, {:?}, {:p});",
                rate,
                samples,
                locations
            );
        }
        let out = call_atomic_ptr_3arg(
            "glShadingRateSampleOrderCustomNV",
            &glShadingRateSampleOrderCustomNV_p,
            rate,
            samples,
            locations,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glShadingRateSampleOrderCustomNV");
        }
        out
    }
    #[cfg(any(feature = "GL_NV_shading_rate_image"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_shading_rate_image"))))]
    static glShadingRateSampleOrderCustomNV_p: APcv = ap_None();
    /// Tries to load [`glShadingRateSampleOrderCustomNV`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    #[cfg(any(feature = "GL_NV_shading_rate_image"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_shading_rate_image"))))]
    pub unsafe fn glShadingRateSampleOrderCustomNV_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glShadingRateSampleOrderCustomNV\0",
            &glShadingRateSampleOrderCustomNV_p,
        )
    }
    /// Checks if the pointer for [`glShadingRateSampleOrderCustomNV`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    #[cfg(any(feature = "GL_NV_shading_rate_image"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_shading_rate_image"))))]
    pub fn glShadingRateSampleOrderCustomNV_is_loaded() -> bool {
        !glShadingRateSampleOrderCustomNV_p.load(RELAX).is_null()
    }

    /// [glShadingRateSampleOrderNV](http://docs.gl/es3/glShadingRateSampleOrderNV)(order)
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    #[cfg(any(feature = "GL_NV_shading_rate_image"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_shading_rate_image"))))]
    pub unsafe fn glShadingRateSampleOrderNV(order: GLenum) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!("calling glShadingRateSampleOrderNV({:#X});", order);
        }
        let out = call_atomic_ptr_1arg(
            "glShadingRateSampleOrderNV",
            &glShadingRateSampleOrderNV_p,
            order,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glShadingRateSampleOrderNV");
        }
        out
    }
    #[cfg(any(feature = "GL_NV_shading_rate_image"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_shading_rate_image"))))]
    static glShadingRateSampleOrderNV_p: APcv = ap_None();
    /// Tries to load [`glShadingRateSampleOrderNV`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    #[cfg(any(feature = "GL_NV_shading_rate_image"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_shading_rate_image"))))]
    pub unsafe fn glShadingRateSampleOrderNV_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glShadingRateSampleOrderNV\0",
            &glShadingRateSampleOrderNV_p,
        )
    }
    /// Checks if the pointer for [`glShadingRateSampleOrderNV`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    #[cfg(any(feature = "GL_NV_shading_rate_image"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_shading_rate_image"))))]
    pub fn glShadingRateSampleOrderNV_is_loaded() -> bool {
        !glShadingRateSampleOrderNV_p.load(RELAX).is_null()
    }

    /// [glSignalSemaphoreEXT](http://docs.gl/es3/glSignalSemaphoreEXT)(semaphore, numBufferBarriers, buffers, numTextureBarriers, textures, dstLayouts)
    /// `buffers` len: COMPSIZE(numBufferBarriers)
    /// `buffers` class: buffer
    /// `textures` len: COMPSIZE(numTextureBarriers)
    /// `textures` class: texture
    /// `dstLayouts` group: TextureLayout
    /// `dstLayouts` len: COMPSIZE(numTextureBarriers)
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    #[cfg(any(feature = "GL_EXT_semaphore"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_semaphore"))))]
    pub unsafe fn glSignalSemaphoreEXT(
        semaphore: GLuint,
        numBufferBarriers: GLuint,
        buffers: *const GLuint,
        numTextureBarriers: GLuint,
        textures: *const GLuint,
        dstLayouts: *const GLenum,
    ) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glSignalSemaphoreEXT({:?}, {:?}, {:p}, {:?}, {:p}, {:p});",
                semaphore,
                numBufferBarriers,
                buffers,
                numTextureBarriers,
                textures,
                dstLayouts
            );
        }
        let out = call_atomic_ptr_6arg(
            "glSignalSemaphoreEXT",
            &glSignalSemaphoreEXT_p,
            semaphore,
            numBufferBarriers,
            buffers,
            numTextureBarriers,
            textures,
            dstLayouts,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glSignalSemaphoreEXT");
        }
        out
    }
    #[cfg(any(feature = "GL_EXT_semaphore"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_semaphore"))))]
    static glSignalSemaphoreEXT_p: APcv = ap_None();
    /// Tries to load [`glSignalSemaphoreEXT`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    #[cfg(any(feature = "GL_EXT_semaphore"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_semaphore"))))]
    pub unsafe fn glSignalSemaphoreEXT_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glSignalSemaphoreEXT\0",
            &glSignalSemaphoreEXT_p,
        )
    }
    /// Checks if the pointer for [`glSignalSemaphoreEXT`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    #[cfg(any(feature = "GL_EXT_semaphore"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_semaphore"))))]
    pub fn glSignalSemaphoreEXT_is_loaded() -> bool {
        !glSignalSemaphoreEXT_p.load(RELAX).is_null()
    }

    /// [glSignalVkFenceNV](http://docs.gl/es3/glSignalVkFenceNV)(vkFence)
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    #[cfg(any(feature = "GL_NV_draw_vulkan_image"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_draw_vulkan_image"))))]
    pub unsafe fn glSignalVkFenceNV(vkFence: GLuint64) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!("calling glSignalVkFenceNV({:?});", vkFence);
        }
        let out = call_atomic_ptr_1arg("glSignalVkFenceNV", &glSignalVkFenceNV_p, vkFence);
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glSignalVkFenceNV");
        }
        out
    }
    #[cfg(any(feature = "GL_NV_draw_vulkan_image"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_draw_vulkan_image"))))]
    static glSignalVkFenceNV_p: APcv = ap_None();
    /// Tries to load [`glSignalVkFenceNV`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    #[cfg(any(feature = "GL_NV_draw_vulkan_image"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_draw_vulkan_image"))))]
    pub unsafe fn glSignalVkFenceNV_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glSignalVkFenceNV\0",
            &glSignalVkFenceNV_p,
        )
    }
    /// Checks if the pointer for [`glSignalVkFenceNV`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    #[cfg(any(feature = "GL_NV_draw_vulkan_image"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_draw_vulkan_image"))))]
    pub fn glSignalVkFenceNV_is_loaded() -> bool {
        !glSignalVkFenceNV_p.load(RELAX).is_null()
    }

    /// [glSignalVkSemaphoreNV](http://docs.gl/es3/glSignalVkSemaphoreNV)(vkSemaphore)
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    #[cfg(any(feature = "GL_NV_draw_vulkan_image"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_draw_vulkan_image"))))]
    pub unsafe fn glSignalVkSemaphoreNV(vkSemaphore: GLuint64) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!("calling glSignalVkSemaphoreNV({:?});", vkSemaphore);
        }
        let out = call_atomic_ptr_1arg(
            "glSignalVkSemaphoreNV",
            &glSignalVkSemaphoreNV_p,
            vkSemaphore,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glSignalVkSemaphoreNV");
        }
        out
    }
    #[cfg(any(feature = "GL_NV_draw_vulkan_image"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_draw_vulkan_image"))))]
    static glSignalVkSemaphoreNV_p: APcv = ap_None();
    /// Tries to load [`glSignalVkSemaphoreNV`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    #[cfg(any(feature = "GL_NV_draw_vulkan_image"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_draw_vulkan_image"))))]
    pub unsafe fn glSignalVkSemaphoreNV_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glSignalVkSemaphoreNV\0",
            &glSignalVkSemaphoreNV_p,
        )
    }
    /// Checks if the pointer for [`glSignalVkSemaphoreNV`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    #[cfg(any(feature = "GL_NV_draw_vulkan_image"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_draw_vulkan_image"))))]
    pub fn glSignalVkSemaphoreNV_is_loaded() -> bool {
        !glSignalVkSemaphoreNV_p.load(RELAX).is_null()
    }

    /// [glStartTilingQCOM](http://docs.gl/es3/glStartTilingQCOM)(x, y, width, height, preserveMask)
    /// `preserveMask` group: BufferBitQCOM
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    #[cfg(any(feature = "GL_QCOM_tiled_rendering"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_QCOM_tiled_rendering"))))]
    pub unsafe fn glStartTilingQCOM(
        x: GLuint,
        y: GLuint,
        width: GLuint,
        height: GLuint,
        preserveMask: GLbitfield,
    ) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glStartTilingQCOM({:?}, {:?}, {:?}, {:?}, {:?});",
                x,
                y,
                width,
                height,
                preserveMask
            );
        }
        let out = call_atomic_ptr_5arg(
            "glStartTilingQCOM",
            &glStartTilingQCOM_p,
            x,
            y,
            width,
            height,
            preserveMask,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glStartTilingQCOM");
        }
        out
    }
    #[cfg(any(feature = "GL_QCOM_tiled_rendering"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_QCOM_tiled_rendering"))))]
    static glStartTilingQCOM_p: APcv = ap_None();
    /// Tries to load [`glStartTilingQCOM`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    #[cfg(any(feature = "GL_QCOM_tiled_rendering"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_QCOM_tiled_rendering"))))]
    pub unsafe fn glStartTilingQCOM_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glStartTilingQCOM\0",
            &glStartTilingQCOM_p,
        )
    }
    /// Checks if the pointer for [`glStartTilingQCOM`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    #[cfg(any(feature = "GL_QCOM_tiled_rendering"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_QCOM_tiled_rendering"))))]
    pub fn glStartTilingQCOM_is_loaded() -> bool {
        !glStartTilingQCOM_p.load(RELAX).is_null()
    }

    /// [glStencilFillPathInstancedNV](http://docs.gl/es3/glStencilFillPathInstancedNV)(numPaths, pathNameType, paths, pathBase, fillMode, mask, transformType, transformValues)
    /// `pathNameType` group: PathElementType
    /// `paths` group: PathElement
    /// `paths` len: COMPSIZE(numPaths,pathNameType,paths)
    /// `pathBase` group: Path
    /// `fillMode` group: PathFillMode
    /// `mask` group: MaskedStencilValue
    /// `transformType` group: PathTransformType
    /// `transformValues` len: COMPSIZE(numPaths,transformType)
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    #[cfg(any(feature = "GL_NV_path_rendering"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_path_rendering"))))]
    pub unsafe fn glStencilFillPathInstancedNV(
        numPaths: GLsizei,
        pathNameType: GLenum,
        paths: *const c_void,
        pathBase: GLuint,
        fillMode: GLenum,
        mask: GLuint,
        transformType: GLenum,
        transformValues: *const GLfloat,
    ) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glStencilFillPathInstancedNV({:?}, {:#X}, {:p}, {:?}, {:#X}, {:?}, {:#X}, {:p});",
                numPaths,
                pathNameType,
                paths,
                pathBase,
                fillMode,
                mask,
                transformType,
                transformValues
            );
        }
        let out = call_atomic_ptr_8arg(
            "glStencilFillPathInstancedNV",
            &glStencilFillPathInstancedNV_p,
            numPaths,
            pathNameType,
            paths,
            pathBase,
            fillMode,
            mask,
            transformType,
            transformValues,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glStencilFillPathInstancedNV");
        }
        out
    }
    #[cfg(any(feature = "GL_NV_path_rendering"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_path_rendering"))))]
    static glStencilFillPathInstancedNV_p: APcv = ap_None();
    /// Tries to load [`glStencilFillPathInstancedNV`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    #[cfg(any(feature = "GL_NV_path_rendering"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_path_rendering"))))]
    pub unsafe fn glStencilFillPathInstancedNV_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glStencilFillPathInstancedNV\0",
            &glStencilFillPathInstancedNV_p,
        )
    }
    /// Checks if the pointer for [`glStencilFillPathInstancedNV`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    #[cfg(any(feature = "GL_NV_path_rendering"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_path_rendering"))))]
    pub fn glStencilFillPathInstancedNV_is_loaded() -> bool {
        !glStencilFillPathInstancedNV_p.load(RELAX).is_null()
    }

    /// [glStencilFillPathNV](http://docs.gl/es3/glStencilFillPathNV)(path, fillMode, mask)
    /// `path` group: Path
    /// `fillMode` group: PathFillMode
    /// `mask` group: MaskedStencilValue
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    #[cfg(any(feature = "GL_NV_path_rendering"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_path_rendering"))))]
    pub unsafe fn glStencilFillPathNV(path: GLuint, fillMode: GLenum, mask: GLuint) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glStencilFillPathNV({:?}, {:#X}, {:?});",
                path,
                fillMode,
                mask
            );
        }
        let out = call_atomic_ptr_3arg(
            "glStencilFillPathNV",
            &glStencilFillPathNV_p,
            path,
            fillMode,
            mask,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glStencilFillPathNV");
        }
        out
    }
    #[cfg(any(feature = "GL_NV_path_rendering"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_path_rendering"))))]
    static glStencilFillPathNV_p: APcv = ap_None();
    /// Tries to load [`glStencilFillPathNV`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    #[cfg(any(feature = "GL_NV_path_rendering"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_path_rendering"))))]
    pub unsafe fn glStencilFillPathNV_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glStencilFillPathNV\0",
            &glStencilFillPathNV_p,
        )
    }
    /// Checks if the pointer for [`glStencilFillPathNV`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    #[cfg(any(feature = "GL_NV_path_rendering"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_path_rendering"))))]
    pub fn glStencilFillPathNV_is_loaded() -> bool {
        !glStencilFillPathNV_p.load(RELAX).is_null()
    }

    /// [glStencilFunc](http://docs.gl/es3/glStencilFunc)(func, ref_, mask)
    /// `func` group: StencilFunction
    /// `ref_` group: StencilValue
    /// `mask` group: MaskedStencilValue
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn glStencilFunc(func: GLenum, ref_: GLint, mask: GLuint) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glStencilFunc({:#X}, {:?}, {:?});",
                func,
                ref_,
                mask
            );
        }
        let out = call_atomic_ptr_3arg("glStencilFunc", &glStencilFunc_p, func, ref_, mask);
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glStencilFunc");
        }
        out
    }
    static glStencilFunc_p: APcv = ap_None();
    /// Tries to load [`glStencilFunc`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    pub unsafe fn glStencilFunc_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(get_proc_address, b"glStencilFunc\0", &glStencilFunc_p)
    }
    /// Checks if the pointer for [`glStencilFunc`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    pub fn glStencilFunc_is_loaded() -> bool {
        !glStencilFunc_p.load(RELAX).is_null()
    }

    /// [glStencilFuncSeparate](http://docs.gl/es3/glStencilFuncSeparate)(face, func, ref_, mask)
    /// `face` group: StencilFaceDirection
    /// `func` group: StencilFunction
    /// `ref_` group: StencilValue
    /// `mask` group: MaskedStencilValue
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn glStencilFuncSeparate(face: GLenum, func: GLenum, ref_: GLint, mask: GLuint) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glStencilFuncSeparate({:#X}, {:#X}, {:?}, {:?});",
                face,
                func,
                ref_,
                mask
            );
        }
        let out = call_atomic_ptr_4arg(
            "glStencilFuncSeparate",
            &glStencilFuncSeparate_p,
            face,
            func,
            ref_,
            mask,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glStencilFuncSeparate");
        }
        out
    }
    static glStencilFuncSeparate_p: APcv = ap_None();
    /// Tries to load [`glStencilFuncSeparate`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    pub unsafe fn glStencilFuncSeparate_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glStencilFuncSeparate\0",
            &glStencilFuncSeparate_p,
        )
    }
    /// Checks if the pointer for [`glStencilFuncSeparate`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    pub fn glStencilFuncSeparate_is_loaded() -> bool {
        !glStencilFuncSeparate_p.load(RELAX).is_null()
    }

    /// [glStencilMask](http://docs.gl/es3/glStencilMask)(mask)
    /// `mask` group: MaskedStencilValue
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn glStencilMask(mask: GLuint) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!("calling glStencilMask({:?});", mask);
        }
        let out = call_atomic_ptr_1arg("glStencilMask", &glStencilMask_p, mask);
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glStencilMask");
        }
        out
    }
    static glStencilMask_p: APcv = ap_None();
    /// Tries to load [`glStencilMask`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    pub unsafe fn glStencilMask_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(get_proc_address, b"glStencilMask\0", &glStencilMask_p)
    }
    /// Checks if the pointer for [`glStencilMask`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    pub fn glStencilMask_is_loaded() -> bool {
        !glStencilMask_p.load(RELAX).is_null()
    }

    /// [glStencilMaskSeparate](http://docs.gl/es3/glStencilMaskSeparate)(face, mask)
    /// `face` group: StencilFaceDirection
    /// `mask` group: MaskedStencilValue
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn glStencilMaskSeparate(face: GLenum, mask: GLuint) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!("calling glStencilMaskSeparate({:#X}, {:?});", face, mask);
        }
        let out = call_atomic_ptr_2arg(
            "glStencilMaskSeparate",
            &glStencilMaskSeparate_p,
            face,
            mask,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glStencilMaskSeparate");
        }
        out
    }
    static glStencilMaskSeparate_p: APcv = ap_None();
    /// Tries to load [`glStencilMaskSeparate`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    pub unsafe fn glStencilMaskSeparate_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glStencilMaskSeparate\0",
            &glStencilMaskSeparate_p,
        )
    }
    /// Checks if the pointer for [`glStencilMaskSeparate`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    pub fn glStencilMaskSeparate_is_loaded() -> bool {
        !glStencilMaskSeparate_p.load(RELAX).is_null()
    }

    /// [glStencilOp](http://docs.gl/es3/glStencilOp)(fail, zfail, zpass)
    /// `fail` group: StencilOp
    /// `zfail` group: StencilOp
    /// `zpass` group: StencilOp
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn glStencilOp(fail: GLenum, zfail: GLenum, zpass: GLenum) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glStencilOp({:#X}, {:#X}, {:#X});",
                fail,
                zfail,
                zpass
            );
        }
        let out = call_atomic_ptr_3arg("glStencilOp", &glStencilOp_p, fail, zfail, zpass);
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glStencilOp");
        }
        out
    }
    static glStencilOp_p: APcv = ap_None();
    /// Tries to load [`glStencilOp`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    pub unsafe fn glStencilOp_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(get_proc_address, b"glStencilOp\0", &glStencilOp_p)
    }
    /// Checks if the pointer for [`glStencilOp`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    pub fn glStencilOp_is_loaded() -> bool {
        !glStencilOp_p.load(RELAX).is_null()
    }

    /// [glStencilOpSeparate](http://docs.gl/es3/glStencilOpSeparate)(face, sfail, dpfail, dppass)
    /// `face` group: StencilFaceDirection
    /// `sfail` group: StencilOp
    /// `dpfail` group: StencilOp
    /// `dppass` group: StencilOp
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn glStencilOpSeparate(face: GLenum, sfail: GLenum, dpfail: GLenum, dppass: GLenum) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glStencilOpSeparate({:#X}, {:#X}, {:#X}, {:#X});",
                face,
                sfail,
                dpfail,
                dppass
            );
        }
        let out = call_atomic_ptr_4arg(
            "glStencilOpSeparate",
            &glStencilOpSeparate_p,
            face,
            sfail,
            dpfail,
            dppass,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glStencilOpSeparate");
        }
        out
    }
    static glStencilOpSeparate_p: APcv = ap_None();
    /// Tries to load [`glStencilOpSeparate`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    pub unsafe fn glStencilOpSeparate_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glStencilOpSeparate\0",
            &glStencilOpSeparate_p,
        )
    }
    /// Checks if the pointer for [`glStencilOpSeparate`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    pub fn glStencilOpSeparate_is_loaded() -> bool {
        !glStencilOpSeparate_p.load(RELAX).is_null()
    }

    /// [glStencilStrokePathInstancedNV](http://docs.gl/es3/glStencilStrokePathInstancedNV)(numPaths, pathNameType, paths, pathBase, reference, mask, transformType, transformValues)
    /// `pathNameType` group: PathElementType
    /// `paths` group: PathElement
    /// `paths` len: COMPSIZE(numPaths,pathNameType,paths)
    /// `pathBase` group: Path
    /// `reference` group: StencilValue
    /// `mask` group: MaskedStencilValue
    /// `transformType` group: PathTransformType
    /// `transformValues` len: COMPSIZE(numPaths,transformType)
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    #[cfg(any(feature = "GL_NV_path_rendering"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_path_rendering"))))]
    pub unsafe fn glStencilStrokePathInstancedNV(
        numPaths: GLsizei,
        pathNameType: GLenum,
        paths: *const c_void,
        pathBase: GLuint,
        reference: GLint,
        mask: GLuint,
        transformType: GLenum,
        transformValues: *const GLfloat,
    ) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glStencilStrokePathInstancedNV({:?}, {:#X}, {:p}, {:?}, {:?}, {:?}, {:#X}, {:p});",
                numPaths,
                pathNameType,
                paths,
                pathBase,
                reference,
                mask,
                transformType,
                transformValues
            );
        }
        let out = call_atomic_ptr_8arg(
            "glStencilStrokePathInstancedNV",
            &glStencilStrokePathInstancedNV_p,
            numPaths,
            pathNameType,
            paths,
            pathBase,
            reference,
            mask,
            transformType,
            transformValues,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glStencilStrokePathInstancedNV");
        }
        out
    }
    #[cfg(any(feature = "GL_NV_path_rendering"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_path_rendering"))))]
    static glStencilStrokePathInstancedNV_p: APcv = ap_None();
    /// Tries to load [`glStencilStrokePathInstancedNV`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    #[cfg(any(feature = "GL_NV_path_rendering"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_path_rendering"))))]
    pub unsafe fn glStencilStrokePathInstancedNV_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glStencilStrokePathInstancedNV\0",
            &glStencilStrokePathInstancedNV_p,
        )
    }
    /// Checks if the pointer for [`glStencilStrokePathInstancedNV`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    #[cfg(any(feature = "GL_NV_path_rendering"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_path_rendering"))))]
    pub fn glStencilStrokePathInstancedNV_is_loaded() -> bool {
        !glStencilStrokePathInstancedNV_p.load(RELAX).is_null()
    }

    /// [glStencilStrokePathNV](http://docs.gl/es3/glStencilStrokePathNV)(path, reference, mask)
    /// `path` group: Path
    /// `reference` group: StencilValue
    /// `mask` group: MaskedStencilValue
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    #[cfg(any(feature = "GL_NV_path_rendering"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_path_rendering"))))]
    pub unsafe fn glStencilStrokePathNV(path: GLuint, reference: GLint, mask: GLuint) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glStencilStrokePathNV({:?}, {:?}, {:?});",
                path,
                reference,
                mask
            );
        }
        let out = call_atomic_ptr_3arg(
            "glStencilStrokePathNV",
            &glStencilStrokePathNV_p,
            path,
            reference,
            mask,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glStencilStrokePathNV");
        }
        out
    }
    #[cfg(any(feature = "GL_NV_path_rendering"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_path_rendering"))))]
    static glStencilStrokePathNV_p: APcv = ap_None();
    /// Tries to load [`glStencilStrokePathNV`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    #[cfg(any(feature = "GL_NV_path_rendering"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_path_rendering"))))]
    pub unsafe fn glStencilStrokePathNV_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glStencilStrokePathNV\0",
            &glStencilStrokePathNV_p,
        )
    }
    /// Checks if the pointer for [`glStencilStrokePathNV`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    #[cfg(any(feature = "GL_NV_path_rendering"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_path_rendering"))))]
    pub fn glStencilStrokePathNV_is_loaded() -> bool {
        !glStencilStrokePathNV_p.load(RELAX).is_null()
    }

    /// [glStencilThenCoverFillPathInstancedNV](http://docs.gl/es3/glStencilThenCoverFillPathInstancedNV)(numPaths, pathNameType, paths, pathBase, fillMode, mask, coverMode, transformType, transformValues)
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    #[cfg(any(feature = "GL_NV_path_rendering"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_path_rendering"))))]
    pub unsafe fn glStencilThenCoverFillPathInstancedNV(
        numPaths: GLsizei,
        pathNameType: GLenum,
        paths: *const c_void,
        pathBase: GLuint,
        fillMode: GLenum,
        mask: GLuint,
        coverMode: GLenum,
        transformType: GLenum,
        transformValues: *const GLfloat,
    ) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!("calling glStencilThenCoverFillPathInstancedNV({:?}, {:#X}, {:p}, {:?}, {:#X}, {:?}, {:#X}, {:#X}, {:p});", numPaths, pathNameType, paths, pathBase, fillMode, mask, coverMode, transformType, transformValues);
        }
        let out = call_atomic_ptr_9arg(
            "glStencilThenCoverFillPathInstancedNV",
            &glStencilThenCoverFillPathInstancedNV_p,
            numPaths,
            pathNameType,
            paths,
            pathBase,
            fillMode,
            mask,
            coverMode,
            transformType,
            transformValues,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glStencilThenCoverFillPathInstancedNV");
        }
        out
    }
    #[cfg(any(feature = "GL_NV_path_rendering"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_path_rendering"))))]
    static glStencilThenCoverFillPathInstancedNV_p: APcv = ap_None();
    /// Tries to load [`glStencilThenCoverFillPathInstancedNV`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    #[cfg(any(feature = "GL_NV_path_rendering"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_path_rendering"))))]
    pub unsafe fn glStencilThenCoverFillPathInstancedNV_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glStencilThenCoverFillPathInstancedNV\0",
            &glStencilThenCoverFillPathInstancedNV_p,
        )
    }
    /// Checks if the pointer for [`glStencilThenCoverFillPathInstancedNV`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    #[cfg(any(feature = "GL_NV_path_rendering"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_path_rendering"))))]
    pub fn glStencilThenCoverFillPathInstancedNV_is_loaded() -> bool {
        !glStencilThenCoverFillPathInstancedNV_p
            .load(RELAX)
            .is_null()
    }

    /// [glStencilThenCoverFillPathNV](http://docs.gl/es3/glStencilThenCoverFillPathNV)(path, fillMode, mask, coverMode)
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    #[cfg(any(feature = "GL_NV_path_rendering"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_path_rendering"))))]
    pub unsafe fn glStencilThenCoverFillPathNV(
        path: GLuint,
        fillMode: GLenum,
        mask: GLuint,
        coverMode: GLenum,
    ) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glStencilThenCoverFillPathNV({:?}, {:#X}, {:?}, {:#X});",
                path,
                fillMode,
                mask,
                coverMode
            );
        }
        let out = call_atomic_ptr_4arg(
            "glStencilThenCoverFillPathNV",
            &glStencilThenCoverFillPathNV_p,
            path,
            fillMode,
            mask,
            coverMode,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glStencilThenCoverFillPathNV");
        }
        out
    }
    #[cfg(any(feature = "GL_NV_path_rendering"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_path_rendering"))))]
    static glStencilThenCoverFillPathNV_p: APcv = ap_None();
    /// Tries to load [`glStencilThenCoverFillPathNV`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    #[cfg(any(feature = "GL_NV_path_rendering"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_path_rendering"))))]
    pub unsafe fn glStencilThenCoverFillPathNV_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glStencilThenCoverFillPathNV\0",
            &glStencilThenCoverFillPathNV_p,
        )
    }
    /// Checks if the pointer for [`glStencilThenCoverFillPathNV`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    #[cfg(any(feature = "GL_NV_path_rendering"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_path_rendering"))))]
    pub fn glStencilThenCoverFillPathNV_is_loaded() -> bool {
        !glStencilThenCoverFillPathNV_p.load(RELAX).is_null()
    }

    /// [glStencilThenCoverStrokePathInstancedNV](http://docs.gl/es3/glStencilThenCoverStrokePathInstancedNV)(numPaths, pathNameType, paths, pathBase, reference, mask, coverMode, transformType, transformValues)
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    #[cfg(any(feature = "GL_NV_path_rendering"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_path_rendering"))))]
    pub unsafe fn glStencilThenCoverStrokePathInstancedNV(
        numPaths: GLsizei,
        pathNameType: GLenum,
        paths: *const c_void,
        pathBase: GLuint,
        reference: GLint,
        mask: GLuint,
        coverMode: GLenum,
        transformType: GLenum,
        transformValues: *const GLfloat,
    ) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!("calling glStencilThenCoverStrokePathInstancedNV({:?}, {:#X}, {:p}, {:?}, {:?}, {:?}, {:#X}, {:#X}, {:p});", numPaths, pathNameType, paths, pathBase, reference, mask, coverMode, transformType, transformValues);
        }
        let out = call_atomic_ptr_9arg(
            "glStencilThenCoverStrokePathInstancedNV",
            &glStencilThenCoverStrokePathInstancedNV_p,
            numPaths,
            pathNameType,
            paths,
            pathBase,
            reference,
            mask,
            coverMode,
            transformType,
            transformValues,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glStencilThenCoverStrokePathInstancedNV");
        }
        out
    }
    #[cfg(any(feature = "GL_NV_path_rendering"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_path_rendering"))))]
    static glStencilThenCoverStrokePathInstancedNV_p: APcv = ap_None();
    /// Tries to load [`glStencilThenCoverStrokePathInstancedNV`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    #[cfg(any(feature = "GL_NV_path_rendering"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_path_rendering"))))]
    pub unsafe fn glStencilThenCoverStrokePathInstancedNV_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glStencilThenCoverStrokePathInstancedNV\0",
            &glStencilThenCoverStrokePathInstancedNV_p,
        )
    }
    /// Checks if the pointer for [`glStencilThenCoverStrokePathInstancedNV`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    #[cfg(any(feature = "GL_NV_path_rendering"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_path_rendering"))))]
    pub fn glStencilThenCoverStrokePathInstancedNV_is_loaded() -> bool {
        !glStencilThenCoverStrokePathInstancedNV_p
            .load(RELAX)
            .is_null()
    }

    /// [glStencilThenCoverStrokePathNV](http://docs.gl/es3/glStencilThenCoverStrokePathNV)(path, reference, mask, coverMode)
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    #[cfg(any(feature = "GL_NV_path_rendering"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_path_rendering"))))]
    pub unsafe fn glStencilThenCoverStrokePathNV(
        path: GLuint,
        reference: GLint,
        mask: GLuint,
        coverMode: GLenum,
    ) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glStencilThenCoverStrokePathNV({:?}, {:?}, {:?}, {:#X});",
                path,
                reference,
                mask,
                coverMode
            );
        }
        let out = call_atomic_ptr_4arg(
            "glStencilThenCoverStrokePathNV",
            &glStencilThenCoverStrokePathNV_p,
            path,
            reference,
            mask,
            coverMode,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glStencilThenCoverStrokePathNV");
        }
        out
    }
    #[cfg(any(feature = "GL_NV_path_rendering"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_path_rendering"))))]
    static glStencilThenCoverStrokePathNV_p: APcv = ap_None();
    /// Tries to load [`glStencilThenCoverStrokePathNV`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    #[cfg(any(feature = "GL_NV_path_rendering"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_path_rendering"))))]
    pub unsafe fn glStencilThenCoverStrokePathNV_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glStencilThenCoverStrokePathNV\0",
            &glStencilThenCoverStrokePathNV_p,
        )
    }
    /// Checks if the pointer for [`glStencilThenCoverStrokePathNV`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    #[cfg(any(feature = "GL_NV_path_rendering"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_path_rendering"))))]
    pub fn glStencilThenCoverStrokePathNV_is_loaded() -> bool {
        !glStencilThenCoverStrokePathNV_p.load(RELAX).is_null()
    }

    /// [glSubpixelPrecisionBiasNV](http://docs.gl/es3/glSubpixelPrecisionBiasNV)(xbits, ybits)
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    #[cfg(any(feature = "GL_NV_conservative_raster"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_conservative_raster"))))]
    pub unsafe fn glSubpixelPrecisionBiasNV(xbits: GLuint, ybits: GLuint) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glSubpixelPrecisionBiasNV({:?}, {:?});",
                xbits,
                ybits
            );
        }
        let out = call_atomic_ptr_2arg(
            "glSubpixelPrecisionBiasNV",
            &glSubpixelPrecisionBiasNV_p,
            xbits,
            ybits,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glSubpixelPrecisionBiasNV");
        }
        out
    }
    #[cfg(any(feature = "GL_NV_conservative_raster"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_conservative_raster"))))]
    static glSubpixelPrecisionBiasNV_p: APcv = ap_None();
    /// Tries to load [`glSubpixelPrecisionBiasNV`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    #[cfg(any(feature = "GL_NV_conservative_raster"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_conservative_raster"))))]
    pub unsafe fn glSubpixelPrecisionBiasNV_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glSubpixelPrecisionBiasNV\0",
            &glSubpixelPrecisionBiasNV_p,
        )
    }
    /// Checks if the pointer for [`glSubpixelPrecisionBiasNV`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    #[cfg(any(feature = "GL_NV_conservative_raster"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_conservative_raster"))))]
    pub fn glSubpixelPrecisionBiasNV_is_loaded() -> bool {
        !glSubpixelPrecisionBiasNV_p.load(RELAX).is_null()
    }

    /// [glTestFenceNV](http://docs.gl/es3/glTestFenceNV)(fence)
    /// `fence` group: FenceNV
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    #[cfg(any(feature = "GL_NV_fence"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_fence"))))]
    pub unsafe fn glTestFenceNV(fence: GLuint) -> GLboolean {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!("calling glTestFenceNV({:?});", fence);
        }
        let out = call_atomic_ptr_1arg("glTestFenceNV", &glTestFenceNV_p, fence);
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glTestFenceNV");
        }
        out
    }
    #[cfg(any(feature = "GL_NV_fence"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_fence"))))]
    static glTestFenceNV_p: APcv = ap_None();
    /// Tries to load [`glTestFenceNV`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    #[cfg(any(feature = "GL_NV_fence"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_fence"))))]
    pub unsafe fn glTestFenceNV_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(get_proc_address, b"glTestFenceNV\0", &glTestFenceNV_p)
    }
    /// Checks if the pointer for [`glTestFenceNV`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    #[cfg(any(feature = "GL_NV_fence"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_fence"))))]
    pub fn glTestFenceNV_is_loaded() -> bool {
        !glTestFenceNV_p.load(RELAX).is_null()
    }

    /// [glTexAttachMemoryNV](http://docs.gl/es3/glTexAttachMemoryNV)(target, memory, offset)
    /// `target` group: TextureTarget
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    #[cfg(any(feature = "GL_NV_memory_attachment"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_memory_attachment"))))]
    pub unsafe fn glTexAttachMemoryNV(target: GLenum, memory: GLuint, offset: GLuint64) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glTexAttachMemoryNV({:#X}, {:?}, {:?});",
                target,
                memory,
                offset
            );
        }
        let out = call_atomic_ptr_3arg(
            "glTexAttachMemoryNV",
            &glTexAttachMemoryNV_p,
            target,
            memory,
            offset,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glTexAttachMemoryNV");
        }
        out
    }
    #[cfg(any(feature = "GL_NV_memory_attachment"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_memory_attachment"))))]
    static glTexAttachMemoryNV_p: APcv = ap_None();
    /// Tries to load [`glTexAttachMemoryNV`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    #[cfg(any(feature = "GL_NV_memory_attachment"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_memory_attachment"))))]
    pub unsafe fn glTexAttachMemoryNV_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glTexAttachMemoryNV\0",
            &glTexAttachMemoryNV_p,
        )
    }
    /// Checks if the pointer for [`glTexAttachMemoryNV`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    #[cfg(any(feature = "GL_NV_memory_attachment"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_memory_attachment"))))]
    pub fn glTexAttachMemoryNV_is_loaded() -> bool {
        !glTexAttachMemoryNV_p.load(RELAX).is_null()
    }

    /// [glTexBuffer](http://docs.gl/es3/glTexBuffer)(target, internalformat, buffer)
    /// `target` group: TextureTarget
    /// `internalformat` group: SizedInternalFormat
    /// `buffer` class: buffer
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn glTexBuffer(target: GLenum, internalformat: GLenum, buffer: GLuint) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glTexBuffer({:#X}, {:#X}, {:?});",
                target,
                internalformat,
                buffer
            );
        }
        let out = call_atomic_ptr_3arg(
            "glTexBuffer",
            &glTexBuffer_p,
            target,
            internalformat,
            buffer,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glTexBuffer");
        }
        out
    }
    static glTexBuffer_p: APcv = ap_None();
    /// Tries to load [`glTexBuffer`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    pub unsafe fn glTexBuffer_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(get_proc_address, b"glTexBuffer\0", &glTexBuffer_p)
    }
    /// Checks if the pointer for [`glTexBuffer`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    pub fn glTexBuffer_is_loaded() -> bool {
        !glTexBuffer_p.load(RELAX).is_null()
    }

    /// [glTexBufferEXT](http://docs.gl/es3/glTexBufferEXT)(target, internalformat, buffer)
    /// `target` group: TextureTarget
    /// `internalformat` group: SizedInternalFormat
    /// `buffer` class: buffer
    /// alias of: [`glTexBuffer`]
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    #[cfg(any(feature = "GL_EXT_texture_buffer"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_texture_buffer"))))]
    pub unsafe fn glTexBufferEXT(target: GLenum, internalformat: GLenum, buffer: GLuint) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glTexBufferEXT({:#X}, {:#X}, {:?});",
                target,
                internalformat,
                buffer
            );
        }
        let out = call_atomic_ptr_3arg(
            "glTexBufferEXT",
            &glTexBufferEXT_p,
            target,
            internalformat,
            buffer,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glTexBufferEXT");
        }
        out
    }
    #[cfg(any(feature = "GL_EXT_texture_buffer"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_texture_buffer"))))]
    static glTexBufferEXT_p: APcv = ap_None();
    /// Tries to load [`glTexBufferEXT`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    #[cfg(any(feature = "GL_EXT_texture_buffer"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_texture_buffer"))))]
    pub unsafe fn glTexBufferEXT_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(get_proc_address, b"glTexBufferEXT\0", &glTexBufferEXT_p)
    }
    /// Checks if the pointer for [`glTexBufferEXT`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    #[cfg(any(feature = "GL_EXT_texture_buffer"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_texture_buffer"))))]
    pub fn glTexBufferEXT_is_loaded() -> bool {
        !glTexBufferEXT_p.load(RELAX).is_null()
    }

    /// [glTexBufferOES](http://docs.gl/es3/glTexBufferOES)(target, internalformat, buffer)
    /// `target` group: TextureTarget
    /// `internalformat` group: SizedInternalFormat
    /// `buffer` class: buffer
    /// alias of: [`glTexBuffer`]
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    #[cfg(any(feature = "GL_OES_texture_buffer"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_OES_texture_buffer"))))]
    pub unsafe fn glTexBufferOES(target: GLenum, internalformat: GLenum, buffer: GLuint) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glTexBufferOES({:#X}, {:#X}, {:?});",
                target,
                internalformat,
                buffer
            );
        }
        let out = call_atomic_ptr_3arg(
            "glTexBufferOES",
            &glTexBufferOES_p,
            target,
            internalformat,
            buffer,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glTexBufferOES");
        }
        out
    }
    #[cfg(any(feature = "GL_OES_texture_buffer"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_OES_texture_buffer"))))]
    static glTexBufferOES_p: APcv = ap_None();
    /// Tries to load [`glTexBufferOES`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    #[cfg(any(feature = "GL_OES_texture_buffer"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_OES_texture_buffer"))))]
    pub unsafe fn glTexBufferOES_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(get_proc_address, b"glTexBufferOES\0", &glTexBufferOES_p)
    }
    /// Checks if the pointer for [`glTexBufferOES`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    #[cfg(any(feature = "GL_OES_texture_buffer"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_OES_texture_buffer"))))]
    pub fn glTexBufferOES_is_loaded() -> bool {
        !glTexBufferOES_p.load(RELAX).is_null()
    }

    /// [glTexBufferRange](http://docs.gl/es3/glTexBufferRange)(target, internalformat, buffer, offset, size)
    /// `target` group: TextureTarget
    /// `internalformat` group: SizedInternalFormat
    /// `buffer` class: buffer
    /// `offset` group: BufferOffset
    /// `size` group: BufferSize
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn glTexBufferRange(
        target: GLenum,
        internalformat: GLenum,
        buffer: GLuint,
        offset: GLintptr,
        size: GLsizeiptr,
    ) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glTexBufferRange({:#X}, {:#X}, {:?}, {:?}, {:?});",
                target,
                internalformat,
                buffer,
                offset,
                size
            );
        }
        let out = call_atomic_ptr_5arg(
            "glTexBufferRange",
            &glTexBufferRange_p,
            target,
            internalformat,
            buffer,
            offset,
            size,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glTexBufferRange");
        }
        out
    }
    static glTexBufferRange_p: APcv = ap_None();
    /// Tries to load [`glTexBufferRange`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    pub unsafe fn glTexBufferRange_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(get_proc_address, b"glTexBufferRange\0", &glTexBufferRange_p)
    }
    /// Checks if the pointer for [`glTexBufferRange`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    pub fn glTexBufferRange_is_loaded() -> bool {
        !glTexBufferRange_p.load(RELAX).is_null()
    }

    /// [glTexBufferRangeEXT](http://docs.gl/es3/glTexBufferRangeEXT)(target, internalformat, buffer, offset, size)
    /// `target` group: TextureTarget
    /// `internalformat` group: SizedInternalFormat
    /// `buffer` class: buffer
    /// `offset` group: BufferOffset
    /// `size` group: BufferSize
    /// alias of: [`glTexBufferRange`]
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    #[cfg(any(feature = "GL_EXT_texture_buffer"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_texture_buffer"))))]
    pub unsafe fn glTexBufferRangeEXT(
        target: GLenum,
        internalformat: GLenum,
        buffer: GLuint,
        offset: GLintptr,
        size: GLsizeiptr,
    ) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glTexBufferRangeEXT({:#X}, {:#X}, {:?}, {:?}, {:?});",
                target,
                internalformat,
                buffer,
                offset,
                size
            );
        }
        let out = call_atomic_ptr_5arg(
            "glTexBufferRangeEXT",
            &glTexBufferRangeEXT_p,
            target,
            internalformat,
            buffer,
            offset,
            size,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glTexBufferRangeEXT");
        }
        out
    }
    #[cfg(any(feature = "GL_EXT_texture_buffer"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_texture_buffer"))))]
    static glTexBufferRangeEXT_p: APcv = ap_None();
    /// Tries to load [`glTexBufferRangeEXT`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    #[cfg(any(feature = "GL_EXT_texture_buffer"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_texture_buffer"))))]
    pub unsafe fn glTexBufferRangeEXT_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glTexBufferRangeEXT\0",
            &glTexBufferRangeEXT_p,
        )
    }
    /// Checks if the pointer for [`glTexBufferRangeEXT`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    #[cfg(any(feature = "GL_EXT_texture_buffer"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_texture_buffer"))))]
    pub fn glTexBufferRangeEXT_is_loaded() -> bool {
        !glTexBufferRangeEXT_p.load(RELAX).is_null()
    }

    /// [glTexBufferRangeOES](http://docs.gl/es3/glTexBufferRangeOES)(target, internalformat, buffer, offset, size)
    /// `target` group: TextureTarget
    /// `internalformat` group: SizedInternalFormat
    /// `buffer` class: buffer
    /// `offset` group: BufferOffset
    /// `size` group: BufferSize
    /// alias of: [`glTexBufferRange`]
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    #[cfg(any(feature = "GL_OES_texture_buffer"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_OES_texture_buffer"))))]
    pub unsafe fn glTexBufferRangeOES(
        target: GLenum,
        internalformat: GLenum,
        buffer: GLuint,
        offset: GLintptr,
        size: GLsizeiptr,
    ) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glTexBufferRangeOES({:#X}, {:#X}, {:?}, {:?}, {:?});",
                target,
                internalformat,
                buffer,
                offset,
                size
            );
        }
        let out = call_atomic_ptr_5arg(
            "glTexBufferRangeOES",
            &glTexBufferRangeOES_p,
            target,
            internalformat,
            buffer,
            offset,
            size,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glTexBufferRangeOES");
        }
        out
    }
    #[cfg(any(feature = "GL_OES_texture_buffer"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_OES_texture_buffer"))))]
    static glTexBufferRangeOES_p: APcv = ap_None();
    /// Tries to load [`glTexBufferRangeOES`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    #[cfg(any(feature = "GL_OES_texture_buffer"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_OES_texture_buffer"))))]
    pub unsafe fn glTexBufferRangeOES_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glTexBufferRangeOES\0",
            &glTexBufferRangeOES_p,
        )
    }
    /// Checks if the pointer for [`glTexBufferRangeOES`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    #[cfg(any(feature = "GL_OES_texture_buffer"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_OES_texture_buffer"))))]
    pub fn glTexBufferRangeOES_is_loaded() -> bool {
        !glTexBufferRangeOES_p.load(RELAX).is_null()
    }

    /// [glTexEstimateMotionQCOM](http://docs.gl/es3/glTexEstimateMotionQCOM)(ref_, target, output)
    /// `ref_` group: Texture
    /// `ref_` class: texture
    /// `target` group: Texture
    /// `target` class: texture
    /// `output` group: Texture
    /// `output` class: texture
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    #[cfg(any(feature = "GL_QCOM_motion_estimation"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_QCOM_motion_estimation"))))]
    pub unsafe fn glTexEstimateMotionQCOM(ref_: GLuint, target: GLuint, output: GLuint) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glTexEstimateMotionQCOM({:?}, {:?}, {:?});",
                ref_,
                target,
                output
            );
        }
        let out = call_atomic_ptr_3arg(
            "glTexEstimateMotionQCOM",
            &glTexEstimateMotionQCOM_p,
            ref_,
            target,
            output,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glTexEstimateMotionQCOM");
        }
        out
    }
    #[cfg(any(feature = "GL_QCOM_motion_estimation"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_QCOM_motion_estimation"))))]
    static glTexEstimateMotionQCOM_p: APcv = ap_None();
    /// Tries to load [`glTexEstimateMotionQCOM`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    #[cfg(any(feature = "GL_QCOM_motion_estimation"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_QCOM_motion_estimation"))))]
    pub unsafe fn glTexEstimateMotionQCOM_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glTexEstimateMotionQCOM\0",
            &glTexEstimateMotionQCOM_p,
        )
    }
    /// Checks if the pointer for [`glTexEstimateMotionQCOM`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    #[cfg(any(feature = "GL_QCOM_motion_estimation"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_QCOM_motion_estimation"))))]
    pub fn glTexEstimateMotionQCOM_is_loaded() -> bool {
        !glTexEstimateMotionQCOM_p.load(RELAX).is_null()
    }

    /// [glTexEstimateMotionRegionsQCOM](http://docs.gl/es3/glTexEstimateMotionRegionsQCOM)(ref_, target, output, mask)
    /// `ref_` group: Texture
    /// `ref_` class: texture
    /// `target` group: Texture
    /// `target` class: texture
    /// `output` group: Texture
    /// `output` class: texture
    /// `mask` group: Texture
    /// `mask` class: texture
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    #[cfg(any(feature = "GL_QCOM_motion_estimation"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_QCOM_motion_estimation"))))]
    pub unsafe fn glTexEstimateMotionRegionsQCOM(
        ref_: GLuint,
        target: GLuint,
        output: GLuint,
        mask: GLuint,
    ) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glTexEstimateMotionRegionsQCOM({:?}, {:?}, {:?}, {:?});",
                ref_,
                target,
                output,
                mask
            );
        }
        let out = call_atomic_ptr_4arg(
            "glTexEstimateMotionRegionsQCOM",
            &glTexEstimateMotionRegionsQCOM_p,
            ref_,
            target,
            output,
            mask,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glTexEstimateMotionRegionsQCOM");
        }
        out
    }
    #[cfg(any(feature = "GL_QCOM_motion_estimation"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_QCOM_motion_estimation"))))]
    static glTexEstimateMotionRegionsQCOM_p: APcv = ap_None();
    /// Tries to load [`glTexEstimateMotionRegionsQCOM`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    #[cfg(any(feature = "GL_QCOM_motion_estimation"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_QCOM_motion_estimation"))))]
    pub unsafe fn glTexEstimateMotionRegionsQCOM_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glTexEstimateMotionRegionsQCOM\0",
            &glTexEstimateMotionRegionsQCOM_p,
        )
    }
    /// Checks if the pointer for [`glTexEstimateMotionRegionsQCOM`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    #[cfg(any(feature = "GL_QCOM_motion_estimation"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_QCOM_motion_estimation"))))]
    pub fn glTexEstimateMotionRegionsQCOM_is_loaded() -> bool {
        !glTexEstimateMotionRegionsQCOM_p.load(RELAX).is_null()
    }

    /// [glTexImage2D](http://docs.gl/es3/glTexImage2D)(target, level, internalformat, width, height, border, format, type_, pixels)
    /// `target` group: TextureTarget
    /// `level` group: CheckedInt32
    /// `internalformat` group: InternalFormat
    /// `border` group: CheckedInt32
    /// `format` group: PixelFormat
    /// `type_` group: PixelType
    /// `pixels` len: COMPSIZE(format,type,width,height)
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn glTexImage2D(
        target: GLenum,
        level: GLint,
        internalformat: GLint,
        width: GLsizei,
        height: GLsizei,
        border: GLint,
        format: GLenum,
        type_: GLenum,
        pixels: *const c_void,
    ) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glTexImage2D({:#X}, {:?}, {:?}, {:?}, {:?}, {:?}, {:#X}, {:#X}, {:p});",
                target,
                level,
                internalformat,
                width,
                height,
                border,
                format,
                type_,
                pixels
            );
        }
        let out = call_atomic_ptr_9arg(
            "glTexImage2D",
            &glTexImage2D_p,
            target,
            level,
            internalformat,
            width,
            height,
            border,
            format,
            type_,
            pixels,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glTexImage2D");
        }
        out
    }
    static glTexImage2D_p: APcv = ap_None();
    /// Tries to load [`glTexImage2D`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    pub unsafe fn glTexImage2D_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(get_proc_address, b"glTexImage2D\0", &glTexImage2D_p)
    }
    /// Checks if the pointer for [`glTexImage2D`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    pub fn glTexImage2D_is_loaded() -> bool {
        !glTexImage2D_p.load(RELAX).is_null()
    }

    /// [glTexImage3D](http://docs.gl/es3/glTexImage3D)(target, level, internalformat, width, height, depth, border, format, type_, pixels)
    /// `target` group: TextureTarget
    /// `level` group: CheckedInt32
    /// `internalformat` group: InternalFormat
    /// `border` group: CheckedInt32
    /// `format` group: PixelFormat
    /// `type_` group: PixelType
    /// `pixels` len: COMPSIZE(format,type,width,height,depth)
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn glTexImage3D(
        target: GLenum,
        level: GLint,
        internalformat: GLint,
        width: GLsizei,
        height: GLsizei,
        depth: GLsizei,
        border: GLint,
        format: GLenum,
        type_: GLenum,
        pixels: *const c_void,
    ) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glTexImage3D({:#X}, {:?}, {:?}, {:?}, {:?}, {:?}, {:?}, {:#X}, {:#X}, {:p});",
                target,
                level,
                internalformat,
                width,
                height,
                depth,
                border,
                format,
                type_,
                pixels
            );
        }
        let out = call_atomic_ptr_10arg(
            "glTexImage3D",
            &glTexImage3D_p,
            target,
            level,
            internalformat,
            width,
            height,
            depth,
            border,
            format,
            type_,
            pixels,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glTexImage3D");
        }
        out
    }
    static glTexImage3D_p: APcv = ap_None();
    /// Tries to load [`glTexImage3D`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    pub unsafe fn glTexImage3D_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(get_proc_address, b"glTexImage3D\0", &glTexImage3D_p)
    }
    /// Checks if the pointer for [`glTexImage3D`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    pub fn glTexImage3D_is_loaded() -> bool {
        !glTexImage3D_p.load(RELAX).is_null()
    }

    /// [glTexImage3DOES](http://docs.gl/es3/glTexImage3DOES)(target, level, internalformat, width, height, depth, border, format, type_, pixels)
    /// `target` group: TextureTarget
    /// `internalformat` group: InternalFormat
    /// `format` group: PixelFormat
    /// `type_` group: PixelType
    /// `pixels` len: COMPSIZE(format,type,width,height,depth)
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    #[cfg(any(feature = "GL_OES_texture_3D"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_OES_texture_3D"))))]
    pub unsafe fn glTexImage3DOES(
        target: GLenum,
        level: GLint,
        internalformat: GLenum,
        width: GLsizei,
        height: GLsizei,
        depth: GLsizei,
        border: GLint,
        format: GLenum,
        type_: GLenum,
        pixels: *const c_void,
    ) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glTexImage3DOES({:#X}, {:?}, {:#X}, {:?}, {:?}, {:?}, {:?}, {:#X}, {:#X}, {:p});",
                target,
                level,
                internalformat,
                width,
                height,
                depth,
                border,
                format,
                type_,
                pixels
            );
        }
        let out = call_atomic_ptr_10arg(
            "glTexImage3DOES",
            &glTexImage3DOES_p,
            target,
            level,
            internalformat,
            width,
            height,
            depth,
            border,
            format,
            type_,
            pixels,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glTexImage3DOES");
        }
        out
    }
    #[cfg(any(feature = "GL_OES_texture_3D"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_OES_texture_3D"))))]
    static glTexImage3DOES_p: APcv = ap_None();
    /// Tries to load [`glTexImage3DOES`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    #[cfg(any(feature = "GL_OES_texture_3D"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_OES_texture_3D"))))]
    pub unsafe fn glTexImage3DOES_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(get_proc_address, b"glTexImage3DOES\0", &glTexImage3DOES_p)
    }
    /// Checks if the pointer for [`glTexImage3DOES`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    #[cfg(any(feature = "GL_OES_texture_3D"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_OES_texture_3D"))))]
    pub fn glTexImage3DOES_is_loaded() -> bool {
        !glTexImage3DOES_p.load(RELAX).is_null()
    }

    /// [glTexPageCommitmentEXT](http://docs.gl/es3/glTexPageCommitmentEXT)(target, level, xoffset, yoffset, zoffset, width, height, depth, commit)
    /// alias of: [`glTexPageCommitmentARB`]
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    #[cfg(any(feature = "GL_EXT_sparse_texture"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_sparse_texture"))))]
    pub unsafe fn glTexPageCommitmentEXT(
        target: GLenum,
        level: GLint,
        xoffset: GLint,
        yoffset: GLint,
        zoffset: GLint,
        width: GLsizei,
        height: GLsizei,
        depth: GLsizei,
        commit: GLboolean,
    ) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glTexPageCommitmentEXT({:#X}, {:?}, {:?}, {:?}, {:?}, {:?}, {:?}, {:?}, {:?});",
                target,
                level,
                xoffset,
                yoffset,
                zoffset,
                width,
                height,
                depth,
                commit
            );
        }
        let out = call_atomic_ptr_9arg(
            "glTexPageCommitmentEXT",
            &glTexPageCommitmentEXT_p,
            target,
            level,
            xoffset,
            yoffset,
            zoffset,
            width,
            height,
            depth,
            commit,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glTexPageCommitmentEXT");
        }
        out
    }
    #[cfg(any(feature = "GL_EXT_sparse_texture"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_sparse_texture"))))]
    static glTexPageCommitmentEXT_p: APcv = ap_None();
    /// Tries to load [`glTexPageCommitmentEXT`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    #[cfg(any(feature = "GL_EXT_sparse_texture"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_sparse_texture"))))]
    pub unsafe fn glTexPageCommitmentEXT_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glTexPageCommitmentEXT\0",
            &glTexPageCommitmentEXT_p,
        )
    }
    /// Checks if the pointer for [`glTexPageCommitmentEXT`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    #[cfg(any(feature = "GL_EXT_sparse_texture"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_sparse_texture"))))]
    pub fn glTexPageCommitmentEXT_is_loaded() -> bool {
        !glTexPageCommitmentEXT_p.load(RELAX).is_null()
    }

    /// [glTexPageCommitmentMemNV](http://docs.gl/es3/glTexPageCommitmentMemNV)(target, layer, level, xoffset, yoffset, zoffset, width, height, depth, memory, offset, commit)
    /// `target` group: TextureTarget
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    #[cfg(any(feature = "GL_NV_memory_object_sparse"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_memory_object_sparse"))))]
    pub unsafe fn glTexPageCommitmentMemNV(
        target: GLenum,
        layer: GLint,
        level: GLint,
        xoffset: GLint,
        yoffset: GLint,
        zoffset: GLint,
        width: GLsizei,
        height: GLsizei,
        depth: GLsizei,
        memory: GLuint,
        offset: GLuint64,
        commit: GLboolean,
    ) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!("calling glTexPageCommitmentMemNV({:#X}, {:?}, {:?}, {:?}, {:?}, {:?}, {:?}, {:?}, {:?}, {:?}, {:?}, {:?});", target, layer, level, xoffset, yoffset, zoffset, width, height, depth, memory, offset, commit);
        }
        let out = call_atomic_ptr_12arg(
            "glTexPageCommitmentMemNV",
            &glTexPageCommitmentMemNV_p,
            target,
            layer,
            level,
            xoffset,
            yoffset,
            zoffset,
            width,
            height,
            depth,
            memory,
            offset,
            commit,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glTexPageCommitmentMemNV");
        }
        out
    }
    #[cfg(any(feature = "GL_NV_memory_object_sparse"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_memory_object_sparse"))))]
    static glTexPageCommitmentMemNV_p: APcv = ap_None();
    /// Tries to load [`glTexPageCommitmentMemNV`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    #[cfg(any(feature = "GL_NV_memory_object_sparse"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_memory_object_sparse"))))]
    pub unsafe fn glTexPageCommitmentMemNV_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glTexPageCommitmentMemNV\0",
            &glTexPageCommitmentMemNV_p,
        )
    }
    /// Checks if the pointer for [`glTexPageCommitmentMemNV`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    #[cfg(any(feature = "GL_NV_memory_object_sparse"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_memory_object_sparse"))))]
    pub fn glTexPageCommitmentMemNV_is_loaded() -> bool {
        !glTexPageCommitmentMemNV_p.load(RELAX).is_null()
    }

    /// [glTexParameterIiv](http://docs.gl/es3/glTexParameter)(target, pname, params)
    /// `target` group: TextureTarget
    /// `pname` group: TextureParameterName
    /// `params` len: COMPSIZE(pname)
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn glTexParameterIiv(target: GLenum, pname: GLenum, params: *const GLint) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glTexParameterIiv({:#X}, {:#X}, {:p});",
                target,
                pname,
                params
            );
        }
        let out = call_atomic_ptr_3arg(
            "glTexParameterIiv",
            &glTexParameterIiv_p,
            target,
            pname,
            params,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glTexParameterIiv");
        }
        out
    }
    static glTexParameterIiv_p: APcv = ap_None();
    /// Tries to load [`glTexParameterIiv`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    pub unsafe fn glTexParameterIiv_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glTexParameterIiv\0",
            &glTexParameterIiv_p,
        )
    }
    /// Checks if the pointer for [`glTexParameterIiv`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    pub fn glTexParameterIiv_is_loaded() -> bool {
        !glTexParameterIiv_p.load(RELAX).is_null()
    }

    /// [glTexParameterIivEXT](http://docs.gl/es3/glTexParameterIivEXT)(target, pname, params)
    /// `target` group: TextureTarget
    /// `pname` group: TextureParameterName
    /// `params` len: COMPSIZE(pname)
    /// alias of: [`glTexParameterIiv`]
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    #[cfg(any(feature = "GL_EXT_texture_border_clamp"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_texture_border_clamp"))))]
    pub unsafe fn glTexParameterIivEXT(target: GLenum, pname: GLenum, params: *const GLint) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glTexParameterIivEXT({:#X}, {:#X}, {:p});",
                target,
                pname,
                params
            );
        }
        let out = call_atomic_ptr_3arg(
            "glTexParameterIivEXT",
            &glTexParameterIivEXT_p,
            target,
            pname,
            params,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glTexParameterIivEXT");
        }
        out
    }
    #[cfg(any(feature = "GL_EXT_texture_border_clamp"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_texture_border_clamp"))))]
    static glTexParameterIivEXT_p: APcv = ap_None();
    /// Tries to load [`glTexParameterIivEXT`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    #[cfg(any(feature = "GL_EXT_texture_border_clamp"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_texture_border_clamp"))))]
    pub unsafe fn glTexParameterIivEXT_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glTexParameterIivEXT\0",
            &glTexParameterIivEXT_p,
        )
    }
    /// Checks if the pointer for [`glTexParameterIivEXT`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    #[cfg(any(feature = "GL_EXT_texture_border_clamp"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_texture_border_clamp"))))]
    pub fn glTexParameterIivEXT_is_loaded() -> bool {
        !glTexParameterIivEXT_p.load(RELAX).is_null()
    }

    /// [glTexParameterIivOES](http://docs.gl/es3/glTexParameterIivOES)(target, pname, params)
    /// `target` group: TextureTarget
    /// `pname` group: TextureParameterName
    /// `params` len: COMPSIZE(pname)
    /// alias of: [`glTexParameterIiv`]
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    #[cfg(any(feature = "GL_OES_texture_border_clamp"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_OES_texture_border_clamp"))))]
    pub unsafe fn glTexParameterIivOES(target: GLenum, pname: GLenum, params: *const GLint) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glTexParameterIivOES({:#X}, {:#X}, {:p});",
                target,
                pname,
                params
            );
        }
        let out = call_atomic_ptr_3arg(
            "glTexParameterIivOES",
            &glTexParameterIivOES_p,
            target,
            pname,
            params,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glTexParameterIivOES");
        }
        out
    }
    #[cfg(any(feature = "GL_OES_texture_border_clamp"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_OES_texture_border_clamp"))))]
    static glTexParameterIivOES_p: APcv = ap_None();
    /// Tries to load [`glTexParameterIivOES`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    #[cfg(any(feature = "GL_OES_texture_border_clamp"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_OES_texture_border_clamp"))))]
    pub unsafe fn glTexParameterIivOES_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glTexParameterIivOES\0",
            &glTexParameterIivOES_p,
        )
    }
    /// Checks if the pointer for [`glTexParameterIivOES`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    #[cfg(any(feature = "GL_OES_texture_border_clamp"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_OES_texture_border_clamp"))))]
    pub fn glTexParameterIivOES_is_loaded() -> bool {
        !glTexParameterIivOES_p.load(RELAX).is_null()
    }

    /// [glTexParameterIuiv](http://docs.gl/es3/glTexParameter)(target, pname, params)
    /// `target` group: TextureTarget
    /// `pname` group: TextureParameterName
    /// `params` len: COMPSIZE(pname)
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn glTexParameterIuiv(target: GLenum, pname: GLenum, params: *const GLuint) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glTexParameterIuiv({:#X}, {:#X}, {:p});",
                target,
                pname,
                params
            );
        }
        let out = call_atomic_ptr_3arg(
            "glTexParameterIuiv",
            &glTexParameterIuiv_p,
            target,
            pname,
            params,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glTexParameterIuiv");
        }
        out
    }
    static glTexParameterIuiv_p: APcv = ap_None();
    /// Tries to load [`glTexParameterIuiv`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    pub unsafe fn glTexParameterIuiv_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glTexParameterIuiv\0",
            &glTexParameterIuiv_p,
        )
    }
    /// Checks if the pointer for [`glTexParameterIuiv`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    pub fn glTexParameterIuiv_is_loaded() -> bool {
        !glTexParameterIuiv_p.load(RELAX).is_null()
    }

    /// [glTexParameterIuivEXT](http://docs.gl/es3/glTexParameterIuivEXT)(target, pname, params)
    /// `target` group: TextureTarget
    /// `pname` group: TextureParameterName
    /// `params` len: COMPSIZE(pname)
    /// alias of: [`glTexParameterIuiv`]
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    #[cfg(any(feature = "GL_EXT_texture_border_clamp"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_texture_border_clamp"))))]
    pub unsafe fn glTexParameterIuivEXT(target: GLenum, pname: GLenum, params: *const GLuint) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glTexParameterIuivEXT({:#X}, {:#X}, {:p});",
                target,
                pname,
                params
            );
        }
        let out = call_atomic_ptr_3arg(
            "glTexParameterIuivEXT",
            &glTexParameterIuivEXT_p,
            target,
            pname,
            params,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glTexParameterIuivEXT");
        }
        out
    }
    #[cfg(any(feature = "GL_EXT_texture_border_clamp"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_texture_border_clamp"))))]
    static glTexParameterIuivEXT_p: APcv = ap_None();
    /// Tries to load [`glTexParameterIuivEXT`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    #[cfg(any(feature = "GL_EXT_texture_border_clamp"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_texture_border_clamp"))))]
    pub unsafe fn glTexParameterIuivEXT_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glTexParameterIuivEXT\0",
            &glTexParameterIuivEXT_p,
        )
    }
    /// Checks if the pointer for [`glTexParameterIuivEXT`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    #[cfg(any(feature = "GL_EXT_texture_border_clamp"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_texture_border_clamp"))))]
    pub fn glTexParameterIuivEXT_is_loaded() -> bool {
        !glTexParameterIuivEXT_p.load(RELAX).is_null()
    }

    /// [glTexParameterIuivOES](http://docs.gl/es3/glTexParameterIuivOES)(target, pname, params)
    /// `target` group: TextureTarget
    /// `pname` group: TextureParameterName
    /// `params` len: COMPSIZE(pname)
    /// alias of: [`glTexParameterIuiv`]
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    #[cfg(any(feature = "GL_OES_texture_border_clamp"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_OES_texture_border_clamp"))))]
    pub unsafe fn glTexParameterIuivOES(target: GLenum, pname: GLenum, params: *const GLuint) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glTexParameterIuivOES({:#X}, {:#X}, {:p});",
                target,
                pname,
                params
            );
        }
        let out = call_atomic_ptr_3arg(
            "glTexParameterIuivOES",
            &glTexParameterIuivOES_p,
            target,
            pname,
            params,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glTexParameterIuivOES");
        }
        out
    }
    #[cfg(any(feature = "GL_OES_texture_border_clamp"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_OES_texture_border_clamp"))))]
    static glTexParameterIuivOES_p: APcv = ap_None();
    /// Tries to load [`glTexParameterIuivOES`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    #[cfg(any(feature = "GL_OES_texture_border_clamp"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_OES_texture_border_clamp"))))]
    pub unsafe fn glTexParameterIuivOES_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glTexParameterIuivOES\0",
            &glTexParameterIuivOES_p,
        )
    }
    /// Checks if the pointer for [`glTexParameterIuivOES`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    #[cfg(any(feature = "GL_OES_texture_border_clamp"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_OES_texture_border_clamp"))))]
    pub fn glTexParameterIuivOES_is_loaded() -> bool {
        !glTexParameterIuivOES_p.load(RELAX).is_null()
    }

    /// [glTexParameterf](http://docs.gl/es3/glTexParameter)(target, pname, param)
    /// `target` group: TextureTarget
    /// `pname` group: TextureParameterName
    /// `param` group: CheckedFloat32
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn glTexParameterf(target: GLenum, pname: GLenum, param: GLfloat) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glTexParameterf({:#X}, {:#X}, {:?});",
                target,
                pname,
                param
            );
        }
        let out = call_atomic_ptr_3arg("glTexParameterf", &glTexParameterf_p, target, pname, param);
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glTexParameterf");
        }
        out
    }
    static glTexParameterf_p: APcv = ap_None();
    /// Tries to load [`glTexParameterf`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    pub unsafe fn glTexParameterf_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(get_proc_address, b"glTexParameterf\0", &glTexParameterf_p)
    }
    /// Checks if the pointer for [`glTexParameterf`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    pub fn glTexParameterf_is_loaded() -> bool {
        !glTexParameterf_p.load(RELAX).is_null()
    }

    /// [glTexParameterfv](http://docs.gl/es3/glTexParameter)(target, pname, params)
    /// `target` group: TextureTarget
    /// `pname` group: TextureParameterName
    /// `params` group: CheckedFloat32
    /// `params` len: COMPSIZE(pname)
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn glTexParameterfv(target: GLenum, pname: GLenum, params: *const GLfloat) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glTexParameterfv({:#X}, {:#X}, {:p});",
                target,
                pname,
                params
            );
        }
        let out = call_atomic_ptr_3arg(
            "glTexParameterfv",
            &glTexParameterfv_p,
            target,
            pname,
            params,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glTexParameterfv");
        }
        out
    }
    static glTexParameterfv_p: APcv = ap_None();
    /// Tries to load [`glTexParameterfv`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    pub unsafe fn glTexParameterfv_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(get_proc_address, b"glTexParameterfv\0", &glTexParameterfv_p)
    }
    /// Checks if the pointer for [`glTexParameterfv`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    pub fn glTexParameterfv_is_loaded() -> bool {
        !glTexParameterfv_p.load(RELAX).is_null()
    }

    /// [glTexParameteri](http://docs.gl/es3/glTexParameter)(target, pname, param)
    /// `target` group: TextureTarget
    /// `pname` group: TextureParameterName
    /// `param` group: CheckedInt32
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn glTexParameteri(target: GLenum, pname: GLenum, param: GLint) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glTexParameteri({:#X}, {:#X}, {:?});",
                target,
                pname,
                param
            );
        }
        let out = call_atomic_ptr_3arg("glTexParameteri", &glTexParameteri_p, target, pname, param);
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glTexParameteri");
        }
        out
    }
    static glTexParameteri_p: APcv = ap_None();
    /// Tries to load [`glTexParameteri`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    pub unsafe fn glTexParameteri_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(get_proc_address, b"glTexParameteri\0", &glTexParameteri_p)
    }
    /// Checks if the pointer for [`glTexParameteri`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    pub fn glTexParameteri_is_loaded() -> bool {
        !glTexParameteri_p.load(RELAX).is_null()
    }

    /// [glTexParameteriv](http://docs.gl/es3/glTexParameter)(target, pname, params)
    /// `target` group: TextureTarget
    /// `pname` group: TextureParameterName
    /// `params` group: CheckedInt32
    /// `params` len: COMPSIZE(pname)
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn glTexParameteriv(target: GLenum, pname: GLenum, params: *const GLint) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glTexParameteriv({:#X}, {:#X}, {:p});",
                target,
                pname,
                params
            );
        }
        let out = call_atomic_ptr_3arg(
            "glTexParameteriv",
            &glTexParameteriv_p,
            target,
            pname,
            params,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glTexParameteriv");
        }
        out
    }
    static glTexParameteriv_p: APcv = ap_None();
    /// Tries to load [`glTexParameteriv`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    pub unsafe fn glTexParameteriv_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(get_proc_address, b"glTexParameteriv\0", &glTexParameteriv_p)
    }
    /// Checks if the pointer for [`glTexParameteriv`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    pub fn glTexParameteriv_is_loaded() -> bool {
        !glTexParameteriv_p.load(RELAX).is_null()
    }

    /// [glTexStorage1DEXT](http://docs.gl/es3/glTexStorage1DEXT)(target, levels, internalformat, width)
    /// `target` group: TextureTarget
    /// `internalformat` group: SizedInternalFormat
    /// alias of: [`glTexStorage1D`]
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    #[cfg(any(feature = "GL_EXT_texture_storage"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_texture_storage"))))]
    pub unsafe fn glTexStorage1DEXT(
        target: GLenum,
        levels: GLsizei,
        internalformat: GLenum,
        width: GLsizei,
    ) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glTexStorage1DEXT({:#X}, {:?}, {:#X}, {:?});",
                target,
                levels,
                internalformat,
                width
            );
        }
        let out = call_atomic_ptr_4arg(
            "glTexStorage1DEXT",
            &glTexStorage1DEXT_p,
            target,
            levels,
            internalformat,
            width,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glTexStorage1DEXT");
        }
        out
    }
    #[cfg(any(feature = "GL_EXT_texture_storage"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_texture_storage"))))]
    static glTexStorage1DEXT_p: APcv = ap_None();
    /// Tries to load [`glTexStorage1DEXT`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    #[cfg(any(feature = "GL_EXT_texture_storage"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_texture_storage"))))]
    pub unsafe fn glTexStorage1DEXT_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glTexStorage1DEXT\0",
            &glTexStorage1DEXT_p,
        )
    }
    /// Checks if the pointer for [`glTexStorage1DEXT`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    #[cfg(any(feature = "GL_EXT_texture_storage"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_texture_storage"))))]
    pub fn glTexStorage1DEXT_is_loaded() -> bool {
        !glTexStorage1DEXT_p.load(RELAX).is_null()
    }

    /// [glTexStorage2D](http://docs.gl/es3/glTexStorage2D)(target, levels, internalformat, width, height)
    /// `target` group: TextureTarget
    /// `internalformat` group: SizedInternalFormat
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn glTexStorage2D(
        target: GLenum,
        levels: GLsizei,
        internalformat: GLenum,
        width: GLsizei,
        height: GLsizei,
    ) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glTexStorage2D({:#X}, {:?}, {:#X}, {:?}, {:?});",
                target,
                levels,
                internalformat,
                width,
                height
            );
        }
        let out = call_atomic_ptr_5arg(
            "glTexStorage2D",
            &glTexStorage2D_p,
            target,
            levels,
            internalformat,
            width,
            height,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glTexStorage2D");
        }
        out
    }
    static glTexStorage2D_p: APcv = ap_None();
    /// Tries to load [`glTexStorage2D`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    pub unsafe fn glTexStorage2D_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(get_proc_address, b"glTexStorage2D\0", &glTexStorage2D_p)
    }
    /// Checks if the pointer for [`glTexStorage2D`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    pub fn glTexStorage2D_is_loaded() -> bool {
        !glTexStorage2D_p.load(RELAX).is_null()
    }

    /// [glTexStorage2DEXT](http://docs.gl/es3/glTexStorage2DEXT)(target, levels, internalformat, width, height)
    /// `target` group: TextureTarget
    /// `internalformat` group: SizedInternalFormat
    /// alias of: [`glTexStorage2D`]
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    #[cfg(any(feature = "GL_EXT_texture_storage"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_texture_storage"))))]
    pub unsafe fn glTexStorage2DEXT(
        target: GLenum,
        levels: GLsizei,
        internalformat: GLenum,
        width: GLsizei,
        height: GLsizei,
    ) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glTexStorage2DEXT({:#X}, {:?}, {:#X}, {:?}, {:?});",
                target,
                levels,
                internalformat,
                width,
                height
            );
        }
        let out = call_atomic_ptr_5arg(
            "glTexStorage2DEXT",
            &glTexStorage2DEXT_p,
            target,
            levels,
            internalformat,
            width,
            height,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glTexStorage2DEXT");
        }
        out
    }
    #[cfg(any(feature = "GL_EXT_texture_storage"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_texture_storage"))))]
    static glTexStorage2DEXT_p: APcv = ap_None();
    /// Tries to load [`glTexStorage2DEXT`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    #[cfg(any(feature = "GL_EXT_texture_storage"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_texture_storage"))))]
    pub unsafe fn glTexStorage2DEXT_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glTexStorage2DEXT\0",
            &glTexStorage2DEXT_p,
        )
    }
    /// Checks if the pointer for [`glTexStorage2DEXT`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    #[cfg(any(feature = "GL_EXT_texture_storage"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_texture_storage"))))]
    pub fn glTexStorage2DEXT_is_loaded() -> bool {
        !glTexStorage2DEXT_p.load(RELAX).is_null()
    }

    /// [glTexStorage2DMultisample](http://docs.gl/es3/glTexStorage2DMultisample)(target, samples, internalformat, width, height, fixedsamplelocations)
    /// `target` group: TextureTarget
    /// `internalformat` group: SizedInternalFormat
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn glTexStorage2DMultisample(
        target: GLenum,
        samples: GLsizei,
        internalformat: GLenum,
        width: GLsizei,
        height: GLsizei,
        fixedsamplelocations: GLboolean,
    ) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glTexStorage2DMultisample({:#X}, {:?}, {:#X}, {:?}, {:?}, {:?});",
                target,
                samples,
                internalformat,
                width,
                height,
                fixedsamplelocations
            );
        }
        let out = call_atomic_ptr_6arg(
            "glTexStorage2DMultisample",
            &glTexStorage2DMultisample_p,
            target,
            samples,
            internalformat,
            width,
            height,
            fixedsamplelocations,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glTexStorage2DMultisample");
        }
        out
    }
    static glTexStorage2DMultisample_p: APcv = ap_None();
    /// Tries to load [`glTexStorage2DMultisample`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    pub unsafe fn glTexStorage2DMultisample_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glTexStorage2DMultisample\0",
            &glTexStorage2DMultisample_p,
        )
    }
    /// Checks if the pointer for [`glTexStorage2DMultisample`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    pub fn glTexStorage2DMultisample_is_loaded() -> bool {
        !glTexStorage2DMultisample_p.load(RELAX).is_null()
    }

    /// [glTexStorage3D](http://docs.gl/es3/glTexStorage3D)(target, levels, internalformat, width, height, depth)
    /// `target` group: TextureTarget
    /// `internalformat` group: SizedInternalFormat
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn glTexStorage3D(
        target: GLenum,
        levels: GLsizei,
        internalformat: GLenum,
        width: GLsizei,
        height: GLsizei,
        depth: GLsizei,
    ) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glTexStorage3D({:#X}, {:?}, {:#X}, {:?}, {:?}, {:?});",
                target,
                levels,
                internalformat,
                width,
                height,
                depth
            );
        }
        let out = call_atomic_ptr_6arg(
            "glTexStorage3D",
            &glTexStorage3D_p,
            target,
            levels,
            internalformat,
            width,
            height,
            depth,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glTexStorage3D");
        }
        out
    }
    static glTexStorage3D_p: APcv = ap_None();
    /// Tries to load [`glTexStorage3D`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    pub unsafe fn glTexStorage3D_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(get_proc_address, b"glTexStorage3D\0", &glTexStorage3D_p)
    }
    /// Checks if the pointer for [`glTexStorage3D`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    pub fn glTexStorage3D_is_loaded() -> bool {
        !glTexStorage3D_p.load(RELAX).is_null()
    }

    /// [glTexStorage3DEXT](http://docs.gl/es3/glTexStorage3DEXT)(target, levels, internalformat, width, height, depth)
    /// `target` group: TextureTarget
    /// `internalformat` group: SizedInternalFormat
    /// alias of: [`glTexStorage3D`]
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    #[cfg(any(feature = "GL_EXT_texture_storage"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_texture_storage"))))]
    pub unsafe fn glTexStorage3DEXT(
        target: GLenum,
        levels: GLsizei,
        internalformat: GLenum,
        width: GLsizei,
        height: GLsizei,
        depth: GLsizei,
    ) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glTexStorage3DEXT({:#X}, {:?}, {:#X}, {:?}, {:?}, {:?});",
                target,
                levels,
                internalformat,
                width,
                height,
                depth
            );
        }
        let out = call_atomic_ptr_6arg(
            "glTexStorage3DEXT",
            &glTexStorage3DEXT_p,
            target,
            levels,
            internalformat,
            width,
            height,
            depth,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glTexStorage3DEXT");
        }
        out
    }
    #[cfg(any(feature = "GL_EXT_texture_storage"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_texture_storage"))))]
    static glTexStorage3DEXT_p: APcv = ap_None();
    /// Tries to load [`glTexStorage3DEXT`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    #[cfg(any(feature = "GL_EXT_texture_storage"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_texture_storage"))))]
    pub unsafe fn glTexStorage3DEXT_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glTexStorage3DEXT\0",
            &glTexStorage3DEXT_p,
        )
    }
    /// Checks if the pointer for [`glTexStorage3DEXT`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    #[cfg(any(feature = "GL_EXT_texture_storage"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_texture_storage"))))]
    pub fn glTexStorage3DEXT_is_loaded() -> bool {
        !glTexStorage3DEXT_p.load(RELAX).is_null()
    }

    /// [glTexStorage3DMultisample](http://docs.gl/es3/glTexStorage3DMultisample)(target, samples, internalformat, width, height, depth, fixedsamplelocations)
    /// `target` group: TextureTarget
    /// `internalformat` group: SizedInternalFormat
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn glTexStorage3DMultisample(
        target: GLenum,
        samples: GLsizei,
        internalformat: GLenum,
        width: GLsizei,
        height: GLsizei,
        depth: GLsizei,
        fixedsamplelocations: GLboolean,
    ) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glTexStorage3DMultisample({:#X}, {:?}, {:#X}, {:?}, {:?}, {:?}, {:?});",
                target,
                samples,
                internalformat,
                width,
                height,
                depth,
                fixedsamplelocations
            );
        }
        let out = call_atomic_ptr_7arg(
            "glTexStorage3DMultisample",
            &glTexStorage3DMultisample_p,
            target,
            samples,
            internalformat,
            width,
            height,
            depth,
            fixedsamplelocations,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glTexStorage3DMultisample");
        }
        out
    }
    static glTexStorage3DMultisample_p: APcv = ap_None();
    /// Tries to load [`glTexStorage3DMultisample`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    pub unsafe fn glTexStorage3DMultisample_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glTexStorage3DMultisample\0",
            &glTexStorage3DMultisample_p,
        )
    }
    /// Checks if the pointer for [`glTexStorage3DMultisample`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    pub fn glTexStorage3DMultisample_is_loaded() -> bool {
        !glTexStorage3DMultisample_p.load(RELAX).is_null()
    }

    /// [glTexStorage3DMultisampleOES](http://docs.gl/es3/glTexStorage3DMultisampleOES)(target, samples, internalformat, width, height, depth, fixedsamplelocations)
    /// `target` group: TextureTarget
    /// `internalformat` group: SizedInternalFormat
    /// alias of: [`glTexStorage3DMultisample`]
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    #[cfg(any(feature = "GL_OES_texture_storage_multisample_2d_array"))]
    #[cfg_attr(
        docs_rs,
        doc(cfg(any(feature = "GL_OES_texture_storage_multisample_2d_array")))
    )]
    pub unsafe fn glTexStorage3DMultisampleOES(
        target: GLenum,
        samples: GLsizei,
        internalformat: GLenum,
        width: GLsizei,
        height: GLsizei,
        depth: GLsizei,
        fixedsamplelocations: GLboolean,
    ) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glTexStorage3DMultisampleOES({:#X}, {:?}, {:#X}, {:?}, {:?}, {:?}, {:?});",
                target,
                samples,
                internalformat,
                width,
                height,
                depth,
                fixedsamplelocations
            );
        }
        let out = call_atomic_ptr_7arg(
            "glTexStorage3DMultisampleOES",
            &glTexStorage3DMultisampleOES_p,
            target,
            samples,
            internalformat,
            width,
            height,
            depth,
            fixedsamplelocations,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glTexStorage3DMultisampleOES");
        }
        out
    }
    #[cfg(any(feature = "GL_OES_texture_storage_multisample_2d_array"))]
    #[cfg_attr(
        docs_rs,
        doc(cfg(any(feature = "GL_OES_texture_storage_multisample_2d_array")))
    )]
    static glTexStorage3DMultisampleOES_p: APcv = ap_None();
    /// Tries to load [`glTexStorage3DMultisampleOES`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    #[cfg(any(feature = "GL_OES_texture_storage_multisample_2d_array"))]
    #[cfg_attr(
        docs_rs,
        doc(cfg(any(feature = "GL_OES_texture_storage_multisample_2d_array")))
    )]
    pub unsafe fn glTexStorage3DMultisampleOES_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glTexStorage3DMultisampleOES\0",
            &glTexStorage3DMultisampleOES_p,
        )
    }
    /// Checks if the pointer for [`glTexStorage3DMultisampleOES`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    #[cfg(any(feature = "GL_OES_texture_storage_multisample_2d_array"))]
    #[cfg_attr(
        docs_rs,
        doc(cfg(any(feature = "GL_OES_texture_storage_multisample_2d_array")))
    )]
    pub fn glTexStorage3DMultisampleOES_is_loaded() -> bool {
        !glTexStorage3DMultisampleOES_p.load(RELAX).is_null()
    }

    /// [glTexStorageMem2DEXT](http://docs.gl/es3/glTexStorageMem2DEXT)(target, levels, internalFormat, width, height, memory, offset)
    /// `target` group: TextureTarget
    /// `internalFormat` group: SizedInternalFormat
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    #[cfg(any(feature = "GL_EXT_memory_object"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_memory_object"))))]
    pub unsafe fn glTexStorageMem2DEXT(
        target: GLenum,
        levels: GLsizei,
        internalFormat: GLenum,
        width: GLsizei,
        height: GLsizei,
        memory: GLuint,
        offset: GLuint64,
    ) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glTexStorageMem2DEXT({:#X}, {:?}, {:#X}, {:?}, {:?}, {:?}, {:?});",
                target,
                levels,
                internalFormat,
                width,
                height,
                memory,
                offset
            );
        }
        let out = call_atomic_ptr_7arg(
            "glTexStorageMem2DEXT",
            &glTexStorageMem2DEXT_p,
            target,
            levels,
            internalFormat,
            width,
            height,
            memory,
            offset,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glTexStorageMem2DEXT");
        }
        out
    }
    #[cfg(any(feature = "GL_EXT_memory_object"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_memory_object"))))]
    static glTexStorageMem2DEXT_p: APcv = ap_None();
    /// Tries to load [`glTexStorageMem2DEXT`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    #[cfg(any(feature = "GL_EXT_memory_object"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_memory_object"))))]
    pub unsafe fn glTexStorageMem2DEXT_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glTexStorageMem2DEXT\0",
            &glTexStorageMem2DEXT_p,
        )
    }
    /// Checks if the pointer for [`glTexStorageMem2DEXT`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    #[cfg(any(feature = "GL_EXT_memory_object"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_memory_object"))))]
    pub fn glTexStorageMem2DEXT_is_loaded() -> bool {
        !glTexStorageMem2DEXT_p.load(RELAX).is_null()
    }

    /// [glTexStorageMem2DMultisampleEXT](http://docs.gl/es3/glTexStorageMem2DMultisampleEXT)(target, samples, internalFormat, width, height, fixedSampleLocations, memory, offset)
    /// `target` group: TextureTarget
    /// `internalFormat` group: SizedInternalFormat
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    #[cfg(any(feature = "GL_EXT_memory_object"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_memory_object"))))]
    pub unsafe fn glTexStorageMem2DMultisampleEXT(
        target: GLenum,
        samples: GLsizei,
        internalFormat: GLenum,
        width: GLsizei,
        height: GLsizei,
        fixedSampleLocations: GLboolean,
        memory: GLuint,
        offset: GLuint64,
    ) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glTexStorageMem2DMultisampleEXT({:#X}, {:?}, {:#X}, {:?}, {:?}, {:?}, {:?}, {:?});",
                target,
                samples,
                internalFormat,
                width,
                height,
                fixedSampleLocations,
                memory,
                offset
            );
        }
        let out = call_atomic_ptr_8arg(
            "glTexStorageMem2DMultisampleEXT",
            &glTexStorageMem2DMultisampleEXT_p,
            target,
            samples,
            internalFormat,
            width,
            height,
            fixedSampleLocations,
            memory,
            offset,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glTexStorageMem2DMultisampleEXT");
        }
        out
    }
    #[cfg(any(feature = "GL_EXT_memory_object"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_memory_object"))))]
    static glTexStorageMem2DMultisampleEXT_p: APcv = ap_None();
    /// Tries to load [`glTexStorageMem2DMultisampleEXT`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    #[cfg(any(feature = "GL_EXT_memory_object"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_memory_object"))))]
    pub unsafe fn glTexStorageMem2DMultisampleEXT_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glTexStorageMem2DMultisampleEXT\0",
            &glTexStorageMem2DMultisampleEXT_p,
        )
    }
    /// Checks if the pointer for [`glTexStorageMem2DMultisampleEXT`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    #[cfg(any(feature = "GL_EXT_memory_object"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_memory_object"))))]
    pub fn glTexStorageMem2DMultisampleEXT_is_loaded() -> bool {
        !glTexStorageMem2DMultisampleEXT_p.load(RELAX).is_null()
    }

    /// [glTexStorageMem3DEXT](http://docs.gl/es3/glTexStorageMem3DEXT)(target, levels, internalFormat, width, height, depth, memory, offset)
    /// `target` group: TextureTarget
    /// `internalFormat` group: SizedInternalFormat
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    #[cfg(any(feature = "GL_EXT_memory_object"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_memory_object"))))]
    pub unsafe fn glTexStorageMem3DEXT(
        target: GLenum,
        levels: GLsizei,
        internalFormat: GLenum,
        width: GLsizei,
        height: GLsizei,
        depth: GLsizei,
        memory: GLuint,
        offset: GLuint64,
    ) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glTexStorageMem3DEXT({:#X}, {:?}, {:#X}, {:?}, {:?}, {:?}, {:?}, {:?});",
                target,
                levels,
                internalFormat,
                width,
                height,
                depth,
                memory,
                offset
            );
        }
        let out = call_atomic_ptr_8arg(
            "glTexStorageMem3DEXT",
            &glTexStorageMem3DEXT_p,
            target,
            levels,
            internalFormat,
            width,
            height,
            depth,
            memory,
            offset,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glTexStorageMem3DEXT");
        }
        out
    }
    #[cfg(any(feature = "GL_EXT_memory_object"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_memory_object"))))]
    static glTexStorageMem3DEXT_p: APcv = ap_None();
    /// Tries to load [`glTexStorageMem3DEXT`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    #[cfg(any(feature = "GL_EXT_memory_object"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_memory_object"))))]
    pub unsafe fn glTexStorageMem3DEXT_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glTexStorageMem3DEXT\0",
            &glTexStorageMem3DEXT_p,
        )
    }
    /// Checks if the pointer for [`glTexStorageMem3DEXT`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    #[cfg(any(feature = "GL_EXT_memory_object"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_memory_object"))))]
    pub fn glTexStorageMem3DEXT_is_loaded() -> bool {
        !glTexStorageMem3DEXT_p.load(RELAX).is_null()
    }

    /// [glTexStorageMem3DMultisampleEXT](http://docs.gl/es3/glTexStorageMem3DMultisampleEXT)(target, samples, internalFormat, width, height, depth, fixedSampleLocations, memory, offset)
    /// `target` group: TextureTarget
    /// `internalFormat` group: SizedInternalFormat
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    #[cfg(any(feature = "GL_EXT_memory_object"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_memory_object"))))]
    pub unsafe fn glTexStorageMem3DMultisampleEXT(
        target: GLenum,
        samples: GLsizei,
        internalFormat: GLenum,
        width: GLsizei,
        height: GLsizei,
        depth: GLsizei,
        fixedSampleLocations: GLboolean,
        memory: GLuint,
        offset: GLuint64,
    ) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glTexStorageMem3DMultisampleEXT({:#X}, {:?}, {:#X}, {:?}, {:?}, {:?}, {:?}, {:?}, {:?});",
                target,
                samples,
                internalFormat,
                width,
                height,
                depth,
                fixedSampleLocations,
                memory,
                offset
            );
        }
        let out = call_atomic_ptr_9arg(
            "glTexStorageMem3DMultisampleEXT",
            &glTexStorageMem3DMultisampleEXT_p,
            target,
            samples,
            internalFormat,
            width,
            height,
            depth,
            fixedSampleLocations,
            memory,
            offset,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glTexStorageMem3DMultisampleEXT");
        }
        out
    }
    #[cfg(any(feature = "GL_EXT_memory_object"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_memory_object"))))]
    static glTexStorageMem3DMultisampleEXT_p: APcv = ap_None();
    /// Tries to load [`glTexStorageMem3DMultisampleEXT`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    #[cfg(any(feature = "GL_EXT_memory_object"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_memory_object"))))]
    pub unsafe fn glTexStorageMem3DMultisampleEXT_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glTexStorageMem3DMultisampleEXT\0",
            &glTexStorageMem3DMultisampleEXT_p,
        )
    }
    /// Checks if the pointer for [`glTexStorageMem3DMultisampleEXT`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    #[cfg(any(feature = "GL_EXT_memory_object"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_memory_object"))))]
    pub fn glTexStorageMem3DMultisampleEXT_is_loaded() -> bool {
        !glTexStorageMem3DMultisampleEXT_p.load(RELAX).is_null()
    }

    /// [glTexSubImage2D](http://docs.gl/es3/glTexSubImage2D)(target, level, xoffset, yoffset, width, height, format, type_, pixels)
    /// `target` group: TextureTarget
    /// `level` group: CheckedInt32
    /// `xoffset` group: CheckedInt32
    /// `yoffset` group: CheckedInt32
    /// `format` group: PixelFormat
    /// `type_` group: PixelType
    /// `pixels` len: COMPSIZE(format,type,width,height)
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn glTexSubImage2D(
        target: GLenum,
        level: GLint,
        xoffset: GLint,
        yoffset: GLint,
        width: GLsizei,
        height: GLsizei,
        format: GLenum,
        type_: GLenum,
        pixels: *const c_void,
    ) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glTexSubImage2D({:#X}, {:?}, {:?}, {:?}, {:?}, {:?}, {:#X}, {:#X}, {:p});",
                target,
                level,
                xoffset,
                yoffset,
                width,
                height,
                format,
                type_,
                pixels
            );
        }
        let out = call_atomic_ptr_9arg(
            "glTexSubImage2D",
            &glTexSubImage2D_p,
            target,
            level,
            xoffset,
            yoffset,
            width,
            height,
            format,
            type_,
            pixels,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glTexSubImage2D");
        }
        out
    }
    static glTexSubImage2D_p: APcv = ap_None();
    /// Tries to load [`glTexSubImage2D`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    pub unsafe fn glTexSubImage2D_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(get_proc_address, b"glTexSubImage2D\0", &glTexSubImage2D_p)
    }
    /// Checks if the pointer for [`glTexSubImage2D`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    pub fn glTexSubImage2D_is_loaded() -> bool {
        !glTexSubImage2D_p.load(RELAX).is_null()
    }

    /// [glTexSubImage3D](http://docs.gl/es3/glTexSubImage3D)(target, level, xoffset, yoffset, zoffset, width, height, depth, format, type_, pixels)
    /// `target` group: TextureTarget
    /// `level` group: CheckedInt32
    /// `xoffset` group: CheckedInt32
    /// `yoffset` group: CheckedInt32
    /// `zoffset` group: CheckedInt32
    /// `format` group: PixelFormat
    /// `type_` group: PixelType
    /// `pixels` len: COMPSIZE(format,type,width,height,depth)
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn glTexSubImage3D(
        target: GLenum,
        level: GLint,
        xoffset: GLint,
        yoffset: GLint,
        zoffset: GLint,
        width: GLsizei,
        height: GLsizei,
        depth: GLsizei,
        format: GLenum,
        type_: GLenum,
        pixels: *const c_void,
    ) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glTexSubImage3D({:#X}, {:?}, {:?}, {:?}, {:?}, {:?}, {:?}, {:?}, {:#X}, {:#X}, {:p});",
                target,
                level,
                xoffset,
                yoffset,
                zoffset,
                width,
                height,
                depth,
                format,
                type_,
                pixels
            );
        }
        let out = call_atomic_ptr_11arg(
            "glTexSubImage3D",
            &glTexSubImage3D_p,
            target,
            level,
            xoffset,
            yoffset,
            zoffset,
            width,
            height,
            depth,
            format,
            type_,
            pixels,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glTexSubImage3D");
        }
        out
    }
    static glTexSubImage3D_p: APcv = ap_None();
    /// Tries to load [`glTexSubImage3D`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    pub unsafe fn glTexSubImage3D_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(get_proc_address, b"glTexSubImage3D\0", &glTexSubImage3D_p)
    }
    /// Checks if the pointer for [`glTexSubImage3D`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    pub fn glTexSubImage3D_is_loaded() -> bool {
        !glTexSubImage3D_p.load(RELAX).is_null()
    }

    /// [glTexSubImage3DOES](http://docs.gl/es3/glTexSubImage3DOES)(target, level, xoffset, yoffset, zoffset, width, height, depth, format, type_, pixels)
    /// `target` group: TextureTarget
    /// `format` group: PixelFormat
    /// `type_` group: PixelType
    /// `pixels` len: COMPSIZE(format,type,width,height,depth)
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    #[cfg(any(feature = "GL_OES_texture_3D"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_OES_texture_3D"))))]
    pub unsafe fn glTexSubImage3DOES(
        target: GLenum,
        level: GLint,
        xoffset: GLint,
        yoffset: GLint,
        zoffset: GLint,
        width: GLsizei,
        height: GLsizei,
        depth: GLsizei,
        format: GLenum,
        type_: GLenum,
        pixels: *const c_void,
    ) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glTexSubImage3DOES({:#X}, {:?}, {:?}, {:?}, {:?}, {:?}, {:?}, {:?}, {:#X}, {:#X}, {:p});",
                target,
                level,
                xoffset,
                yoffset,
                zoffset,
                width,
                height,
                depth,
                format,
                type_,
                pixels
            );
        }
        let out = call_atomic_ptr_11arg(
            "glTexSubImage3DOES",
            &glTexSubImage3DOES_p,
            target,
            level,
            xoffset,
            yoffset,
            zoffset,
            width,
            height,
            depth,
            format,
            type_,
            pixels,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glTexSubImage3DOES");
        }
        out
    }
    #[cfg(any(feature = "GL_OES_texture_3D"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_OES_texture_3D"))))]
    static glTexSubImage3DOES_p: APcv = ap_None();
    /// Tries to load [`glTexSubImage3DOES`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    #[cfg(any(feature = "GL_OES_texture_3D"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_OES_texture_3D"))))]
    pub unsafe fn glTexSubImage3DOES_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glTexSubImage3DOES\0",
            &glTexSubImage3DOES_p,
        )
    }
    /// Checks if the pointer for [`glTexSubImage3DOES`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    #[cfg(any(feature = "GL_OES_texture_3D"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_OES_texture_3D"))))]
    pub fn glTexSubImage3DOES_is_loaded() -> bool {
        !glTexSubImage3DOES_p.load(RELAX).is_null()
    }

    /// [glTextureAttachMemoryNV](http://docs.gl/es3/glTextureAttachMemoryNV)(texture, memory, offset)
    /// `texture` class: texture
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    #[cfg(any(feature = "GL_NV_memory_attachment"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_memory_attachment"))))]
    pub unsafe fn glTextureAttachMemoryNV(texture: GLuint, memory: GLuint, offset: GLuint64) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glTextureAttachMemoryNV({:?}, {:?}, {:?});",
                texture,
                memory,
                offset
            );
        }
        let out = call_atomic_ptr_3arg(
            "glTextureAttachMemoryNV",
            &glTextureAttachMemoryNV_p,
            texture,
            memory,
            offset,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glTextureAttachMemoryNV");
        }
        out
    }
    #[cfg(any(feature = "GL_NV_memory_attachment"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_memory_attachment"))))]
    static glTextureAttachMemoryNV_p: APcv = ap_None();
    /// Tries to load [`glTextureAttachMemoryNV`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    #[cfg(any(feature = "GL_NV_memory_attachment"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_memory_attachment"))))]
    pub unsafe fn glTextureAttachMemoryNV_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glTextureAttachMemoryNV\0",
            &glTextureAttachMemoryNV_p,
        )
    }
    /// Checks if the pointer for [`glTextureAttachMemoryNV`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    #[cfg(any(feature = "GL_NV_memory_attachment"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_memory_attachment"))))]
    pub fn glTextureAttachMemoryNV_is_loaded() -> bool {
        !glTextureAttachMemoryNV_p.load(RELAX).is_null()
    }

    /// [glTextureFoveationParametersQCOM](http://docs.gl/es3/glTextureFoveationParametersQCOM)(texture, layer, focalPoint, focalX, focalY, gainX, gainY, foveaArea)
    /// `texture` group: Texture
    /// `texture` class: texture
    /// `focalX` group: CheckedFloat32
    /// `focalY` group: CheckedFloat32
    /// `gainX` group: CheckedFloat32
    /// `gainY` group: CheckedFloat32
    /// `foveaArea` group: CheckedFloat32
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    #[cfg(any(feature = "GL_QCOM_texture_foveated"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_QCOM_texture_foveated"))))]
    pub unsafe fn glTextureFoveationParametersQCOM(
        texture: GLuint,
        layer: GLuint,
        focalPoint: GLuint,
        focalX: GLfloat,
        focalY: GLfloat,
        gainX: GLfloat,
        gainY: GLfloat,
        foveaArea: GLfloat,
    ) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glTextureFoveationParametersQCOM({:?}, {:?}, {:?}, {:?}, {:?}, {:?}, {:?}, {:?});",
                texture,
                layer,
                focalPoint,
                focalX,
                focalY,
                gainX,
                gainY,
                foveaArea
            );
        }
        let out = call_atomic_ptr_8arg(
            "glTextureFoveationParametersQCOM",
            &glTextureFoveationParametersQCOM_p,
            texture,
            layer,
            focalPoint,
            focalX,
            focalY,
            gainX,
            gainY,
            foveaArea,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glTextureFoveationParametersQCOM");
        }
        out
    }
    #[cfg(any(feature = "GL_QCOM_texture_foveated"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_QCOM_texture_foveated"))))]
    static glTextureFoveationParametersQCOM_p: APcv = ap_None();
    /// Tries to load [`glTextureFoveationParametersQCOM`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    #[cfg(any(feature = "GL_QCOM_texture_foveated"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_QCOM_texture_foveated"))))]
    pub unsafe fn glTextureFoveationParametersQCOM_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glTextureFoveationParametersQCOM\0",
            &glTextureFoveationParametersQCOM_p,
        )
    }
    /// Checks if the pointer for [`glTextureFoveationParametersQCOM`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    #[cfg(any(feature = "GL_QCOM_texture_foveated"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_QCOM_texture_foveated"))))]
    pub fn glTextureFoveationParametersQCOM_is_loaded() -> bool {
        !glTextureFoveationParametersQCOM_p.load(RELAX).is_null()
    }

    /// [glTexturePageCommitmentMemNV](http://docs.gl/es3/glTexturePageCommitmentMemNV)(texture, layer, level, xoffset, yoffset, zoffset, width, height, depth, memory, offset, commit)
    /// `texture` class: texture
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    #[cfg(any(feature = "GL_NV_memory_object_sparse"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_memory_object_sparse"))))]
    pub unsafe fn glTexturePageCommitmentMemNV(
        texture: GLuint,
        layer: GLint,
        level: GLint,
        xoffset: GLint,
        yoffset: GLint,
        zoffset: GLint,
        width: GLsizei,
        height: GLsizei,
        depth: GLsizei,
        memory: GLuint,
        offset: GLuint64,
        commit: GLboolean,
    ) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!("calling glTexturePageCommitmentMemNV({:?}, {:?}, {:?}, {:?}, {:?}, {:?}, {:?}, {:?}, {:?}, {:?}, {:?}, {:?});", texture, layer, level, xoffset, yoffset, zoffset, width, height, depth, memory, offset, commit);
        }
        let out = call_atomic_ptr_12arg(
            "glTexturePageCommitmentMemNV",
            &glTexturePageCommitmentMemNV_p,
            texture,
            layer,
            level,
            xoffset,
            yoffset,
            zoffset,
            width,
            height,
            depth,
            memory,
            offset,
            commit,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glTexturePageCommitmentMemNV");
        }
        out
    }
    #[cfg(any(feature = "GL_NV_memory_object_sparse"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_memory_object_sparse"))))]
    static glTexturePageCommitmentMemNV_p: APcv = ap_None();
    /// Tries to load [`glTexturePageCommitmentMemNV`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    #[cfg(any(feature = "GL_NV_memory_object_sparse"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_memory_object_sparse"))))]
    pub unsafe fn glTexturePageCommitmentMemNV_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glTexturePageCommitmentMemNV\0",
            &glTexturePageCommitmentMemNV_p,
        )
    }
    /// Checks if the pointer for [`glTexturePageCommitmentMemNV`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    #[cfg(any(feature = "GL_NV_memory_object_sparse"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_memory_object_sparse"))))]
    pub fn glTexturePageCommitmentMemNV_is_loaded() -> bool {
        !glTexturePageCommitmentMemNV_p.load(RELAX).is_null()
    }

    /// [glTextureStorage1DEXT](http://docs.gl/es3/glTextureStorage1DEXT)(texture, target, levels, internalformat, width)
    /// `texture` class: texture
    /// `internalformat` group: SizedInternalFormat
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    #[cfg(any(feature = "GL_EXT_texture_storage"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_texture_storage"))))]
    pub unsafe fn glTextureStorage1DEXT(
        texture: GLuint,
        target: GLenum,
        levels: GLsizei,
        internalformat: GLenum,
        width: GLsizei,
    ) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glTextureStorage1DEXT({:?}, {:#X}, {:?}, {:#X}, {:?});",
                texture,
                target,
                levels,
                internalformat,
                width
            );
        }
        let out = call_atomic_ptr_5arg(
            "glTextureStorage1DEXT",
            &glTextureStorage1DEXT_p,
            texture,
            target,
            levels,
            internalformat,
            width,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glTextureStorage1DEXT");
        }
        out
    }
    #[cfg(any(feature = "GL_EXT_texture_storage"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_texture_storage"))))]
    static glTextureStorage1DEXT_p: APcv = ap_None();
    /// Tries to load [`glTextureStorage1DEXT`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    #[cfg(any(feature = "GL_EXT_texture_storage"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_texture_storage"))))]
    pub unsafe fn glTextureStorage1DEXT_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glTextureStorage1DEXT\0",
            &glTextureStorage1DEXT_p,
        )
    }
    /// Checks if the pointer for [`glTextureStorage1DEXT`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    #[cfg(any(feature = "GL_EXT_texture_storage"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_texture_storage"))))]
    pub fn glTextureStorage1DEXT_is_loaded() -> bool {
        !glTextureStorage1DEXT_p.load(RELAX).is_null()
    }

    /// [glTextureStorage2DEXT](http://docs.gl/es3/glTextureStorage2DEXT)(texture, target, levels, internalformat, width, height)
    /// `texture` class: texture
    /// `internalformat` group: SizedInternalFormat
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    #[cfg(any(feature = "GL_EXT_texture_storage"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_texture_storage"))))]
    pub unsafe fn glTextureStorage2DEXT(
        texture: GLuint,
        target: GLenum,
        levels: GLsizei,
        internalformat: GLenum,
        width: GLsizei,
        height: GLsizei,
    ) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glTextureStorage2DEXT({:?}, {:#X}, {:?}, {:#X}, {:?}, {:?});",
                texture,
                target,
                levels,
                internalformat,
                width,
                height
            );
        }
        let out = call_atomic_ptr_6arg(
            "glTextureStorage2DEXT",
            &glTextureStorage2DEXT_p,
            texture,
            target,
            levels,
            internalformat,
            width,
            height,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glTextureStorage2DEXT");
        }
        out
    }
    #[cfg(any(feature = "GL_EXT_texture_storage"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_texture_storage"))))]
    static glTextureStorage2DEXT_p: APcv = ap_None();
    /// Tries to load [`glTextureStorage2DEXT`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    #[cfg(any(feature = "GL_EXT_texture_storage"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_texture_storage"))))]
    pub unsafe fn glTextureStorage2DEXT_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glTextureStorage2DEXT\0",
            &glTextureStorage2DEXT_p,
        )
    }
    /// Checks if the pointer for [`glTextureStorage2DEXT`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    #[cfg(any(feature = "GL_EXT_texture_storage"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_texture_storage"))))]
    pub fn glTextureStorage2DEXT_is_loaded() -> bool {
        !glTextureStorage2DEXT_p.load(RELAX).is_null()
    }

    /// [glTextureStorage3DEXT](http://docs.gl/es3/glTextureStorage3DEXT)(texture, target, levels, internalformat, width, height, depth)
    /// `texture` class: texture
    /// `internalformat` group: SizedInternalFormat
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    #[cfg(any(feature = "GL_EXT_texture_storage"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_texture_storage"))))]
    pub unsafe fn glTextureStorage3DEXT(
        texture: GLuint,
        target: GLenum,
        levels: GLsizei,
        internalformat: GLenum,
        width: GLsizei,
        height: GLsizei,
        depth: GLsizei,
    ) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glTextureStorage3DEXT({:?}, {:#X}, {:?}, {:#X}, {:?}, {:?}, {:?});",
                texture,
                target,
                levels,
                internalformat,
                width,
                height,
                depth
            );
        }
        let out = call_atomic_ptr_7arg(
            "glTextureStorage3DEXT",
            &glTextureStorage3DEXT_p,
            texture,
            target,
            levels,
            internalformat,
            width,
            height,
            depth,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glTextureStorage3DEXT");
        }
        out
    }
    #[cfg(any(feature = "GL_EXT_texture_storage"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_texture_storage"))))]
    static glTextureStorage3DEXT_p: APcv = ap_None();
    /// Tries to load [`glTextureStorage3DEXT`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    #[cfg(any(feature = "GL_EXT_texture_storage"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_texture_storage"))))]
    pub unsafe fn glTextureStorage3DEXT_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glTextureStorage3DEXT\0",
            &glTextureStorage3DEXT_p,
        )
    }
    /// Checks if the pointer for [`glTextureStorage3DEXT`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    #[cfg(any(feature = "GL_EXT_texture_storage"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_texture_storage"))))]
    pub fn glTextureStorage3DEXT_is_loaded() -> bool {
        !glTextureStorage3DEXT_p.load(RELAX).is_null()
    }

    /// [glTextureStorageMem2DEXT](http://docs.gl/es3/glTextureStorageMem2DEXT)(texture, levels, internalFormat, width, height, memory, offset)
    /// `texture` class: texture
    /// `internalFormat` group: SizedInternalFormat
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    #[cfg(any(feature = "GL_EXT_memory_object"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_memory_object"))))]
    pub unsafe fn glTextureStorageMem2DEXT(
        texture: GLuint,
        levels: GLsizei,
        internalFormat: GLenum,
        width: GLsizei,
        height: GLsizei,
        memory: GLuint,
        offset: GLuint64,
    ) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glTextureStorageMem2DEXT({:?}, {:?}, {:#X}, {:?}, {:?}, {:?}, {:?});",
                texture,
                levels,
                internalFormat,
                width,
                height,
                memory,
                offset
            );
        }
        let out = call_atomic_ptr_7arg(
            "glTextureStorageMem2DEXT",
            &glTextureStorageMem2DEXT_p,
            texture,
            levels,
            internalFormat,
            width,
            height,
            memory,
            offset,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glTextureStorageMem2DEXT");
        }
        out
    }
    #[cfg(any(feature = "GL_EXT_memory_object"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_memory_object"))))]
    static glTextureStorageMem2DEXT_p: APcv = ap_None();
    /// Tries to load [`glTextureStorageMem2DEXT`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    #[cfg(any(feature = "GL_EXT_memory_object"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_memory_object"))))]
    pub unsafe fn glTextureStorageMem2DEXT_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glTextureStorageMem2DEXT\0",
            &glTextureStorageMem2DEXT_p,
        )
    }
    /// Checks if the pointer for [`glTextureStorageMem2DEXT`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    #[cfg(any(feature = "GL_EXT_memory_object"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_memory_object"))))]
    pub fn glTextureStorageMem2DEXT_is_loaded() -> bool {
        !glTextureStorageMem2DEXT_p.load(RELAX).is_null()
    }

    /// [glTextureStorageMem2DMultisampleEXT](http://docs.gl/es3/glTextureStorageMem2DMultisampleEXT)(texture, samples, internalFormat, width, height, fixedSampleLocations, memory, offset)
    /// `texture` class: texture
    /// `internalFormat` group: SizedInternalFormat
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    #[cfg(any(feature = "GL_EXT_memory_object"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_memory_object"))))]
    pub unsafe fn glTextureStorageMem2DMultisampleEXT(
        texture: GLuint,
        samples: GLsizei,
        internalFormat: GLenum,
        width: GLsizei,
        height: GLsizei,
        fixedSampleLocations: GLboolean,
        memory: GLuint,
        offset: GLuint64,
    ) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glTextureStorageMem2DMultisampleEXT({:?}, {:?}, {:#X}, {:?}, {:?}, {:?}, {:?}, {:?});",
                texture,
                samples,
                internalFormat,
                width,
                height,
                fixedSampleLocations,
                memory,
                offset
            );
        }
        let out = call_atomic_ptr_8arg(
            "glTextureStorageMem2DMultisampleEXT",
            &glTextureStorageMem2DMultisampleEXT_p,
            texture,
            samples,
            internalFormat,
            width,
            height,
            fixedSampleLocations,
            memory,
            offset,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glTextureStorageMem2DMultisampleEXT");
        }
        out
    }
    #[cfg(any(feature = "GL_EXT_memory_object"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_memory_object"))))]
    static glTextureStorageMem2DMultisampleEXT_p: APcv = ap_None();
    /// Tries to load [`glTextureStorageMem2DMultisampleEXT`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    #[cfg(any(feature = "GL_EXT_memory_object"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_memory_object"))))]
    pub unsafe fn glTextureStorageMem2DMultisampleEXT_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glTextureStorageMem2DMultisampleEXT\0",
            &glTextureStorageMem2DMultisampleEXT_p,
        )
    }
    /// Checks if the pointer for [`glTextureStorageMem2DMultisampleEXT`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    #[cfg(any(feature = "GL_EXT_memory_object"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_memory_object"))))]
    pub fn glTextureStorageMem2DMultisampleEXT_is_loaded() -> bool {
        !glTextureStorageMem2DMultisampleEXT_p.load(RELAX).is_null()
    }

    /// [glTextureStorageMem3DEXT](http://docs.gl/es3/glTextureStorageMem3DEXT)(texture, levels, internalFormat, width, height, depth, memory, offset)
    /// `texture` class: texture
    /// `internalFormat` group: SizedInternalFormat
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    #[cfg(any(feature = "GL_EXT_memory_object"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_memory_object"))))]
    pub unsafe fn glTextureStorageMem3DEXT(
        texture: GLuint,
        levels: GLsizei,
        internalFormat: GLenum,
        width: GLsizei,
        height: GLsizei,
        depth: GLsizei,
        memory: GLuint,
        offset: GLuint64,
    ) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glTextureStorageMem3DEXT({:?}, {:?}, {:#X}, {:?}, {:?}, {:?}, {:?}, {:?});",
                texture,
                levels,
                internalFormat,
                width,
                height,
                depth,
                memory,
                offset
            );
        }
        let out = call_atomic_ptr_8arg(
            "glTextureStorageMem3DEXT",
            &glTextureStorageMem3DEXT_p,
            texture,
            levels,
            internalFormat,
            width,
            height,
            depth,
            memory,
            offset,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glTextureStorageMem3DEXT");
        }
        out
    }
    #[cfg(any(feature = "GL_EXT_memory_object"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_memory_object"))))]
    static glTextureStorageMem3DEXT_p: APcv = ap_None();
    /// Tries to load [`glTextureStorageMem3DEXT`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    #[cfg(any(feature = "GL_EXT_memory_object"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_memory_object"))))]
    pub unsafe fn glTextureStorageMem3DEXT_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glTextureStorageMem3DEXT\0",
            &glTextureStorageMem3DEXT_p,
        )
    }
    /// Checks if the pointer for [`glTextureStorageMem3DEXT`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    #[cfg(any(feature = "GL_EXT_memory_object"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_memory_object"))))]
    pub fn glTextureStorageMem3DEXT_is_loaded() -> bool {
        !glTextureStorageMem3DEXT_p.load(RELAX).is_null()
    }

    /// [glTextureStorageMem3DMultisampleEXT](http://docs.gl/es3/glTextureStorageMem3DMultisampleEXT)(texture, samples, internalFormat, width, height, depth, fixedSampleLocations, memory, offset)
    /// `texture` class: texture
    /// `internalFormat` group: SizedInternalFormat
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    #[cfg(any(feature = "GL_EXT_memory_object"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_memory_object"))))]
    pub unsafe fn glTextureStorageMem3DMultisampleEXT(
        texture: GLuint,
        samples: GLsizei,
        internalFormat: GLenum,
        width: GLsizei,
        height: GLsizei,
        depth: GLsizei,
        fixedSampleLocations: GLboolean,
        memory: GLuint,
        offset: GLuint64,
    ) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glTextureStorageMem3DMultisampleEXT({:?}, {:?}, {:#X}, {:?}, {:?}, {:?}, {:?}, {:?}, {:?});",
                texture,
                samples,
                internalFormat,
                width,
                height,
                depth,
                fixedSampleLocations,
                memory,
                offset
            );
        }
        let out = call_atomic_ptr_9arg(
            "glTextureStorageMem3DMultisampleEXT",
            &glTextureStorageMem3DMultisampleEXT_p,
            texture,
            samples,
            internalFormat,
            width,
            height,
            depth,
            fixedSampleLocations,
            memory,
            offset,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glTextureStorageMem3DMultisampleEXT");
        }
        out
    }
    #[cfg(any(feature = "GL_EXT_memory_object"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_memory_object"))))]
    static glTextureStorageMem3DMultisampleEXT_p: APcv = ap_None();
    /// Tries to load [`glTextureStorageMem3DMultisampleEXT`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    #[cfg(any(feature = "GL_EXT_memory_object"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_memory_object"))))]
    pub unsafe fn glTextureStorageMem3DMultisampleEXT_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glTextureStorageMem3DMultisampleEXT\0",
            &glTextureStorageMem3DMultisampleEXT_p,
        )
    }
    /// Checks if the pointer for [`glTextureStorageMem3DMultisampleEXT`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    #[cfg(any(feature = "GL_EXT_memory_object"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_memory_object"))))]
    pub fn glTextureStorageMem3DMultisampleEXT_is_loaded() -> bool {
        !glTextureStorageMem3DMultisampleEXT_p.load(RELAX).is_null()
    }

    /// [glTextureViewEXT](http://docs.gl/es3/glTextureViewEXT)(texture, target, origtexture, internalformat, minlevel, numlevels, minlayer, numlayers)
    /// `texture` class: texture
    /// `target` group: TextureTarget
    /// `origtexture` class: texture
    /// `internalformat` group: SizedInternalFormat
    /// alias of: [`glTextureView`]
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    #[cfg(any(feature = "GL_EXT_texture_view"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_texture_view"))))]
    pub unsafe fn glTextureViewEXT(
        texture: GLuint,
        target: GLenum,
        origtexture: GLuint,
        internalformat: GLenum,
        minlevel: GLuint,
        numlevels: GLuint,
        minlayer: GLuint,
        numlayers: GLuint,
    ) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glTextureViewEXT({:?}, {:#X}, {:?}, {:#X}, {:?}, {:?}, {:?}, {:?});",
                texture,
                target,
                origtexture,
                internalformat,
                minlevel,
                numlevels,
                minlayer,
                numlayers
            );
        }
        let out = call_atomic_ptr_8arg(
            "glTextureViewEXT",
            &glTextureViewEXT_p,
            texture,
            target,
            origtexture,
            internalformat,
            minlevel,
            numlevels,
            minlayer,
            numlayers,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glTextureViewEXT");
        }
        out
    }
    #[cfg(any(feature = "GL_EXT_texture_view"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_texture_view"))))]
    static glTextureViewEXT_p: APcv = ap_None();
    /// Tries to load [`glTextureViewEXT`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    #[cfg(any(feature = "GL_EXT_texture_view"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_texture_view"))))]
    pub unsafe fn glTextureViewEXT_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(get_proc_address, b"glTextureViewEXT\0", &glTextureViewEXT_p)
    }
    /// Checks if the pointer for [`glTextureViewEXT`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    #[cfg(any(feature = "GL_EXT_texture_view"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_texture_view"))))]
    pub fn glTextureViewEXT_is_loaded() -> bool {
        !glTextureViewEXT_p.load(RELAX).is_null()
    }

    /// [glTextureViewOES](http://docs.gl/es3/glTextureViewOES)(texture, target, origtexture, internalformat, minlevel, numlevels, minlayer, numlayers)
    /// `texture` class: texture
    /// `target` group: TextureTarget
    /// `origtexture` class: texture
    /// `internalformat` group: SizedInternalFormat
    /// alias of: [`glTextureView`]
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    #[cfg(any(feature = "GL_OES_texture_view"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_OES_texture_view"))))]
    pub unsafe fn glTextureViewOES(
        texture: GLuint,
        target: GLenum,
        origtexture: GLuint,
        internalformat: GLenum,
        minlevel: GLuint,
        numlevels: GLuint,
        minlayer: GLuint,
        numlayers: GLuint,
    ) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glTextureViewOES({:?}, {:#X}, {:?}, {:#X}, {:?}, {:?}, {:?}, {:?});",
                texture,
                target,
                origtexture,
                internalformat,
                minlevel,
                numlevels,
                minlayer,
                numlayers
            );
        }
        let out = call_atomic_ptr_8arg(
            "glTextureViewOES",
            &glTextureViewOES_p,
            texture,
            target,
            origtexture,
            internalformat,
            minlevel,
            numlevels,
            minlayer,
            numlayers,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glTextureViewOES");
        }
        out
    }
    #[cfg(any(feature = "GL_OES_texture_view"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_OES_texture_view"))))]
    static glTextureViewOES_p: APcv = ap_None();
    /// Tries to load [`glTextureViewOES`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    #[cfg(any(feature = "GL_OES_texture_view"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_OES_texture_view"))))]
    pub unsafe fn glTextureViewOES_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(get_proc_address, b"glTextureViewOES\0", &glTextureViewOES_p)
    }
    /// Checks if the pointer for [`glTextureViewOES`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    #[cfg(any(feature = "GL_OES_texture_view"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_OES_texture_view"))))]
    pub fn glTextureViewOES_is_loaded() -> bool {
        !glTextureViewOES_p.load(RELAX).is_null()
    }

    /// [glTransformFeedbackVaryings](http://docs.gl/es3/glTransformFeedbackVaryings)(program, count, varyings, bufferMode)
    /// `program` class: program
    /// `varyings` len: count
    /// `bufferMode` group: TransformFeedbackBufferMode
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn glTransformFeedbackVaryings(
        program: GLuint,
        count: GLsizei,
        varyings: *const *const GLchar,
        bufferMode: GLenum,
    ) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glTransformFeedbackVaryings({:?}, {:?}, {:p}, {:#X});",
                program,
                count,
                varyings,
                bufferMode
            );
        }
        let out = call_atomic_ptr_4arg(
            "glTransformFeedbackVaryings",
            &glTransformFeedbackVaryings_p,
            program,
            count,
            varyings,
            bufferMode,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glTransformFeedbackVaryings");
        }
        out
    }
    static glTransformFeedbackVaryings_p: APcv = ap_None();
    /// Tries to load [`glTransformFeedbackVaryings`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    pub unsafe fn glTransformFeedbackVaryings_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glTransformFeedbackVaryings\0",
            &glTransformFeedbackVaryings_p,
        )
    }
    /// Checks if the pointer for [`glTransformFeedbackVaryings`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    pub fn glTransformFeedbackVaryings_is_loaded() -> bool {
        !glTransformFeedbackVaryings_p.load(RELAX).is_null()
    }

    /// [glTransformPathNV](http://docs.gl/es3/glTransformPathNV)(resultPath, srcPath, transformType, transformValues)
    /// `resultPath` group: Path
    /// `srcPath` group: Path
    /// `transformType` group: PathTransformType
    /// `transformValues` len: COMPSIZE(transformType)
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    #[cfg(any(feature = "GL_NV_path_rendering"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_path_rendering"))))]
    pub unsafe fn glTransformPathNV(
        resultPath: GLuint,
        srcPath: GLuint,
        transformType: GLenum,
        transformValues: *const GLfloat,
    ) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glTransformPathNV({:?}, {:?}, {:#X}, {:p});",
                resultPath,
                srcPath,
                transformType,
                transformValues
            );
        }
        let out = call_atomic_ptr_4arg(
            "glTransformPathNV",
            &glTransformPathNV_p,
            resultPath,
            srcPath,
            transformType,
            transformValues,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glTransformPathNV");
        }
        out
    }
    #[cfg(any(feature = "GL_NV_path_rendering"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_path_rendering"))))]
    static glTransformPathNV_p: APcv = ap_None();
    /// Tries to load [`glTransformPathNV`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    #[cfg(any(feature = "GL_NV_path_rendering"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_path_rendering"))))]
    pub unsafe fn glTransformPathNV_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glTransformPathNV\0",
            &glTransformPathNV_p,
        )
    }
    /// Checks if the pointer for [`glTransformPathNV`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    #[cfg(any(feature = "GL_NV_path_rendering"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_path_rendering"))))]
    pub fn glTransformPathNV_is_loaded() -> bool {
        !glTransformPathNV_p.load(RELAX).is_null()
    }

    /// [glUniform1f](http://docs.gl/es3/glUniform)(location, v0)
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn glUniform1f(location: GLint, v0: GLfloat) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!("calling glUniform1f({:?}, {:?});", location, v0);
        }
        let out = call_atomic_ptr_2arg("glUniform1f", &glUniform1f_p, location, v0);
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glUniform1f");
        }
        out
    }
    static glUniform1f_p: APcv = ap_None();
    /// Tries to load [`glUniform1f`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    pub unsafe fn glUniform1f_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(get_proc_address, b"glUniform1f\0", &glUniform1f_p)
    }
    /// Checks if the pointer for [`glUniform1f`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    pub fn glUniform1f_is_loaded() -> bool {
        !glUniform1f_p.load(RELAX).is_null()
    }

    /// [glUniform1fv](http://docs.gl/es3/glUniform)(location, count, value)
    /// `value` len: count*1
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn glUniform1fv(location: GLint, count: GLsizei, value: *const GLfloat) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glUniform1fv({:?}, {:?}, {:p});",
                location,
                count,
                value
            );
        }
        let out = call_atomic_ptr_3arg("glUniform1fv", &glUniform1fv_p, location, count, value);
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glUniform1fv");
        }
        out
    }
    static glUniform1fv_p: APcv = ap_None();
    /// Tries to load [`glUniform1fv`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    pub unsafe fn glUniform1fv_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(get_proc_address, b"glUniform1fv\0", &glUniform1fv_p)
    }
    /// Checks if the pointer for [`glUniform1fv`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    pub fn glUniform1fv_is_loaded() -> bool {
        !glUniform1fv_p.load(RELAX).is_null()
    }

    /// [glUniform1i](http://docs.gl/es3/glUniform)(location, v0)
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn glUniform1i(location: GLint, v0: GLint) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!("calling glUniform1i({:?}, {:?});", location, v0);
        }
        let out = call_atomic_ptr_2arg("glUniform1i", &glUniform1i_p, location, v0);
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glUniform1i");
        }
        out
    }
    static glUniform1i_p: APcv = ap_None();
    /// Tries to load [`glUniform1i`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    pub unsafe fn glUniform1i_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(get_proc_address, b"glUniform1i\0", &glUniform1i_p)
    }
    /// Checks if the pointer for [`glUniform1i`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    pub fn glUniform1i_is_loaded() -> bool {
        !glUniform1i_p.load(RELAX).is_null()
    }

    /// [glUniform1i64NV](http://docs.gl/es3/glUniform1i64NV)(location, x)
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    #[cfg(any(feature = "GL_NV_gpu_shader5"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_gpu_shader5"))))]
    pub unsafe fn glUniform1i64NV(location: GLint, x: GLint64EXT) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!("calling glUniform1i64NV({:?}, {:?});", location, x);
        }
        let out = call_atomic_ptr_2arg("glUniform1i64NV", &glUniform1i64NV_p, location, x);
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glUniform1i64NV");
        }
        out
    }
    #[cfg(any(feature = "GL_NV_gpu_shader5"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_gpu_shader5"))))]
    static glUniform1i64NV_p: APcv = ap_None();
    /// Tries to load [`glUniform1i64NV`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    #[cfg(any(feature = "GL_NV_gpu_shader5"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_gpu_shader5"))))]
    pub unsafe fn glUniform1i64NV_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(get_proc_address, b"glUniform1i64NV\0", &glUniform1i64NV_p)
    }
    /// Checks if the pointer for [`glUniform1i64NV`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    #[cfg(any(feature = "GL_NV_gpu_shader5"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_gpu_shader5"))))]
    pub fn glUniform1i64NV_is_loaded() -> bool {
        !glUniform1i64NV_p.load(RELAX).is_null()
    }

    /// [glUniform1i64vNV](http://docs.gl/es3/glUniform1i64vNV)(location, count, value)
    /// `value` len: count*1
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    #[cfg(any(feature = "GL_NV_gpu_shader5"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_gpu_shader5"))))]
    pub unsafe fn glUniform1i64vNV(location: GLint, count: GLsizei, value: *const GLint64EXT) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glUniform1i64vNV({:?}, {:?}, {:p});",
                location,
                count,
                value
            );
        }
        let out = call_atomic_ptr_3arg(
            "glUniform1i64vNV",
            &glUniform1i64vNV_p,
            location,
            count,
            value,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glUniform1i64vNV");
        }
        out
    }
    #[cfg(any(feature = "GL_NV_gpu_shader5"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_gpu_shader5"))))]
    static glUniform1i64vNV_p: APcv = ap_None();
    /// Tries to load [`glUniform1i64vNV`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    #[cfg(any(feature = "GL_NV_gpu_shader5"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_gpu_shader5"))))]
    pub unsafe fn glUniform1i64vNV_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(get_proc_address, b"glUniform1i64vNV\0", &glUniform1i64vNV_p)
    }
    /// Checks if the pointer for [`glUniform1i64vNV`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    #[cfg(any(feature = "GL_NV_gpu_shader5"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_gpu_shader5"))))]
    pub fn glUniform1i64vNV_is_loaded() -> bool {
        !glUniform1i64vNV_p.load(RELAX).is_null()
    }

    /// [glUniform1iv](http://docs.gl/es3/glUniform)(location, count, value)
    /// `value` len: count*1
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn glUniform1iv(location: GLint, count: GLsizei, value: *const GLint) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glUniform1iv({:?}, {:?}, {:p});",
                location,
                count,
                value
            );
        }
        let out = call_atomic_ptr_3arg("glUniform1iv", &glUniform1iv_p, location, count, value);
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glUniform1iv");
        }
        out
    }
    static glUniform1iv_p: APcv = ap_None();
    /// Tries to load [`glUniform1iv`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    pub unsafe fn glUniform1iv_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(get_proc_address, b"glUniform1iv\0", &glUniform1iv_p)
    }
    /// Checks if the pointer for [`glUniform1iv`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    pub fn glUniform1iv_is_loaded() -> bool {
        !glUniform1iv_p.load(RELAX).is_null()
    }

    /// [glUniform1ui](http://docs.gl/es3/glUniform)(location, v0)
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn glUniform1ui(location: GLint, v0: GLuint) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!("calling glUniform1ui({:?}, {:?});", location, v0);
        }
        let out = call_atomic_ptr_2arg("glUniform1ui", &glUniform1ui_p, location, v0);
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glUniform1ui");
        }
        out
    }
    static glUniform1ui_p: APcv = ap_None();
    /// Tries to load [`glUniform1ui`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    pub unsafe fn glUniform1ui_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(get_proc_address, b"glUniform1ui\0", &glUniform1ui_p)
    }
    /// Checks if the pointer for [`glUniform1ui`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    pub fn glUniform1ui_is_loaded() -> bool {
        !glUniform1ui_p.load(RELAX).is_null()
    }

    /// [glUniform1ui64NV](http://docs.gl/es3/glUniform1ui64NV)(location, x)
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    #[cfg(any(feature = "GL_NV_gpu_shader5"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_gpu_shader5"))))]
    pub unsafe fn glUniform1ui64NV(location: GLint, x: GLuint64EXT) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!("calling glUniform1ui64NV({:?}, {:?});", location, x);
        }
        let out = call_atomic_ptr_2arg("glUniform1ui64NV", &glUniform1ui64NV_p, location, x);
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glUniform1ui64NV");
        }
        out
    }
    #[cfg(any(feature = "GL_NV_gpu_shader5"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_gpu_shader5"))))]
    static glUniform1ui64NV_p: APcv = ap_None();
    /// Tries to load [`glUniform1ui64NV`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    #[cfg(any(feature = "GL_NV_gpu_shader5"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_gpu_shader5"))))]
    pub unsafe fn glUniform1ui64NV_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(get_proc_address, b"glUniform1ui64NV\0", &glUniform1ui64NV_p)
    }
    /// Checks if the pointer for [`glUniform1ui64NV`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    #[cfg(any(feature = "GL_NV_gpu_shader5"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_gpu_shader5"))))]
    pub fn glUniform1ui64NV_is_loaded() -> bool {
        !glUniform1ui64NV_p.load(RELAX).is_null()
    }

    /// [glUniform1ui64vNV](http://docs.gl/es3/glUniform1ui64vNV)(location, count, value)
    /// `value` len: count*1
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    #[cfg(any(feature = "GL_NV_gpu_shader5"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_gpu_shader5"))))]
    pub unsafe fn glUniform1ui64vNV(location: GLint, count: GLsizei, value: *const GLuint64EXT) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glUniform1ui64vNV({:?}, {:?}, {:p});",
                location,
                count,
                value
            );
        }
        let out = call_atomic_ptr_3arg(
            "glUniform1ui64vNV",
            &glUniform1ui64vNV_p,
            location,
            count,
            value,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glUniform1ui64vNV");
        }
        out
    }
    #[cfg(any(feature = "GL_NV_gpu_shader5"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_gpu_shader5"))))]
    static glUniform1ui64vNV_p: APcv = ap_None();
    /// Tries to load [`glUniform1ui64vNV`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    #[cfg(any(feature = "GL_NV_gpu_shader5"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_gpu_shader5"))))]
    pub unsafe fn glUniform1ui64vNV_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glUniform1ui64vNV\0",
            &glUniform1ui64vNV_p,
        )
    }
    /// Checks if the pointer for [`glUniform1ui64vNV`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    #[cfg(any(feature = "GL_NV_gpu_shader5"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_gpu_shader5"))))]
    pub fn glUniform1ui64vNV_is_loaded() -> bool {
        !glUniform1ui64vNV_p.load(RELAX).is_null()
    }

    /// [glUniform1uiv](http://docs.gl/es3/glUniform)(location, count, value)
    /// `value` len: count*1
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn glUniform1uiv(location: GLint, count: GLsizei, value: *const GLuint) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glUniform1uiv({:?}, {:?}, {:p});",
                location,
                count,
                value
            );
        }
        let out = call_atomic_ptr_3arg("glUniform1uiv", &glUniform1uiv_p, location, count, value);
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glUniform1uiv");
        }
        out
    }
    static glUniform1uiv_p: APcv = ap_None();
    /// Tries to load [`glUniform1uiv`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    pub unsafe fn glUniform1uiv_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(get_proc_address, b"glUniform1uiv\0", &glUniform1uiv_p)
    }
    /// Checks if the pointer for [`glUniform1uiv`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    pub fn glUniform1uiv_is_loaded() -> bool {
        !glUniform1uiv_p.load(RELAX).is_null()
    }

    /// [glUniform2f](http://docs.gl/es3/glUniform)(location, v0, v1)
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn glUniform2f(location: GLint, v0: GLfloat, v1: GLfloat) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!("calling glUniform2f({:?}, {:?}, {:?});", location, v0, v1);
        }
        let out = call_atomic_ptr_3arg("glUniform2f", &glUniform2f_p, location, v0, v1);
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glUniform2f");
        }
        out
    }
    static glUniform2f_p: APcv = ap_None();
    /// Tries to load [`glUniform2f`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    pub unsafe fn glUniform2f_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(get_proc_address, b"glUniform2f\0", &glUniform2f_p)
    }
    /// Checks if the pointer for [`glUniform2f`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    pub fn glUniform2f_is_loaded() -> bool {
        !glUniform2f_p.load(RELAX).is_null()
    }

    /// [glUniform2fv](http://docs.gl/es3/glUniform)(location, count, value)
    /// `value` len: count*2
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn glUniform2fv(location: GLint, count: GLsizei, value: *const GLfloat) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glUniform2fv({:?}, {:?}, {:p});",
                location,
                count,
                value
            );
        }
        let out = call_atomic_ptr_3arg("glUniform2fv", &glUniform2fv_p, location, count, value);
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glUniform2fv");
        }
        out
    }
    static glUniform2fv_p: APcv = ap_None();
    /// Tries to load [`glUniform2fv`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    pub unsafe fn glUniform2fv_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(get_proc_address, b"glUniform2fv\0", &glUniform2fv_p)
    }
    /// Checks if the pointer for [`glUniform2fv`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    pub fn glUniform2fv_is_loaded() -> bool {
        !glUniform2fv_p.load(RELAX).is_null()
    }

    /// [glUniform2i](http://docs.gl/es3/glUniform)(location, v0, v1)
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn glUniform2i(location: GLint, v0: GLint, v1: GLint) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!("calling glUniform2i({:?}, {:?}, {:?});", location, v0, v1);
        }
        let out = call_atomic_ptr_3arg("glUniform2i", &glUniform2i_p, location, v0, v1);
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glUniform2i");
        }
        out
    }
    static glUniform2i_p: APcv = ap_None();
    /// Tries to load [`glUniform2i`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    pub unsafe fn glUniform2i_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(get_proc_address, b"glUniform2i\0", &glUniform2i_p)
    }
    /// Checks if the pointer for [`glUniform2i`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    pub fn glUniform2i_is_loaded() -> bool {
        !glUniform2i_p.load(RELAX).is_null()
    }

    /// [glUniform2i64NV](http://docs.gl/es3/glUniform2i64NV)(location, x, y)
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    #[cfg(any(feature = "GL_NV_gpu_shader5"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_gpu_shader5"))))]
    pub unsafe fn glUniform2i64NV(location: GLint, x: GLint64EXT, y: GLint64EXT) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!("calling glUniform2i64NV({:?}, {:?}, {:?});", location, x, y);
        }
        let out = call_atomic_ptr_3arg("glUniform2i64NV", &glUniform2i64NV_p, location, x, y);
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glUniform2i64NV");
        }
        out
    }
    #[cfg(any(feature = "GL_NV_gpu_shader5"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_gpu_shader5"))))]
    static glUniform2i64NV_p: APcv = ap_None();
    /// Tries to load [`glUniform2i64NV`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    #[cfg(any(feature = "GL_NV_gpu_shader5"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_gpu_shader5"))))]
    pub unsafe fn glUniform2i64NV_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(get_proc_address, b"glUniform2i64NV\0", &glUniform2i64NV_p)
    }
    /// Checks if the pointer for [`glUniform2i64NV`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    #[cfg(any(feature = "GL_NV_gpu_shader5"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_gpu_shader5"))))]
    pub fn glUniform2i64NV_is_loaded() -> bool {
        !glUniform2i64NV_p.load(RELAX).is_null()
    }

    /// [glUniform2i64vNV](http://docs.gl/es3/glUniform2i64vNV)(location, count, value)
    /// `value` len: count*2
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    #[cfg(any(feature = "GL_NV_gpu_shader5"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_gpu_shader5"))))]
    pub unsafe fn glUniform2i64vNV(location: GLint, count: GLsizei, value: *const GLint64EXT) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glUniform2i64vNV({:?}, {:?}, {:p});",
                location,
                count,
                value
            );
        }
        let out = call_atomic_ptr_3arg(
            "glUniform2i64vNV",
            &glUniform2i64vNV_p,
            location,
            count,
            value,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glUniform2i64vNV");
        }
        out
    }
    #[cfg(any(feature = "GL_NV_gpu_shader5"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_gpu_shader5"))))]
    static glUniform2i64vNV_p: APcv = ap_None();
    /// Tries to load [`glUniform2i64vNV`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    #[cfg(any(feature = "GL_NV_gpu_shader5"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_gpu_shader5"))))]
    pub unsafe fn glUniform2i64vNV_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(get_proc_address, b"glUniform2i64vNV\0", &glUniform2i64vNV_p)
    }
    /// Checks if the pointer for [`glUniform2i64vNV`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    #[cfg(any(feature = "GL_NV_gpu_shader5"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_gpu_shader5"))))]
    pub fn glUniform2i64vNV_is_loaded() -> bool {
        !glUniform2i64vNV_p.load(RELAX).is_null()
    }

    /// [glUniform2iv](http://docs.gl/es3/glUniform)(location, count, value)
    /// `value` len: count*2
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn glUniform2iv(location: GLint, count: GLsizei, value: *const GLint) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glUniform2iv({:?}, {:?}, {:p});",
                location,
                count,
                value
            );
        }
        let out = call_atomic_ptr_3arg("glUniform2iv", &glUniform2iv_p, location, count, value);
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glUniform2iv");
        }
        out
    }
    static glUniform2iv_p: APcv = ap_None();
    /// Tries to load [`glUniform2iv`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    pub unsafe fn glUniform2iv_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(get_proc_address, b"glUniform2iv\0", &glUniform2iv_p)
    }
    /// Checks if the pointer for [`glUniform2iv`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    pub fn glUniform2iv_is_loaded() -> bool {
        !glUniform2iv_p.load(RELAX).is_null()
    }

    /// [glUniform2ui](http://docs.gl/es3/glUniform)(location, v0, v1)
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn glUniform2ui(location: GLint, v0: GLuint, v1: GLuint) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!("calling glUniform2ui({:?}, {:?}, {:?});", location, v0, v1);
        }
        let out = call_atomic_ptr_3arg("glUniform2ui", &glUniform2ui_p, location, v0, v1);
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glUniform2ui");
        }
        out
    }
    static glUniform2ui_p: APcv = ap_None();
    /// Tries to load [`glUniform2ui`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    pub unsafe fn glUniform2ui_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(get_proc_address, b"glUniform2ui\0", &glUniform2ui_p)
    }
    /// Checks if the pointer for [`glUniform2ui`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    pub fn glUniform2ui_is_loaded() -> bool {
        !glUniform2ui_p.load(RELAX).is_null()
    }

    /// [glUniform2ui64NV](http://docs.gl/es3/glUniform2ui64NV)(location, x, y)
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    #[cfg(any(feature = "GL_NV_gpu_shader5"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_gpu_shader5"))))]
    pub unsafe fn glUniform2ui64NV(location: GLint, x: GLuint64EXT, y: GLuint64EXT) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glUniform2ui64NV({:?}, {:?}, {:?});",
                location,
                x,
                y
            );
        }
        let out = call_atomic_ptr_3arg("glUniform2ui64NV", &glUniform2ui64NV_p, location, x, y);
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glUniform2ui64NV");
        }
        out
    }
    #[cfg(any(feature = "GL_NV_gpu_shader5"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_gpu_shader5"))))]
    static glUniform2ui64NV_p: APcv = ap_None();
    /// Tries to load [`glUniform2ui64NV`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    #[cfg(any(feature = "GL_NV_gpu_shader5"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_gpu_shader5"))))]
    pub unsafe fn glUniform2ui64NV_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(get_proc_address, b"glUniform2ui64NV\0", &glUniform2ui64NV_p)
    }
    /// Checks if the pointer for [`glUniform2ui64NV`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    #[cfg(any(feature = "GL_NV_gpu_shader5"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_gpu_shader5"))))]
    pub fn glUniform2ui64NV_is_loaded() -> bool {
        !glUniform2ui64NV_p.load(RELAX).is_null()
    }

    /// [glUniform2ui64vNV](http://docs.gl/es3/glUniform2ui64vNV)(location, count, value)
    /// `value` len: count*2
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    #[cfg(any(feature = "GL_NV_gpu_shader5"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_gpu_shader5"))))]
    pub unsafe fn glUniform2ui64vNV(location: GLint, count: GLsizei, value: *const GLuint64EXT) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glUniform2ui64vNV({:?}, {:?}, {:p});",
                location,
                count,
                value
            );
        }
        let out = call_atomic_ptr_3arg(
            "glUniform2ui64vNV",
            &glUniform2ui64vNV_p,
            location,
            count,
            value,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glUniform2ui64vNV");
        }
        out
    }
    #[cfg(any(feature = "GL_NV_gpu_shader5"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_gpu_shader5"))))]
    static glUniform2ui64vNV_p: APcv = ap_None();
    /// Tries to load [`glUniform2ui64vNV`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    #[cfg(any(feature = "GL_NV_gpu_shader5"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_gpu_shader5"))))]
    pub unsafe fn glUniform2ui64vNV_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glUniform2ui64vNV\0",
            &glUniform2ui64vNV_p,
        )
    }
    /// Checks if the pointer for [`glUniform2ui64vNV`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    #[cfg(any(feature = "GL_NV_gpu_shader5"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_gpu_shader5"))))]
    pub fn glUniform2ui64vNV_is_loaded() -> bool {
        !glUniform2ui64vNV_p.load(RELAX).is_null()
    }

    /// [glUniform2uiv](http://docs.gl/es3/glUniform)(location, count, value)
    /// `value` len: count*2
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn glUniform2uiv(location: GLint, count: GLsizei, value: *const GLuint) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glUniform2uiv({:?}, {:?}, {:p});",
                location,
                count,
                value
            );
        }
        let out = call_atomic_ptr_3arg("glUniform2uiv", &glUniform2uiv_p, location, count, value);
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glUniform2uiv");
        }
        out
    }
    static glUniform2uiv_p: APcv = ap_None();
    /// Tries to load [`glUniform2uiv`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    pub unsafe fn glUniform2uiv_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(get_proc_address, b"glUniform2uiv\0", &glUniform2uiv_p)
    }
    /// Checks if the pointer for [`glUniform2uiv`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    pub fn glUniform2uiv_is_loaded() -> bool {
        !glUniform2uiv_p.load(RELAX).is_null()
    }

    /// [glUniform3f](http://docs.gl/es3/glUniform)(location, v0, v1, v2)
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn glUniform3f(location: GLint, v0: GLfloat, v1: GLfloat, v2: GLfloat) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glUniform3f({:?}, {:?}, {:?}, {:?});",
                location,
                v0,
                v1,
                v2
            );
        }
        let out = call_atomic_ptr_4arg("glUniform3f", &glUniform3f_p, location, v0, v1, v2);
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glUniform3f");
        }
        out
    }
    static glUniform3f_p: APcv = ap_None();
    /// Tries to load [`glUniform3f`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    pub unsafe fn glUniform3f_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(get_proc_address, b"glUniform3f\0", &glUniform3f_p)
    }
    /// Checks if the pointer for [`glUniform3f`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    pub fn glUniform3f_is_loaded() -> bool {
        !glUniform3f_p.load(RELAX).is_null()
    }

    /// [glUniform3fv](http://docs.gl/es3/glUniform)(location, count, value)
    /// `value` len: count*3
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn glUniform3fv(location: GLint, count: GLsizei, value: *const GLfloat) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glUniform3fv({:?}, {:?}, {:p});",
                location,
                count,
                value
            );
        }
        let out = call_atomic_ptr_3arg("glUniform3fv", &glUniform3fv_p, location, count, value);
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glUniform3fv");
        }
        out
    }
    static glUniform3fv_p: APcv = ap_None();
    /// Tries to load [`glUniform3fv`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    pub unsafe fn glUniform3fv_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(get_proc_address, b"glUniform3fv\0", &glUniform3fv_p)
    }
    /// Checks if the pointer for [`glUniform3fv`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    pub fn glUniform3fv_is_loaded() -> bool {
        !glUniform3fv_p.load(RELAX).is_null()
    }

    /// [glUniform3i](http://docs.gl/es3/glUniform)(location, v0, v1, v2)
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn glUniform3i(location: GLint, v0: GLint, v1: GLint, v2: GLint) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glUniform3i({:?}, {:?}, {:?}, {:?});",
                location,
                v0,
                v1,
                v2
            );
        }
        let out = call_atomic_ptr_4arg("glUniform3i", &glUniform3i_p, location, v0, v1, v2);
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glUniform3i");
        }
        out
    }
    static glUniform3i_p: APcv = ap_None();
    /// Tries to load [`glUniform3i`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    pub unsafe fn glUniform3i_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(get_proc_address, b"glUniform3i\0", &glUniform3i_p)
    }
    /// Checks if the pointer for [`glUniform3i`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    pub fn glUniform3i_is_loaded() -> bool {
        !glUniform3i_p.load(RELAX).is_null()
    }

    /// [glUniform3i64NV](http://docs.gl/es3/glUniform3i64NV)(location, x, y, z)
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    #[cfg(any(feature = "GL_NV_gpu_shader5"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_gpu_shader5"))))]
    pub unsafe fn glUniform3i64NV(location: GLint, x: GLint64EXT, y: GLint64EXT, z: GLint64EXT) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glUniform3i64NV({:?}, {:?}, {:?}, {:?});",
                location,
                x,
                y,
                z
            );
        }
        let out = call_atomic_ptr_4arg("glUniform3i64NV", &glUniform3i64NV_p, location, x, y, z);
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glUniform3i64NV");
        }
        out
    }
    #[cfg(any(feature = "GL_NV_gpu_shader5"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_gpu_shader5"))))]
    static glUniform3i64NV_p: APcv = ap_None();
    /// Tries to load [`glUniform3i64NV`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    #[cfg(any(feature = "GL_NV_gpu_shader5"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_gpu_shader5"))))]
    pub unsafe fn glUniform3i64NV_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(get_proc_address, b"glUniform3i64NV\0", &glUniform3i64NV_p)
    }
    /// Checks if the pointer for [`glUniform3i64NV`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    #[cfg(any(feature = "GL_NV_gpu_shader5"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_gpu_shader5"))))]
    pub fn glUniform3i64NV_is_loaded() -> bool {
        !glUniform3i64NV_p.load(RELAX).is_null()
    }

    /// [glUniform3i64vNV](http://docs.gl/es3/glUniform3i64vNV)(location, count, value)
    /// `value` len: count*3
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    #[cfg(any(feature = "GL_NV_gpu_shader5"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_gpu_shader5"))))]
    pub unsafe fn glUniform3i64vNV(location: GLint, count: GLsizei, value: *const GLint64EXT) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glUniform3i64vNV({:?}, {:?}, {:p});",
                location,
                count,
                value
            );
        }
        let out = call_atomic_ptr_3arg(
            "glUniform3i64vNV",
            &glUniform3i64vNV_p,
            location,
            count,
            value,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glUniform3i64vNV");
        }
        out
    }
    #[cfg(any(feature = "GL_NV_gpu_shader5"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_gpu_shader5"))))]
    static glUniform3i64vNV_p: APcv = ap_None();
    /// Tries to load [`glUniform3i64vNV`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    #[cfg(any(feature = "GL_NV_gpu_shader5"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_gpu_shader5"))))]
    pub unsafe fn glUniform3i64vNV_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(get_proc_address, b"glUniform3i64vNV\0", &glUniform3i64vNV_p)
    }
    /// Checks if the pointer for [`glUniform3i64vNV`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    #[cfg(any(feature = "GL_NV_gpu_shader5"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_gpu_shader5"))))]
    pub fn glUniform3i64vNV_is_loaded() -> bool {
        !glUniform3i64vNV_p.load(RELAX).is_null()
    }

    /// [glUniform3iv](http://docs.gl/es3/glUniform)(location, count, value)
    /// `value` len: count*3
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn glUniform3iv(location: GLint, count: GLsizei, value: *const GLint) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glUniform3iv({:?}, {:?}, {:p});",
                location,
                count,
                value
            );
        }
        let out = call_atomic_ptr_3arg("glUniform3iv", &glUniform3iv_p, location, count, value);
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glUniform3iv");
        }
        out
    }
    static glUniform3iv_p: APcv = ap_None();
    /// Tries to load [`glUniform3iv`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    pub unsafe fn glUniform3iv_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(get_proc_address, b"glUniform3iv\0", &glUniform3iv_p)
    }
    /// Checks if the pointer for [`glUniform3iv`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    pub fn glUniform3iv_is_loaded() -> bool {
        !glUniform3iv_p.load(RELAX).is_null()
    }

    /// [glUniform3ui](http://docs.gl/es3/glUniform)(location, v0, v1, v2)
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn glUniform3ui(location: GLint, v0: GLuint, v1: GLuint, v2: GLuint) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glUniform3ui({:?}, {:?}, {:?}, {:?});",
                location,
                v0,
                v1,
                v2
            );
        }
        let out = call_atomic_ptr_4arg("glUniform3ui", &glUniform3ui_p, location, v0, v1, v2);
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glUniform3ui");
        }
        out
    }
    static glUniform3ui_p: APcv = ap_None();
    /// Tries to load [`glUniform3ui`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    pub unsafe fn glUniform3ui_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(get_proc_address, b"glUniform3ui\0", &glUniform3ui_p)
    }
    /// Checks if the pointer for [`glUniform3ui`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    pub fn glUniform3ui_is_loaded() -> bool {
        !glUniform3ui_p.load(RELAX).is_null()
    }

    /// [glUniform3ui64NV](http://docs.gl/es3/glUniform3ui64NV)(location, x, y, z)
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    #[cfg(any(feature = "GL_NV_gpu_shader5"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_gpu_shader5"))))]
    pub unsafe fn glUniform3ui64NV(
        location: GLint,
        x: GLuint64EXT,
        y: GLuint64EXT,
        z: GLuint64EXT,
    ) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glUniform3ui64NV({:?}, {:?}, {:?}, {:?});",
                location,
                x,
                y,
                z
            );
        }
        let out = call_atomic_ptr_4arg("glUniform3ui64NV", &glUniform3ui64NV_p, location, x, y, z);
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glUniform3ui64NV");
        }
        out
    }
    #[cfg(any(feature = "GL_NV_gpu_shader5"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_gpu_shader5"))))]
    static glUniform3ui64NV_p: APcv = ap_None();
    /// Tries to load [`glUniform3ui64NV`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    #[cfg(any(feature = "GL_NV_gpu_shader5"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_gpu_shader5"))))]
    pub unsafe fn glUniform3ui64NV_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(get_proc_address, b"glUniform3ui64NV\0", &glUniform3ui64NV_p)
    }
    /// Checks if the pointer for [`glUniform3ui64NV`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    #[cfg(any(feature = "GL_NV_gpu_shader5"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_gpu_shader5"))))]
    pub fn glUniform3ui64NV_is_loaded() -> bool {
        !glUniform3ui64NV_p.load(RELAX).is_null()
    }

    /// [glUniform3ui64vNV](http://docs.gl/es3/glUniform3ui64vNV)(location, count, value)
    /// `value` len: count*3
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    #[cfg(any(feature = "GL_NV_gpu_shader5"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_gpu_shader5"))))]
    pub unsafe fn glUniform3ui64vNV(location: GLint, count: GLsizei, value: *const GLuint64EXT) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glUniform3ui64vNV({:?}, {:?}, {:p});",
                location,
                count,
                value
            );
        }
        let out = call_atomic_ptr_3arg(
            "glUniform3ui64vNV",
            &glUniform3ui64vNV_p,
            location,
            count,
            value,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glUniform3ui64vNV");
        }
        out
    }
    #[cfg(any(feature = "GL_NV_gpu_shader5"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_gpu_shader5"))))]
    static glUniform3ui64vNV_p: APcv = ap_None();
    /// Tries to load [`glUniform3ui64vNV`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    #[cfg(any(feature = "GL_NV_gpu_shader5"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_gpu_shader5"))))]
    pub unsafe fn glUniform3ui64vNV_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glUniform3ui64vNV\0",
            &glUniform3ui64vNV_p,
        )
    }
    /// Checks if the pointer for [`glUniform3ui64vNV`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    #[cfg(any(feature = "GL_NV_gpu_shader5"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_gpu_shader5"))))]
    pub fn glUniform3ui64vNV_is_loaded() -> bool {
        !glUniform3ui64vNV_p.load(RELAX).is_null()
    }

    /// [glUniform3uiv](http://docs.gl/es3/glUniform)(location, count, value)
    /// `value` len: count*3
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn glUniform3uiv(location: GLint, count: GLsizei, value: *const GLuint) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glUniform3uiv({:?}, {:?}, {:p});",
                location,
                count,
                value
            );
        }
        let out = call_atomic_ptr_3arg("glUniform3uiv", &glUniform3uiv_p, location, count, value);
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glUniform3uiv");
        }
        out
    }
    static glUniform3uiv_p: APcv = ap_None();
    /// Tries to load [`glUniform3uiv`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    pub unsafe fn glUniform3uiv_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(get_proc_address, b"glUniform3uiv\0", &glUniform3uiv_p)
    }
    /// Checks if the pointer for [`glUniform3uiv`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    pub fn glUniform3uiv_is_loaded() -> bool {
        !glUniform3uiv_p.load(RELAX).is_null()
    }

    /// [glUniform4f](http://docs.gl/es3/glUniform)(location, v0, v1, v2, v3)
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn glUniform4f(location: GLint, v0: GLfloat, v1: GLfloat, v2: GLfloat, v3: GLfloat) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glUniform4f({:?}, {:?}, {:?}, {:?}, {:?});",
                location,
                v0,
                v1,
                v2,
                v3
            );
        }
        let out = call_atomic_ptr_5arg("glUniform4f", &glUniform4f_p, location, v0, v1, v2, v3);
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glUniform4f");
        }
        out
    }
    static glUniform4f_p: APcv = ap_None();
    /// Tries to load [`glUniform4f`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    pub unsafe fn glUniform4f_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(get_proc_address, b"glUniform4f\0", &glUniform4f_p)
    }
    /// Checks if the pointer for [`glUniform4f`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    pub fn glUniform4f_is_loaded() -> bool {
        !glUniform4f_p.load(RELAX).is_null()
    }

    /// [glUniform4fv](http://docs.gl/es3/glUniform)(location, count, value)
    /// `value` len: count*4
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn glUniform4fv(location: GLint, count: GLsizei, value: *const GLfloat) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glUniform4fv({:?}, {:?}, {:p});",
                location,
                count,
                value
            );
        }
        let out = call_atomic_ptr_3arg("glUniform4fv", &glUniform4fv_p, location, count, value);
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glUniform4fv");
        }
        out
    }
    static glUniform4fv_p: APcv = ap_None();
    /// Tries to load [`glUniform4fv`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    pub unsafe fn glUniform4fv_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(get_proc_address, b"glUniform4fv\0", &glUniform4fv_p)
    }
    /// Checks if the pointer for [`glUniform4fv`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    pub fn glUniform4fv_is_loaded() -> bool {
        !glUniform4fv_p.load(RELAX).is_null()
    }

    /// [glUniform4i](http://docs.gl/es3/glUniform)(location, v0, v1, v2, v3)
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn glUniform4i(location: GLint, v0: GLint, v1: GLint, v2: GLint, v3: GLint) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glUniform4i({:?}, {:?}, {:?}, {:?}, {:?});",
                location,
                v0,
                v1,
                v2,
                v3
            );
        }
        let out = call_atomic_ptr_5arg("glUniform4i", &glUniform4i_p, location, v0, v1, v2, v3);
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glUniform4i");
        }
        out
    }
    static glUniform4i_p: APcv = ap_None();
    /// Tries to load [`glUniform4i`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    pub unsafe fn glUniform4i_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(get_proc_address, b"glUniform4i\0", &glUniform4i_p)
    }
    /// Checks if the pointer for [`glUniform4i`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    pub fn glUniform4i_is_loaded() -> bool {
        !glUniform4i_p.load(RELAX).is_null()
    }

    /// [glUniform4i64NV](http://docs.gl/es3/glUniform4i64NV)(location, x, y, z, w)
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    #[cfg(any(feature = "GL_NV_gpu_shader5"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_gpu_shader5"))))]
    pub unsafe fn glUniform4i64NV(
        location: GLint,
        x: GLint64EXT,
        y: GLint64EXT,
        z: GLint64EXT,
        w: GLint64EXT,
    ) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glUniform4i64NV({:?}, {:?}, {:?}, {:?}, {:?});",
                location,
                x,
                y,
                z,
                w
            );
        }
        let out = call_atomic_ptr_5arg("glUniform4i64NV", &glUniform4i64NV_p, location, x, y, z, w);
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glUniform4i64NV");
        }
        out
    }
    #[cfg(any(feature = "GL_NV_gpu_shader5"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_gpu_shader5"))))]
    static glUniform4i64NV_p: APcv = ap_None();
    /// Tries to load [`glUniform4i64NV`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    #[cfg(any(feature = "GL_NV_gpu_shader5"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_gpu_shader5"))))]
    pub unsafe fn glUniform4i64NV_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(get_proc_address, b"glUniform4i64NV\0", &glUniform4i64NV_p)
    }
    /// Checks if the pointer for [`glUniform4i64NV`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    #[cfg(any(feature = "GL_NV_gpu_shader5"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_gpu_shader5"))))]
    pub fn glUniform4i64NV_is_loaded() -> bool {
        !glUniform4i64NV_p.load(RELAX).is_null()
    }

    /// [glUniform4i64vNV](http://docs.gl/es3/glUniform4i64vNV)(location, count, value)
    /// `value` len: count*4
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    #[cfg(any(feature = "GL_NV_gpu_shader5"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_gpu_shader5"))))]
    pub unsafe fn glUniform4i64vNV(location: GLint, count: GLsizei, value: *const GLint64EXT) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glUniform4i64vNV({:?}, {:?}, {:p});",
                location,
                count,
                value
            );
        }
        let out = call_atomic_ptr_3arg(
            "glUniform4i64vNV",
            &glUniform4i64vNV_p,
            location,
            count,
            value,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glUniform4i64vNV");
        }
        out
    }
    #[cfg(any(feature = "GL_NV_gpu_shader5"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_gpu_shader5"))))]
    static glUniform4i64vNV_p: APcv = ap_None();
    /// Tries to load [`glUniform4i64vNV`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    #[cfg(any(feature = "GL_NV_gpu_shader5"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_gpu_shader5"))))]
    pub unsafe fn glUniform4i64vNV_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(get_proc_address, b"glUniform4i64vNV\0", &glUniform4i64vNV_p)
    }
    /// Checks if the pointer for [`glUniform4i64vNV`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    #[cfg(any(feature = "GL_NV_gpu_shader5"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_gpu_shader5"))))]
    pub fn glUniform4i64vNV_is_loaded() -> bool {
        !glUniform4i64vNV_p.load(RELAX).is_null()
    }

    /// [glUniform4iv](http://docs.gl/es3/glUniform)(location, count, value)
    /// `value` len: count*4
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn glUniform4iv(location: GLint, count: GLsizei, value: *const GLint) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glUniform4iv({:?}, {:?}, {:p});",
                location,
                count,
                value
            );
        }
        let out = call_atomic_ptr_3arg("glUniform4iv", &glUniform4iv_p, location, count, value);
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glUniform4iv");
        }
        out
    }
    static glUniform4iv_p: APcv = ap_None();
    /// Tries to load [`glUniform4iv`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    pub unsafe fn glUniform4iv_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(get_proc_address, b"glUniform4iv\0", &glUniform4iv_p)
    }
    /// Checks if the pointer for [`glUniform4iv`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    pub fn glUniform4iv_is_loaded() -> bool {
        !glUniform4iv_p.load(RELAX).is_null()
    }

    /// [glUniform4ui](http://docs.gl/es3/glUniform)(location, v0, v1, v2, v3)
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn glUniform4ui(location: GLint, v0: GLuint, v1: GLuint, v2: GLuint, v3: GLuint) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glUniform4ui({:?}, {:?}, {:?}, {:?}, {:?});",
                location,
                v0,
                v1,
                v2,
                v3
            );
        }
        let out = call_atomic_ptr_5arg("glUniform4ui", &glUniform4ui_p, location, v0, v1, v2, v3);
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glUniform4ui");
        }
        out
    }
    static glUniform4ui_p: APcv = ap_None();
    /// Tries to load [`glUniform4ui`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    pub unsafe fn glUniform4ui_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(get_proc_address, b"glUniform4ui\0", &glUniform4ui_p)
    }
    /// Checks if the pointer for [`glUniform4ui`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    pub fn glUniform4ui_is_loaded() -> bool {
        !glUniform4ui_p.load(RELAX).is_null()
    }

    /// [glUniform4ui64NV](http://docs.gl/es3/glUniform4ui64NV)(location, x, y, z, w)
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    #[cfg(any(feature = "GL_NV_gpu_shader5"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_gpu_shader5"))))]
    pub unsafe fn glUniform4ui64NV(
        location: GLint,
        x: GLuint64EXT,
        y: GLuint64EXT,
        z: GLuint64EXT,
        w: GLuint64EXT,
    ) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glUniform4ui64NV({:?}, {:?}, {:?}, {:?}, {:?});",
                location,
                x,
                y,
                z,
                w
            );
        }
        let out = call_atomic_ptr_5arg(
            "glUniform4ui64NV",
            &glUniform4ui64NV_p,
            location,
            x,
            y,
            z,
            w,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glUniform4ui64NV");
        }
        out
    }
    #[cfg(any(feature = "GL_NV_gpu_shader5"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_gpu_shader5"))))]
    static glUniform4ui64NV_p: APcv = ap_None();
    /// Tries to load [`glUniform4ui64NV`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    #[cfg(any(feature = "GL_NV_gpu_shader5"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_gpu_shader5"))))]
    pub unsafe fn glUniform4ui64NV_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(get_proc_address, b"glUniform4ui64NV\0", &glUniform4ui64NV_p)
    }
    /// Checks if the pointer for [`glUniform4ui64NV`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    #[cfg(any(feature = "GL_NV_gpu_shader5"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_gpu_shader5"))))]
    pub fn glUniform4ui64NV_is_loaded() -> bool {
        !glUniform4ui64NV_p.load(RELAX).is_null()
    }

    /// [glUniform4ui64vNV](http://docs.gl/es3/glUniform4ui64vNV)(location, count, value)
    /// `value` len: count*4
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    #[cfg(any(feature = "GL_NV_gpu_shader5"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_gpu_shader5"))))]
    pub unsafe fn glUniform4ui64vNV(location: GLint, count: GLsizei, value: *const GLuint64EXT) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glUniform4ui64vNV({:?}, {:?}, {:p});",
                location,
                count,
                value
            );
        }
        let out = call_atomic_ptr_3arg(
            "glUniform4ui64vNV",
            &glUniform4ui64vNV_p,
            location,
            count,
            value,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glUniform4ui64vNV");
        }
        out
    }
    #[cfg(any(feature = "GL_NV_gpu_shader5"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_gpu_shader5"))))]
    static glUniform4ui64vNV_p: APcv = ap_None();
    /// Tries to load [`glUniform4ui64vNV`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    #[cfg(any(feature = "GL_NV_gpu_shader5"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_gpu_shader5"))))]
    pub unsafe fn glUniform4ui64vNV_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glUniform4ui64vNV\0",
            &glUniform4ui64vNV_p,
        )
    }
    /// Checks if the pointer for [`glUniform4ui64vNV`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    #[cfg(any(feature = "GL_NV_gpu_shader5"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_gpu_shader5"))))]
    pub fn glUniform4ui64vNV_is_loaded() -> bool {
        !glUniform4ui64vNV_p.load(RELAX).is_null()
    }

    /// [glUniform4uiv](http://docs.gl/es3/glUniform)(location, count, value)
    /// `value` len: count*4
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn glUniform4uiv(location: GLint, count: GLsizei, value: *const GLuint) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glUniform4uiv({:?}, {:?}, {:p});",
                location,
                count,
                value
            );
        }
        let out = call_atomic_ptr_3arg("glUniform4uiv", &glUniform4uiv_p, location, count, value);
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glUniform4uiv");
        }
        out
    }
    static glUniform4uiv_p: APcv = ap_None();
    /// Tries to load [`glUniform4uiv`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    pub unsafe fn glUniform4uiv_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(get_proc_address, b"glUniform4uiv\0", &glUniform4uiv_p)
    }
    /// Checks if the pointer for [`glUniform4uiv`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    pub fn glUniform4uiv_is_loaded() -> bool {
        !glUniform4uiv_p.load(RELAX).is_null()
    }

    /// [glUniformBlockBinding](http://docs.gl/es3/glUniformBlockBinding)(program, uniformBlockIndex, uniformBlockBinding)
    /// `program` class: program
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn glUniformBlockBinding(
        program: GLuint,
        uniformBlockIndex: GLuint,
        uniformBlockBinding: GLuint,
    ) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glUniformBlockBinding({:?}, {:?}, {:?});",
                program,
                uniformBlockIndex,
                uniformBlockBinding
            );
        }
        let out = call_atomic_ptr_3arg(
            "glUniformBlockBinding",
            &glUniformBlockBinding_p,
            program,
            uniformBlockIndex,
            uniformBlockBinding,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glUniformBlockBinding");
        }
        out
    }
    static glUniformBlockBinding_p: APcv = ap_None();
    /// Tries to load [`glUniformBlockBinding`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    pub unsafe fn glUniformBlockBinding_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glUniformBlockBinding\0",
            &glUniformBlockBinding_p,
        )
    }
    /// Checks if the pointer for [`glUniformBlockBinding`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    pub fn glUniformBlockBinding_is_loaded() -> bool {
        !glUniformBlockBinding_p.load(RELAX).is_null()
    }

    /// [glUniformHandleui64IMG](http://docs.gl/es3/glUniformHandleui64IMG)(location, value)
    /// alias of: [`glUniformHandleui64ARB`]
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    #[cfg(any(feature = "GL_IMG_bindless_texture"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_IMG_bindless_texture"))))]
    pub unsafe fn glUniformHandleui64IMG(location: GLint, value: GLuint64) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glUniformHandleui64IMG({:?}, {:?});",
                location,
                value
            );
        }
        let out = call_atomic_ptr_2arg(
            "glUniformHandleui64IMG",
            &glUniformHandleui64IMG_p,
            location,
            value,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glUniformHandleui64IMG");
        }
        out
    }
    #[cfg(any(feature = "GL_IMG_bindless_texture"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_IMG_bindless_texture"))))]
    static glUniformHandleui64IMG_p: APcv = ap_None();
    /// Tries to load [`glUniformHandleui64IMG`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    #[cfg(any(feature = "GL_IMG_bindless_texture"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_IMG_bindless_texture"))))]
    pub unsafe fn glUniformHandleui64IMG_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glUniformHandleui64IMG\0",
            &glUniformHandleui64IMG_p,
        )
    }
    /// Checks if the pointer for [`glUniformHandleui64IMG`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    #[cfg(any(feature = "GL_IMG_bindless_texture"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_IMG_bindless_texture"))))]
    pub fn glUniformHandleui64IMG_is_loaded() -> bool {
        !glUniformHandleui64IMG_p.load(RELAX).is_null()
    }

    /// [glUniformHandleui64NV](http://docs.gl/es3/glUniformHandleui64NV)(location, value)
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    #[cfg(any(feature = "GL_NV_bindless_texture"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_bindless_texture"))))]
    pub unsafe fn glUniformHandleui64NV(location: GLint, value: GLuint64) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glUniformHandleui64NV({:?}, {:?});",
                location,
                value
            );
        }
        let out = call_atomic_ptr_2arg(
            "glUniformHandleui64NV",
            &glUniformHandleui64NV_p,
            location,
            value,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glUniformHandleui64NV");
        }
        out
    }
    #[cfg(any(feature = "GL_NV_bindless_texture"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_bindless_texture"))))]
    static glUniformHandleui64NV_p: APcv = ap_None();
    /// Tries to load [`glUniformHandleui64NV`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    #[cfg(any(feature = "GL_NV_bindless_texture"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_bindless_texture"))))]
    pub unsafe fn glUniformHandleui64NV_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glUniformHandleui64NV\0",
            &glUniformHandleui64NV_p,
        )
    }
    /// Checks if the pointer for [`glUniformHandleui64NV`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    #[cfg(any(feature = "GL_NV_bindless_texture"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_bindless_texture"))))]
    pub fn glUniformHandleui64NV_is_loaded() -> bool {
        !glUniformHandleui64NV_p.load(RELAX).is_null()
    }

    /// [glUniformHandleui64vIMG](http://docs.gl/es3/glUniformHandleui64vIMG)(location, count, value)
    /// `value` len: count
    /// alias of: [`glUniformHandleui64vARB`]
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    #[cfg(any(feature = "GL_IMG_bindless_texture"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_IMG_bindless_texture"))))]
    pub unsafe fn glUniformHandleui64vIMG(location: GLint, count: GLsizei, value: *const GLuint64) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glUniformHandleui64vIMG({:?}, {:?}, {:p});",
                location,
                count,
                value
            );
        }
        let out = call_atomic_ptr_3arg(
            "glUniformHandleui64vIMG",
            &glUniformHandleui64vIMG_p,
            location,
            count,
            value,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glUniformHandleui64vIMG");
        }
        out
    }
    #[cfg(any(feature = "GL_IMG_bindless_texture"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_IMG_bindless_texture"))))]
    static glUniformHandleui64vIMG_p: APcv = ap_None();
    /// Tries to load [`glUniformHandleui64vIMG`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    #[cfg(any(feature = "GL_IMG_bindless_texture"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_IMG_bindless_texture"))))]
    pub unsafe fn glUniformHandleui64vIMG_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glUniformHandleui64vIMG\0",
            &glUniformHandleui64vIMG_p,
        )
    }
    /// Checks if the pointer for [`glUniformHandleui64vIMG`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    #[cfg(any(feature = "GL_IMG_bindless_texture"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_IMG_bindless_texture"))))]
    pub fn glUniformHandleui64vIMG_is_loaded() -> bool {
        !glUniformHandleui64vIMG_p.load(RELAX).is_null()
    }

    /// [glUniformHandleui64vNV](http://docs.gl/es3/glUniformHandleui64vNV)(location, count, value)
    /// `value` len: count
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    #[cfg(any(feature = "GL_NV_bindless_texture"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_bindless_texture"))))]
    pub unsafe fn glUniformHandleui64vNV(location: GLint, count: GLsizei, value: *const GLuint64) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glUniformHandleui64vNV({:?}, {:?}, {:p});",
                location,
                count,
                value
            );
        }
        let out = call_atomic_ptr_3arg(
            "glUniformHandleui64vNV",
            &glUniformHandleui64vNV_p,
            location,
            count,
            value,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glUniformHandleui64vNV");
        }
        out
    }
    #[cfg(any(feature = "GL_NV_bindless_texture"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_bindless_texture"))))]
    static glUniformHandleui64vNV_p: APcv = ap_None();
    /// Tries to load [`glUniformHandleui64vNV`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    #[cfg(any(feature = "GL_NV_bindless_texture"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_bindless_texture"))))]
    pub unsafe fn glUniformHandleui64vNV_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glUniformHandleui64vNV\0",
            &glUniformHandleui64vNV_p,
        )
    }
    /// Checks if the pointer for [`glUniformHandleui64vNV`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    #[cfg(any(feature = "GL_NV_bindless_texture"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_bindless_texture"))))]
    pub fn glUniformHandleui64vNV_is_loaded() -> bool {
        !glUniformHandleui64vNV_p.load(RELAX).is_null()
    }

    /// [glUniformMatrix2fv](http://docs.gl/es3/glUniform)(location, count, transpose, value)
    /// `value` len: count*4
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn glUniformMatrix2fv(
        location: GLint,
        count: GLsizei,
        transpose: GLboolean,
        value: *const GLfloat,
    ) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glUniformMatrix2fv({:?}, {:?}, {:?}, {:p});",
                location,
                count,
                transpose,
                value
            );
        }
        let out = call_atomic_ptr_4arg(
            "glUniformMatrix2fv",
            &glUniformMatrix2fv_p,
            location,
            count,
            transpose,
            value,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glUniformMatrix2fv");
        }
        out
    }
    static glUniformMatrix2fv_p: APcv = ap_None();
    /// Tries to load [`glUniformMatrix2fv`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    pub unsafe fn glUniformMatrix2fv_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glUniformMatrix2fv\0",
            &glUniformMatrix2fv_p,
        )
    }
    /// Checks if the pointer for [`glUniformMatrix2fv`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    pub fn glUniformMatrix2fv_is_loaded() -> bool {
        !glUniformMatrix2fv_p.load(RELAX).is_null()
    }

    /// [glUniformMatrix2x3fv](http://docs.gl/es3/glUniform)(location, count, transpose, value)
    /// `value` len: count*6
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn glUniformMatrix2x3fv(
        location: GLint,
        count: GLsizei,
        transpose: GLboolean,
        value: *const GLfloat,
    ) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glUniformMatrix2x3fv({:?}, {:?}, {:?}, {:p});",
                location,
                count,
                transpose,
                value
            );
        }
        let out = call_atomic_ptr_4arg(
            "glUniformMatrix2x3fv",
            &glUniformMatrix2x3fv_p,
            location,
            count,
            transpose,
            value,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glUniformMatrix2x3fv");
        }
        out
    }
    static glUniformMatrix2x3fv_p: APcv = ap_None();
    /// Tries to load [`glUniformMatrix2x3fv`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    pub unsafe fn glUniformMatrix2x3fv_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glUniformMatrix2x3fv\0",
            &glUniformMatrix2x3fv_p,
        )
    }
    /// Checks if the pointer for [`glUniformMatrix2x3fv`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    pub fn glUniformMatrix2x3fv_is_loaded() -> bool {
        !glUniformMatrix2x3fv_p.load(RELAX).is_null()
    }

    /// [glUniformMatrix2x3fvNV](http://docs.gl/es3/glUniformMatrix2x3fvNV)(location, count, transpose, value)
    /// `value` len: count*6
    /// alias of: [`glUniformMatrix2x3fv`]
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    #[cfg(any(feature = "GL_NV_non_square_matrices"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_non_square_matrices"))))]
    pub unsafe fn glUniformMatrix2x3fvNV(
        location: GLint,
        count: GLsizei,
        transpose: GLboolean,
        value: *const GLfloat,
    ) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glUniformMatrix2x3fvNV({:?}, {:?}, {:?}, {:p});",
                location,
                count,
                transpose,
                value
            );
        }
        let out = call_atomic_ptr_4arg(
            "glUniformMatrix2x3fvNV",
            &glUniformMatrix2x3fvNV_p,
            location,
            count,
            transpose,
            value,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glUniformMatrix2x3fvNV");
        }
        out
    }
    #[cfg(any(feature = "GL_NV_non_square_matrices"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_non_square_matrices"))))]
    static glUniformMatrix2x3fvNV_p: APcv = ap_None();
    /// Tries to load [`glUniformMatrix2x3fvNV`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    #[cfg(any(feature = "GL_NV_non_square_matrices"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_non_square_matrices"))))]
    pub unsafe fn glUniformMatrix2x3fvNV_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glUniformMatrix2x3fvNV\0",
            &glUniformMatrix2x3fvNV_p,
        )
    }
    /// Checks if the pointer for [`glUniformMatrix2x3fvNV`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    #[cfg(any(feature = "GL_NV_non_square_matrices"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_non_square_matrices"))))]
    pub fn glUniformMatrix2x3fvNV_is_loaded() -> bool {
        !glUniformMatrix2x3fvNV_p.load(RELAX).is_null()
    }

    /// [glUniformMatrix2x4fv](http://docs.gl/es3/glUniform)(location, count, transpose, value)
    /// `value` len: count*8
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn glUniformMatrix2x4fv(
        location: GLint,
        count: GLsizei,
        transpose: GLboolean,
        value: *const GLfloat,
    ) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glUniformMatrix2x4fv({:?}, {:?}, {:?}, {:p});",
                location,
                count,
                transpose,
                value
            );
        }
        let out = call_atomic_ptr_4arg(
            "glUniformMatrix2x4fv",
            &glUniformMatrix2x4fv_p,
            location,
            count,
            transpose,
            value,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glUniformMatrix2x4fv");
        }
        out
    }
    static glUniformMatrix2x4fv_p: APcv = ap_None();
    /// Tries to load [`glUniformMatrix2x4fv`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    pub unsafe fn glUniformMatrix2x4fv_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glUniformMatrix2x4fv\0",
            &glUniformMatrix2x4fv_p,
        )
    }
    /// Checks if the pointer for [`glUniformMatrix2x4fv`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    pub fn glUniformMatrix2x4fv_is_loaded() -> bool {
        !glUniformMatrix2x4fv_p.load(RELAX).is_null()
    }

    /// [glUniformMatrix2x4fvNV](http://docs.gl/es3/glUniformMatrix2x4fvNV)(location, count, transpose, value)
    /// `value` len: count*8
    /// alias of: [`glUniformMatrix2x4fv`]
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    #[cfg(any(feature = "GL_NV_non_square_matrices"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_non_square_matrices"))))]
    pub unsafe fn glUniformMatrix2x4fvNV(
        location: GLint,
        count: GLsizei,
        transpose: GLboolean,
        value: *const GLfloat,
    ) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glUniformMatrix2x4fvNV({:?}, {:?}, {:?}, {:p});",
                location,
                count,
                transpose,
                value
            );
        }
        let out = call_atomic_ptr_4arg(
            "glUniformMatrix2x4fvNV",
            &glUniformMatrix2x4fvNV_p,
            location,
            count,
            transpose,
            value,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glUniformMatrix2x4fvNV");
        }
        out
    }
    #[cfg(any(feature = "GL_NV_non_square_matrices"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_non_square_matrices"))))]
    static glUniformMatrix2x4fvNV_p: APcv = ap_None();
    /// Tries to load [`glUniformMatrix2x4fvNV`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    #[cfg(any(feature = "GL_NV_non_square_matrices"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_non_square_matrices"))))]
    pub unsafe fn glUniformMatrix2x4fvNV_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glUniformMatrix2x4fvNV\0",
            &glUniformMatrix2x4fvNV_p,
        )
    }
    /// Checks if the pointer for [`glUniformMatrix2x4fvNV`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    #[cfg(any(feature = "GL_NV_non_square_matrices"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_non_square_matrices"))))]
    pub fn glUniformMatrix2x4fvNV_is_loaded() -> bool {
        !glUniformMatrix2x4fvNV_p.load(RELAX).is_null()
    }

    /// [glUniformMatrix3fv](http://docs.gl/es3/glUniform)(location, count, transpose, value)
    /// `value` len: count*9
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn glUniformMatrix3fv(
        location: GLint,
        count: GLsizei,
        transpose: GLboolean,
        value: *const GLfloat,
    ) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glUniformMatrix3fv({:?}, {:?}, {:?}, {:p});",
                location,
                count,
                transpose,
                value
            );
        }
        let out = call_atomic_ptr_4arg(
            "glUniformMatrix3fv",
            &glUniformMatrix3fv_p,
            location,
            count,
            transpose,
            value,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glUniformMatrix3fv");
        }
        out
    }
    static glUniformMatrix3fv_p: APcv = ap_None();
    /// Tries to load [`glUniformMatrix3fv`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    pub unsafe fn glUniformMatrix3fv_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glUniformMatrix3fv\0",
            &glUniformMatrix3fv_p,
        )
    }
    /// Checks if the pointer for [`glUniformMatrix3fv`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    pub fn glUniformMatrix3fv_is_loaded() -> bool {
        !glUniformMatrix3fv_p.load(RELAX).is_null()
    }

    /// [glUniformMatrix3x2fv](http://docs.gl/es3/glUniform)(location, count, transpose, value)
    /// `value` len: count*6
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn glUniformMatrix3x2fv(
        location: GLint,
        count: GLsizei,
        transpose: GLboolean,
        value: *const GLfloat,
    ) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glUniformMatrix3x2fv({:?}, {:?}, {:?}, {:p});",
                location,
                count,
                transpose,
                value
            );
        }
        let out = call_atomic_ptr_4arg(
            "glUniformMatrix3x2fv",
            &glUniformMatrix3x2fv_p,
            location,
            count,
            transpose,
            value,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glUniformMatrix3x2fv");
        }
        out
    }
    static glUniformMatrix3x2fv_p: APcv = ap_None();
    /// Tries to load [`glUniformMatrix3x2fv`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    pub unsafe fn glUniformMatrix3x2fv_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glUniformMatrix3x2fv\0",
            &glUniformMatrix3x2fv_p,
        )
    }
    /// Checks if the pointer for [`glUniformMatrix3x2fv`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    pub fn glUniformMatrix3x2fv_is_loaded() -> bool {
        !glUniformMatrix3x2fv_p.load(RELAX).is_null()
    }

    /// [glUniformMatrix3x2fvNV](http://docs.gl/es3/glUniformMatrix3x2fvNV)(location, count, transpose, value)
    /// `value` len: count*6
    /// alias of: [`glUniformMatrix3x2fv`]
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    #[cfg(any(feature = "GL_NV_non_square_matrices"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_non_square_matrices"))))]
    pub unsafe fn glUniformMatrix3x2fvNV(
        location: GLint,
        count: GLsizei,
        transpose: GLboolean,
        value: *const GLfloat,
    ) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glUniformMatrix3x2fvNV({:?}, {:?}, {:?}, {:p});",
                location,
                count,
                transpose,
                value
            );
        }
        let out = call_atomic_ptr_4arg(
            "glUniformMatrix3x2fvNV",
            &glUniformMatrix3x2fvNV_p,
            location,
            count,
            transpose,
            value,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glUniformMatrix3x2fvNV");
        }
        out
    }
    #[cfg(any(feature = "GL_NV_non_square_matrices"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_non_square_matrices"))))]
    static glUniformMatrix3x2fvNV_p: APcv = ap_None();
    /// Tries to load [`glUniformMatrix3x2fvNV`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    #[cfg(any(feature = "GL_NV_non_square_matrices"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_non_square_matrices"))))]
    pub unsafe fn glUniformMatrix3x2fvNV_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glUniformMatrix3x2fvNV\0",
            &glUniformMatrix3x2fvNV_p,
        )
    }
    /// Checks if the pointer for [`glUniformMatrix3x2fvNV`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    #[cfg(any(feature = "GL_NV_non_square_matrices"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_non_square_matrices"))))]
    pub fn glUniformMatrix3x2fvNV_is_loaded() -> bool {
        !glUniformMatrix3x2fvNV_p.load(RELAX).is_null()
    }

    /// [glUniformMatrix3x4fv](http://docs.gl/es3/glUniform)(location, count, transpose, value)
    /// `value` len: count*12
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn glUniformMatrix3x4fv(
        location: GLint,
        count: GLsizei,
        transpose: GLboolean,
        value: *const GLfloat,
    ) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glUniformMatrix3x4fv({:?}, {:?}, {:?}, {:p});",
                location,
                count,
                transpose,
                value
            );
        }
        let out = call_atomic_ptr_4arg(
            "glUniformMatrix3x4fv",
            &glUniformMatrix3x4fv_p,
            location,
            count,
            transpose,
            value,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glUniformMatrix3x4fv");
        }
        out
    }
    static glUniformMatrix3x4fv_p: APcv = ap_None();
    /// Tries to load [`glUniformMatrix3x4fv`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    pub unsafe fn glUniformMatrix3x4fv_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glUniformMatrix3x4fv\0",
            &glUniformMatrix3x4fv_p,
        )
    }
    /// Checks if the pointer for [`glUniformMatrix3x4fv`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    pub fn glUniformMatrix3x4fv_is_loaded() -> bool {
        !glUniformMatrix3x4fv_p.load(RELAX).is_null()
    }

    /// [glUniformMatrix3x4fvNV](http://docs.gl/es3/glUniformMatrix3x4fvNV)(location, count, transpose, value)
    /// `value` len: count*12
    /// alias of: [`glUniformMatrix3x4fv`]
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    #[cfg(any(feature = "GL_NV_non_square_matrices"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_non_square_matrices"))))]
    pub unsafe fn glUniformMatrix3x4fvNV(
        location: GLint,
        count: GLsizei,
        transpose: GLboolean,
        value: *const GLfloat,
    ) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glUniformMatrix3x4fvNV({:?}, {:?}, {:?}, {:p});",
                location,
                count,
                transpose,
                value
            );
        }
        let out = call_atomic_ptr_4arg(
            "glUniformMatrix3x4fvNV",
            &glUniformMatrix3x4fvNV_p,
            location,
            count,
            transpose,
            value,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glUniformMatrix3x4fvNV");
        }
        out
    }
    #[cfg(any(feature = "GL_NV_non_square_matrices"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_non_square_matrices"))))]
    static glUniformMatrix3x4fvNV_p: APcv = ap_None();
    /// Tries to load [`glUniformMatrix3x4fvNV`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    #[cfg(any(feature = "GL_NV_non_square_matrices"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_non_square_matrices"))))]
    pub unsafe fn glUniformMatrix3x4fvNV_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glUniformMatrix3x4fvNV\0",
            &glUniformMatrix3x4fvNV_p,
        )
    }
    /// Checks if the pointer for [`glUniformMatrix3x4fvNV`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    #[cfg(any(feature = "GL_NV_non_square_matrices"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_non_square_matrices"))))]
    pub fn glUniformMatrix3x4fvNV_is_loaded() -> bool {
        !glUniformMatrix3x4fvNV_p.load(RELAX).is_null()
    }

    /// [glUniformMatrix4fv](http://docs.gl/es3/glUniform)(location, count, transpose, value)
    /// `value` len: count*16
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn glUniformMatrix4fv(
        location: GLint,
        count: GLsizei,
        transpose: GLboolean,
        value: *const GLfloat,
    ) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glUniformMatrix4fv({:?}, {:?}, {:?}, {:p});",
                location,
                count,
                transpose,
                value
            );
        }
        let out = call_atomic_ptr_4arg(
            "glUniformMatrix4fv",
            &glUniformMatrix4fv_p,
            location,
            count,
            transpose,
            value,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glUniformMatrix4fv");
        }
        out
    }
    static glUniformMatrix4fv_p: APcv = ap_None();
    /// Tries to load [`glUniformMatrix4fv`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    pub unsafe fn glUniformMatrix4fv_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glUniformMatrix4fv\0",
            &glUniformMatrix4fv_p,
        )
    }
    /// Checks if the pointer for [`glUniformMatrix4fv`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    pub fn glUniformMatrix4fv_is_loaded() -> bool {
        !glUniformMatrix4fv_p.load(RELAX).is_null()
    }

    /// [glUniformMatrix4x2fv](http://docs.gl/es3/glUniform)(location, count, transpose, value)
    /// `value` len: count*8
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn glUniformMatrix4x2fv(
        location: GLint,
        count: GLsizei,
        transpose: GLboolean,
        value: *const GLfloat,
    ) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glUniformMatrix4x2fv({:?}, {:?}, {:?}, {:p});",
                location,
                count,
                transpose,
                value
            );
        }
        let out = call_atomic_ptr_4arg(
            "glUniformMatrix4x2fv",
            &glUniformMatrix4x2fv_p,
            location,
            count,
            transpose,
            value,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glUniformMatrix4x2fv");
        }
        out
    }
    static glUniformMatrix4x2fv_p: APcv = ap_None();
    /// Tries to load [`glUniformMatrix4x2fv`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    pub unsafe fn glUniformMatrix4x2fv_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glUniformMatrix4x2fv\0",
            &glUniformMatrix4x2fv_p,
        )
    }
    /// Checks if the pointer for [`glUniformMatrix4x2fv`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    pub fn glUniformMatrix4x2fv_is_loaded() -> bool {
        !glUniformMatrix4x2fv_p.load(RELAX).is_null()
    }

    /// [glUniformMatrix4x2fvNV](http://docs.gl/es3/glUniformMatrix4x2fvNV)(location, count, transpose, value)
    /// `value` len: count*8
    /// alias of: [`glUniformMatrix4x2fv`]
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    #[cfg(any(feature = "GL_NV_non_square_matrices"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_non_square_matrices"))))]
    pub unsafe fn glUniformMatrix4x2fvNV(
        location: GLint,
        count: GLsizei,
        transpose: GLboolean,
        value: *const GLfloat,
    ) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glUniformMatrix4x2fvNV({:?}, {:?}, {:?}, {:p});",
                location,
                count,
                transpose,
                value
            );
        }
        let out = call_atomic_ptr_4arg(
            "glUniformMatrix4x2fvNV",
            &glUniformMatrix4x2fvNV_p,
            location,
            count,
            transpose,
            value,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glUniformMatrix4x2fvNV");
        }
        out
    }
    #[cfg(any(feature = "GL_NV_non_square_matrices"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_non_square_matrices"))))]
    static glUniformMatrix4x2fvNV_p: APcv = ap_None();
    /// Tries to load [`glUniformMatrix4x2fvNV`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    #[cfg(any(feature = "GL_NV_non_square_matrices"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_non_square_matrices"))))]
    pub unsafe fn glUniformMatrix4x2fvNV_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glUniformMatrix4x2fvNV\0",
            &glUniformMatrix4x2fvNV_p,
        )
    }
    /// Checks if the pointer for [`glUniformMatrix4x2fvNV`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    #[cfg(any(feature = "GL_NV_non_square_matrices"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_non_square_matrices"))))]
    pub fn glUniformMatrix4x2fvNV_is_loaded() -> bool {
        !glUniformMatrix4x2fvNV_p.load(RELAX).is_null()
    }

    /// [glUniformMatrix4x3fv](http://docs.gl/es3/glUniform)(location, count, transpose, value)
    /// `value` len: count*12
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn glUniformMatrix4x3fv(
        location: GLint,
        count: GLsizei,
        transpose: GLboolean,
        value: *const GLfloat,
    ) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glUniformMatrix4x3fv({:?}, {:?}, {:?}, {:p});",
                location,
                count,
                transpose,
                value
            );
        }
        let out = call_atomic_ptr_4arg(
            "glUniformMatrix4x3fv",
            &glUniformMatrix4x3fv_p,
            location,
            count,
            transpose,
            value,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glUniformMatrix4x3fv");
        }
        out
    }
    static glUniformMatrix4x3fv_p: APcv = ap_None();
    /// Tries to load [`glUniformMatrix4x3fv`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    pub unsafe fn glUniformMatrix4x3fv_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glUniformMatrix4x3fv\0",
            &glUniformMatrix4x3fv_p,
        )
    }
    /// Checks if the pointer for [`glUniformMatrix4x3fv`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    pub fn glUniformMatrix4x3fv_is_loaded() -> bool {
        !glUniformMatrix4x3fv_p.load(RELAX).is_null()
    }

    /// [glUniformMatrix4x3fvNV](http://docs.gl/es3/glUniformMatrix4x3fvNV)(location, count, transpose, value)
    /// `value` len: count*12
    /// alias of: [`glUniformMatrix4x3fv`]
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    #[cfg(any(feature = "GL_NV_non_square_matrices"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_non_square_matrices"))))]
    pub unsafe fn glUniformMatrix4x3fvNV(
        location: GLint,
        count: GLsizei,
        transpose: GLboolean,
        value: *const GLfloat,
    ) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glUniformMatrix4x3fvNV({:?}, {:?}, {:?}, {:p});",
                location,
                count,
                transpose,
                value
            );
        }
        let out = call_atomic_ptr_4arg(
            "glUniformMatrix4x3fvNV",
            &glUniformMatrix4x3fvNV_p,
            location,
            count,
            transpose,
            value,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glUniformMatrix4x3fvNV");
        }
        out
    }
    #[cfg(any(feature = "GL_NV_non_square_matrices"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_non_square_matrices"))))]
    static glUniformMatrix4x3fvNV_p: APcv = ap_None();
    /// Tries to load [`glUniformMatrix4x3fvNV`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    #[cfg(any(feature = "GL_NV_non_square_matrices"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_non_square_matrices"))))]
    pub unsafe fn glUniformMatrix4x3fvNV_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glUniformMatrix4x3fvNV\0",
            &glUniformMatrix4x3fvNV_p,
        )
    }
    /// Checks if the pointer for [`glUniformMatrix4x3fvNV`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    #[cfg(any(feature = "GL_NV_non_square_matrices"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_non_square_matrices"))))]
    pub fn glUniformMatrix4x3fvNV_is_loaded() -> bool {
        !glUniformMatrix4x3fvNV_p.load(RELAX).is_null()
    }

    /// [glUnmapBuffer](http://docs.gl/es3/glUnmapBuffer)(target)
    /// `target` group: BufferTargetARB
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn glUnmapBuffer(target: GLenum) -> GLboolean {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!("calling glUnmapBuffer({:#X});", target);
        }
        let out = call_atomic_ptr_1arg("glUnmapBuffer", &glUnmapBuffer_p, target);
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glUnmapBuffer");
        }
        out
    }
    static glUnmapBuffer_p: APcv = ap_None();
    /// Tries to load [`glUnmapBuffer`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    pub unsafe fn glUnmapBuffer_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(get_proc_address, b"glUnmapBuffer\0", &glUnmapBuffer_p)
    }
    /// Checks if the pointer for [`glUnmapBuffer`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    pub fn glUnmapBuffer_is_loaded() -> bool {
        !glUnmapBuffer_p.load(RELAX).is_null()
    }

    /// [glUnmapBufferOES](http://docs.gl/es3/glUnmapBufferOES)(target)
    /// alias of: [`glUnmapBuffer`]
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    #[cfg(any(feature = "GL_OES_mapbuffer"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_OES_mapbuffer"))))]
    pub unsafe fn glUnmapBufferOES(target: GLenum) -> GLboolean {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!("calling glUnmapBufferOES({:#X});", target);
        }
        let out = call_atomic_ptr_1arg("glUnmapBufferOES", &glUnmapBufferOES_p, target);
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glUnmapBufferOES");
        }
        out
    }
    #[cfg(any(feature = "GL_OES_mapbuffer"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_OES_mapbuffer"))))]
    static glUnmapBufferOES_p: APcv = ap_None();
    /// Tries to load [`glUnmapBufferOES`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    #[cfg(any(feature = "GL_OES_mapbuffer"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_OES_mapbuffer"))))]
    pub unsafe fn glUnmapBufferOES_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(get_proc_address, b"glUnmapBufferOES\0", &glUnmapBufferOES_p)
    }
    /// Checks if the pointer for [`glUnmapBufferOES`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    #[cfg(any(feature = "GL_OES_mapbuffer"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_OES_mapbuffer"))))]
    pub fn glUnmapBufferOES_is_loaded() -> bool {
        !glUnmapBufferOES_p.load(RELAX).is_null()
    }

    /// [glUseProgram](http://docs.gl/es3/glUseProgram)(program)
    /// `program` class: program
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn glUseProgram(program: GLuint) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!("calling glUseProgram({:?});", program);
        }
        let out = call_atomic_ptr_1arg("glUseProgram", &glUseProgram_p, program);
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glUseProgram");
        }
        out
    }
    static glUseProgram_p: APcv = ap_None();
    /// Tries to load [`glUseProgram`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    pub unsafe fn glUseProgram_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(get_proc_address, b"glUseProgram\0", &glUseProgram_p)
    }
    /// Checks if the pointer for [`glUseProgram`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    pub fn glUseProgram_is_loaded() -> bool {
        !glUseProgram_p.load(RELAX).is_null()
    }

    /// [glUseProgramStages](http://docs.gl/es3/glUseProgramStages)(pipeline, stages, program)
    /// `pipeline` class: program pipeline
    /// `stages` group: UseProgramStageMask
    /// `program` class: program
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn glUseProgramStages(pipeline: GLuint, stages: GLbitfield, program: GLuint) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glUseProgramStages({:?}, {:?}, {:?});",
                pipeline,
                stages,
                program
            );
        }
        let out = call_atomic_ptr_3arg(
            "glUseProgramStages",
            &glUseProgramStages_p,
            pipeline,
            stages,
            program,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glUseProgramStages");
        }
        out
    }
    static glUseProgramStages_p: APcv = ap_None();
    /// Tries to load [`glUseProgramStages`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    pub unsafe fn glUseProgramStages_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glUseProgramStages\0",
            &glUseProgramStages_p,
        )
    }
    /// Checks if the pointer for [`glUseProgramStages`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    pub fn glUseProgramStages_is_loaded() -> bool {
        !glUseProgramStages_p.load(RELAX).is_null()
    }

    /// [glUseProgramStagesEXT](http://docs.gl/es3/glUseProgramStagesEXT)(pipeline, stages, program)
    /// `pipeline` class: program pipeline
    /// `stages` group: UseProgramStageMask
    /// `program` class: program
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    #[cfg(any(feature = "GL_EXT_separate_shader_objects"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_separate_shader_objects"))))]
    pub unsafe fn glUseProgramStagesEXT(pipeline: GLuint, stages: GLbitfield, program: GLuint) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glUseProgramStagesEXT({:?}, {:?}, {:?});",
                pipeline,
                stages,
                program
            );
        }
        let out = call_atomic_ptr_3arg(
            "glUseProgramStagesEXT",
            &glUseProgramStagesEXT_p,
            pipeline,
            stages,
            program,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glUseProgramStagesEXT");
        }
        out
    }
    #[cfg(any(feature = "GL_EXT_separate_shader_objects"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_separate_shader_objects"))))]
    static glUseProgramStagesEXT_p: APcv = ap_None();
    /// Tries to load [`glUseProgramStagesEXT`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    #[cfg(any(feature = "GL_EXT_separate_shader_objects"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_separate_shader_objects"))))]
    pub unsafe fn glUseProgramStagesEXT_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glUseProgramStagesEXT\0",
            &glUseProgramStagesEXT_p,
        )
    }
    /// Checks if the pointer for [`glUseProgramStagesEXT`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    #[cfg(any(feature = "GL_EXT_separate_shader_objects"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_separate_shader_objects"))))]
    pub fn glUseProgramStagesEXT_is_loaded() -> bool {
        !glUseProgramStagesEXT_p.load(RELAX).is_null()
    }

    /// [glValidateProgram](http://docs.gl/es3/glValidateProgram)(program)
    /// `program` class: program
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn glValidateProgram(program: GLuint) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!("calling glValidateProgram({:?});", program);
        }
        let out = call_atomic_ptr_1arg("glValidateProgram", &glValidateProgram_p, program);
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glValidateProgram");
        }
        out
    }
    static glValidateProgram_p: APcv = ap_None();
    /// Tries to load [`glValidateProgram`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    pub unsafe fn glValidateProgram_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glValidateProgram\0",
            &glValidateProgram_p,
        )
    }
    /// Checks if the pointer for [`glValidateProgram`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    pub fn glValidateProgram_is_loaded() -> bool {
        !glValidateProgram_p.load(RELAX).is_null()
    }

    /// [glValidateProgramPipeline](http://docs.gl/es3/glValidateProgramPipeline)(pipeline)
    /// `pipeline` class: program pipeline
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn glValidateProgramPipeline(pipeline: GLuint) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!("calling glValidateProgramPipeline({:?});", pipeline);
        }
        let out = call_atomic_ptr_1arg(
            "glValidateProgramPipeline",
            &glValidateProgramPipeline_p,
            pipeline,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glValidateProgramPipeline");
        }
        out
    }
    static glValidateProgramPipeline_p: APcv = ap_None();
    /// Tries to load [`glValidateProgramPipeline`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    pub unsafe fn glValidateProgramPipeline_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glValidateProgramPipeline\0",
            &glValidateProgramPipeline_p,
        )
    }
    /// Checks if the pointer for [`glValidateProgramPipeline`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    pub fn glValidateProgramPipeline_is_loaded() -> bool {
        !glValidateProgramPipeline_p.load(RELAX).is_null()
    }

    /// [glValidateProgramPipelineEXT](http://docs.gl/es3/glValidateProgramPipelineEXT)(pipeline)
    /// `pipeline` class: program pipeline
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    #[cfg(any(feature = "GL_EXT_separate_shader_objects"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_separate_shader_objects"))))]
    pub unsafe fn glValidateProgramPipelineEXT(pipeline: GLuint) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!("calling glValidateProgramPipelineEXT({:?});", pipeline);
        }
        let out = call_atomic_ptr_1arg(
            "glValidateProgramPipelineEXT",
            &glValidateProgramPipelineEXT_p,
            pipeline,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glValidateProgramPipelineEXT");
        }
        out
    }
    #[cfg(any(feature = "GL_EXT_separate_shader_objects"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_separate_shader_objects"))))]
    static glValidateProgramPipelineEXT_p: APcv = ap_None();
    /// Tries to load [`glValidateProgramPipelineEXT`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    #[cfg(any(feature = "GL_EXT_separate_shader_objects"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_separate_shader_objects"))))]
    pub unsafe fn glValidateProgramPipelineEXT_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glValidateProgramPipelineEXT\0",
            &glValidateProgramPipelineEXT_p,
        )
    }
    /// Checks if the pointer for [`glValidateProgramPipelineEXT`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    #[cfg(any(feature = "GL_EXT_separate_shader_objects"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_separate_shader_objects"))))]
    pub fn glValidateProgramPipelineEXT_is_loaded() -> bool {
        !glValidateProgramPipelineEXT_p.load(RELAX).is_null()
    }

    /// [glVertexAttrib1f](http://docs.gl/es3/glVertexAttrib)(index, x)
    /// vector equivalent: [`glVertexAttrib1fv`]
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn glVertexAttrib1f(index: GLuint, x: GLfloat) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!("calling glVertexAttrib1f({:?}, {:?});", index, x);
        }
        let out = call_atomic_ptr_2arg("glVertexAttrib1f", &glVertexAttrib1f_p, index, x);
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glVertexAttrib1f");
        }
        out
    }
    static glVertexAttrib1f_p: APcv = ap_None();
    /// Tries to load [`glVertexAttrib1f`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    pub unsafe fn glVertexAttrib1f_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(get_proc_address, b"glVertexAttrib1f\0", &glVertexAttrib1f_p)
    }
    /// Checks if the pointer for [`glVertexAttrib1f`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    pub fn glVertexAttrib1f_is_loaded() -> bool {
        !glVertexAttrib1f_p.load(RELAX).is_null()
    }

    /// [glVertexAttrib1fv](http://docs.gl/es3/glVertexAttrib)(index, v)
    /// `v` len: 1
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn glVertexAttrib1fv(index: GLuint, v: *const GLfloat) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!("calling glVertexAttrib1fv({:?}, {:p});", index, v);
        }
        let out = call_atomic_ptr_2arg("glVertexAttrib1fv", &glVertexAttrib1fv_p, index, v);
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glVertexAttrib1fv");
        }
        out
    }
    static glVertexAttrib1fv_p: APcv = ap_None();
    /// Tries to load [`glVertexAttrib1fv`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    pub unsafe fn glVertexAttrib1fv_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glVertexAttrib1fv\0",
            &glVertexAttrib1fv_p,
        )
    }
    /// Checks if the pointer for [`glVertexAttrib1fv`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    pub fn glVertexAttrib1fv_is_loaded() -> bool {
        !glVertexAttrib1fv_p.load(RELAX).is_null()
    }

    /// [glVertexAttrib2f](http://docs.gl/es3/glVertexAttrib)(index, x, y)
    /// vector equivalent: [`glVertexAttrib2fv`]
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn glVertexAttrib2f(index: GLuint, x: GLfloat, y: GLfloat) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!("calling glVertexAttrib2f({:?}, {:?}, {:?});", index, x, y);
        }
        let out = call_atomic_ptr_3arg("glVertexAttrib2f", &glVertexAttrib2f_p, index, x, y);
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glVertexAttrib2f");
        }
        out
    }
    static glVertexAttrib2f_p: APcv = ap_None();
    /// Tries to load [`glVertexAttrib2f`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    pub unsafe fn glVertexAttrib2f_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(get_proc_address, b"glVertexAttrib2f\0", &glVertexAttrib2f_p)
    }
    /// Checks if the pointer for [`glVertexAttrib2f`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    pub fn glVertexAttrib2f_is_loaded() -> bool {
        !glVertexAttrib2f_p.load(RELAX).is_null()
    }

    /// [glVertexAttrib2fv](http://docs.gl/es3/glVertexAttrib)(index, v)
    /// `v` len: 2
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn glVertexAttrib2fv(index: GLuint, v: *const GLfloat) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!("calling glVertexAttrib2fv({:?}, {:p});", index, v);
        }
        let out = call_atomic_ptr_2arg("glVertexAttrib2fv", &glVertexAttrib2fv_p, index, v);
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glVertexAttrib2fv");
        }
        out
    }
    static glVertexAttrib2fv_p: APcv = ap_None();
    /// Tries to load [`glVertexAttrib2fv`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    pub unsafe fn glVertexAttrib2fv_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glVertexAttrib2fv\0",
            &glVertexAttrib2fv_p,
        )
    }
    /// Checks if the pointer for [`glVertexAttrib2fv`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    pub fn glVertexAttrib2fv_is_loaded() -> bool {
        !glVertexAttrib2fv_p.load(RELAX).is_null()
    }

    /// [glVertexAttrib3f](http://docs.gl/es3/glVertexAttrib)(index, x, y, z)
    /// vector equivalent: [`glVertexAttrib3fv`]
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn glVertexAttrib3f(index: GLuint, x: GLfloat, y: GLfloat, z: GLfloat) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glVertexAttrib3f({:?}, {:?}, {:?}, {:?});",
                index,
                x,
                y,
                z
            );
        }
        let out = call_atomic_ptr_4arg("glVertexAttrib3f", &glVertexAttrib3f_p, index, x, y, z);
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glVertexAttrib3f");
        }
        out
    }
    static glVertexAttrib3f_p: APcv = ap_None();
    /// Tries to load [`glVertexAttrib3f`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    pub unsafe fn glVertexAttrib3f_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(get_proc_address, b"glVertexAttrib3f\0", &glVertexAttrib3f_p)
    }
    /// Checks if the pointer for [`glVertexAttrib3f`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    pub fn glVertexAttrib3f_is_loaded() -> bool {
        !glVertexAttrib3f_p.load(RELAX).is_null()
    }

    /// [glVertexAttrib3fv](http://docs.gl/es3/glVertexAttrib)(index, v)
    /// `v` len: 3
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn glVertexAttrib3fv(index: GLuint, v: *const GLfloat) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!("calling glVertexAttrib3fv({:?}, {:p});", index, v);
        }
        let out = call_atomic_ptr_2arg("glVertexAttrib3fv", &glVertexAttrib3fv_p, index, v);
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glVertexAttrib3fv");
        }
        out
    }
    static glVertexAttrib3fv_p: APcv = ap_None();
    /// Tries to load [`glVertexAttrib3fv`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    pub unsafe fn glVertexAttrib3fv_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glVertexAttrib3fv\0",
            &glVertexAttrib3fv_p,
        )
    }
    /// Checks if the pointer for [`glVertexAttrib3fv`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    pub fn glVertexAttrib3fv_is_loaded() -> bool {
        !glVertexAttrib3fv_p.load(RELAX).is_null()
    }

    /// [glVertexAttrib4f](http://docs.gl/es3/glVertexAttrib)(index, x, y, z, w)
    /// vector equivalent: [`glVertexAttrib4fv`]
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn glVertexAttrib4f(index: GLuint, x: GLfloat, y: GLfloat, z: GLfloat, w: GLfloat) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glVertexAttrib4f({:?}, {:?}, {:?}, {:?}, {:?});",
                index,
                x,
                y,
                z,
                w
            );
        }
        let out = call_atomic_ptr_5arg("glVertexAttrib4f", &glVertexAttrib4f_p, index, x, y, z, w);
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glVertexAttrib4f");
        }
        out
    }
    static glVertexAttrib4f_p: APcv = ap_None();
    /// Tries to load [`glVertexAttrib4f`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    pub unsafe fn glVertexAttrib4f_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(get_proc_address, b"glVertexAttrib4f\0", &glVertexAttrib4f_p)
    }
    /// Checks if the pointer for [`glVertexAttrib4f`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    pub fn glVertexAttrib4f_is_loaded() -> bool {
        !glVertexAttrib4f_p.load(RELAX).is_null()
    }

    /// [glVertexAttrib4fv](http://docs.gl/es3/glVertexAttrib)(index, v)
    /// `v` len: 4
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn glVertexAttrib4fv(index: GLuint, v: *const GLfloat) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!("calling glVertexAttrib4fv({:?}, {:p});", index, v);
        }
        let out = call_atomic_ptr_2arg("glVertexAttrib4fv", &glVertexAttrib4fv_p, index, v);
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glVertexAttrib4fv");
        }
        out
    }
    static glVertexAttrib4fv_p: APcv = ap_None();
    /// Tries to load [`glVertexAttrib4fv`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    pub unsafe fn glVertexAttrib4fv_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glVertexAttrib4fv\0",
            &glVertexAttrib4fv_p,
        )
    }
    /// Checks if the pointer for [`glVertexAttrib4fv`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    pub fn glVertexAttrib4fv_is_loaded() -> bool {
        !glVertexAttrib4fv_p.load(RELAX).is_null()
    }

    /// [glVertexAttribBinding](http://docs.gl/es3/glVertexAttribBinding)(attribindex, bindingindex)
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn glVertexAttribBinding(attribindex: GLuint, bindingindex: GLuint) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glVertexAttribBinding({:?}, {:?});",
                attribindex,
                bindingindex
            );
        }
        let out = call_atomic_ptr_2arg(
            "glVertexAttribBinding",
            &glVertexAttribBinding_p,
            attribindex,
            bindingindex,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glVertexAttribBinding");
        }
        out
    }
    static glVertexAttribBinding_p: APcv = ap_None();
    /// Tries to load [`glVertexAttribBinding`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    pub unsafe fn glVertexAttribBinding_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glVertexAttribBinding\0",
            &glVertexAttribBinding_p,
        )
    }
    /// Checks if the pointer for [`glVertexAttribBinding`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    pub fn glVertexAttribBinding_is_loaded() -> bool {
        !glVertexAttribBinding_p.load(RELAX).is_null()
    }

    /// [glVertexAttribDivisor](http://docs.gl/es3/glVertexAttribDivisor)(index, divisor)
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn glVertexAttribDivisor(index: GLuint, divisor: GLuint) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!("calling glVertexAttribDivisor({:?}, {:?});", index, divisor);
        }
        let out = call_atomic_ptr_2arg(
            "glVertexAttribDivisor",
            &glVertexAttribDivisor_p,
            index,
            divisor,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glVertexAttribDivisor");
        }
        out
    }
    static glVertexAttribDivisor_p: APcv = ap_None();
    /// Tries to load [`glVertexAttribDivisor`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    pub unsafe fn glVertexAttribDivisor_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glVertexAttribDivisor\0",
            &glVertexAttribDivisor_p,
        )
    }
    /// Checks if the pointer for [`glVertexAttribDivisor`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    pub fn glVertexAttribDivisor_is_loaded() -> bool {
        !glVertexAttribDivisor_p.load(RELAX).is_null()
    }

    /// [glVertexAttribDivisorANGLE](http://docs.gl/es3/glVertexAttribDivisorANGLE)(index, divisor)
    /// alias of: [`glVertexAttribDivisor`]
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    #[cfg(any(feature = "GL_ANGLE_instanced_arrays"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_ANGLE_instanced_arrays"))))]
    pub unsafe fn glVertexAttribDivisorANGLE(index: GLuint, divisor: GLuint) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glVertexAttribDivisorANGLE({:?}, {:?});",
                index,
                divisor
            );
        }
        let out = call_atomic_ptr_2arg(
            "glVertexAttribDivisorANGLE",
            &glVertexAttribDivisorANGLE_p,
            index,
            divisor,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glVertexAttribDivisorANGLE");
        }
        out
    }
    #[cfg(any(feature = "GL_ANGLE_instanced_arrays"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_ANGLE_instanced_arrays"))))]
    static glVertexAttribDivisorANGLE_p: APcv = ap_None();
    /// Tries to load [`glVertexAttribDivisorANGLE`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    #[cfg(any(feature = "GL_ANGLE_instanced_arrays"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_ANGLE_instanced_arrays"))))]
    pub unsafe fn glVertexAttribDivisorANGLE_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glVertexAttribDivisorANGLE\0",
            &glVertexAttribDivisorANGLE_p,
        )
    }
    /// Checks if the pointer for [`glVertexAttribDivisorANGLE`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    #[cfg(any(feature = "GL_ANGLE_instanced_arrays"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_ANGLE_instanced_arrays"))))]
    pub fn glVertexAttribDivisorANGLE_is_loaded() -> bool {
        !glVertexAttribDivisorANGLE_p.load(RELAX).is_null()
    }

    /// [glVertexAttribDivisorEXT](http://docs.gl/es3/glVertexAttribDivisorEXT)(index, divisor)
    /// alias of: [`glVertexAttribDivisor`]
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    #[cfg(any(feature = "GL_EXT_instanced_arrays"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_instanced_arrays"))))]
    pub unsafe fn glVertexAttribDivisorEXT(index: GLuint, divisor: GLuint) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glVertexAttribDivisorEXT({:?}, {:?});",
                index,
                divisor
            );
        }
        let out = call_atomic_ptr_2arg(
            "glVertexAttribDivisorEXT",
            &glVertexAttribDivisorEXT_p,
            index,
            divisor,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glVertexAttribDivisorEXT");
        }
        out
    }
    #[cfg(any(feature = "GL_EXT_instanced_arrays"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_instanced_arrays"))))]
    static glVertexAttribDivisorEXT_p: APcv = ap_None();
    /// Tries to load [`glVertexAttribDivisorEXT`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    #[cfg(any(feature = "GL_EXT_instanced_arrays"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_instanced_arrays"))))]
    pub unsafe fn glVertexAttribDivisorEXT_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glVertexAttribDivisorEXT\0",
            &glVertexAttribDivisorEXT_p,
        )
    }
    /// Checks if the pointer for [`glVertexAttribDivisorEXT`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    #[cfg(any(feature = "GL_EXT_instanced_arrays"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_instanced_arrays"))))]
    pub fn glVertexAttribDivisorEXT_is_loaded() -> bool {
        !glVertexAttribDivisorEXT_p.load(RELAX).is_null()
    }

    /// [glVertexAttribDivisorNV](http://docs.gl/es3/glVertexAttribDivisorNV)(index, divisor)
    /// alias of: [`glVertexAttribDivisor`]
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    #[cfg(any(feature = "GL_NV_instanced_arrays"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_instanced_arrays"))))]
    pub unsafe fn glVertexAttribDivisorNV(index: GLuint, divisor: GLuint) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glVertexAttribDivisorNV({:?}, {:?});",
                index,
                divisor
            );
        }
        let out = call_atomic_ptr_2arg(
            "glVertexAttribDivisorNV",
            &glVertexAttribDivisorNV_p,
            index,
            divisor,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glVertexAttribDivisorNV");
        }
        out
    }
    #[cfg(any(feature = "GL_NV_instanced_arrays"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_instanced_arrays"))))]
    static glVertexAttribDivisorNV_p: APcv = ap_None();
    /// Tries to load [`glVertexAttribDivisorNV`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    #[cfg(any(feature = "GL_NV_instanced_arrays"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_instanced_arrays"))))]
    pub unsafe fn glVertexAttribDivisorNV_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glVertexAttribDivisorNV\0",
            &glVertexAttribDivisorNV_p,
        )
    }
    /// Checks if the pointer for [`glVertexAttribDivisorNV`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    #[cfg(any(feature = "GL_NV_instanced_arrays"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_instanced_arrays"))))]
    pub fn glVertexAttribDivisorNV_is_loaded() -> bool {
        !glVertexAttribDivisorNV_p.load(RELAX).is_null()
    }

    /// [glVertexAttribFormat](http://docs.gl/es3/glVertexAttribFormat)(attribindex, size, type_, normalized, relativeoffset)
    /// `type_` group: VertexAttribType
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn glVertexAttribFormat(
        attribindex: GLuint,
        size: GLint,
        type_: GLenum,
        normalized: GLboolean,
        relativeoffset: GLuint,
    ) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glVertexAttribFormat({:?}, {:?}, {:#X}, {:?}, {:?});",
                attribindex,
                size,
                type_,
                normalized,
                relativeoffset
            );
        }
        let out = call_atomic_ptr_5arg(
            "glVertexAttribFormat",
            &glVertexAttribFormat_p,
            attribindex,
            size,
            type_,
            normalized,
            relativeoffset,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glVertexAttribFormat");
        }
        out
    }
    static glVertexAttribFormat_p: APcv = ap_None();
    /// Tries to load [`glVertexAttribFormat`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    pub unsafe fn glVertexAttribFormat_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glVertexAttribFormat\0",
            &glVertexAttribFormat_p,
        )
    }
    /// Checks if the pointer for [`glVertexAttribFormat`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    pub fn glVertexAttribFormat_is_loaded() -> bool {
        !glVertexAttribFormat_p.load(RELAX).is_null()
    }

    /// [glVertexAttribI4i](http://docs.gl/es3/glVertexAttribI)(index, x, y, z, w)
    /// vector equivalent: [`glVertexAttribI4iv`]
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn glVertexAttribI4i(index: GLuint, x: GLint, y: GLint, z: GLint, w: GLint) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glVertexAttribI4i({:?}, {:?}, {:?}, {:?}, {:?});",
                index,
                x,
                y,
                z,
                w
            );
        }
        let out =
            call_atomic_ptr_5arg("glVertexAttribI4i", &glVertexAttribI4i_p, index, x, y, z, w);
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glVertexAttribI4i");
        }
        out
    }
    static glVertexAttribI4i_p: APcv = ap_None();
    /// Tries to load [`glVertexAttribI4i`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    pub unsafe fn glVertexAttribI4i_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glVertexAttribI4i\0",
            &glVertexAttribI4i_p,
        )
    }
    /// Checks if the pointer for [`glVertexAttribI4i`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    pub fn glVertexAttribI4i_is_loaded() -> bool {
        !glVertexAttribI4i_p.load(RELAX).is_null()
    }

    /// [glVertexAttribI4iv](http://docs.gl/es3/glVertexAttrib)(index, v)
    /// `v` len: 4
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn glVertexAttribI4iv(index: GLuint, v: *const GLint) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!("calling glVertexAttribI4iv({:?}, {:p});", index, v);
        }
        let out = call_atomic_ptr_2arg("glVertexAttribI4iv", &glVertexAttribI4iv_p, index, v);
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glVertexAttribI4iv");
        }
        out
    }
    static glVertexAttribI4iv_p: APcv = ap_None();
    /// Tries to load [`glVertexAttribI4iv`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    pub unsafe fn glVertexAttribI4iv_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glVertexAttribI4iv\0",
            &glVertexAttribI4iv_p,
        )
    }
    /// Checks if the pointer for [`glVertexAttribI4iv`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    pub fn glVertexAttribI4iv_is_loaded() -> bool {
        !glVertexAttribI4iv_p.load(RELAX).is_null()
    }

    /// [glVertexAttribI4ui](http://docs.gl/es3/glVertexAttrib)(index, x, y, z, w)
    /// vector equivalent: [`glVertexAttribI4uiv`]
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn glVertexAttribI4ui(index: GLuint, x: GLuint, y: GLuint, z: GLuint, w: GLuint) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glVertexAttribI4ui({:?}, {:?}, {:?}, {:?}, {:?});",
                index,
                x,
                y,
                z,
                w
            );
        }
        let out = call_atomic_ptr_5arg(
            "glVertexAttribI4ui",
            &glVertexAttribI4ui_p,
            index,
            x,
            y,
            z,
            w,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glVertexAttribI4ui");
        }
        out
    }
    static glVertexAttribI4ui_p: APcv = ap_None();
    /// Tries to load [`glVertexAttribI4ui`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    pub unsafe fn glVertexAttribI4ui_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glVertexAttribI4ui\0",
            &glVertexAttribI4ui_p,
        )
    }
    /// Checks if the pointer for [`glVertexAttribI4ui`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    pub fn glVertexAttribI4ui_is_loaded() -> bool {
        !glVertexAttribI4ui_p.load(RELAX).is_null()
    }

    /// [glVertexAttribI4uiv](http://docs.gl/es3/glVertexAttrib)(index, v)
    /// `v` len: 4
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn glVertexAttribI4uiv(index: GLuint, v: *const GLuint) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!("calling glVertexAttribI4uiv({:?}, {:p});", index, v);
        }
        let out = call_atomic_ptr_2arg("glVertexAttribI4uiv", &glVertexAttribI4uiv_p, index, v);
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glVertexAttribI4uiv");
        }
        out
    }
    static glVertexAttribI4uiv_p: APcv = ap_None();
    /// Tries to load [`glVertexAttribI4uiv`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    pub unsafe fn glVertexAttribI4uiv_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glVertexAttribI4uiv\0",
            &glVertexAttribI4uiv_p,
        )
    }
    /// Checks if the pointer for [`glVertexAttribI4uiv`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    pub fn glVertexAttribI4uiv_is_loaded() -> bool {
        !glVertexAttribI4uiv_p.load(RELAX).is_null()
    }

    /// [glVertexAttribIFormat](http://docs.gl/es3/glVertexAttribIFormat)(attribindex, size, type_, relativeoffset)
    /// `type_` group: VertexAttribIType
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn glVertexAttribIFormat(
        attribindex: GLuint,
        size: GLint,
        type_: GLenum,
        relativeoffset: GLuint,
    ) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glVertexAttribIFormat({:?}, {:?}, {:#X}, {:?});",
                attribindex,
                size,
                type_,
                relativeoffset
            );
        }
        let out = call_atomic_ptr_4arg(
            "glVertexAttribIFormat",
            &glVertexAttribIFormat_p,
            attribindex,
            size,
            type_,
            relativeoffset,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glVertexAttribIFormat");
        }
        out
    }
    static glVertexAttribIFormat_p: APcv = ap_None();
    /// Tries to load [`glVertexAttribIFormat`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    pub unsafe fn glVertexAttribIFormat_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glVertexAttribIFormat\0",
            &glVertexAttribIFormat_p,
        )
    }
    /// Checks if the pointer for [`glVertexAttribIFormat`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    pub fn glVertexAttribIFormat_is_loaded() -> bool {
        !glVertexAttribIFormat_p.load(RELAX).is_null()
    }

    /// [glVertexAttribIPointer](http://docs.gl/es3/glVertexAttribPointer)(index, size, type_, stride, pointer)
    /// `type_` group: VertexAttribIType
    /// `pointer` len: COMPSIZE(size,type,stride)
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn glVertexAttribIPointer(
        index: GLuint,
        size: GLint,
        type_: GLenum,
        stride: GLsizei,
        pointer: *const c_void,
    ) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glVertexAttribIPointer({:?}, {:?}, {:#X}, {:?}, {:p});",
                index,
                size,
                type_,
                stride,
                pointer
            );
        }
        let out = call_atomic_ptr_5arg(
            "glVertexAttribIPointer",
            &glVertexAttribIPointer_p,
            index,
            size,
            type_,
            stride,
            pointer,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glVertexAttribIPointer");
        }
        out
    }
    static glVertexAttribIPointer_p: APcv = ap_None();
    /// Tries to load [`glVertexAttribIPointer`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    pub unsafe fn glVertexAttribIPointer_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glVertexAttribIPointer\0",
            &glVertexAttribIPointer_p,
        )
    }
    /// Checks if the pointer for [`glVertexAttribIPointer`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    pub fn glVertexAttribIPointer_is_loaded() -> bool {
        !glVertexAttribIPointer_p.load(RELAX).is_null()
    }

    /// [glVertexAttribPointer](http://docs.gl/es3/glVertexAttribPointer)(index, size, type_, normalized, stride, pointer)
    /// `type_` group: VertexAttribPointerType
    /// `pointer` len: COMPSIZE(size,type,stride)
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn glVertexAttribPointer(
        index: GLuint,
        size: GLint,
        type_: GLenum,
        normalized: GLboolean,
        stride: GLsizei,
        pointer: *const c_void,
    ) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glVertexAttribPointer({:?}, {:?}, {:#X}, {:?}, {:?}, {:p});",
                index,
                size,
                type_,
                normalized,
                stride,
                pointer
            );
        }
        let out = call_atomic_ptr_6arg(
            "glVertexAttribPointer",
            &glVertexAttribPointer_p,
            index,
            size,
            type_,
            normalized,
            stride,
            pointer,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glVertexAttribPointer");
        }
        out
    }
    static glVertexAttribPointer_p: APcv = ap_None();
    /// Tries to load [`glVertexAttribPointer`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    pub unsafe fn glVertexAttribPointer_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glVertexAttribPointer\0",
            &glVertexAttribPointer_p,
        )
    }
    /// Checks if the pointer for [`glVertexAttribPointer`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    pub fn glVertexAttribPointer_is_loaded() -> bool {
        !glVertexAttribPointer_p.load(RELAX).is_null()
    }

    /// [glVertexBindingDivisor](http://docs.gl/es3/glVertexBindingDivisor)(bindingindex, divisor)
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn glVertexBindingDivisor(bindingindex: GLuint, divisor: GLuint) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glVertexBindingDivisor({:?}, {:?});",
                bindingindex,
                divisor
            );
        }
        let out = call_atomic_ptr_2arg(
            "glVertexBindingDivisor",
            &glVertexBindingDivisor_p,
            bindingindex,
            divisor,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glVertexBindingDivisor");
        }
        out
    }
    static glVertexBindingDivisor_p: APcv = ap_None();
    /// Tries to load [`glVertexBindingDivisor`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    pub unsafe fn glVertexBindingDivisor_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glVertexBindingDivisor\0",
            &glVertexBindingDivisor_p,
        )
    }
    /// Checks if the pointer for [`glVertexBindingDivisor`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    pub fn glVertexBindingDivisor_is_loaded() -> bool {
        !glVertexBindingDivisor_p.load(RELAX).is_null()
    }

    /// [glViewport](http://docs.gl/es3/glViewport)(x, y, width, height)
    /// `x` group: WinCoord
    /// `y` group: WinCoord
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn glViewport(x: GLint, y: GLint, width: GLsizei, height: GLsizei) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glViewport({:?}, {:?}, {:?}, {:?});",
                x,
                y,
                width,
                height
            );
        }
        let out = call_atomic_ptr_4arg("glViewport", &glViewport_p, x, y, width, height);
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glViewport");
        }
        out
    }
    static glViewport_p: APcv = ap_None();
    /// Tries to load [`glViewport`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    pub unsafe fn glViewport_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(get_proc_address, b"glViewport\0", &glViewport_p)
    }
    /// Checks if the pointer for [`glViewport`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    pub fn glViewport_is_loaded() -> bool {
        !glViewport_p.load(RELAX).is_null()
    }

    /// [glViewportArrayvNV](http://docs.gl/es3/glViewportArrayvNV)(first, count, v)
    /// `v` len: COMPSIZE(count)
    /// alias of: [`glViewportArrayv`]
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    #[cfg(any(feature = "GL_NV_viewport_array"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_viewport_array"))))]
    pub unsafe fn glViewportArrayvNV(first: GLuint, count: GLsizei, v: *const GLfloat) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glViewportArrayvNV({:?}, {:?}, {:p});",
                first,
                count,
                v
            );
        }
        let out =
            call_atomic_ptr_3arg("glViewportArrayvNV", &glViewportArrayvNV_p, first, count, v);
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glViewportArrayvNV");
        }
        out
    }
    #[cfg(any(feature = "GL_NV_viewport_array"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_viewport_array"))))]
    static glViewportArrayvNV_p: APcv = ap_None();
    /// Tries to load [`glViewportArrayvNV`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    #[cfg(any(feature = "GL_NV_viewport_array"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_viewport_array"))))]
    pub unsafe fn glViewportArrayvNV_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glViewportArrayvNV\0",
            &glViewportArrayvNV_p,
        )
    }
    /// Checks if the pointer for [`glViewportArrayvNV`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    #[cfg(any(feature = "GL_NV_viewport_array"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_viewport_array"))))]
    pub fn glViewportArrayvNV_is_loaded() -> bool {
        !glViewportArrayvNV_p.load(RELAX).is_null()
    }

    /// [glViewportArrayvOES](http://docs.gl/es3/glViewportArrayvOES)(first, count, v)
    /// `v` len: COMPSIZE(count)
    /// alias of: [`glViewportArrayv`]
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    #[cfg(any(feature = "GL_OES_viewport_array"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_OES_viewport_array"))))]
    pub unsafe fn glViewportArrayvOES(first: GLuint, count: GLsizei, v: *const GLfloat) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glViewportArrayvOES({:?}, {:?}, {:p});",
                first,
                count,
                v
            );
        }
        let out = call_atomic_ptr_3arg(
            "glViewportArrayvOES",
            &glViewportArrayvOES_p,
            first,
            count,
            v,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glViewportArrayvOES");
        }
        out
    }
    #[cfg(any(feature = "GL_OES_viewport_array"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_OES_viewport_array"))))]
    static glViewportArrayvOES_p: APcv = ap_None();
    /// Tries to load [`glViewportArrayvOES`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    #[cfg(any(feature = "GL_OES_viewport_array"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_OES_viewport_array"))))]
    pub unsafe fn glViewportArrayvOES_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glViewportArrayvOES\0",
            &glViewportArrayvOES_p,
        )
    }
    /// Checks if the pointer for [`glViewportArrayvOES`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    #[cfg(any(feature = "GL_OES_viewport_array"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_OES_viewport_array"))))]
    pub fn glViewportArrayvOES_is_loaded() -> bool {
        !glViewportArrayvOES_p.load(RELAX).is_null()
    }

    /// [glViewportIndexedfNV](http://docs.gl/es3/glViewportIndexedfNV)(index, x, y, w, h)
    /// alias of: [`glViewportIndexedf`]
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    #[cfg(any(feature = "GL_NV_viewport_array"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_viewport_array"))))]
    pub unsafe fn glViewportIndexedfNV(
        index: GLuint,
        x: GLfloat,
        y: GLfloat,
        w: GLfloat,
        h: GLfloat,
    ) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glViewportIndexedfNV({:?}, {:?}, {:?}, {:?}, {:?});",
                index,
                x,
                y,
                w,
                h
            );
        }
        let out = call_atomic_ptr_5arg(
            "glViewportIndexedfNV",
            &glViewportIndexedfNV_p,
            index,
            x,
            y,
            w,
            h,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glViewportIndexedfNV");
        }
        out
    }
    #[cfg(any(feature = "GL_NV_viewport_array"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_viewport_array"))))]
    static glViewportIndexedfNV_p: APcv = ap_None();
    /// Tries to load [`glViewportIndexedfNV`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    #[cfg(any(feature = "GL_NV_viewport_array"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_viewport_array"))))]
    pub unsafe fn glViewportIndexedfNV_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glViewportIndexedfNV\0",
            &glViewportIndexedfNV_p,
        )
    }
    /// Checks if the pointer for [`glViewportIndexedfNV`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    #[cfg(any(feature = "GL_NV_viewport_array"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_viewport_array"))))]
    pub fn glViewportIndexedfNV_is_loaded() -> bool {
        !glViewportIndexedfNV_p.load(RELAX).is_null()
    }

    /// [glViewportIndexedfOES](http://docs.gl/es3/glViewportIndexedfOES)(index, x, y, w, h)
    /// alias of: [`glViewportIndexedf`]
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    #[cfg(any(feature = "GL_OES_viewport_array"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_OES_viewport_array"))))]
    pub unsafe fn glViewportIndexedfOES(
        index: GLuint,
        x: GLfloat,
        y: GLfloat,
        w: GLfloat,
        h: GLfloat,
    ) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glViewportIndexedfOES({:?}, {:?}, {:?}, {:?}, {:?});",
                index,
                x,
                y,
                w,
                h
            );
        }
        let out = call_atomic_ptr_5arg(
            "glViewportIndexedfOES",
            &glViewportIndexedfOES_p,
            index,
            x,
            y,
            w,
            h,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glViewportIndexedfOES");
        }
        out
    }
    #[cfg(any(feature = "GL_OES_viewport_array"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_OES_viewport_array"))))]
    static glViewportIndexedfOES_p: APcv = ap_None();
    /// Tries to load [`glViewportIndexedfOES`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    #[cfg(any(feature = "GL_OES_viewport_array"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_OES_viewport_array"))))]
    pub unsafe fn glViewportIndexedfOES_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glViewportIndexedfOES\0",
            &glViewportIndexedfOES_p,
        )
    }
    /// Checks if the pointer for [`glViewportIndexedfOES`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    #[cfg(any(feature = "GL_OES_viewport_array"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_OES_viewport_array"))))]
    pub fn glViewportIndexedfOES_is_loaded() -> bool {
        !glViewportIndexedfOES_p.load(RELAX).is_null()
    }

    /// [glViewportIndexedfvNV](http://docs.gl/es3/glViewportIndexedfvNV)(index, v)
    /// `v` len: 4
    /// alias of: [`glViewportIndexedfv`]
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    #[cfg(any(feature = "GL_NV_viewport_array"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_viewport_array"))))]
    pub unsafe fn glViewportIndexedfvNV(index: GLuint, v: *const GLfloat) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!("calling glViewportIndexedfvNV({:?}, {:p});", index, v);
        }
        let out = call_atomic_ptr_2arg("glViewportIndexedfvNV", &glViewportIndexedfvNV_p, index, v);
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glViewportIndexedfvNV");
        }
        out
    }
    #[cfg(any(feature = "GL_NV_viewport_array"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_viewport_array"))))]
    static glViewportIndexedfvNV_p: APcv = ap_None();
    /// Tries to load [`glViewportIndexedfvNV`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    #[cfg(any(feature = "GL_NV_viewport_array"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_viewport_array"))))]
    pub unsafe fn glViewportIndexedfvNV_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glViewportIndexedfvNV\0",
            &glViewportIndexedfvNV_p,
        )
    }
    /// Checks if the pointer for [`glViewportIndexedfvNV`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    #[cfg(any(feature = "GL_NV_viewport_array"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_viewport_array"))))]
    pub fn glViewportIndexedfvNV_is_loaded() -> bool {
        !glViewportIndexedfvNV_p.load(RELAX).is_null()
    }

    /// [glViewportIndexedfvOES](http://docs.gl/es3/glViewportIndexedfvOES)(index, v)
    /// `v` len: 4
    /// alias of: [`glViewportIndexedfv`]
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    #[cfg(any(feature = "GL_OES_viewport_array"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_OES_viewport_array"))))]
    pub unsafe fn glViewportIndexedfvOES(index: GLuint, v: *const GLfloat) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!("calling glViewportIndexedfvOES({:?}, {:p});", index, v);
        }
        let out = call_atomic_ptr_2arg(
            "glViewportIndexedfvOES",
            &glViewportIndexedfvOES_p,
            index,
            v,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glViewportIndexedfvOES");
        }
        out
    }
    #[cfg(any(feature = "GL_OES_viewport_array"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_OES_viewport_array"))))]
    static glViewportIndexedfvOES_p: APcv = ap_None();
    /// Tries to load [`glViewportIndexedfvOES`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    #[cfg(any(feature = "GL_OES_viewport_array"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_OES_viewport_array"))))]
    pub unsafe fn glViewportIndexedfvOES_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glViewportIndexedfvOES\0",
            &glViewportIndexedfvOES_p,
        )
    }
    /// Checks if the pointer for [`glViewportIndexedfvOES`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    #[cfg(any(feature = "GL_OES_viewport_array"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_OES_viewport_array"))))]
    pub fn glViewportIndexedfvOES_is_loaded() -> bool {
        !glViewportIndexedfvOES_p.load(RELAX).is_null()
    }

    /// [glViewportPositionWScaleNV](http://docs.gl/es3/glViewportPositionWScaleNV)(index, xcoeff, ycoeff)
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    #[cfg(any(feature = "GL_NV_clip_space_w_scaling"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_clip_space_w_scaling"))))]
    pub unsafe fn glViewportPositionWScaleNV(index: GLuint, xcoeff: GLfloat, ycoeff: GLfloat) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glViewportPositionWScaleNV({:?}, {:?}, {:?});",
                index,
                xcoeff,
                ycoeff
            );
        }
        let out = call_atomic_ptr_3arg(
            "glViewportPositionWScaleNV",
            &glViewportPositionWScaleNV_p,
            index,
            xcoeff,
            ycoeff,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glViewportPositionWScaleNV");
        }
        out
    }
    #[cfg(any(feature = "GL_NV_clip_space_w_scaling"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_clip_space_w_scaling"))))]
    static glViewportPositionWScaleNV_p: APcv = ap_None();
    /// Tries to load [`glViewportPositionWScaleNV`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    #[cfg(any(feature = "GL_NV_clip_space_w_scaling"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_clip_space_w_scaling"))))]
    pub unsafe fn glViewportPositionWScaleNV_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glViewportPositionWScaleNV\0",
            &glViewportPositionWScaleNV_p,
        )
    }
    /// Checks if the pointer for [`glViewportPositionWScaleNV`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    #[cfg(any(feature = "GL_NV_clip_space_w_scaling"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_clip_space_w_scaling"))))]
    pub fn glViewportPositionWScaleNV_is_loaded() -> bool {
        !glViewportPositionWScaleNV_p.load(RELAX).is_null()
    }

    /// [glViewportSwizzleNV](http://docs.gl/es3/glViewportSwizzleNV)(index, swizzlex, swizzley, swizzlez, swizzlew)
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    #[cfg(any(feature = "GL_NV_viewport_swizzle"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_viewport_swizzle"))))]
    pub unsafe fn glViewportSwizzleNV(
        index: GLuint,
        swizzlex: GLenum,
        swizzley: GLenum,
        swizzlez: GLenum,
        swizzlew: GLenum,
    ) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glViewportSwizzleNV({:?}, {:#X}, {:#X}, {:#X}, {:#X});",
                index,
                swizzlex,
                swizzley,
                swizzlez,
                swizzlew
            );
        }
        let out = call_atomic_ptr_5arg(
            "glViewportSwizzleNV",
            &glViewportSwizzleNV_p,
            index,
            swizzlex,
            swizzley,
            swizzlez,
            swizzlew,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glViewportSwizzleNV");
        }
        out
    }
    #[cfg(any(feature = "GL_NV_viewport_swizzle"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_viewport_swizzle"))))]
    static glViewportSwizzleNV_p: APcv = ap_None();
    /// Tries to load [`glViewportSwizzleNV`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    #[cfg(any(feature = "GL_NV_viewport_swizzle"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_viewport_swizzle"))))]
    pub unsafe fn glViewportSwizzleNV_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glViewportSwizzleNV\0",
            &glViewportSwizzleNV_p,
        )
    }
    /// Checks if the pointer for [`glViewportSwizzleNV`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    #[cfg(any(feature = "GL_NV_viewport_swizzle"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_viewport_swizzle"))))]
    pub fn glViewportSwizzleNV_is_loaded() -> bool {
        !glViewportSwizzleNV_p.load(RELAX).is_null()
    }

    /// [glWaitSemaphoreEXT](http://docs.gl/es3/glWaitSemaphoreEXT)(semaphore, numBufferBarriers, buffers, numTextureBarriers, textures, srcLayouts)
    /// `buffers` len: COMPSIZE(numBufferBarriers)
    /// `buffers` class: buffer
    /// `textures` len: COMPSIZE(numTextureBarriers)
    /// `textures` class: texture
    /// `srcLayouts` group: TextureLayout
    /// `srcLayouts` len: COMPSIZE(numTextureBarriers)
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    #[cfg(any(feature = "GL_EXT_semaphore"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_semaphore"))))]
    pub unsafe fn glWaitSemaphoreEXT(
        semaphore: GLuint,
        numBufferBarriers: GLuint,
        buffers: *const GLuint,
        numTextureBarriers: GLuint,
        textures: *const GLuint,
        srcLayouts: *const GLenum,
    ) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glWaitSemaphoreEXT({:?}, {:?}, {:p}, {:?}, {:p}, {:p});",
                semaphore,
                numBufferBarriers,
                buffers,
                numTextureBarriers,
                textures,
                srcLayouts
            );
        }
        let out = call_atomic_ptr_6arg(
            "glWaitSemaphoreEXT",
            &glWaitSemaphoreEXT_p,
            semaphore,
            numBufferBarriers,
            buffers,
            numTextureBarriers,
            textures,
            srcLayouts,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glWaitSemaphoreEXT");
        }
        out
    }
    #[cfg(any(feature = "GL_EXT_semaphore"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_semaphore"))))]
    static glWaitSemaphoreEXT_p: APcv = ap_None();
    /// Tries to load [`glWaitSemaphoreEXT`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    #[cfg(any(feature = "GL_EXT_semaphore"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_semaphore"))))]
    pub unsafe fn glWaitSemaphoreEXT_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glWaitSemaphoreEXT\0",
            &glWaitSemaphoreEXT_p,
        )
    }
    /// Checks if the pointer for [`glWaitSemaphoreEXT`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    #[cfg(any(feature = "GL_EXT_semaphore"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_semaphore"))))]
    pub fn glWaitSemaphoreEXT_is_loaded() -> bool {
        !glWaitSemaphoreEXT_p.load(RELAX).is_null()
    }

    /// [glWaitSync](http://docs.gl/es3/glWaitSync)(sync, flags, timeout)
    /// `sync` group: sync
    /// `sync` class: sync
    /// `flags` group: SyncBehaviorFlags
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    pub unsafe fn glWaitSync(sync: GLsync, flags: GLbitfield, timeout: GLuint64) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glWaitSync({:p}, {:?}, {:?});",
                sync,
                flags,
                timeout
            );
        }
        let out = call_atomic_ptr_3arg("glWaitSync", &glWaitSync_p, sync, flags, timeout);
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glWaitSync");
        }
        out
    }
    static glWaitSync_p: APcv = ap_None();
    /// Tries to load [`glWaitSync`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    pub unsafe fn glWaitSync_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(get_proc_address, b"glWaitSync\0", &glWaitSync_p)
    }
    /// Checks if the pointer for [`glWaitSync`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    pub fn glWaitSync_is_loaded() -> bool {
        !glWaitSync_p.load(RELAX).is_null()
    }

    /// [glWaitSyncAPPLE](http://docs.gl/es3/glWaitSyncAPPLE)(sync, flags, timeout)
    /// `sync` class: sync
    /// `flags` group: SyncBehaviorFlags
    /// alias of: [`glWaitSync`]
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    #[cfg(any(feature = "GL_APPLE_sync"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_APPLE_sync"))))]
    pub unsafe fn glWaitSyncAPPLE(sync: GLsync, flags: GLbitfield, timeout: GLuint64) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glWaitSyncAPPLE({:p}, {:?}, {:?});",
                sync,
                flags,
                timeout
            );
        }
        let out = call_atomic_ptr_3arg("glWaitSyncAPPLE", &glWaitSyncAPPLE_p, sync, flags, timeout);
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glWaitSyncAPPLE");
        }
        out
    }
    #[cfg(any(feature = "GL_APPLE_sync"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_APPLE_sync"))))]
    static glWaitSyncAPPLE_p: APcv = ap_None();
    /// Tries to load [`glWaitSyncAPPLE`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    #[cfg(any(feature = "GL_APPLE_sync"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_APPLE_sync"))))]
    pub unsafe fn glWaitSyncAPPLE_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(get_proc_address, b"glWaitSyncAPPLE\0", &glWaitSyncAPPLE_p)
    }
    /// Checks if the pointer for [`glWaitSyncAPPLE`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    #[cfg(any(feature = "GL_APPLE_sync"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_APPLE_sync"))))]
    pub fn glWaitSyncAPPLE_is_loaded() -> bool {
        !glWaitSyncAPPLE_p.load(RELAX).is_null()
    }

    /// [glWaitVkSemaphoreNV](http://docs.gl/es3/glWaitVkSemaphoreNV)(vkSemaphore)
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    #[cfg(any(feature = "GL_NV_draw_vulkan_image"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_draw_vulkan_image"))))]
    pub unsafe fn glWaitVkSemaphoreNV(vkSemaphore: GLuint64) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!("calling glWaitVkSemaphoreNV({:?});", vkSemaphore);
        }
        let out = call_atomic_ptr_1arg("glWaitVkSemaphoreNV", &glWaitVkSemaphoreNV_p, vkSemaphore);
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glWaitVkSemaphoreNV");
        }
        out
    }
    #[cfg(any(feature = "GL_NV_draw_vulkan_image"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_draw_vulkan_image"))))]
    static glWaitVkSemaphoreNV_p: APcv = ap_None();
    /// Tries to load [`glWaitVkSemaphoreNV`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    #[cfg(any(feature = "GL_NV_draw_vulkan_image"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_draw_vulkan_image"))))]
    pub unsafe fn glWaitVkSemaphoreNV_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glWaitVkSemaphoreNV\0",
            &glWaitVkSemaphoreNV_p,
        )
    }
    /// Checks if the pointer for [`glWaitVkSemaphoreNV`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    #[cfg(any(feature = "GL_NV_draw_vulkan_image"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_draw_vulkan_image"))))]
    pub fn glWaitVkSemaphoreNV_is_loaded() -> bool {
        !glWaitVkSemaphoreNV_p.load(RELAX).is_null()
    }

    /// [glWeightPathsNV](http://docs.gl/es3/glWeightPathsNV)(resultPath, numPaths, paths, weights)
    /// `resultPath` group: Path
    /// `paths` group: Path
    /// `paths` len: numPaths
    /// `weights` len: numPaths
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    #[cfg(any(feature = "GL_NV_path_rendering"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_path_rendering"))))]
    pub unsafe fn glWeightPathsNV(
        resultPath: GLuint,
        numPaths: GLsizei,
        paths: *const GLuint,
        weights: *const GLfloat,
    ) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glWeightPathsNV({:?}, {:?}, {:p}, {:p});",
                resultPath,
                numPaths,
                paths,
                weights
            );
        }
        let out = call_atomic_ptr_4arg(
            "glWeightPathsNV",
            &glWeightPathsNV_p,
            resultPath,
            numPaths,
            paths,
            weights,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glWeightPathsNV");
        }
        out
    }
    #[cfg(any(feature = "GL_NV_path_rendering"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_path_rendering"))))]
    static glWeightPathsNV_p: APcv = ap_None();
    /// Tries to load [`glWeightPathsNV`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    #[cfg(any(feature = "GL_NV_path_rendering"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_path_rendering"))))]
    pub unsafe fn glWeightPathsNV_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(get_proc_address, b"glWeightPathsNV\0", &glWeightPathsNV_p)
    }
    /// Checks if the pointer for [`glWeightPathsNV`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    #[cfg(any(feature = "GL_NV_path_rendering"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_NV_path_rendering"))))]
    pub fn glWeightPathsNV_is_loaded() -> bool {
        !glWeightPathsNV_p.load(RELAX).is_null()
    }

    /// [glWindowRectanglesEXT](http://docs.gl/es3/glWindowRectanglesEXT)(mode, count, box)
    /// `box` len: COMPSIZE(count)
    #[cfg_attr(feature = "inline", inline)]
    #[cfg_attr(feature = "inline_always", inline(always))]
    #[cfg(any(feature = "GL_EXT_window_rectangles"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_window_rectangles"))))]
    pub unsafe fn glWindowRectanglesEXT(mode: GLenum, count: GLsizei, box_: *const GLint) {
        #[cfg(all(debug_assertions, feature = "debug_trace_calls"))]
        {
            trace!(
                "calling glWindowRectanglesEXT({:#X}, {:?}, {:p});",
                mode,
                count,
                box_
            );
        }
        let out = call_atomic_ptr_3arg(
            "glWindowRectanglesEXT",
            &glWindowRectanglesEXT_p,
            mode,
            count,
            box_,
        );
        #[cfg(all(debug_assertions, feature = "debug_automatic_glGetError"))]
        {
            global_automatic_glGetError("glWindowRectanglesEXT");
        }
        out
    }
    #[cfg(any(feature = "GL_EXT_window_rectangles"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_window_rectangles"))))]
    static glWindowRectanglesEXT_p: APcv = ap_None();
    /// Tries to load [`glWindowRectanglesEXT`], returns if a non-None pointer was obtained.
    #[doc(hidden)]
    #[cfg(any(feature = "GL_EXT_window_rectangles"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_window_rectangles"))))]
    pub unsafe fn glWindowRectanglesEXT_load_with_dyn(
        get_proc_address: &mut dyn FnMut(*const c_char) -> *mut c_void,
    ) -> bool {
        load_dyn_name_atomic_ptr(
            get_proc_address,
            b"glWindowRectanglesEXT\0",
            &glWindowRectanglesEXT_p,
        )
    }
    /// Checks if the pointer for [`glWindowRectanglesEXT`] is loaded (non-None).
    #[inline]
    #[doc(hidden)]
    #[cfg(any(feature = "GL_EXT_window_rectangles"))]
    #[cfg_attr(docs_rs, doc(cfg(any(feature = "GL_EXT_window_rectangles"))))]
    pub fn glWindowRectanglesEXT_is_loaded() -> bool {
        !glWindowRectanglesEXT_p.load(RELAX).is_null()
    }
}

// end of module
